(function(define){var __define; typeof define === "function" && (__define=define,define=null);
// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"3YyNe":[function(require,module,exports) {
var u = typeof globalThis.process < "u" ? globalThis.process.argv : [];
var h = ()=>typeof globalThis.process < "u" ? globalThis.process.env : {};
var B = new Set(u), _ = (e)=>B.has(e), G = u.filter((e)=>e.startsWith("--") && e.includes("=")).map((e)=>e.split("=")).reduce((e, [t, o])=>(e[t] = o, e), {});
var U = _("--dry-run"), g = ()=>_("--verbose") || h().VERBOSE === "true", N = g();
var m = (e = "", ...t)=>console.log(e.padEnd(9), "|", ...t);
var y = (...e)=>console.error("\uD83D\uDD34 ERROR".padEnd(9), "|", ...e), b = (...e)=>m("\uD83D\uDD35 INFO", ...e), f = (...e)=>m("\uD83D\uDFE0 WARN", ...e), M = 0, i = (...e)=>g() && m(`\u{1F7E1} ${M++}`, ...e);
var v = ()=>{
    let e = globalThis.browser?.runtime || globalThis.chrome?.runtime, t = ()=>setInterval(e.getPlatformInfo, 24e3);
    e.onStartup.addListener(t), t();
};
var n = {
    "isContentScript": false,
    "isBackground": true,
    "isReact": false,
    "runtimes": [
        "background-service-runtime"
    ],
    "host": "localhost",
    "port": 1815,
    "entryFilePath": "/Users/charlesmaddock/Projects/dendrite/dendrite-auth-extension/.plasmo/static/background/index.ts",
    "bundleId": "c338908e704c91f1",
    "envHash": "d99a5ffa57acd638",
    "verbose": "false",
    "secure": false,
    "serverPort": 63592
};
module.bundle.HMR_BUNDLE_ID = n.bundleId;
globalThis.process = {
    argv: [],
    env: {
        VERBOSE: n.verbose
    }
};
var D = module.bundle.Module;
function H(e) {
    D.call(this, e), this.hot = {
        data: module.bundle.hotData[e],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(t) {
            this._acceptCallbacks.push(t || function() {});
        },
        dispose: function(t) {
            this._disposeCallbacks.push(t);
        }
    }, module.bundle.hotData[e] = void 0;
}
module.bundle.Module = H;
module.bundle.hotData = {};
var c = globalThis.browser || globalThis.chrome || null;
function R() {
    return !n.host || n.host === "0.0.0.0" ? location.protocol.indexOf("http") === 0 ? location.hostname : "localhost" : n.host;
}
function x() {
    return !n.host || n.host === "0.0.0.0" ? "localhost" : n.host;
}
function d() {
    return n.port || location.port;
}
var P = "__plasmo_runtime_page_", S = "__plasmo_runtime_script_";
var O = `${n.secure ? "https" : "http"}://${R()}:${d()}/`;
async function k(e = 1470) {
    for(;;)try {
        await fetch(O);
        break;
    } catch  {
        await new Promise((o)=>setTimeout(o, e));
    }
}
if (c.runtime.getManifest().manifest_version === 3) {
    let e = c.runtime.getURL("/__plasmo_hmr_proxy__?url=");
    globalThis.addEventListener("fetch", function(t) {
        let o = t.request.url;
        if (o.startsWith(e)) {
            let s = new URL(decodeURIComponent(o.slice(e.length)));
            s.hostname === n.host && s.port === `${n.port}` ? (s.searchParams.set("t", Date.now().toString()), t.respondWith(fetch(s).then((r)=>new Response(r.body, {
                    headers: {
                        "Content-Type": r.headers.get("Content-Type") ?? "text/javascript"
                    }
                })))) : t.respondWith(new Response("Plasmo HMR", {
                status: 200,
                statusText: "Testing"
            }));
        }
    });
}
function E(e, t) {
    let { modules: o } = e;
    return o ? !!o[t] : !1;
}
function C(e = d()) {
    let t = x();
    return `${n.secure || location.protocol === "https:" && !/localhost|127.0.0.1|0.0.0.0/.test(t) ? "wss" : "ws"}://${t}:${e}/`;
}
function T(e) {
    typeof e.message == "string" && y("[plasmo/parcel-runtime]: " + e.message);
}
function L(e) {
    if (typeof globalThis.WebSocket > "u") return;
    let t = new WebSocket(C(Number(d()) + 1));
    return t.addEventListener("message", async function(o) {
        let s = JSON.parse(o.data);
        await e(s);
    }), t.addEventListener("error", T), t;
}
function A(e) {
    if (typeof globalThis.WebSocket > "u") return;
    let t = new WebSocket(C());
    return t.addEventListener("message", async function(o) {
        let s = JSON.parse(o.data);
        if (s.type === "update" && await e(s.assets), s.type === "error") for (let r of s.diagnostics.ansi){
            let l = r.codeframe || r.stack;
            f("[plasmo/parcel-runtime]: " + r.message + `
` + l + `

` + r.hints.join(`
`));
        }
    }), t.addEventListener("error", T), t.addEventListener("open", ()=>{
        b(`[plasmo/parcel-runtime]: Connected to HMR server for ${n.entryFilePath}`);
    }), t.addEventListener("close", ()=>{
        f(`[plasmo/parcel-runtime]: Connection to the HMR server is closed for ${n.entryFilePath}`);
    }), t;
}
var w = module.bundle.parent, a = {
    buildReady: !1,
    bgChanged: !1,
    csChanged: !1,
    pageChanged: !1,
    scriptPorts: new Set,
    pagePorts: new Set
};
async function p(e = !1) {
    if (e || a.buildReady && a.pageChanged) {
        i("BGSW Runtime - reloading Page");
        for (let t of a.pagePorts)t.postMessage(null);
    }
    if (e || a.buildReady && (a.bgChanged || a.csChanged)) {
        i("BGSW Runtime - reloading CS");
        let t = await c?.tabs.query({
            active: !0
        });
        for (let o of a.scriptPorts){
            let s = t.some((r)=>r.id === o.sender.tab?.id);
            o.postMessage({
                __plasmo_cs_active_tab__: s
            });
        }
        c.runtime.reload();
    }
}
if (!w || !w.isParcelRequire) {
    v();
    let e = A(async (t)=>{
        i("BGSW Runtime - On HMR Update"), a.bgChanged ||= t.filter((s)=>s.envHash === n.envHash).some((s)=>E(module.bundle, s.id));
        let o = t.find((s)=>s.type === "json");
        if (o) {
            let s = new Set(t.map((l)=>l.id)), r = Object.values(o.depsByBundle).map((l)=>Object.values(l)).flat();
            a.bgChanged ||= r.every((l)=>s.has(l));
        }
        p();
    });
    e.addEventListener("open", ()=>{
        let t = setInterval(()=>e.send("ping"), 24e3);
        e.addEventListener("close", ()=>clearInterval(t));
    }), e.addEventListener("close", async ()=>{
        await k(), p(!0);
    });
}
L(async (e)=>{
    switch(i("BGSW Runtime - On Build Repackaged"), e.type){
        case "build_ready":
            a.buildReady ||= !0, p();
            break;
        case "cs_changed":
            a.csChanged ||= !0, p();
            break;
    }
});
c.runtime.onConnect.addListener(function(e) {
    let t = e.name.startsWith(P), o = e.name.startsWith(S);
    if (t || o) {
        let s = t ? a.pagePorts : a.scriptPorts;
        s.add(e), e.onDisconnect.addListener(()=>{
            s.delete(e);
        }), e.onMessage.addListener(function(r) {
            i("BGSW Runtime - On source changed", r), r.__plasmo_cs_changed__ && (a.csChanged ||= !0), r.__plasmo_page_changed__ && (a.pageChanged ||= !0), p();
        });
    }
});
c.runtime.onMessage.addListener(function(t) {
    return t.__plasmo_full_reload__ && (i("BGSW Runtime - On top-level code changed"), p()), !0;
});

},{}],"8oeFb":[function(require,module,exports) {
var _messaging = require("./messaging");
var _index = require("../../../background/index");

},{"./messaging":"gGuoe","../../../background/index":"leaNT"}],"gGuoe":[function(require,module,exports) {
// @ts-nocheck
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
var _saveSession = require("~background/messages/save-session");
var _saveSessionDefault = parcelHelpers.interopDefault(_saveSession);
globalThis.__plasmoInternalPortMap = new Map();
chrome.runtime.onMessageExternal.addListener((request, sender, sendResponse)=>{
    request?.name;
    return true;
});
chrome.runtime.onMessage.addListener((request, sender, sendResponse)=>{
    switch(request.name){
        case "save-session":
            (0, _saveSessionDefault.default)({
                ...request,
                sender
            }, {
                send: (p)=>sendResponse(p)
            });
            break;
        default:
            break;
    }
    return true;
});
chrome.runtime.onConnect.addListener(function(port) {
    globalThis.__plasmoInternalPortMap.set(port.name, port);
    port.onMessage.addListener(function(request) {
        port.name;
    });
});

},{"~background/messages/save-session":"33EnW","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"33EnW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _messaging = require("@plasmohq/messaging");
var _cookies = require("~lib/background/cookies");
var _constants = require("~lib/constants");
var _serverActions = require("~lib/server-actions");
var _utils = require("~lib/utils");
const handler = async (req, res)=>{
    try {
        const { url, userAgent, localStorage } = await (0, _messaging.sendToContentScript)({
            name: (0, _constants.MESSAGE_NAMES).FETCH_SESSION
        });
        const domain = (0, _utils.getHostnameWithoutSubdomain)(url);
        console.log({
            domain
        });
        const cookies = await (0, _cookies.getCookies)(domain);
        const sessionDTO = {
            domain,
            user_agent: userAgent,
            cookies,
            origins_storage: localStorage
        };
        console.log("Saving session data:", sessionDTO);
        await (0, _serverActions.submitSession)(sessionDTO);
        res.send({
            success: true,
            message: "Great success"
        });
    } catch (err) {
        console.error(err);
        res.send({
            success: false,
            message: (0, _utils.errorMessage)(err)
        });
    }
};
exports.default = handler;

},{"@plasmohq/messaging":"cto8s","~lib/background/cookies":"84Vaz","~lib/constants":"6KjBj","~lib/server-actions":"7TLEJ","~lib/utils":"6QCW4","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"cto8s":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "relay", ()=>E);
parcelHelpers.export(exports, "relayMessage", ()=>M);
parcelHelpers.export(exports, "sendToActiveContentScript", ()=>h);
parcelHelpers.export(exports, "sendToBackground", ()=>p);
parcelHelpers.export(exports, "sendToBackgroundViaRelay", ()=>u);
parcelHelpers.export(exports, "sendToContentScript", ()=>x);
parcelHelpers.export(exports, "sendViaRelay", ()=>S);
var _nanoid = require("nanoid");
var l = globalThis.browser?.tabs || globalThis.chrome?.tabs, d = ()=>{
    let e = globalThis.browser?.runtime || globalThis.chrome?.runtime;
    if (!e) throw new Error("Extension runtime is not available");
    return e;
}, i = ()=>{
    if (!l) throw new Error("Extension tabs API is not available");
    return l;
}, m = async ()=>{
    let e = i(), [a] = await e.query({
        active: !0,
        currentWindow: !0
    });
    return a;
}, g = (e, a)=>!a.__internal && e.source === globalThis.window && e.data.name === a.name && (a.relayId === void 0 || e.data.relayId === a.relayId);
var c = (e, a, n = globalThis.window)=>{
    let r = async (s)=>{
        if (g(s, e) && !s.data.relayed) {
            let o = {
                name: e.name,
                relayId: e.relayId,
                body: s.data.body
            }, t = await a?.(o);
            n.postMessage({
                name: e.name,
                relayId: e.relayId,
                instanceId: s.data.instanceId,
                body: t,
                relayed: !0
            }, {
                targetOrigin: e.targetOrigin || "/"
            });
        }
    };
    return n.addEventListener("message", r), ()=>n.removeEventListener("message", r);
}, y = (e, a = globalThis.window)=>new Promise((n, r)=>{
        let s = (0, _nanoid.nanoid)(), o = new AbortController;
        a.addEventListener("message", (t)=>{
            g(t, e) && t.data.relayed && t.data.instanceId === s && (n(t.data.body), o.abort());
        }, {
            signal: o.signal
        }), a.postMessage({
            ...e,
            instanceId: s
        }, {
            targetOrigin: e.targetOrigin || "/"
        });
    });
var p = async (e)=>d().sendMessage(e.extensionId ?? null, e), x = async (e)=>{
    let a = typeof e.tabId == "number" ? e.tabId : (await m())?.id;
    if (!a) throw new Error("No active tab found to send message to.");
    return i().sendMessage(a, e);
}, h = x, M = (e)=>c(e, p), E = M, u = y, S = u;

},{"nanoid":"4oYEq","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"4oYEq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "urlAlphabet", ()=>(0, _indexJs.urlAlphabet));
parcelHelpers.export(exports, "random", ()=>random);
parcelHelpers.export(exports, "customRandom", ()=>customRandom);
parcelHelpers.export(exports, "customAlphabet", ()=>customAlphabet);
parcelHelpers.export(exports, "nanoid", ()=>nanoid);
var _indexJs = require("./url-alphabet/index.js");
let random = (bytes)=>crypto.getRandomValues(new Uint8Array(bytes));
let customRandom = (alphabet, defaultSize, getRandom)=>{
    let mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;
    let step = -~(1.6 * mask * defaultSize / alphabet.length);
    return (size = defaultSize)=>{
        let id = "";
        while(true){
            let bytes = getRandom(step);
            let j = step;
            while(j--){
                id += alphabet[bytes[j] & mask] || "";
                if (id.length === size) return id;
            }
        }
    };
};
let customAlphabet = (alphabet, size = 21)=>customRandom(alphabet, size, random);
let nanoid = (size = 21)=>crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte)=>{
        byte &= 63;
        if (byte < 36) id += byte.toString(36);
        else if (byte < 62) id += (byte - 26).toString(36).toUpperCase();
        else if (byte > 62) id += "-";
        else id += "_";
        return id;
    }, "");

},{"./url-alphabet/index.js":false,"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"iIXqM":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"84Vaz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getCookies", ()=>getCookies);
const sameSiteMap = {
    unspecified: "Lax",
    no_restriction: "None",
    lax: "Lax",
    strict: "Strict"
};
const mapChromeCookie = (cookie, customProps)=>({
        ...cookie,
        expires: cookie.expirationDate,
        sameSite: sameSiteMap[cookie.sameSite],
        ...customProps ?? {}
    });
const getCookies = async (domain)=>{
    const cookies = [];
    const generalCookies = await chrome.cookies.getAll({
        domain
    });
    cookies.push(...generalCookies.map((c)=>mapChromeCookie(c)));
    return cookies;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"6KjBj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LS_KEYS", ()=>LS_KEYS);
parcelHelpers.export(exports, "MESSAGE_NAMES", ()=>MESSAGE_NAMES);
const LS_KEYS = {
    USER_DATA: "user_data"
};
const MESSAGE_NAMES = {
    FETCH_SESSION: "fetch_session"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"7TLEJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "submitSession", ()=>submitSession);
var _axios = require("axios");
var _axiosDefault = parcelHelpers.interopDefault(_axios);
var _auth = require("./background/auth");
var _utils = require("./utils");
const NODE_ENV = "development", LOCAL_URL = "http://localhost:8000/api/v1", LIVE_URL = "https://dendrite-server.azurewebsites.net/api/v1";
const API_URL = NODE_ENV === "development" ? LOCAL_URL : LIVE_URL;
const client = (0, _axiosDefault.default).create({
    baseURL: API_URL,
    withCredentials: false
});
const submitSession = async (session)=>{
    try {
        // await new Promise((resolve) => setTimeout(resolve, 3000))
        // return
        const config = await (0, _auth.getAuthHeaders)();
        return client.post("/user/session", session, config);
    } catch (err) {
        throw (0, _utils.errorMessage)(err);
    }
};

},{"axios":"1cHfH","./background/auth":"4TsiO","./utils":"6QCW4","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"1cHfH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>(0, _axiosJsDefault.default));
parcelHelpers.export(exports, "Axios", ()=>Axios);
parcelHelpers.export(exports, "AxiosError", ()=>AxiosError);
parcelHelpers.export(exports, "CanceledError", ()=>CanceledError);
parcelHelpers.export(exports, "isCancel", ()=>isCancel);
parcelHelpers.export(exports, "CancelToken", ()=>CancelToken);
parcelHelpers.export(exports, "VERSION", ()=>VERSION);
parcelHelpers.export(exports, "all", ()=>all);
parcelHelpers.export(exports, "Cancel", ()=>Cancel);
parcelHelpers.export(exports, "isAxiosError", ()=>isAxiosError);
parcelHelpers.export(exports, "spread", ()=>spread);
parcelHelpers.export(exports, "toFormData", ()=>toFormData);
parcelHelpers.export(exports, "AxiosHeaders", ()=>AxiosHeaders);
parcelHelpers.export(exports, "HttpStatusCode", ()=>HttpStatusCode);
parcelHelpers.export(exports, "formToJSON", ()=>formToJSON);
parcelHelpers.export(exports, "getAdapter", ()=>getAdapter);
parcelHelpers.export(exports, "mergeConfig", ()=>mergeConfig);
var _axiosJs = require("./lib/axios.js");
var _axiosJsDefault = parcelHelpers.interopDefault(_axiosJs);
// This module is intended to unwrap Axios default export as named.
// Keep top-level export same with static properties
// so that it can keep same with es module or cjs
const { Axios, AxiosError, CanceledError, isCancel, CancelToken, VERSION, all, Cancel, isAxiosError, spread, toFormData, AxiosHeaders, HttpStatusCode, formToJSON, getAdapter, mergeConfig } = (0, _axiosJsDefault.default);

},{"./lib/axios.js":"czEBF","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"czEBF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _bindJs = require("./helpers/bind.js");
var _bindJsDefault = parcelHelpers.interopDefault(_bindJs);
var _axiosJs = require("./core/Axios.js");
var _axiosJsDefault = parcelHelpers.interopDefault(_axiosJs);
var _mergeConfigJs = require("./core/mergeConfig.js");
var _mergeConfigJsDefault = parcelHelpers.interopDefault(_mergeConfigJs);
var _indexJs = require("./defaults/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _formDataToJSONJs = require("./helpers/formDataToJSON.js");
var _formDataToJSONJsDefault = parcelHelpers.interopDefault(_formDataToJSONJs);
var _canceledErrorJs = require("./cancel/CanceledError.js");
var _canceledErrorJsDefault = parcelHelpers.interopDefault(_canceledErrorJs);
var _cancelTokenJs = require("./cancel/CancelToken.js");
var _cancelTokenJsDefault = parcelHelpers.interopDefault(_cancelTokenJs);
var _isCancelJs = require("./cancel/isCancel.js");
var _isCancelJsDefault = parcelHelpers.interopDefault(_isCancelJs);
var _dataJs = require("./env/data.js");
var _toFormDataJs = require("./helpers/toFormData.js");
var _toFormDataJsDefault = parcelHelpers.interopDefault(_toFormDataJs);
var _axiosErrorJs = require("./core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
var _spreadJs = require("./helpers/spread.js");
var _spreadJsDefault = parcelHelpers.interopDefault(_spreadJs);
var _isAxiosErrorJs = require("./helpers/isAxiosError.js");
var _isAxiosErrorJsDefault = parcelHelpers.interopDefault(_isAxiosErrorJs);
var _axiosHeadersJs = require("./core/AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
var _adaptersJs = require("./adapters/adapters.js");
var _adaptersJsDefault = parcelHelpers.interopDefault(_adaptersJs);
var _httpStatusCodeJs = require("./helpers/HttpStatusCode.js");
var _httpStatusCodeJsDefault = parcelHelpers.interopDefault(_httpStatusCodeJs);
"use strict";
/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 *
 * @returns {Axios} A new instance of Axios
 */ function createInstance(defaultConfig) {
    const context = new (0, _axiosJsDefault.default)(defaultConfig);
    const instance = (0, _bindJsDefault.default)((0, _axiosJsDefault.default).prototype.request, context);
    // Copy axios.prototype to instance
    (0, _utilsJsDefault.default).extend(instance, (0, _axiosJsDefault.default).prototype, context, {
        allOwnKeys: true
    });
    // Copy context to instance
    (0, _utilsJsDefault.default).extend(instance, context, null, {
        allOwnKeys: true
    });
    // Factory for creating new instances
    instance.create = function create(instanceConfig) {
        return createInstance((0, _mergeConfigJsDefault.default)(defaultConfig, instanceConfig));
    };
    return instance;
}
// Create the default instance to be exported
const axios = createInstance((0, _indexJsDefault.default));
// Expose Axios class to allow class inheritance
axios.Axios = (0, _axiosJsDefault.default);
// Expose Cancel & CancelToken
axios.CanceledError = (0, _canceledErrorJsDefault.default);
axios.CancelToken = (0, _cancelTokenJsDefault.default);
axios.isCancel = (0, _isCancelJsDefault.default);
axios.VERSION = (0, _dataJs.VERSION);
axios.toFormData = (0, _toFormDataJsDefault.default);
// Expose AxiosError class
axios.AxiosError = (0, _axiosErrorJsDefault.default);
// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;
// Expose all/spread
axios.all = function all(promises) {
    return Promise.all(promises);
};
axios.spread = (0, _spreadJsDefault.default);
// Expose isAxiosError
axios.isAxiosError = (0, _isAxiosErrorJsDefault.default);
// Expose mergeConfig
axios.mergeConfig = (0, _mergeConfigJsDefault.default);
axios.AxiosHeaders = (0, _axiosHeadersJsDefault.default);
axios.formToJSON = (thing)=>(0, _formDataToJSONJsDefault.default)((0, _utilsJsDefault.default).isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = (0, _adaptersJsDefault.default).getAdapter;
axios.HttpStatusCode = (0, _httpStatusCodeJsDefault.default);
axios.default = axios;
// this module should only have a default export
exports.default = axios;

},{"./utils.js":"6pgCP","./helpers/bind.js":"4iJnq","./core/Axios.js":"2UlrX","./core/mergeConfig.js":"hCK5X","./defaults/index.js":"8lnvF","./helpers/formDataToJSON.js":"bHtc6","./cancel/CanceledError.js":"6Jxkj","./cancel/CancelToken.js":"45Qou","./cancel/isCancel.js":"9fV5q","./env/data.js":"2P4GS","./helpers/toFormData.js":"bWqOm","./core/AxiosError.js":"jWuNn","./helpers/spread.js":"lJWiD","./helpers/isAxiosError.js":"96kwV","./core/AxiosHeaders.js":"dG0u5","./adapters/adapters.js":"bgiN9","./helpers/HttpStatusCode.js":"8evH5","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"6pgCP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _bindJs = require("./helpers/bind.js");
var _bindJsDefault = parcelHelpers.interopDefault(_bindJs);
var global = arguments[3];
"use strict";
// utils is a library of generic helper functions non-specific to axios
const { toString } = Object.prototype;
const { getPrototypeOf } = Object;
const kindOf = ((cache)=>(thing)=>{
        const str = toString.call(thing);
        return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
    })(Object.create(null));
const kindOfTest = (type)=>{
    type = type.toLowerCase();
    return (thing)=>kindOf(thing) === type;
};
const typeOfTest = (type)=>(thing)=>typeof thing === type;
/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 *
 * @returns {boolean} True if value is an Array, otherwise false
 */ const { isArray } = Array;
/**
 * Determine if a value is undefined
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if the value is undefined, otherwise false
 */ const isUndefined = typeOfTest("undefined");
/**
 * Determine if a value is a Buffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Buffer, otherwise false
 */ function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */ const isArrayBuffer = kindOfTest("ArrayBuffer");
/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */ function isArrayBufferView(val) {
    let result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) result = ArrayBuffer.isView(val);
    else result = val && val.buffer && isArrayBuffer(val.buffer);
    return result;
}
/**
 * Determine if a value is a String
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a String, otherwise false
 */ const isString = typeOfTest("string");
/**
 * Determine if a value is a Function
 *
 * @param {*} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */ const isFunction = typeOfTest("function");
/**
 * Determine if a value is a Number
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Number, otherwise false
 */ const isNumber = typeOfTest("number");
/**
 * Determine if a value is an Object
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an Object, otherwise false
 */ const isObject = (thing)=>thing !== null && typeof thing === "object";
/**
 * Determine if a value is a Boolean
 *
 * @param {*} thing The value to test
 * @returns {boolean} True if value is a Boolean, otherwise false
 */ const isBoolean = (thing)=>thing === true || thing === false;
/**
 * Determine if a value is a plain Object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a plain Object, otherwise false
 */ const isPlainObject = (val)=>{
    if (kindOf(val) !== "object") return false;
    const prototype = getPrototypeOf(val);
    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
/**
 * Determine if a value is a Date
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Date, otherwise false
 */ const isDate = kindOfTest("Date");
/**
 * Determine if a value is a File
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */ const isFile = kindOfTest("File");
/**
 * Determine if a value is a Blob
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Blob, otherwise false
 */ const isBlob = kindOfTest("Blob");
/**
 * Determine if a value is a FileList
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */ const isFileList = kindOfTest("FileList");
/**
 * Determine if a value is a Stream
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Stream, otherwise false
 */ const isStream = (val)=>isObject(val) && isFunction(val.pipe);
/**
 * Determine if a value is a FormData
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an FormData, otherwise false
 */ const isFormData = (thing)=>{
    let kind;
    return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
    kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */ const isURLSearchParams = kindOfTest("URLSearchParams");
const [isReadableStream, isRequest, isResponse, isHeaders] = [
    "ReadableStream",
    "Request",
    "Response",
    "Headers"
].map(kindOfTest);
/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 *
 * @returns {String} The String freed of excess whitespace
 */ const trim = (str)=>str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 *
 * @param {Boolean} [allOwnKeys = false]
 * @returns {any}
 */ function forEach(obj, fn, { allOwnKeys = false } = {}) {
    // Don't bother if no value provided
    if (obj === null || typeof obj === "undefined") return;
    let i;
    let l;
    // Force an array if not already something iterable
    if (typeof obj !== "object") /*eslint no-param-reassign:0*/ obj = [
        obj
    ];
    if (isArray(obj)) // Iterate over array values
    for(i = 0, l = obj.length; i < l; i++)fn.call(null, obj[i], i, obj);
    else {
        // Iterate over object keys
        const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        const len = keys.length;
        let key;
        for(i = 0; i < len; i++){
            key = keys[i];
            fn.call(null, obj[key], key, obj);
        }
    }
}
function findKey(obj, key) {
    key = key.toLowerCase();
    const keys = Object.keys(obj);
    let i = keys.length;
    let _key;
    while(i-- > 0){
        _key = keys[i];
        if (key === _key.toLowerCase()) return _key;
    }
    return null;
}
const _global = (()=>{
    /*eslint no-undef:0*/ if (typeof globalThis !== "undefined") return globalThis;
    return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
const isContextDefined = (context)=>!isUndefined(context) && context !== _global;
/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 *
 * @returns {Object} Result of all merge properties
 */ function merge() {
    const { caseless } = isContextDefined(this) && this || {};
    const result = {};
    const assignValue = (val, key)=>{
        const targetKey = caseless && findKey(result, key) || key;
        if (isPlainObject(result[targetKey]) && isPlainObject(val)) result[targetKey] = merge(result[targetKey], val);
        else if (isPlainObject(val)) result[targetKey] = merge({}, val);
        else if (isArray(val)) result[targetKey] = val.slice();
        else result[targetKey] = val;
    };
    for(let i = 0, l = arguments.length; i < l; i++)arguments[i] && forEach(arguments[i], assignValue);
    return result;
}
/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 *
 * @param {Boolean} [allOwnKeys]
 * @returns {Object} The resulting value of object a
 */ const extend = (a, b, thisArg, { allOwnKeys } = {})=>{
    forEach(b, (val, key)=>{
        if (thisArg && isFunction(val)) a[key] = (0, _bindJsDefault.default)(val, thisArg);
        else a[key] = val;
    }, {
        allOwnKeys
    });
    return a;
};
/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 *
 * @returns {string} content value without BOM
 */ const stripBOM = (content)=>{
    if (content.charCodeAt(0) === 0xFEFF) content = content.slice(1);
    return content;
};
/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 *
 * @returns {void}
 */ const inherits = (constructor, superConstructor, props, descriptors)=>{
    constructor.prototype = Object.create(superConstructor.prototype, descriptors);
    constructor.prototype.constructor = constructor;
    Object.defineProperty(constructor, "super", {
        value: superConstructor.prototype
    });
    props && Object.assign(constructor.prototype, props);
};
/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function|Boolean} [filter]
 * @param {Function} [propFilter]
 *
 * @returns {Object}
 */ const toFlatObject = (sourceObj, destObj, filter, propFilter)=>{
    let props;
    let i;
    let prop;
    const merged = {};
    destObj = destObj || {};
    // eslint-disable-next-line no-eq-null,eqeqeq
    if (sourceObj == null) return destObj;
    do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while(i-- > 0){
            prop = props[i];
            if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
                destObj[prop] = sourceObj[prop];
                merged[prop] = true;
            }
        }
        sourceObj = filter !== false && getPrototypeOf(sourceObj);
    }while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
    return destObj;
};
/**
 * Determines whether a string ends with the characters of a specified string
 *
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 *
 * @returns {boolean}
 */ const endsWith = (str, searchString, position)=>{
    str = String(str);
    if (position === undefined || position > str.length) position = str.length;
    position -= searchString.length;
    const lastIndex = str.indexOf(searchString, position);
    return lastIndex !== -1 && lastIndex === position;
};
/**
 * Returns new array from array like object or null if failed
 *
 * @param {*} [thing]
 *
 * @returns {?Array}
 */ const toArray = (thing)=>{
    if (!thing) return null;
    if (isArray(thing)) return thing;
    let i = thing.length;
    if (!isNumber(i)) return null;
    const arr = new Array(i);
    while(i-- > 0)arr[i] = thing[i];
    return arr;
};
/**
 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
 * thing passed in is an instance of Uint8Array
 *
 * @param {TypedArray}
 *
 * @returns {Array}
 */ // eslint-disable-next-line func-names
const isTypedArray = ((TypedArray)=>{
    // eslint-disable-next-line func-names
    return (thing)=>{
        return TypedArray && thing instanceof TypedArray;
    };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
/**
 * For each entry in the object, call the function with the key and value.
 *
 * @param {Object<any, any>} obj - The object to iterate over.
 * @param {Function} fn - The function to call for each entry.
 *
 * @returns {void}
 */ const forEachEntry = (obj, fn)=>{
    const generator = obj && obj[Symbol.iterator];
    const iterator = generator.call(obj);
    let result;
    while((result = iterator.next()) && !result.done){
        const pair = result.value;
        fn.call(obj, pair[0], pair[1]);
    }
};
/**
 * It takes a regular expression and a string, and returns an array of all the matches
 *
 * @param {string} regExp - The regular expression to match against.
 * @param {string} str - The string to search.
 *
 * @returns {Array<boolean>}
 */ const matchAll = (regExp, str)=>{
    let matches;
    const arr = [];
    while((matches = regExp.exec(str)) !== null)arr.push(matches);
    return arr;
};
/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */ const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str)=>{
    return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function replacer(m, p1, p2) {
        return p1.toUpperCase() + p2;
    });
};
/* Creating a function that will check if an object has a property. */ const hasOwnProperty = (({ hasOwnProperty })=>(obj, prop)=>hasOwnProperty.call(obj, prop))(Object.prototype);
/**
 * Determine if a value is a RegExp object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a RegExp object, otherwise false
 */ const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer)=>{
    const descriptors = Object.getOwnPropertyDescriptors(obj);
    const reducedDescriptors = {};
    forEach(descriptors, (descriptor, name)=>{
        let ret;
        if ((ret = reducer(descriptor, name, obj)) !== false) reducedDescriptors[name] = ret || descriptor;
    });
    Object.defineProperties(obj, reducedDescriptors);
};
/**
 * Makes all methods read-only
 * @param {Object} obj
 */ const freezeMethods = (obj)=>{
    reduceDescriptors(obj, (descriptor, name)=>{
        // skip restricted props in strict mode
        if (isFunction(obj) && [
            "arguments",
            "caller",
            "callee"
        ].indexOf(name) !== -1) return false;
        const value = obj[name];
        if (!isFunction(value)) return;
        descriptor.enumerable = false;
        if ("writable" in descriptor) {
            descriptor.writable = false;
            return;
        }
        if (!descriptor.set) descriptor.set = ()=>{
            throw Error("Can not rewrite read-only method '" + name + "'");
        };
    });
};
const toObjectSet = (arrayOrString, delimiter)=>{
    const obj = {};
    const define = (arr)=>{
        arr.forEach((value)=>{
            obj[value] = true;
        });
    };
    isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
    return obj;
};
const noop = ()=>{};
const toFiniteNumber = (value, defaultValue)=>{
    return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
const ALPHA = "abcdefghijklmnopqrstuvwxyz";
const DIGIT = "0123456789";
const ALPHABET = {
    DIGIT,
    ALPHA,
    ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT)=>{
    let str = "";
    const { length } = alphabet;
    while(size--)str += alphabet[Math.random() * length | 0];
    return str;
};
/**
 * If the thing is a FormData object, return true, otherwise return false.
 *
 * @param {unknown} thing - The thing to check.
 *
 * @returns {boolean}
 */ function isSpecCompliantForm(thing) {
    return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
const toJSONObject = (obj)=>{
    const stack = new Array(10);
    const visit = (source, i)=>{
        if (isObject(source)) {
            if (stack.indexOf(source) >= 0) return;
            if (!("toJSON" in source)) {
                stack[i] = source;
                const target = isArray(source) ? [] : {};
                forEach(source, (value, key)=>{
                    const reducedValue = visit(value, i + 1);
                    !isUndefined(reducedValue) && (target[key] = reducedValue);
                });
                stack[i] = undefined;
                return target;
            }
        }
        return source;
    };
    return visit(obj, 0);
};
const isAsyncFn = kindOfTest("AsyncFunction");
const isThenable = (thing)=>thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
exports.default = {
    isArray,
    isArrayBuffer,
    isBuffer,
    isFormData,
    isArrayBufferView,
    isString,
    isNumber,
    isBoolean,
    isObject,
    isPlainObject,
    isReadableStream,
    isRequest,
    isResponse,
    isHeaders,
    isUndefined,
    isDate,
    isFile,
    isBlob,
    isRegExp,
    isFunction,
    isStream,
    isURLSearchParams,
    isTypedArray,
    isFileList,
    forEach,
    merge,
    extend,
    trim,
    stripBOM,
    inherits,
    toFlatObject,
    kindOf,
    kindOfTest,
    endsWith,
    toArray,
    forEachEntry,
    matchAll,
    isHTMLForm,
    hasOwnProperty,
    hasOwnProp: hasOwnProperty,
    reduceDescriptors,
    freezeMethods,
    toObjectSet,
    toCamelCase,
    noop,
    toFiniteNumber,
    findKey,
    global: _global,
    isContextDefined,
    ALPHABET,
    generateString,
    isSpecCompliantForm,
    toJSONObject,
    isAsyncFn,
    isThenable
};

},{"./helpers/bind.js":"4iJnq","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"4iJnq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>bind);
"use strict";
function bind(fn, thisArg) {
    return function wrap() {
        return fn.apply(thisArg, arguments);
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"2UlrX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _buildURLJs = require("../helpers/buildURL.js");
var _buildURLJsDefault = parcelHelpers.interopDefault(_buildURLJs);
var _interceptorManagerJs = require("./InterceptorManager.js");
var _interceptorManagerJsDefault = parcelHelpers.interopDefault(_interceptorManagerJs);
var _dispatchRequestJs = require("./dispatchRequest.js");
var _dispatchRequestJsDefault = parcelHelpers.interopDefault(_dispatchRequestJs);
var _mergeConfigJs = require("./mergeConfig.js");
var _mergeConfigJsDefault = parcelHelpers.interopDefault(_mergeConfigJs);
var _buildFullPathJs = require("./buildFullPath.js");
var _buildFullPathJsDefault = parcelHelpers.interopDefault(_buildFullPathJs);
var _validatorJs = require("../helpers/validator.js");
var _validatorJsDefault = parcelHelpers.interopDefault(_validatorJs);
var _axiosHeadersJs = require("./AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
"use strict";
const validators = (0, _validatorJsDefault.default).validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 *
 * @return {Axios} A new instance of Axios
 */ class Axios {
    constructor(instanceConfig){
        this.defaults = instanceConfig;
        this.interceptors = {
            request: new (0, _interceptorManagerJsDefault.default)(),
            response: new (0, _interceptorManagerJsDefault.default)()
        };
    }
    /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */ async request(configOrUrl, config) {
        try {
            return await this._request(configOrUrl, config);
        } catch (err) {
            if (err instanceof Error) {
                let dummy;
                Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();
                // slice off the Error: ... line
                const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
                try {
                    if (!err.stack) err.stack = stack;
                    else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) err.stack += "\n" + stack;
                } catch (e) {
                // ignore the case where "stack" is an un-writable property
                }
            }
            throw err;
        }
    }
    _request(configOrUrl, config) {
        /*eslint no-param-reassign:0*/ // Allow for axios('example/url'[, config]) a la fetch API
        if (typeof configOrUrl === "string") {
            config = config || {};
            config.url = configOrUrl;
        } else config = configOrUrl || {};
        config = (0, _mergeConfigJsDefault.default)(this.defaults, config);
        const { transitional, paramsSerializer, headers } = config;
        if (transitional !== undefined) (0, _validatorJsDefault.default).assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
        if (paramsSerializer != null) {
            if ((0, _utilsJsDefault.default).isFunction(paramsSerializer)) config.paramsSerializer = {
                serialize: paramsSerializer
            };
            else (0, _validatorJsDefault.default).assertOptions(paramsSerializer, {
                encode: validators.function,
                serialize: validators.function
            }, true);
        }
        // Set config.method
        config.method = (config.method || this.defaults.method || "get").toLowerCase();
        // Flatten headers
        let contextHeaders = headers && (0, _utilsJsDefault.default).merge(headers.common, headers[config.method]);
        headers && (0, _utilsJsDefault.default).forEach([
            "delete",
            "get",
            "head",
            "post",
            "put",
            "patch",
            "common"
        ], (method)=>{
            delete headers[method];
        });
        config.headers = (0, _axiosHeadersJsDefault.default).concat(contextHeaders, headers);
        // filter out skipped interceptors
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
            if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) return;
            synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
            requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
            responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        let promise;
        let i = 0;
        let len;
        if (!synchronousRequestInterceptors) {
            const chain = [
                (0, _dispatchRequestJsDefault.default).bind(this),
                undefined
            ];
            chain.unshift.apply(chain, requestInterceptorChain);
            chain.push.apply(chain, responseInterceptorChain);
            len = chain.length;
            promise = Promise.resolve(config);
            while(i < len)promise = promise.then(chain[i++], chain[i++]);
            return promise;
        }
        len = requestInterceptorChain.length;
        let newConfig = config;
        i = 0;
        while(i < len){
            const onFulfilled = requestInterceptorChain[i++];
            const onRejected = requestInterceptorChain[i++];
            try {
                newConfig = onFulfilled(newConfig);
            } catch (error) {
                onRejected.call(this, error);
                break;
            }
        }
        try {
            promise = (0, _dispatchRequestJsDefault.default).call(this, newConfig);
        } catch (error) {
            return Promise.reject(error);
        }
        i = 0;
        len = responseInterceptorChain.length;
        while(i < len)promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
        return promise;
    }
    getUri(config) {
        config = (0, _mergeConfigJsDefault.default)(this.defaults, config);
        const fullPath = (0, _buildFullPathJsDefault.default)(config.baseURL, config.url);
        return (0, _buildURLJsDefault.default)(fullPath, config.params, config.paramsSerializer);
    }
}
// Provide aliases for supported request methods
(0, _utilsJsDefault.default).forEach([
    "delete",
    "get",
    "head",
    "options"
], function forEachMethodNoData(method) {
    /*eslint func-names:0*/ Axios.prototype[method] = function(url, config) {
        return this.request((0, _mergeConfigJsDefault.default)(config || {}, {
            method,
            url,
            data: (config || {}).data
        }));
    };
});
(0, _utilsJsDefault.default).forEach([
    "post",
    "put",
    "patch"
], function forEachMethodWithData(method) {
    /*eslint func-names:0*/ function generateHTTPMethod(isForm) {
        return function httpMethod(url, data, config) {
            return this.request((0, _mergeConfigJsDefault.default)(config || {}, {
                method,
                headers: isForm ? {
                    "Content-Type": "multipart/form-data"
                } : {},
                url,
                data
            }));
        };
    }
    Axios.prototype[method] = generateHTTPMethod();
    Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
exports.default = Axios;

},{"./../utils.js":"6pgCP","../helpers/buildURL.js":"5TCYf","./InterceptorManager.js":"cSbIA","./dispatchRequest.js":"9S0Mq","./mergeConfig.js":"hCK5X","./buildFullPath.js":"39S5a","../helpers/validator.js":"8TqqD","./AxiosHeaders.js":"dG0u5","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"5TCYf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>buildURL);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _axiosURLSearchParamsJs = require("../helpers/AxiosURLSearchParams.js");
var _axiosURLSearchParamsJsDefault = parcelHelpers.interopDefault(_axiosURLSearchParamsJs);
"use strict";
/**
 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
 * URI encoded counterparts
 *
 * @param {string} val The value to be encoded.
 *
 * @returns {string} The encoded value.
 */ function encode(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
    /*eslint no-param-reassign:0*/ if (!params) return url;
    const _encode = options && options.encode || encode;
    const serializeFn = options && options.serialize;
    let serializedParams;
    if (serializeFn) serializedParams = serializeFn(params, options);
    else serializedParams = (0, _utilsJsDefault.default).isURLSearchParams(params) ? params.toString() : new (0, _axiosURLSearchParamsJsDefault.default)(params, options).toString(_encode);
    if (serializedParams) {
        const hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) url = url.slice(0, hashmarkIndex);
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url;
}

},{"../utils.js":"6pgCP","../helpers/AxiosURLSearchParams.js":"bgjfh","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"bgjfh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _toFormDataJs = require("./toFormData.js");
var _toFormDataJsDefault = parcelHelpers.interopDefault(_toFormDataJs);
"use strict";
/**
 * It encodes a string by replacing all characters that are not in the unreserved set with
 * their percent-encoded equivalents
 *
 * @param {string} str - The string to encode.
 *
 * @returns {string} The encoded string.
 */ function encode(str) {
    const charMap = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\x00"
    };
    return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
        return charMap[match];
    });
}
/**
 * It takes a params object and converts it to a FormData object
 *
 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
 *
 * @returns {void}
 */ function AxiosURLSearchParams(params, options) {
    this._pairs = [];
    params && (0, _toFormDataJsDefault.default)(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name, value) {
    this._pairs.push([
        name,
        value
    ]);
};
prototype.toString = function toString(encoder) {
    const _encode = encoder ? function(value) {
        return encoder.call(this, value, encode);
    } : encode;
    return this._pairs.map(function each(pair) {
        return _encode(pair[0]) + "=" + _encode(pair[1]);
    }, "").join("&");
};
exports.default = AxiosURLSearchParams;

},{"./toFormData.js":"bWqOm","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"bWqOm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
// temporary hotfix to avoid circular references until AxiosURLSearchParams is refactored
var _formDataJs = require("../platform/node/classes/FormData.js");
var _formDataJsDefault = parcelHelpers.interopDefault(_formDataJs);
var Buffer = require("adfd9b103875c2dd").Buffer;
"use strict";
/**
 * Determines if the given thing is a array or js object.
 *
 * @param {string} thing - The object or array to be visited.
 *
 * @returns {boolean}
 */ function isVisitable(thing) {
    return (0, _utilsJsDefault.default).isPlainObject(thing) || (0, _utilsJsDefault.default).isArray(thing);
}
/**
 * It removes the brackets from the end of a string
 *
 * @param {string} key - The key of the parameter.
 *
 * @returns {string} the key without the brackets.
 */ function removeBrackets(key) {
    return (0, _utilsJsDefault.default).endsWith(key, "[]") ? key.slice(0, -2) : key;
}
/**
 * It takes a path, a key, and a boolean, and returns a string
 *
 * @param {string} path - The path to the current key.
 * @param {string} key - The key of the current object being iterated over.
 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
 *
 * @returns {string} The path to the current key.
 */ function renderKey(path, key, dots) {
    if (!path) return key;
    return path.concat(key).map(function each(token, i) {
        // eslint-disable-next-line no-param-reassign
        token = removeBrackets(token);
        return !dots && i ? "[" + token + "]" : token;
    }).join(dots ? "." : "");
}
/**
 * If the array is an array and none of its elements are visitable, then it's a flat array.
 *
 * @param {Array<any>} arr - The array to check
 *
 * @returns {boolean}
 */ function isFlatArray(arr) {
    return (0, _utilsJsDefault.default).isArray(arr) && !arr.some(isVisitable);
}
const predicates = (0, _utilsJsDefault.default).toFlatObject((0, _utilsJsDefault.default), {}, null, function filter(prop) {
    return /^is[A-Z]/.test(prop);
});
/**
 * Convert a data object to FormData
 *
 * @param {Object} obj
 * @param {?Object} [formData]
 * @param {?Object} [options]
 * @param {Function} [options.visitor]
 * @param {Boolean} [options.metaTokens = true]
 * @param {Boolean} [options.dots = false]
 * @param {?Boolean} [options.indexes = false]
 *
 * @returns {Object}
 **/ /**
 * It converts an object into a FormData object
 *
 * @param {Object<any, any>} obj - The object to convert to form data.
 * @param {string} formData - The FormData object to append to.
 * @param {Object<string, any>} options
 *
 * @returns
 */ function toFormData(obj, formData, options) {
    if (!(0, _utilsJsDefault.default).isObject(obj)) throw new TypeError("target must be an object");
    // eslint-disable-next-line no-param-reassign
    formData = formData || new ((0, _formDataJsDefault.default) || FormData)();
    // eslint-disable-next-line no-param-reassign
    options = (0, _utilsJsDefault.default).toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
    }, false, function defined(option, source) {
        // eslint-disable-next-line no-eq-null,eqeqeq
        return !(0, _utilsJsDefault.default).isUndefined(source[option]);
    });
    const metaTokens = options.metaTokens;
    // eslint-disable-next-line no-use-before-define
    const visitor = options.visitor || defaultVisitor;
    const dots = options.dots;
    const indexes = options.indexes;
    const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
    const useBlob = _Blob && (0, _utilsJsDefault.default).isSpecCompliantForm(formData);
    if (!(0, _utilsJsDefault.default).isFunction(visitor)) throw new TypeError("visitor must be a function");
    function convertValue(value) {
        if (value === null) return "";
        if ((0, _utilsJsDefault.default).isDate(value)) return value.toISOString();
        if (!useBlob && (0, _utilsJsDefault.default).isBlob(value)) throw new (0, _axiosErrorJsDefault.default)("Blob is not supported. Use a Buffer instead.");
        if ((0, _utilsJsDefault.default).isArrayBuffer(value) || (0, _utilsJsDefault.default).isTypedArray(value)) return useBlob && typeof Blob === "function" ? new Blob([
            value
        ]) : Buffer.from(value);
        return value;
    }
    /**
   * Default visitor.
   *
   * @param {*} value
   * @param {String|Number} key
   * @param {Array<String|Number>} path
   * @this {FormData}
   *
   * @returns {boolean} return true to visit the each prop of the value recursively
   */ function defaultVisitor(value, key, path) {
        let arr = value;
        if (value && !path && typeof value === "object") {
            if ((0, _utilsJsDefault.default).endsWith(key, "{}")) {
                // eslint-disable-next-line no-param-reassign
                key = metaTokens ? key : key.slice(0, -2);
                // eslint-disable-next-line no-param-reassign
                value = JSON.stringify(value);
            } else if ((0, _utilsJsDefault.default).isArray(value) && isFlatArray(value) || ((0, _utilsJsDefault.default).isFileList(value) || (0, _utilsJsDefault.default).endsWith(key, "[]")) && (arr = (0, _utilsJsDefault.default).toArray(value))) {
                // eslint-disable-next-line no-param-reassign
                key = removeBrackets(key);
                arr.forEach(function each(el, index) {
                    !((0, _utilsJsDefault.default).isUndefined(el) || el === null) && formData.append(// eslint-disable-next-line no-nested-ternary
                    indexes === true ? renderKey([
                        key
                    ], index, dots) : indexes === null ? key : key + "[]", convertValue(el));
                });
                return false;
            }
        }
        if (isVisitable(value)) return true;
        formData.append(renderKey(path, key, dots), convertValue(value));
        return false;
    }
    const stack = [];
    const exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
    });
    function build(value, path) {
        if ((0, _utilsJsDefault.default).isUndefined(value)) return;
        if (stack.indexOf(value) !== -1) throw Error("Circular reference detected in " + path.join("."));
        stack.push(value);
        (0, _utilsJsDefault.default).forEach(value, function each(el, key) {
            const result = !((0, _utilsJsDefault.default).isUndefined(el) || el === null) && visitor.call(formData, el, (0, _utilsJsDefault.default).isString(key) ? key.trim() : key, path, exposedHelpers);
            if (result === true) build(el, path ? path.concat(key) : [
                key
            ]);
        });
        stack.pop();
    }
    if (!(0, _utilsJsDefault.default).isObject(obj)) throw new TypeError("data must be an object");
    build(obj);
    return formData;
}
exports.default = toFormData;

},{"adfd9b103875c2dd":"j1qyA","../utils.js":"6pgCP","../core/AxiosError.js":"jWuNn","../platform/node/classes/FormData.js":"hcZFZ","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"j1qyA":[function(require,module,exports) {
var Er = Object.create;
var N = Object.defineProperty;
var dr = Object.getOwnPropertyDescriptor;
var gr = Object.getOwnPropertyNames;
var mr = Object.getPrototypeOf, Ir = Object.prototype.hasOwnProperty;
var $ = (i, r)=>()=>(r || i((r = {
            exports: {}
        }).exports, r), r.exports), Fr = (i, r)=>{
    for(var t in r)N(i, t, {
        get: r[t],
        enumerable: !0
    });
}, L = (i, r, t, n)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let e of gr(r))!Ir.call(i, e) && e !== t && N(i, e, {
        get: ()=>r[e],
        enumerable: !(n = dr(r, e)) || n.enumerable
    });
    return i;
}, S = (i, r, t)=>(L(i, r, "default"), t && L(t, r, "default")), J = (i, r, t)=>(t = i != null ? Er(mr(i)) : {}, L(r || !i || !i.__esModule ? N(t, "default", {
        value: i,
        enumerable: !0
    }) : t, i)), Ar = (i)=>L(N({}, "__esModule", {
        value: !0
    }), i);
var Q = $((M)=>{
    "use strict";
    M.byteLength = Rr;
    M.toByteArray = Cr;
    M.fromByteArray = Lr;
    var B = [], w = [], Ur = typeof Uint8Array < "u" ? Uint8Array : Array, P = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for(m = 0, K = P.length; m < K; ++m)B[m] = P[m], w[P.charCodeAt(m)] = m;
    var m, K;
    w["-".charCodeAt(0)] = 62;
    w["_".charCodeAt(0)] = 63;
    function Z(i) {
        var r = i.length;
        if (r % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
        var t = i.indexOf("=");
        t === -1 && (t = r);
        var n = t === r ? 0 : 4 - t % 4;
        return [
            t,
            n
        ];
    }
    function Rr(i) {
        var r = Z(i), t = r[0], n = r[1];
        return (t + n) * 3 / 4 - n;
    }
    function Tr(i, r, t) {
        return (r + t) * 3 / 4 - t;
    }
    function Cr(i) {
        var r, t = Z(i), n = t[0], e = t[1], o = new Ur(Tr(i, n, e)), u = 0, f = e > 0 ? n - 4 : n, c;
        for(c = 0; c < f; c += 4)r = w[i.charCodeAt(c)] << 18 | w[i.charCodeAt(c + 1)] << 12 | w[i.charCodeAt(c + 2)] << 6 | w[i.charCodeAt(c + 3)], o[u++] = r >> 16 & 255, o[u++] = r >> 8 & 255, o[u++] = r & 255;
        return e === 2 && (r = w[i.charCodeAt(c)] << 2 | w[i.charCodeAt(c + 1)] >> 4, o[u++] = r & 255), e === 1 && (r = w[i.charCodeAt(c)] << 10 | w[i.charCodeAt(c + 1)] << 4 | w[i.charCodeAt(c + 2)] >> 2, o[u++] = r >> 8 & 255, o[u++] = r & 255), o;
    }
    function Sr(i) {
        return B[i >> 18 & 63] + B[i >> 12 & 63] + B[i >> 6 & 63] + B[i & 63];
    }
    function _r(i, r, t) {
        for(var n, e = [], o = r; o < t; o += 3)n = (i[o] << 16 & 16711680) + (i[o + 1] << 8 & 65280) + (i[o + 2] & 255), e.push(Sr(n));
        return e.join("");
    }
    function Lr(i) {
        for(var r, t = i.length, n = t % 3, e = [], o = 16383, u = 0, f = t - n; u < f; u += o)e.push(_r(i, u, u + o > f ? f : u + o));
        return n === 1 ? (r = i[t - 1], e.push(B[r >> 2] + B[r << 4 & 63] + "==")) : n === 2 && (r = (i[t - 2] << 8) + i[t - 1], e.push(B[r >> 10] + B[r >> 4 & 63] + B[r << 2 & 63] + "=")), e.join("");
    }
});
var v = $((O)=>{
    O.read = function(i, r, t, n, e) {
        var o, u, f = e * 8 - n - 1, c = (1 << f) - 1, l = c >> 1, s = -7, p = t ? e - 1 : 0, F = t ? -1 : 1, x = i[r + p];
        for(p += F, o = x & (1 << -s) - 1, x >>= -s, s += f; s > 0; o = o * 256 + i[r + p], p += F, s -= 8);
        for(u = o & (1 << -s) - 1, o >>= -s, s += n; s > 0; u = u * 256 + i[r + p], p += F, s -= 8);
        if (o === 0) o = 1 - l;
        else {
            if (o === c) return u ? NaN : (x ? -1 : 1) * (1 / 0);
            u = u + Math.pow(2, n), o = o - l;
        }
        return (x ? -1 : 1) * u * Math.pow(2, o - n);
    };
    O.write = function(i, r, t, n, e, o) {
        var u, f, c, l = o * 8 - e - 1, s = (1 << l) - 1, p = s >> 1, F = e === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, x = n ? 0 : o - 1, b = n ? 1 : -1, Br = r < 0 || r === 0 && 1 / r < 0 ? 1 : 0;
        for(r = Math.abs(r), isNaN(r) || r === 1 / 0 ? (f = isNaN(r) ? 1 : 0, u = s) : (u = Math.floor(Math.log(r) / Math.LN2), r * (c = Math.pow(2, -u)) < 1 && (u--, c *= 2), u + p >= 1 ? r += F / c : r += F * Math.pow(2, 1 - p), r * c >= 2 && (u++, c /= 2), u + p >= s ? (f = 0, u = s) : u + p >= 1 ? (f = (r * c - 1) * Math.pow(2, e), u = u + p) : (f = r * Math.pow(2, p - 1) * Math.pow(2, e), u = 0)); e >= 8; i[t + x] = f & 255, x += b, f /= 256, e -= 8);
        for(u = u << e | f, l += e; l > 0; i[t + x] = u & 255, x += b, u /= 256, l -= 8);
        i[t + x - b] |= Br * 128;
    };
});
var z = $((T)=>{
    "use strict";
    var G = Q(), U = v(), rr = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    T.Buffer = h;
    T.SlowBuffer = $r;
    T.INSPECT_MAX_BYTES = 50;
    var k = 2147483647;
    T.kMaxLength = k;
    h.TYPED_ARRAY_SUPPORT = Nr();
    !h.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function Nr() {
        try {
            let i = new Uint8Array(1), r = {
                foo: function() {
                    return 42;
                }
            };
            return Object.setPrototypeOf(r, Uint8Array.prototype), Object.setPrototypeOf(i, r), i.foo() === 42;
        } catch (i) {
            return !1;
        }
    }
    Object.defineProperty(h.prototype, "parent", {
        enumerable: !0,
        get: function() {
            if (h.isBuffer(this)) return this.buffer;
        }
    });
    Object.defineProperty(h.prototype, "offset", {
        enumerable: !0,
        get: function() {
            if (h.isBuffer(this)) return this.byteOffset;
        }
    });
    function d(i) {
        if (i > k) throw new RangeError('The value "' + i + '" is invalid for option "size"');
        let r = new Uint8Array(i);
        return Object.setPrototypeOf(r, h.prototype), r;
    }
    function h(i, r, t) {
        if (typeof i == "number") {
            if (typeof r == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
            return j(i);
        }
        return er(i, r, t);
    }
    h.poolSize = 8192;
    function er(i, r, t) {
        if (typeof i == "string") return kr(i, r);
        if (ArrayBuffer.isView(i)) return Dr(i);
        if (i == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof i);
        if (E(i, ArrayBuffer) || i && E(i.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (E(i, SharedArrayBuffer) || i && E(i.buffer, SharedArrayBuffer))) return q(i, r, t);
        if (typeof i == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
        let n = i.valueOf && i.valueOf();
        if (n != null && n !== i) return h.from(n, r, t);
        let e = br(i);
        if (e) return e;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof i[Symbol.toPrimitive] == "function") return h.from(i[Symbol.toPrimitive]("string"), r, t);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof i);
    }
    h.from = function(i, r, t) {
        return er(i, r, t);
    };
    Object.setPrototypeOf(h.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(h, Uint8Array);
    function or(i) {
        if (typeof i != "number") throw new TypeError('"size" argument must be of type number');
        if (i < 0) throw new RangeError('The value "' + i + '" is invalid for option "size"');
    }
    function Mr(i, r, t) {
        return or(i), i <= 0 ? d(i) : r !== void 0 ? typeof t == "string" ? d(i).fill(r, t) : d(i).fill(r) : d(i);
    }
    h.alloc = function(i, r, t) {
        return Mr(i, r, t);
    };
    function j(i) {
        return or(i), d(i < 0 ? 0 : H(i) | 0);
    }
    h.allocUnsafe = function(i) {
        return j(i);
    };
    h.allocUnsafeSlow = function(i) {
        return j(i);
    };
    function kr(i, r) {
        if ((typeof r != "string" || r === "") && (r = "utf8"), !h.isEncoding(r)) throw new TypeError("Unknown encoding: " + r);
        let t = ur(i, r) | 0, n = d(t), e = n.write(i, r);
        return e !== t && (n = n.slice(0, e)), n;
    }
    function Y(i) {
        let r = i.length < 0 ? 0 : H(i.length) | 0, t = d(r);
        for(let n = 0; n < r; n += 1)t[n] = i[n] & 255;
        return t;
    }
    function Dr(i) {
        if (E(i, Uint8Array)) {
            let r = new Uint8Array(i);
            return q(r.buffer, r.byteOffset, r.byteLength);
        }
        return Y(i);
    }
    function q(i, r, t) {
        if (r < 0 || i.byteLength < r) throw new RangeError('"offset" is outside of buffer bounds');
        if (i.byteLength < r + (t || 0)) throw new RangeError('"length" is outside of buffer bounds');
        let n;
        return r === void 0 && t === void 0 ? n = new Uint8Array(i) : t === void 0 ? n = new Uint8Array(i, r) : n = new Uint8Array(i, r, t), Object.setPrototypeOf(n, h.prototype), n;
    }
    function br(i) {
        if (h.isBuffer(i)) {
            let r = H(i.length) | 0, t = d(r);
            return t.length === 0 || i.copy(t, 0, 0, r), t;
        }
        if (i.length !== void 0) return typeof i.length != "number" || X(i.length) ? d(0) : Y(i);
        if (i.type === "Buffer" && Array.isArray(i.data)) return Y(i.data);
    }
    function H(i) {
        if (i >= k) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + k.toString(16) + " bytes");
        return i | 0;
    }
    function $r(i) {
        return +i != i && (i = 0), h.alloc(+i);
    }
    h.isBuffer = function(r) {
        return r != null && r._isBuffer === !0 && r !== h.prototype;
    };
    h.compare = function(r, t) {
        if (E(r, Uint8Array) && (r = h.from(r, r.offset, r.byteLength)), E(t, Uint8Array) && (t = h.from(t, t.offset, t.byteLength)), !h.isBuffer(r) || !h.isBuffer(t)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (r === t) return 0;
        let n = r.length, e = t.length;
        for(let o = 0, u = Math.min(n, e); o < u; ++o)if (r[o] !== t[o]) {
            n = r[o], e = t[o];
            break;
        }
        return n < e ? -1 : e < n ? 1 : 0;
    };
    h.isEncoding = function(r) {
        switch(String(r).toLowerCase()){
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return !0;
            default:
                return !1;
        }
    };
    h.concat = function(r, t) {
        if (!Array.isArray(r)) throw new TypeError('"list" argument must be an Array of Buffers');
        if (r.length === 0) return h.alloc(0);
        let n;
        if (t === void 0) for(t = 0, n = 0; n < r.length; ++n)t += r[n].length;
        let e = h.allocUnsafe(t), o = 0;
        for(n = 0; n < r.length; ++n){
            let u = r[n];
            if (E(u, Uint8Array)) o + u.length > e.length ? (h.isBuffer(u) || (u = h.from(u)), u.copy(e, o)) : Uint8Array.prototype.set.call(e, u, o);
            else if (h.isBuffer(u)) u.copy(e, o);
            else throw new TypeError('"list" argument must be an Array of Buffers');
            o += u.length;
        }
        return e;
    };
    function ur(i, r) {
        if (h.isBuffer(i)) return i.length;
        if (ArrayBuffer.isView(i) || E(i, ArrayBuffer)) return i.byteLength;
        if (typeof i != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof i);
        let t = i.length, n = arguments.length > 2 && arguments[2] === !0;
        if (!n && t === 0) return 0;
        let e = !1;
        for(;;)switch(r){
            case "ascii":
            case "latin1":
            case "binary":
                return t;
            case "utf8":
            case "utf-8":
                return W(i).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return t * 2;
            case "hex":
                return t >>> 1;
            case "base64":
                return wr(i).length;
            default:
                if (e) return n ? -1 : W(i).length;
                r = ("" + r).toLowerCase(), e = !0;
        }
    }
    h.byteLength = ur;
    function Pr(i, r, t) {
        let n = !1;
        if ((r === void 0 || r < 0) && (r = 0), r > this.length || ((t === void 0 || t > this.length) && (t = this.length), t <= 0) || (t >>>= 0, r >>>= 0, t <= r)) return "";
        for(i || (i = "utf8");;)switch(i){
            case "hex":
                return zr(this, r, t);
            case "utf8":
            case "utf-8":
                return fr(this, r, t);
            case "ascii":
                return Vr(this, r, t);
            case "latin1":
            case "binary":
                return Xr(this, r, t);
            case "base64":
                return jr(this, r, t);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return Jr(this, r, t);
            default:
                if (n) throw new TypeError("Unknown encoding: " + i);
                i = (i + "").toLowerCase(), n = !0;
        }
    }
    h.prototype._isBuffer = !0;
    function I(i, r, t) {
        let n = i[r];
        i[r] = i[t], i[t] = n;
    }
    h.prototype.swap16 = function() {
        let r = this.length;
        if (r % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
        for(let t = 0; t < r; t += 2)I(this, t, t + 1);
        return this;
    };
    h.prototype.swap32 = function() {
        let r = this.length;
        if (r % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
        for(let t = 0; t < r; t += 4)I(this, t, t + 3), I(this, t + 1, t + 2);
        return this;
    };
    h.prototype.swap64 = function() {
        let r = this.length;
        if (r % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
        for(let t = 0; t < r; t += 8)I(this, t, t + 7), I(this, t + 1, t + 6), I(this, t + 2, t + 5), I(this, t + 3, t + 4);
        return this;
    };
    h.prototype.toString = function() {
        let r = this.length;
        return r === 0 ? "" : arguments.length === 0 ? fr(this, 0, r) : Pr.apply(this, arguments);
    };
    h.prototype.toLocaleString = h.prototype.toString;
    h.prototype.equals = function(r) {
        if (!h.isBuffer(r)) throw new TypeError("Argument must be a Buffer");
        return this === r ? !0 : h.compare(this, r) === 0;
    };
    h.prototype.inspect = function() {
        let r = "", t = T.INSPECT_MAX_BYTES;
        return r = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim(), this.length > t && (r += " ... "), "<Buffer " + r + ">";
    };
    rr && (h.prototype[rr] = h.prototype.inspect);
    h.prototype.compare = function(r, t, n, e, o) {
        if (E(r, Uint8Array) && (r = h.from(r, r.offset, r.byteLength)), !h.isBuffer(r)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof r);
        if (t === void 0 && (t = 0), n === void 0 && (n = r ? r.length : 0), e === void 0 && (e = 0), o === void 0 && (o = this.length), t < 0 || n > r.length || e < 0 || o > this.length) throw new RangeError("out of range index");
        if (e >= o && t >= n) return 0;
        if (e >= o) return -1;
        if (t >= n) return 1;
        if (t >>>= 0, n >>>= 0, e >>>= 0, o >>>= 0, this === r) return 0;
        let u = o - e, f = n - t, c = Math.min(u, f), l = this.slice(e, o), s = r.slice(t, n);
        for(let p = 0; p < c; ++p)if (l[p] !== s[p]) {
            u = l[p], f = s[p];
            break;
        }
        return u < f ? -1 : f < u ? 1 : 0;
    };
    function hr(i, r, t, n, e) {
        if (i.length === 0) return -1;
        if (typeof t == "string" ? (n = t, t = 0) : t > 2147483647 ? t = 2147483647 : t < -2147483648 && (t = -2147483648), t = +t, X(t) && (t = e ? 0 : i.length - 1), t < 0 && (t = i.length + t), t >= i.length) {
            if (e) return -1;
            t = i.length - 1;
        } else if (t < 0) {
            if (e) t = 0;
            else return -1;
        }
        if (typeof r == "string" && (r = h.from(r, n)), h.isBuffer(r)) return r.length === 0 ? -1 : tr(i, r, t, n, e);
        if (typeof r == "number") return r = r & 255, typeof Uint8Array.prototype.indexOf == "function" ? e ? Uint8Array.prototype.indexOf.call(i, r, t) : Uint8Array.prototype.lastIndexOf.call(i, r, t) : tr(i, [
            r
        ], t, n, e);
        throw new TypeError("val must be string, number or Buffer");
    }
    function tr(i, r, t, n, e) {
        let o = 1, u = i.length, f = r.length;
        if (n !== void 0 && (n = String(n).toLowerCase(), n === "ucs2" || n === "ucs-2" || n === "utf16le" || n === "utf-16le")) {
            if (i.length < 2 || r.length < 2) return -1;
            o = 2, u /= 2, f /= 2, t /= 2;
        }
        function c(s, p) {
            return o === 1 ? s[p] : s.readUInt16BE(p * o);
        }
        let l;
        if (e) {
            let s = -1;
            for(l = t; l < u; l++)if (c(i, l) === c(r, s === -1 ? 0 : l - s)) {
                if (s === -1 && (s = l), l - s + 1 === f) return s * o;
            } else s !== -1 && (l -= l - s), s = -1;
        } else for(t + f > u && (t = u - f), l = t; l >= 0; l--){
            let s = !0;
            for(let p = 0; p < f; p++)if (c(i, l + p) !== c(r, p)) {
                s = !1;
                break;
            }
            if (s) return l;
        }
        return -1;
    }
    h.prototype.includes = function(r, t, n) {
        return this.indexOf(r, t, n) !== -1;
    };
    h.prototype.indexOf = function(r, t, n) {
        return hr(this, r, t, n, !0);
    };
    h.prototype.lastIndexOf = function(r, t, n) {
        return hr(this, r, t, n, !1);
    };
    function Or(i, r, t, n) {
        t = Number(t) || 0;
        let e = i.length - t;
        n ? (n = Number(n), n > e && (n = e)) : n = e;
        let o = r.length;
        n > o / 2 && (n = o / 2);
        let u;
        for(u = 0; u < n; ++u){
            let f = parseInt(r.substr(u * 2, 2), 16);
            if (X(f)) return u;
            i[t + u] = f;
        }
        return u;
    }
    function Gr(i, r, t, n) {
        return D(W(r, i.length - t), i, t, n);
    }
    function Yr(i, r, t, n) {
        return D(vr(r), i, t, n);
    }
    function qr(i, r, t, n) {
        return D(wr(r), i, t, n);
    }
    function Wr(i, r, t, n) {
        return D(rt(r, i.length - t), i, t, n);
    }
    h.prototype.write = function(r, t, n, e) {
        if (t === void 0) e = "utf8", n = this.length, t = 0;
        else if (n === void 0 && typeof t == "string") e = t, n = this.length, t = 0;
        else if (isFinite(t)) t = t >>> 0, isFinite(n) ? (n = n >>> 0, e === void 0 && (e = "utf8")) : (e = n, n = void 0);
        else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        let o = this.length - t;
        if ((n === void 0 || n > o) && (n = o), r.length > 0 && (n < 0 || t < 0) || t > this.length) throw new RangeError("Attempt to write outside buffer bounds");
        e || (e = "utf8");
        let u = !1;
        for(;;)switch(e){
            case "hex":
                return Or(this, r, t, n);
            case "utf8":
            case "utf-8":
                return Gr(this, r, t, n);
            case "ascii":
            case "latin1":
            case "binary":
                return Yr(this, r, t, n);
            case "base64":
                return qr(this, r, t, n);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return Wr(this, r, t, n);
            default:
                if (u) throw new TypeError("Unknown encoding: " + e);
                e = ("" + e).toLowerCase(), u = !0;
        }
    };
    h.prototype.toJSON = function() {
        return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
        };
    };
    function jr(i, r, t) {
        return r === 0 && t === i.length ? G.fromByteArray(i) : G.fromByteArray(i.slice(r, t));
    }
    function fr(i, r, t) {
        t = Math.min(i.length, t);
        let n = [], e = r;
        for(; e < t;){
            let o = i[e], u = null, f = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1;
            if (e + f <= t) {
                let c, l, s, p;
                switch(f){
                    case 1:
                        o < 128 && (u = o);
                        break;
                    case 2:
                        c = i[e + 1], (c & 192) === 128 && (p = (o & 31) << 6 | c & 63, p > 127 && (u = p));
                        break;
                    case 3:
                        c = i[e + 1], l = i[e + 2], (c & 192) === 128 && (l & 192) === 128 && (p = (o & 15) << 12 | (c & 63) << 6 | l & 63, p > 2047 && (p < 55296 || p > 57343) && (u = p));
                        break;
                    case 4:
                        c = i[e + 1], l = i[e + 2], s = i[e + 3], (c & 192) === 128 && (l & 192) === 128 && (s & 192) === 128 && (p = (o & 15) << 18 | (c & 63) << 12 | (l & 63) << 6 | s & 63, p > 65535 && p < 1114112 && (u = p));
                }
            }
            u === null ? (u = 65533, f = 1) : u > 65535 && (u -= 65536, n.push(u >>> 10 & 1023 | 55296), u = 56320 | u & 1023), n.push(u), e += f;
        }
        return Hr(n);
    }
    var ir = 4096;
    function Hr(i) {
        let r = i.length;
        if (r <= ir) return String.fromCharCode.apply(String, i);
        let t = "", n = 0;
        for(; n < r;)t += String.fromCharCode.apply(String, i.slice(n, n += ir));
        return t;
    }
    function Vr(i, r, t) {
        let n = "";
        t = Math.min(i.length, t);
        for(let e = r; e < t; ++e)n += String.fromCharCode(i[e] & 127);
        return n;
    }
    function Xr(i, r, t) {
        let n = "";
        t = Math.min(i.length, t);
        for(let e = r; e < t; ++e)n += String.fromCharCode(i[e]);
        return n;
    }
    function zr(i, r, t) {
        let n = i.length;
        (!r || r < 0) && (r = 0), (!t || t < 0 || t > n) && (t = n);
        let e = "";
        for(let o = r; o < t; ++o)e += tt[i[o]];
        return e;
    }
    function Jr(i, r, t) {
        let n = i.slice(r, t), e = "";
        for(let o = 0; o < n.length - 1; o += 2)e += String.fromCharCode(n[o] + n[o + 1] * 256);
        return e;
    }
    h.prototype.slice = function(r, t) {
        let n = this.length;
        r = ~~r, t = t === void 0 ? n : ~~t, r < 0 ? (r += n, r < 0 && (r = 0)) : r > n && (r = n), t < 0 ? (t += n, t < 0 && (t = 0)) : t > n && (t = n), t < r && (t = r);
        let e = this.subarray(r, t);
        return Object.setPrototypeOf(e, h.prototype), e;
    };
    function a(i, r, t) {
        if (i % 1 !== 0 || i < 0) throw new RangeError("offset is not uint");
        if (i + r > t) throw new RangeError("Trying to access beyond buffer length");
    }
    h.prototype.readUintLE = h.prototype.readUIntLE = function(r, t, n) {
        r = r >>> 0, t = t >>> 0, n || a(r, t, this.length);
        let e = this[r], o = 1, u = 0;
        for(; ++u < t && (o *= 256);)e += this[r + u] * o;
        return e;
    };
    h.prototype.readUintBE = h.prototype.readUIntBE = function(r, t, n) {
        r = r >>> 0, t = t >>> 0, n || a(r, t, this.length);
        let e = this[r + --t], o = 1;
        for(; t > 0 && (o *= 256);)e += this[r + --t] * o;
        return e;
    };
    h.prototype.readUint8 = h.prototype.readUInt8 = function(r, t) {
        return r = r >>> 0, t || a(r, 1, this.length), this[r];
    };
    h.prototype.readUint16LE = h.prototype.readUInt16LE = function(r, t) {
        return r = r >>> 0, t || a(r, 2, this.length), this[r] | this[r + 1] << 8;
    };
    h.prototype.readUint16BE = h.prototype.readUInt16BE = function(r, t) {
        return r = r >>> 0, t || a(r, 2, this.length), this[r] << 8 | this[r + 1];
    };
    h.prototype.readUint32LE = h.prototype.readUInt32LE = function(r, t) {
        return r = r >>> 0, t || a(r, 4, this.length), (this[r] | this[r + 1] << 8 | this[r + 2] << 16) + this[r + 3] * 16777216;
    };
    h.prototype.readUint32BE = h.prototype.readUInt32BE = function(r, t) {
        return r = r >>> 0, t || a(r, 4, this.length), this[r] * 16777216 + (this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3]);
    };
    h.prototype.readBigUInt64LE = g(function(r) {
        r = r >>> 0, R(r, "offset");
        let t = this[r], n = this[r + 7];
        (t === void 0 || n === void 0) && _(r, this.length - 8);
        let e = t + this[++r] * 256 + this[++r] * 2 ** 16 + this[++r] * 2 ** 24, o = this[++r] + this[++r] * 256 + this[++r] * 2 ** 16 + n * 2 ** 24;
        return BigInt(e) + (BigInt(o) << BigInt(32));
    });
    h.prototype.readBigUInt64BE = g(function(r) {
        r = r >>> 0, R(r, "offset");
        let t = this[r], n = this[r + 7];
        (t === void 0 || n === void 0) && _(r, this.length - 8);
        let e = t * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 256 + this[++r], o = this[++r] * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 256 + n;
        return (BigInt(e) << BigInt(32)) + BigInt(o);
    });
    h.prototype.readIntLE = function(r, t, n) {
        r = r >>> 0, t = t >>> 0, n || a(r, t, this.length);
        let e = this[r], o = 1, u = 0;
        for(; ++u < t && (o *= 256);)e += this[r + u] * o;
        return o *= 128, e >= o && (e -= Math.pow(2, 8 * t)), e;
    };
    h.prototype.readIntBE = function(r, t, n) {
        r = r >>> 0, t = t >>> 0, n || a(r, t, this.length);
        let e = t, o = 1, u = this[r + --e];
        for(; e > 0 && (o *= 256);)u += this[r + --e] * o;
        return o *= 128, u >= o && (u -= Math.pow(2, 8 * t)), u;
    };
    h.prototype.readInt8 = function(r, t) {
        return r = r >>> 0, t || a(r, 1, this.length), this[r] & 128 ? (255 - this[r] + 1) * -1 : this[r];
    };
    h.prototype.readInt16LE = function(r, t) {
        r = r >>> 0, t || a(r, 2, this.length);
        let n = this[r] | this[r + 1] << 8;
        return n & 32768 ? n | 4294901760 : n;
    };
    h.prototype.readInt16BE = function(r, t) {
        r = r >>> 0, t || a(r, 2, this.length);
        let n = this[r + 1] | this[r] << 8;
        return n & 32768 ? n | 4294901760 : n;
    };
    h.prototype.readInt32LE = function(r, t) {
        return r = r >>> 0, t || a(r, 4, this.length), this[r] | this[r + 1] << 8 | this[r + 2] << 16 | this[r + 3] << 24;
    };
    h.prototype.readInt32BE = function(r, t) {
        return r = r >>> 0, t || a(r, 4, this.length), this[r] << 24 | this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3];
    };
    h.prototype.readBigInt64LE = g(function(r) {
        r = r >>> 0, R(r, "offset");
        let t = this[r], n = this[r + 7];
        (t === void 0 || n === void 0) && _(r, this.length - 8);
        let e = this[r + 4] + this[r + 5] * 256 + this[r + 6] * 2 ** 16 + (n << 24);
        return (BigInt(e) << BigInt(32)) + BigInt(t + this[++r] * 256 + this[++r] * 2 ** 16 + this[++r] * 2 ** 24);
    });
    h.prototype.readBigInt64BE = g(function(r) {
        r = r >>> 0, R(r, "offset");
        let t = this[r], n = this[r + 7];
        (t === void 0 || n === void 0) && _(r, this.length - 8);
        let e = (t << 24) + this[++r] * 2 ** 16 + this[++r] * 256 + this[++r];
        return (BigInt(e) << BigInt(32)) + BigInt(this[++r] * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 256 + n);
    });
    h.prototype.readFloatLE = function(r, t) {
        return r = r >>> 0, t || a(r, 4, this.length), U.read(this, r, !0, 23, 4);
    };
    h.prototype.readFloatBE = function(r, t) {
        return r = r >>> 0, t || a(r, 4, this.length), U.read(this, r, !1, 23, 4);
    };
    h.prototype.readDoubleLE = function(r, t) {
        return r = r >>> 0, t || a(r, 8, this.length), U.read(this, r, !0, 52, 8);
    };
    h.prototype.readDoubleBE = function(r, t) {
        return r = r >>> 0, t || a(r, 8, this.length), U.read(this, r, !1, 52, 8);
    };
    function y(i, r, t, n, e, o) {
        if (!h.isBuffer(i)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (r > e || r < o) throw new RangeError('"value" argument is out of bounds');
        if (t + n > i.length) throw new RangeError("Index out of range");
    }
    h.prototype.writeUintLE = h.prototype.writeUIntLE = function(r, t, n, e) {
        if (r = +r, t = t >>> 0, n = n >>> 0, !e) {
            let f = Math.pow(2, 8 * n) - 1;
            y(this, r, t, n, f, 0);
        }
        let o = 1, u = 0;
        for(this[t] = r & 255; ++u < n && (o *= 256);)this[t + u] = r / o & 255;
        return t + n;
    };
    h.prototype.writeUintBE = h.prototype.writeUIntBE = function(r, t, n, e) {
        if (r = +r, t = t >>> 0, n = n >>> 0, !e) {
            let f = Math.pow(2, 8 * n) - 1;
            y(this, r, t, n, f, 0);
        }
        let o = n - 1, u = 1;
        for(this[t + o] = r & 255; --o >= 0 && (u *= 256);)this[t + o] = r / u & 255;
        return t + n;
    };
    h.prototype.writeUint8 = h.prototype.writeUInt8 = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 1, 255, 0), this[t] = r & 255, t + 1;
    };
    h.prototype.writeUint16LE = h.prototype.writeUInt16LE = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 2, 65535, 0), this[t] = r & 255, this[t + 1] = r >>> 8, t + 2;
    };
    h.prototype.writeUint16BE = h.prototype.writeUInt16BE = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 2, 65535, 0), this[t] = r >>> 8, this[t + 1] = r & 255, t + 2;
    };
    h.prototype.writeUint32LE = h.prototype.writeUInt32LE = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 4, 4294967295, 0), this[t + 3] = r >>> 24, this[t + 2] = r >>> 16, this[t + 1] = r >>> 8, this[t] = r & 255, t + 4;
    };
    h.prototype.writeUint32BE = h.prototype.writeUInt32BE = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 4, 4294967295, 0), this[t] = r >>> 24, this[t + 1] = r >>> 16, this[t + 2] = r >>> 8, this[t + 3] = r & 255, t + 4;
    };
    function cr(i, r, t, n, e) {
        yr(r, n, e, i, t, 7);
        let o = Number(r & BigInt(4294967295));
        i[t++] = o, o = o >> 8, i[t++] = o, o = o >> 8, i[t++] = o, o = o >> 8, i[t++] = o;
        let u = Number(r >> BigInt(32) & BigInt(4294967295));
        return i[t++] = u, u = u >> 8, i[t++] = u, u = u >> 8, i[t++] = u, u = u >> 8, i[t++] = u, t;
    }
    function pr(i, r, t, n, e) {
        yr(r, n, e, i, t, 7);
        let o = Number(r & BigInt(4294967295));
        i[t + 7] = o, o = o >> 8, i[t + 6] = o, o = o >> 8, i[t + 5] = o, o = o >> 8, i[t + 4] = o;
        let u = Number(r >> BigInt(32) & BigInt(4294967295));
        return i[t + 3] = u, u = u >> 8, i[t + 2] = u, u = u >> 8, i[t + 1] = u, u = u >> 8, i[t] = u, t + 8;
    }
    h.prototype.writeBigUInt64LE = g(function(r, t = 0) {
        return cr(this, r, t, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    h.prototype.writeBigUInt64BE = g(function(r, t = 0) {
        return pr(this, r, t, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    h.prototype.writeIntLE = function(r, t, n, e) {
        if (r = +r, t = t >>> 0, !e) {
            let c = Math.pow(2, 8 * n - 1);
            y(this, r, t, n, c - 1, -c);
        }
        let o = 0, u = 1, f = 0;
        for(this[t] = r & 255; ++o < n && (u *= 256);)r < 0 && f === 0 && this[t + o - 1] !== 0 && (f = 1), this[t + o] = (r / u >> 0) - f & 255;
        return t + n;
    };
    h.prototype.writeIntBE = function(r, t, n, e) {
        if (r = +r, t = t >>> 0, !e) {
            let c = Math.pow(2, 8 * n - 1);
            y(this, r, t, n, c - 1, -c);
        }
        let o = n - 1, u = 1, f = 0;
        for(this[t + o] = r & 255; --o >= 0 && (u *= 256);)r < 0 && f === 0 && this[t + o + 1] !== 0 && (f = 1), this[t + o] = (r / u >> 0) - f & 255;
        return t + n;
    };
    h.prototype.writeInt8 = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 1, 127, -128), r < 0 && (r = 255 + r + 1), this[t] = r & 255, t + 1;
    };
    h.prototype.writeInt16LE = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 2, 32767, -32768), this[t] = r & 255, this[t + 1] = r >>> 8, t + 2;
    };
    h.prototype.writeInt16BE = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 2, 32767, -32768), this[t] = r >>> 8, this[t + 1] = r & 255, t + 2;
    };
    h.prototype.writeInt32LE = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 4, 2147483647, -2147483648), this[t] = r & 255, this[t + 1] = r >>> 8, this[t + 2] = r >>> 16, this[t + 3] = r >>> 24, t + 4;
    };
    h.prototype.writeInt32BE = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 4, 2147483647, -2147483648), r < 0 && (r = 4294967295 + r + 1), this[t] = r >>> 24, this[t + 1] = r >>> 16, this[t + 2] = r >>> 8, this[t + 3] = r & 255, t + 4;
    };
    h.prototype.writeBigInt64LE = g(function(r, t = 0) {
        return cr(this, r, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    h.prototype.writeBigInt64BE = g(function(r, t = 0) {
        return pr(this, r, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function sr(i, r, t, n, e, o) {
        if (t + n > i.length) throw new RangeError("Index out of range");
        if (t < 0) throw new RangeError("Index out of range");
    }
    function lr(i, r, t, n, e) {
        return r = +r, t = t >>> 0, e || sr(i, r, t, 4, 34028234663852886e22, -340282346638528860000000000000000000000), U.write(i, r, t, n, 23, 4), t + 4;
    }
    h.prototype.writeFloatLE = function(r, t, n) {
        return lr(this, r, t, !0, n);
    };
    h.prototype.writeFloatBE = function(r, t, n) {
        return lr(this, r, t, !1, n);
    };
    function ar(i, r, t, n, e) {
        return r = +r, t = t >>> 0, e || sr(i, r, t, 8, 17976931348623157e292, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), U.write(i, r, t, n, 52, 8), t + 8;
    }
    h.prototype.writeDoubleLE = function(r, t, n) {
        return ar(this, r, t, !0, n);
    };
    h.prototype.writeDoubleBE = function(r, t, n) {
        return ar(this, r, t, !1, n);
    };
    h.prototype.copy = function(r, t, n, e) {
        if (!h.isBuffer(r)) throw new TypeError("argument should be a Buffer");
        if (n || (n = 0), !e && e !== 0 && (e = this.length), t >= r.length && (t = r.length), t || (t = 0), e > 0 && e < n && (e = n), e === n || r.length === 0 || this.length === 0) return 0;
        if (t < 0) throw new RangeError("targetStart out of bounds");
        if (n < 0 || n >= this.length) throw new RangeError("Index out of range");
        if (e < 0) throw new RangeError("sourceEnd out of bounds");
        e > this.length && (e = this.length), r.length - t < e - n && (e = r.length - t + n);
        let o = e - n;
        return this === r && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(t, n, e) : Uint8Array.prototype.set.call(r, this.subarray(n, e), t), o;
    };
    h.prototype.fill = function(r, t, n, e) {
        if (typeof r == "string") {
            if (typeof t == "string" ? (e = t, t = 0, n = this.length) : typeof n == "string" && (e = n, n = this.length), e !== void 0 && typeof e != "string") throw new TypeError("encoding must be a string");
            if (typeof e == "string" && !h.isEncoding(e)) throw new TypeError("Unknown encoding: " + e);
            if (r.length === 1) {
                let u = r.charCodeAt(0);
                (e === "utf8" && u < 128 || e === "latin1") && (r = u);
            }
        } else typeof r == "number" ? r = r & 255 : typeof r == "boolean" && (r = Number(r));
        if (t < 0 || this.length < t || this.length < n) throw new RangeError("Out of range index");
        if (n <= t) return this;
        t = t >>> 0, n = n === void 0 ? this.length : n >>> 0, r || (r = 0);
        let o;
        if (typeof r == "number") for(o = t; o < n; ++o)this[o] = r;
        else {
            let u = h.isBuffer(r) ? r : h.from(r, e), f = u.length;
            if (f === 0) throw new TypeError('The value "' + r + '" is invalid for argument "value"');
            for(o = 0; o < n - t; ++o)this[o + t] = u[o % f];
        }
        return this;
    };
    var A = {};
    function V(i, r, t) {
        A[i] = class extends t {
            constructor(){
                super(), Object.defineProperty(this, "message", {
                    value: r.apply(this, arguments),
                    writable: !0,
                    configurable: !0
                }), this.name = "".concat(this.name, " [").concat(i, "]"), this.stack, delete this.name;
            }
            get code() {
                return i;
            }
            set code(e) {
                Object.defineProperty(this, "code", {
                    configurable: !0,
                    enumerable: !0,
                    value: e,
                    writable: !0
                });
            }
            toString() {
                return "".concat(this.name, " [").concat(i, "]: ").concat(this.message);
            }
        };
    }
    V("ERR_BUFFER_OUT_OF_BOUNDS", function(i) {
        return i ? "".concat(i, " is outside of buffer bounds") : "Attempt to access memory outside buffer bounds";
    }, RangeError);
    V("ERR_INVALID_ARG_TYPE", function(i, r) {
        return 'The "'.concat(i, '" argument must be of type number. Received type ').concat(typeof r);
    }, TypeError);
    V("ERR_OUT_OF_RANGE", function(i, r, t) {
        let n = 'The value of "'.concat(i, '" is out of range.'), e = t;
        return Number.isInteger(t) && Math.abs(t) > 2 ** 32 ? e = nr(String(t)) : typeof t == "bigint" && (e = String(t), (t > BigInt(2) ** BigInt(32) || t < -(BigInt(2) ** BigInt(32))) && (e = nr(e)), e += "n"), n += " It must be ".concat(r, ". Received ").concat(e), n;
    }, RangeError);
    function nr(i) {
        let r = "", t = i.length, n = i[0] === "-" ? 1 : 0;
        for(; t >= n + 4; t -= 3)r = "_".concat(i.slice(t - 3, t)).concat(r);
        return "".concat(i.slice(0, t)).concat(r);
    }
    function Kr(i, r, t) {
        R(r, "offset"), (i[r] === void 0 || i[r + t] === void 0) && _(r, i.length - (t + 1));
    }
    function yr(i, r, t, n, e, o) {
        if (i > t || i < r) {
            let u = typeof r == "bigint" ? "n" : "", f;
            throw o > 3 ? r === 0 || r === BigInt(0) ? f = ">= 0".concat(u, " and < 2").concat(u, " ** ").concat((o + 1) * 8).concat(u) : f = ">= -(2".concat(u, " ** ").concat((o + 1) * 8 - 1).concat(u, ") and < 2 ** ") + "".concat((o + 1) * 8 - 1).concat(u) : f = ">= ".concat(r).concat(u, " and <= ").concat(t).concat(u), new A.ERR_OUT_OF_RANGE("value", f, i);
        }
        Kr(n, e, o);
    }
    function R(i, r) {
        if (typeof i != "number") throw new A.ERR_INVALID_ARG_TYPE(r, "number", i);
    }
    function _(i, r, t) {
        throw Math.floor(i) !== i ? (R(i, t), new A.ERR_OUT_OF_RANGE(t || "offset", "an integer", i)) : r < 0 ? new A.ERR_BUFFER_OUT_OF_BOUNDS : new A.ERR_OUT_OF_RANGE(t || "offset", ">= ".concat(t ? 1 : 0, " and <= ").concat(r), i);
    }
    var Zr = /[^+/0-9A-Za-z-_]/g;
    function Qr(i) {
        if (i = i.split("=")[0], i = i.trim().replace(Zr, ""), i.length < 2) return "";
        for(; i.length % 4 !== 0;)i = i + "=";
        return i;
    }
    function W(i, r) {
        r = r || 1 / 0;
        let t, n = i.length, e = null, o = [];
        for(let u = 0; u < n; ++u){
            if (t = i.charCodeAt(u), t > 55295 && t < 57344) {
                if (!e) {
                    if (t > 56319) {
                        (r -= 3) > -1 && o.push(239, 191, 189);
                        continue;
                    } else if (u + 1 === n) {
                        (r -= 3) > -1 && o.push(239, 191, 189);
                        continue;
                    }
                    e = t;
                    continue;
                }
                if (t < 56320) {
                    (r -= 3) > -1 && o.push(239, 191, 189), e = t;
                    continue;
                }
                t = (e - 55296 << 10 | t - 56320) + 65536;
            } else e && (r -= 3) > -1 && o.push(239, 191, 189);
            if (e = null, t < 128) {
                if ((r -= 1) < 0) break;
                o.push(t);
            } else if (t < 2048) {
                if ((r -= 2) < 0) break;
                o.push(t >> 6 | 192, t & 63 | 128);
            } else if (t < 65536) {
                if ((r -= 3) < 0) break;
                o.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128);
            } else if (t < 1114112) {
                if ((r -= 4) < 0) break;
                o.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128);
            } else throw new Error("Invalid code point");
        }
        return o;
    }
    function vr(i) {
        let r = [];
        for(let t = 0; t < i.length; ++t)r.push(i.charCodeAt(t) & 255);
        return r;
    }
    function rt(i, r) {
        let t, n, e, o = [];
        for(let u = 0; u < i.length && !((r -= 2) < 0); ++u)t = i.charCodeAt(u), n = t >> 8, e = t % 256, o.push(e), o.push(n);
        return o;
    }
    function wr(i) {
        return G.toByteArray(Qr(i));
    }
    function D(i, r, t, n) {
        let e;
        for(e = 0; e < n && !(e + t >= r.length || e >= i.length); ++e)r[e + t] = i[e];
        return e;
    }
    function E(i, r) {
        return i instanceof r || i != null && i.constructor != null && i.constructor.name != null && i.constructor.name === r.name;
    }
    function X(i) {
        return i !== i;
    }
    var tt = function() {
        let i = "0123456789abcdef", r = new Array(256);
        for(let t = 0; t < 16; ++t){
            let n = t * 16;
            for(let e = 0; e < 16; ++e)r[n + e] = i[t] + i[e];
        }
        return r;
    }();
    function g(i) {
        return typeof BigInt > "u" ? it : i;
    }
    function it() {
        throw new Error("BigInt not supported");
    }
});
var C = {};
Fr(C, {
    default: ()=>nt
});
module.exports = Ar(C);
var xr = J(z());
S(C, J(z()), module.exports);
var nt = xr.default; /*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/ 

},{}],"jWuNn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
"use strict";
/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 *
 * @returns {Error} The created error.
 */ function AxiosError(message, code, config, request, response) {
    Error.call(this);
    if (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
    else this.stack = new Error().stack;
    this.message = message;
    this.name = "AxiosError";
    code && (this.code = code);
    config && (this.config = config);
    request && (this.request = request);
    response && (this.response = response);
}
(0, _utilsJsDefault.default).inherits(AxiosError, Error, {
    toJSON: function toJSON() {
        return {
            // Standard
            message: this.message,
            name: this.name,
            // Microsoft
            description: this.description,
            number: this.number,
            // Mozilla
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            // Axios
            config: (0, _utilsJsDefault.default).toJSONObject(this.config),
            code: this.code,
            status: this.response && this.response.status ? this.response.status : null
        };
    }
});
const prototype = AxiosError.prototype;
const descriptors = {};
[
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED",
    "ERR_NOT_SUPPORT",
    "ERR_INVALID_URL"
].forEach((code)=>{
    descriptors[code] = {
        value: code
    };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", {
    value: true
});
// eslint-disable-next-line func-names
AxiosError.from = (error, code, config, request, response, customProps)=>{
    const axiosError = Object.create(prototype);
    (0, _utilsJsDefault.default).toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
    }, (prop)=>{
        return prop !== "isAxiosError";
    });
    AxiosError.call(axiosError, error.message, code, config, request, response);
    axiosError.cause = error;
    axiosError.name = error.name;
    customProps && Object.assign(axiosError, customProps);
    return axiosError;
};
exports.default = AxiosError;

},{"../utils.js":"6pgCP","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"hcZFZ":[function(require,module,exports) {
// eslint-disable-next-line strict
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = null;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"cSbIA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
"use strict";
class InterceptorManager {
    constructor(){
        this.handlers = [];
    }
    /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */ use(fulfilled, rejected, options) {
        this.handlers.push({
            fulfilled,
            rejected,
            synchronous: options ? options.synchronous : false,
            runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
    }
    /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */ eject(id) {
        if (this.handlers[id]) this.handlers[id] = null;
    }
    /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */ clear() {
        if (this.handlers) this.handlers = [];
    }
    /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */ forEach(fn) {
        (0, _utilsJsDefault.default).forEach(this.handlers, function forEachHandler(h) {
            if (h !== null) fn(h);
        });
    }
}
exports.default = InterceptorManager;

},{"./../utils.js":"6pgCP","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"9S0Mq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>dispatchRequest);
var _transformDataJs = require("./transformData.js");
var _transformDataJsDefault = parcelHelpers.interopDefault(_transformDataJs);
var _isCancelJs = require("../cancel/isCancel.js");
var _isCancelJsDefault = parcelHelpers.interopDefault(_isCancelJs);
var _indexJs = require("../defaults/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _canceledErrorJs = require("../cancel/CanceledError.js");
var _canceledErrorJsDefault = parcelHelpers.interopDefault(_canceledErrorJs);
var _axiosHeadersJs = require("../core/AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
var _adaptersJs = require("../adapters/adapters.js");
var _adaptersJsDefault = parcelHelpers.interopDefault(_adaptersJs);
"use strict";
/**
 * Throws a `CanceledError` if cancellation has been requested.
 *
 * @param {Object} config The config that is to be used for the request
 *
 * @returns {void}
 */ function throwIfCancellationRequested(config) {
    if (config.cancelToken) config.cancelToken.throwIfRequested();
    if (config.signal && config.signal.aborted) throw new (0, _canceledErrorJsDefault.default)(null, config);
}
function dispatchRequest(config) {
    throwIfCancellationRequested(config);
    config.headers = (0, _axiosHeadersJsDefault.default).from(config.headers);
    // Transform request data
    config.data = (0, _transformDataJsDefault.default).call(config, config.transformRequest);
    if ([
        "post",
        "put",
        "patch"
    ].indexOf(config.method) !== -1) config.headers.setContentType("application/x-www-form-urlencoded", false);
    const adapter = (0, _adaptersJsDefault.default).getAdapter(config.adapter || (0, _indexJsDefault.default).adapter);
    return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        // Transform response data
        response.data = (0, _transformDataJsDefault.default).call(config, config.transformResponse, response);
        response.headers = (0, _axiosHeadersJsDefault.default).from(response.headers);
        return response;
    }, function onAdapterRejection(reason) {
        if (!(0, _isCancelJsDefault.default)(reason)) {
            throwIfCancellationRequested(config);
            // Transform response data
            if (reason && reason.response) {
                reason.response.data = (0, _transformDataJsDefault.default).call(config, config.transformResponse, reason.response);
                reason.response.headers = (0, _axiosHeadersJsDefault.default).from(reason.response.headers);
            }
        }
        return Promise.reject(reason);
    });
}

},{"./transformData.js":"b6SG7","../cancel/isCancel.js":"9fV5q","../defaults/index.js":"8lnvF","../cancel/CanceledError.js":"6Jxkj","../core/AxiosHeaders.js":"dG0u5","../adapters/adapters.js":"bgiN9","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"b6SG7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>transformData);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _indexJs = require("../defaults/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _axiosHeadersJs = require("../core/AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
"use strict";
function transformData(fns, response) {
    const config = this || (0, _indexJsDefault.default);
    const context = response || config;
    const headers = (0, _axiosHeadersJsDefault.default).from(context.headers);
    let data = context.data;
    (0, _utilsJsDefault.default).forEach(fns, function transform(fn) {
        data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
    });
    headers.normalize();
    return data;
}

},{"./../utils.js":"6pgCP","../defaults/index.js":"8lnvF","../core/AxiosHeaders.js":"dG0u5","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"8lnvF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
var _transitionalJs = require("./transitional.js");
var _transitionalJsDefault = parcelHelpers.interopDefault(_transitionalJs);
var _toFormDataJs = require("../helpers/toFormData.js");
var _toFormDataJsDefault = parcelHelpers.interopDefault(_toFormDataJs);
var _toURLEncodedFormJs = require("../helpers/toURLEncodedForm.js");
var _toURLEncodedFormJsDefault = parcelHelpers.interopDefault(_toURLEncodedFormJs);
var _indexJs = require("../platform/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _formDataToJSONJs = require("../helpers/formDataToJSON.js");
var _formDataToJSONJsDefault = parcelHelpers.interopDefault(_formDataToJSONJs);
"use strict";
/**
 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
 * of the input
 *
 * @param {any} rawValue - The value to be stringified.
 * @param {Function} parser - A function that parses a string into a JavaScript object.
 * @param {Function} encoder - A function that takes a value and returns a string.
 *
 * @returns {string} A stringified version of the rawValue.
 */ function stringifySafely(rawValue, parser, encoder) {
    if ((0, _utilsJsDefault.default).isString(rawValue)) try {
        (parser || JSON.parse)(rawValue);
        return (0, _utilsJsDefault.default).trim(rawValue);
    } catch (e) {
        if (e.name !== "SyntaxError") throw e;
    }
    return (encoder || JSON.stringify)(rawValue);
}
const defaults = {
    transitional: (0, _transitionalJsDefault.default),
    adapter: [
        "xhr",
        "http",
        "fetch"
    ],
    transformRequest: [
        function transformRequest(data, headers) {
            const contentType = headers.getContentType() || "";
            const hasJSONContentType = contentType.indexOf("application/json") > -1;
            const isObjectPayload = (0, _utilsJsDefault.default).isObject(data);
            if (isObjectPayload && (0, _utilsJsDefault.default).isHTMLForm(data)) data = new FormData(data);
            const isFormData = (0, _utilsJsDefault.default).isFormData(data);
            if (isFormData) return hasJSONContentType ? JSON.stringify((0, _formDataToJSONJsDefault.default)(data)) : data;
            if ((0, _utilsJsDefault.default).isArrayBuffer(data) || (0, _utilsJsDefault.default).isBuffer(data) || (0, _utilsJsDefault.default).isStream(data) || (0, _utilsJsDefault.default).isFile(data) || (0, _utilsJsDefault.default).isBlob(data) || (0, _utilsJsDefault.default).isReadableStream(data)) return data;
            if ((0, _utilsJsDefault.default).isArrayBufferView(data)) return data.buffer;
            if ((0, _utilsJsDefault.default).isURLSearchParams(data)) {
                headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
                return data.toString();
            }
            let isFileList;
            if (isObjectPayload) {
                if (contentType.indexOf("application/x-www-form-urlencoded") > -1) return (0, _toURLEncodedFormJsDefault.default)(data, this.formSerializer).toString();
                if ((isFileList = (0, _utilsJsDefault.default).isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
                    const _FormData = this.env && this.env.FormData;
                    return (0, _toFormDataJsDefault.default)(isFileList ? {
                        "files[]": data
                    } : data, _FormData && new _FormData(), this.formSerializer);
                }
            }
            if (isObjectPayload || hasJSONContentType) {
                headers.setContentType("application/json", false);
                return stringifySafely(data);
            }
            return data;
        }
    ],
    transformResponse: [
        function transformResponse(data) {
            const transitional = this.transitional || defaults.transitional;
            const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
            const JSONRequested = this.responseType === "json";
            if ((0, _utilsJsDefault.default).isResponse(data) || (0, _utilsJsDefault.default).isReadableStream(data)) return data;
            if (data && (0, _utilsJsDefault.default).isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
                const silentJSONParsing = transitional && transitional.silentJSONParsing;
                const strictJSONParsing = !silentJSONParsing && JSONRequested;
                try {
                    return JSON.parse(data);
                } catch (e) {
                    if (strictJSONParsing) {
                        if (e.name === "SyntaxError") throw (0, _axiosErrorJsDefault.default).from(e, (0, _axiosErrorJsDefault.default).ERR_BAD_RESPONSE, this, null, this.response);
                        throw e;
                    }
                }
            }
            return data;
        }
    ],
    /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */ timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
        FormData: (0, _indexJsDefault.default).classes.FormData,
        Blob: (0, _indexJsDefault.default).classes.Blob
    },
    validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
    },
    headers: {
        common: {
            "Accept": "application/json, text/plain, */*",
            "Content-Type": undefined
        }
    }
};
(0, _utilsJsDefault.default).forEach([
    "delete",
    "get",
    "head",
    "post",
    "put",
    "patch"
], (method)=>{
    defaults.headers[method] = {};
});
exports.default = defaults;

},{"../utils.js":"6pgCP","../core/AxiosError.js":"jWuNn","./transitional.js":"axY64","../helpers/toFormData.js":"bWqOm","../helpers/toURLEncodedForm.js":"ayFZU","../platform/index.js":"gBMPY","../helpers/formDataToJSON.js":"bHtc6","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"axY64":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
"use strict";
exports.default = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"ayFZU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>toURLEncodedForm);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _toFormDataJs = require("./toFormData.js");
var _toFormDataJsDefault = parcelHelpers.interopDefault(_toFormDataJs);
var _indexJs = require("../platform/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
"use strict";
function toURLEncodedForm(data, options) {
    return (0, _toFormDataJsDefault.default)(data, new (0, _indexJsDefault.default).classes.URLSearchParams(), Object.assign({
        visitor: function(value, key, path, helpers) {
            if ((0, _indexJsDefault.default).isNode && (0, _utilsJsDefault.default).isBuffer(value)) {
                this.append(key, value.toString("base64"));
                return false;
            }
            return helpers.defaultVisitor.apply(this, arguments);
        }
    }, options));
}

},{"../utils.js":"6pgCP","./toFormData.js":"bWqOm","../platform/index.js":"gBMPY","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"gBMPY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("./node/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _utilsJs = require("./common/utils.js");
exports.default = {
    ..._utilsJs,
    ...(0, _indexJsDefault.default)
};

},{"./node/index.js":"gvgvA","./common/utils.js":"jNcD1","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"gvgvA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _urlsearchParamsJs = require("./classes/URLSearchParams.js");
var _urlsearchParamsJsDefault = parcelHelpers.interopDefault(_urlsearchParamsJs);
var _formDataJs = require("./classes/FormData.js");
var _formDataJsDefault = parcelHelpers.interopDefault(_formDataJs);
var _blobJs = require("./classes/Blob.js");
var _blobJsDefault = parcelHelpers.interopDefault(_blobJs);
exports.default = {
    isBrowser: true,
    classes: {
        URLSearchParams: (0, _urlsearchParamsJsDefault.default),
        FormData: (0, _formDataJsDefault.default),
        Blob: (0, _blobJsDefault.default)
    },
    protocols: [
        "http",
        "https",
        "file",
        "blob",
        "url",
        "data"
    ]
};

},{"./classes/URLSearchParams.js":"7ob5w","./classes/FormData.js":"kJkAB","./classes/Blob.js":"kHXdH","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"7ob5w":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _axiosURLSearchParamsJs = require("../../../helpers/AxiosURLSearchParams.js");
var _axiosURLSearchParamsJsDefault = parcelHelpers.interopDefault(_axiosURLSearchParamsJs);
"use strict";
exports.default = typeof URLSearchParams !== "undefined" ? URLSearchParams : (0, _axiosURLSearchParamsJsDefault.default);

},{"../../../helpers/AxiosURLSearchParams.js":"bgjfh","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"kJkAB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
"use strict";
exports.default = typeof FormData !== "undefined" ? FormData : null;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"kHXdH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
"use strict";
exports.default = typeof Blob !== "undefined" ? Blob : null;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"jNcD1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hasBrowserEnv", ()=>hasBrowserEnv);
parcelHelpers.export(exports, "hasStandardBrowserWebWorkerEnv", ()=>hasStandardBrowserWebWorkerEnv);
parcelHelpers.export(exports, "hasStandardBrowserEnv", ()=>hasStandardBrowserEnv);
parcelHelpers.export(exports, "origin", ()=>origin);
const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 *
 * @returns {boolean}
 */ const hasStandardBrowserEnv = ((product)=>{
    return hasBrowserEnv && [
        "ReactNative",
        "NativeScript",
        "NS"
    ].indexOf(product) < 0;
})(typeof navigator !== "undefined" && navigator.product);
/**
 * Determine if we're running in a standard browser webWorker environment
 *
 * Although the `isStandardBrowserEnv` method indicates that
 * `allows axios to run in a web worker`, the WebWorker will still be
 * filtered out due to its judgment standard
 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
 * This leads to a problem when axios post `FormData` in webWorker
 */ const hasStandardBrowserWebWorkerEnv = (()=>{
    return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const origin = hasBrowserEnv && window.location.href || "http://localhost";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"bHtc6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
"use strict";
/**
 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
 *
 * @param {string} name - The name of the property to get.
 *
 * @returns An array of strings.
 */ function parsePropPath(name) {
    // foo[x][y][z]
    // foo.x.y.z
    // foo-x-y-z
    // foo x y z
    return (0, _utilsJsDefault.default).matchAll(/\w+|\[(\w*)]/g, name).map((match)=>{
        return match[0] === "[]" ? "" : match[1] || match[0];
    });
}
/**
 * Convert an array to an object.
 *
 * @param {Array<any>} arr - The array to convert to an object.
 *
 * @returns An object with the same keys and values as the array.
 */ function arrayToObject(arr) {
    const obj = {};
    const keys = Object.keys(arr);
    let i;
    const len = keys.length;
    let key;
    for(i = 0; i < len; i++){
        key = keys[i];
        obj[key] = arr[key];
    }
    return obj;
}
/**
 * It takes a FormData object and returns a JavaScript object
 *
 * @param {string} formData The FormData object to convert to JSON.
 *
 * @returns {Object<string, any> | null} The converted object.
 */ function formDataToJSON(formData) {
    function buildPath(path, value, target, index) {
        let name = path[index++];
        if (name === "__proto__") return true;
        const isNumericKey = Number.isFinite(+name);
        const isLast = index >= path.length;
        name = !name && (0, _utilsJsDefault.default).isArray(target) ? target.length : name;
        if (isLast) {
            if ((0, _utilsJsDefault.default).hasOwnProp(target, name)) target[name] = [
                target[name],
                value
            ];
            else target[name] = value;
            return !isNumericKey;
        }
        if (!target[name] || !(0, _utilsJsDefault.default).isObject(target[name])) target[name] = [];
        const result = buildPath(path, value, target[name], index);
        if (result && (0, _utilsJsDefault.default).isArray(target[name])) target[name] = arrayToObject(target[name]);
        return !isNumericKey;
    }
    if ((0, _utilsJsDefault.default).isFormData(formData) && (0, _utilsJsDefault.default).isFunction(formData.entries)) {
        const obj = {};
        (0, _utilsJsDefault.default).forEachEntry(formData, (name, value)=>{
            buildPath(parsePropPath(name), value, obj, 0);
        });
        return obj;
    }
    return null;
}
exports.default = formDataToJSON;

},{"../utils.js":"6pgCP","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"dG0u5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _parseHeadersJs = require("../helpers/parseHeaders.js");
var _parseHeadersJsDefault = parcelHelpers.interopDefault(_parseHeadersJs);
"use strict";
const $internals = Symbol("internals");
function normalizeHeader(header) {
    return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
    if (value === false || value == null) return value;
    return (0, _utilsJsDefault.default).isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
    const tokens = Object.create(null);
    const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let match;
    while(match = tokensRE.exec(str))tokens[match[1]] = match[2];
    return tokens;
}
const isValidHeaderName = (str)=>/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
    if ((0, _utilsJsDefault.default).isFunction(filter)) return filter.call(this, value, header);
    if (isHeaderNameFilter) value = header;
    if (!(0, _utilsJsDefault.default).isString(value)) return;
    if ((0, _utilsJsDefault.default).isString(filter)) return value.indexOf(filter) !== -1;
    if ((0, _utilsJsDefault.default).isRegExp(filter)) return filter.test(value);
}
function formatHeader(header) {
    return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str)=>{
        return char.toUpperCase() + str;
    });
}
function buildAccessors(obj, header) {
    const accessorName = (0, _utilsJsDefault.default).toCamelCase(" " + header);
    [
        "get",
        "set",
        "has"
    ].forEach((methodName)=>{
        Object.defineProperty(obj, methodName + accessorName, {
            value: function(arg1, arg2, arg3) {
                return this[methodName].call(this, header, arg1, arg2, arg3);
            },
            configurable: true
        });
    });
}
class AxiosHeaders {
    constructor(headers){
        headers && this.set(headers);
    }
    set(header, valueOrRewrite, rewrite) {
        const self = this;
        function setHeader(_value, _header, _rewrite) {
            const lHeader = normalizeHeader(_header);
            if (!lHeader) throw new Error("header name must be a non-empty string");
            const key = (0, _utilsJsDefault.default).findKey(self, lHeader);
            if (!key || self[key] === undefined || _rewrite === true || _rewrite === undefined && self[key] !== false) self[key || _header] = normalizeValue(_value);
        }
        const setHeaders = (headers, _rewrite)=>(0, _utilsJsDefault.default).forEach(headers, (_value, _header)=>setHeader(_value, _header, _rewrite));
        if ((0, _utilsJsDefault.default).isPlainObject(header) || header instanceof this.constructor) setHeaders(header, valueOrRewrite);
        else if ((0, _utilsJsDefault.default).isString(header) && (header = header.trim()) && !isValidHeaderName(header)) setHeaders((0, _parseHeadersJsDefault.default)(header), valueOrRewrite);
        else if ((0, _utilsJsDefault.default).isHeaders(header)) for (const [key, value] of header.entries())setHeader(value, key, rewrite);
        else header != null && setHeader(valueOrRewrite, header, rewrite);
        return this;
    }
    get(header, parser) {
        header = normalizeHeader(header);
        if (header) {
            const key = (0, _utilsJsDefault.default).findKey(this, header);
            if (key) {
                const value = this[key];
                if (!parser) return value;
                if (parser === true) return parseTokens(value);
                if ((0, _utilsJsDefault.default).isFunction(parser)) return parser.call(this, value, key);
                if ((0, _utilsJsDefault.default).isRegExp(parser)) return parser.exec(value);
                throw new TypeError("parser must be boolean|regexp|function");
            }
        }
    }
    has(header, matcher) {
        header = normalizeHeader(header);
        if (header) {
            const key = (0, _utilsJsDefault.default).findKey(this, header);
            return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
        }
        return false;
    }
    delete(header, matcher) {
        const self = this;
        let deleted = false;
        function deleteHeader(_header) {
            _header = normalizeHeader(_header);
            if (_header) {
                const key = (0, _utilsJsDefault.default).findKey(self, _header);
                if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
                    delete self[key];
                    deleted = true;
                }
            }
        }
        if ((0, _utilsJsDefault.default).isArray(header)) header.forEach(deleteHeader);
        else deleteHeader(header);
        return deleted;
    }
    clear(matcher) {
        const keys = Object.keys(this);
        let i = keys.length;
        let deleted = false;
        while(i--){
            const key = keys[i];
            if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
                delete this[key];
                deleted = true;
            }
        }
        return deleted;
    }
    normalize(format) {
        const self = this;
        const headers = {};
        (0, _utilsJsDefault.default).forEach(this, (value, header)=>{
            const key = (0, _utilsJsDefault.default).findKey(headers, header);
            if (key) {
                self[key] = normalizeValue(value);
                delete self[header];
                return;
            }
            const normalized = format ? formatHeader(header) : String(header).trim();
            if (normalized !== header) delete self[header];
            self[normalized] = normalizeValue(value);
            headers[normalized] = true;
        });
        return this;
    }
    concat(...targets) {
        return this.constructor.concat(this, ...targets);
    }
    toJSON(asStrings) {
        const obj = Object.create(null);
        (0, _utilsJsDefault.default).forEach(this, (value, header)=>{
            value != null && value !== false && (obj[header] = asStrings && (0, _utilsJsDefault.default).isArray(value) ? value.join(", ") : value);
        });
        return obj;
    }
    [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
        return Object.entries(this.toJSON()).map(([header, value])=>header + ": " + value).join("\n");
    }
    get [Symbol.toStringTag]() {
        return "AxiosHeaders";
    }
    static from(thing) {
        return thing instanceof this ? thing : new this(thing);
    }
    static concat(first, ...targets) {
        const computed = new this(first);
        targets.forEach((target)=>computed.set(target));
        return computed;
    }
    static accessor(header) {
        const internals = this[$internals] = this[$internals] = {
            accessors: {}
        };
        const accessors = internals.accessors;
        const prototype = this.prototype;
        function defineAccessor(_header) {
            const lHeader = normalizeHeader(_header);
            if (!accessors[lHeader]) {
                buildAccessors(prototype, _header);
                accessors[lHeader] = true;
            }
        }
        (0, _utilsJsDefault.default).isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
        return this;
    }
}
AxiosHeaders.accessor([
    "Content-Type",
    "Content-Length",
    "Accept",
    "Accept-Encoding",
    "User-Agent",
    "Authorization"
]);
// reserved names hotfix
(0, _utilsJsDefault.default).reduceDescriptors(AxiosHeaders.prototype, ({ value }, key)=>{
    let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`
    return {
        get: ()=>value,
        set (headerValue) {
            this[mapped] = headerValue;
        }
    };
});
(0, _utilsJsDefault.default).freezeMethods(AxiosHeaders);
exports.default = AxiosHeaders;

},{"../utils.js":"6pgCP","../helpers/parseHeaders.js":"c7VN9","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"c7VN9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
"use strict";
// RawAxiosHeaders whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
const ignoreDuplicateOf = (0, _utilsJsDefault.default).toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
]);
/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} rawHeaders Headers needing to be parsed
 *
 * @returns {Object} Headers parsed into an object
 */ exports.default = (rawHeaders)=>{
    const parsed = {};
    let key;
    let val;
    let i;
    rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
        i = line.indexOf(":");
        key = line.substring(0, i).trim().toLowerCase();
        val = line.substring(i + 1).trim();
        if (!key || parsed[key] && ignoreDuplicateOf[key]) return;
        if (key === "set-cookie") {
            if (parsed[key]) parsed[key].push(val);
            else parsed[key] = [
                val
            ];
        } else parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    });
    return parsed;
};

},{"./../utils.js":"6pgCP","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"9fV5q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>isCancel);
"use strict";
function isCancel(value) {
    return !!(value && value.__CANCEL__);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"6Jxkj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
"use strict";
/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @param {string=} message The message.
 * @param {Object=} config The config.
 * @param {Object=} request The request.
 *
 * @returns {CanceledError} The created error.
 */ function CanceledError(message, config, request) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    (0, _axiosErrorJsDefault.default).call(this, message == null ? "canceled" : message, (0, _axiosErrorJsDefault.default).ERR_CANCELED, config, request);
    this.name = "CanceledError";
}
(0, _utilsJsDefault.default).inherits(CanceledError, (0, _axiosErrorJsDefault.default), {
    __CANCEL__: true
});
exports.default = CanceledError;

},{"../core/AxiosError.js":"jWuNn","../utils.js":"6pgCP","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"bgiN9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _httpJs = require("./http.js");
var _httpJsDefault = parcelHelpers.interopDefault(_httpJs);
var _xhrJs = require("./xhr.js");
var _xhrJsDefault = parcelHelpers.interopDefault(_xhrJs);
var _fetchJs = require("./fetch.js");
var _fetchJsDefault = parcelHelpers.interopDefault(_fetchJs);
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
const knownAdapters = {
    http: (0, _httpJsDefault.default),
    xhr: (0, _xhrJsDefault.default),
    fetch: (0, _fetchJsDefault.default)
};
(0, _utilsJsDefault.default).forEach(knownAdapters, (fn, value)=>{
    if (fn) {
        try {
            Object.defineProperty(fn, "name", {
                value
            });
        } catch (e) {
        // eslint-disable-next-line no-empty
        }
        Object.defineProperty(fn, "adapterName", {
            value
        });
    }
});
const renderReason = (reason)=>`- ${reason}`;
const isResolvedHandle = (adapter)=>(0, _utilsJsDefault.default).isFunction(adapter) || adapter === null || adapter === false;
exports.default = {
    getAdapter: (adapters)=>{
        adapters = (0, _utilsJsDefault.default).isArray(adapters) ? adapters : [
            adapters
        ];
        const { length } = adapters;
        let nameOrAdapter;
        let adapter;
        const rejectedReasons = {};
        for(let i = 0; i < length; i++){
            nameOrAdapter = adapters[i];
            let id;
            adapter = nameOrAdapter;
            if (!isResolvedHandle(nameOrAdapter)) {
                adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
                if (adapter === undefined) throw new (0, _axiosErrorJsDefault.default)(`Unknown adapter '${id}'`);
            }
            if (adapter) break;
            rejectedReasons[id || "#" + i] = adapter;
        }
        if (!adapter) {
            const reasons = Object.entries(rejectedReasons).map(([id, state])=>`adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build"));
            let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
            throw new (0, _axiosErrorJsDefault.default)(`There is no suitable adapter to dispatch the request ` + s, "ERR_NOT_SUPPORT");
        }
        return adapter;
    },
    adapters: knownAdapters
};

},{"../utils.js":"6pgCP","./http.js":"hcZFZ","./xhr.js":"5L3zC","./fetch.js":"h2AUA","../core/AxiosError.js":"jWuNn","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"5L3zC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _settleJs = require("./../core/settle.js");
var _settleJsDefault = parcelHelpers.interopDefault(_settleJs);
var _transitionalJs = require("../defaults/transitional.js");
var _transitionalJsDefault = parcelHelpers.interopDefault(_transitionalJs);
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
var _canceledErrorJs = require("../cancel/CanceledError.js");
var _canceledErrorJsDefault = parcelHelpers.interopDefault(_canceledErrorJs);
var _parseProtocolJs = require("../helpers/parseProtocol.js");
var _parseProtocolJsDefault = parcelHelpers.interopDefault(_parseProtocolJs);
var _indexJs = require("../platform/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _axiosHeadersJs = require("../core/AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
var _progressEventReducerJs = require("../helpers/progressEventReducer.js");
var _progressEventReducerJsDefault = parcelHelpers.interopDefault(_progressEventReducerJs);
var _resolveConfigJs = require("../helpers/resolveConfig.js");
var _resolveConfigJsDefault = parcelHelpers.interopDefault(_resolveConfigJs);
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
exports.default = isXHRAdapterSupported && function(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
        const _config = (0, _resolveConfigJsDefault.default)(config);
        let requestData = _config.data;
        const requestHeaders = (0, _axiosHeadersJsDefault.default).from(_config.headers).normalize();
        let { responseType } = _config;
        let onCanceled;
        function done() {
            if (_config.cancelToken) _config.cancelToken.unsubscribe(onCanceled);
            if (_config.signal) _config.signal.removeEventListener("abort", onCanceled);
        }
        let request = new XMLHttpRequest();
        request.open(_config.method.toUpperCase(), _config.url, true);
        // Set the request timeout in MS
        request.timeout = _config.timeout;
        function onloadend() {
            if (!request) return;
            // Prepare the response
            const responseHeaders = (0, _axiosHeadersJsDefault.default).from("getAllResponseHeaders" in request && request.getAllResponseHeaders());
            const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
            const response = {
                data: responseData,
                status: request.status,
                statusText: request.statusText,
                headers: responseHeaders,
                config,
                request
            };
            (0, _settleJsDefault.default)(function _resolve(value) {
                resolve(value);
                done();
            }, function _reject(err) {
                reject(err);
                done();
            }, response);
            // Clean up request
            request = null;
        }
        if ("onloadend" in request) // Use onloadend if available
        request.onloadend = onloadend;
        else // Listen for ready state to emulate onloadend
        request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) return;
            // The request errored out and we didn't get a response, this will be
            // handled by onerror instead
            // With one exception: request that using file: protocol, most browsers
            // will return status as 0 even though it's a successful request
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) return;
            // readystate handler is calling before onerror or ontimeout handlers,
            // so we should call onloadend on the next 'tick'
            setTimeout(onloadend);
        };
        // Handle browser request cancellation (as opposed to a manual cancellation)
        request.onabort = function handleAbort() {
            if (!request) return;
            reject(new (0, _axiosErrorJsDefault.default)("Request aborted", (0, _axiosErrorJsDefault.default).ECONNABORTED, _config, request));
            // Clean up request
            request = null;
        };
        // Handle low level network errors
        request.onerror = function handleError() {
            // Real errors are hidden from us by the browser
            // onerror should only fire if it's a network error
            reject(new (0, _axiosErrorJsDefault.default)("Network Error", (0, _axiosErrorJsDefault.default).ERR_NETWORK, _config, request));
            // Clean up request
            request = null;
        };
        // Handle timeout
        request.ontimeout = function handleTimeout() {
            let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
            const transitional = _config.transitional || (0, _transitionalJsDefault.default);
            if (_config.timeoutErrorMessage) timeoutErrorMessage = _config.timeoutErrorMessage;
            reject(new (0, _axiosErrorJsDefault.default)(timeoutErrorMessage, transitional.clarifyTimeoutError ? (0, _axiosErrorJsDefault.default).ETIMEDOUT : (0, _axiosErrorJsDefault.default).ECONNABORTED, _config, request));
            // Clean up request
            request = null;
        };
        // Remove Content-Type if data is undefined
        requestData === undefined && requestHeaders.setContentType(null);
        // Add headers to the request
        if ("setRequestHeader" in request) (0, _utilsJsDefault.default).forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
            request.setRequestHeader(key, val);
        });
        // Add withCredentials to request if needed
        if (!(0, _utilsJsDefault.default).isUndefined(_config.withCredentials)) request.withCredentials = !!_config.withCredentials;
        // Add responseType to request if needed
        if (responseType && responseType !== "json") request.responseType = _config.responseType;
        // Handle progress if needed
        if (typeof _config.onDownloadProgress === "function") request.addEventListener("progress", (0, _progressEventReducerJsDefault.default)(_config.onDownloadProgress, true));
        // Not all browsers support upload events
        if (typeof _config.onUploadProgress === "function" && request.upload) request.upload.addEventListener("progress", (0, _progressEventReducerJsDefault.default)(_config.onUploadProgress));
        if (_config.cancelToken || _config.signal) {
            // Handle cancellation
            // eslint-disable-next-line func-names
            onCanceled = (cancel)=>{
                if (!request) return;
                reject(!cancel || cancel.type ? new (0, _canceledErrorJsDefault.default)(null, config, request) : cancel);
                request.abort();
                request = null;
            };
            _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
            if (_config.signal) _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
        }
        const protocol = (0, _parseProtocolJsDefault.default)(_config.url);
        if (protocol && (0, _indexJsDefault.default).protocols.indexOf(protocol) === -1) {
            reject(new (0, _axiosErrorJsDefault.default)("Unsupported protocol " + protocol + ":", (0, _axiosErrorJsDefault.default).ERR_BAD_REQUEST, config));
            return;
        }
        // Send the request
        request.send(requestData || null);
    });
};

},{"./../utils.js":"6pgCP","./../core/settle.js":"eklHb","../defaults/transitional.js":"axY64","../core/AxiosError.js":"jWuNn","../cancel/CanceledError.js":"6Jxkj","../helpers/parseProtocol.js":"bui6a","../platform/index.js":"gBMPY","../core/AxiosHeaders.js":"dG0u5","../helpers/progressEventReducer.js":"a7KxU","../helpers/resolveConfig.js":"iI5md","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"eklHb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>settle);
var _axiosErrorJs = require("./AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
"use strict";
function settle(resolve, reject, response) {
    const validateStatus = response.config.validateStatus;
    if (!response.status || !validateStatus || validateStatus(response.status)) resolve(response);
    else reject(new (0, _axiosErrorJsDefault.default)("Request failed with status code " + response.status, [
        (0, _axiosErrorJsDefault.default).ERR_BAD_REQUEST,
        (0, _axiosErrorJsDefault.default).ERR_BAD_RESPONSE
    ][Math.floor(response.status / 100) - 4], response.config, response.request, response));
}

},{"./AxiosError.js":"jWuNn","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"bui6a":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>parseProtocol);
"use strict";
function parseProtocol(url) {
    const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
    return match && match[1] || "";
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"a7KxU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _speedometerJs = require("./speedometer.js");
var _speedometerJsDefault = parcelHelpers.interopDefault(_speedometerJs);
var _throttleJs = require("./throttle.js");
var _throttleJsDefault = parcelHelpers.interopDefault(_throttleJs);
exports.default = (listener, isDownloadStream, freq = 3)=>{
    let bytesNotified = 0;
    const _speedometer = (0, _speedometerJsDefault.default)(50, 250);
    return (0, _throttleJsDefault.default)((e)=>{
        const loaded = e.loaded;
        const total = e.lengthComputable ? e.total : undefined;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;
        bytesNotified = loaded;
        const data = {
            loaded,
            total,
            progress: total ? loaded / total : undefined,
            bytes: progressBytes,
            rate: rate ? rate : undefined,
            estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
            event: e,
            lengthComputable: total != null
        };
        data[isDownloadStream ? "download" : "upload"] = true;
        listener(data);
    }, freq);
};

},{"./speedometer.js":"94BDL","./throttle.js":"covAO","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"94BDL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
"use strict";
/**
 * Calculate data maxRate
 * @param {Number} [samplesCount= 10]
 * @param {Number} [min= 1000]
 * @returns {Function}
 */ function speedometer(samplesCount, min) {
    samplesCount = samplesCount || 10;
    const bytes = new Array(samplesCount);
    const timestamps = new Array(samplesCount);
    let head = 0;
    let tail = 0;
    let firstSampleTS;
    min = min !== undefined ? min : 1000;
    return function push(chunkLength) {
        const now = Date.now();
        const startedAt = timestamps[tail];
        if (!firstSampleTS) firstSampleTS = now;
        bytes[head] = chunkLength;
        timestamps[head] = now;
        let i = tail;
        let bytesCount = 0;
        while(i !== head){
            bytesCount += bytes[i++];
            i = i % samplesCount;
        }
        head = (head + 1) % samplesCount;
        if (head === tail) tail = (tail + 1) % samplesCount;
        if (now - firstSampleTS < min) return;
        const passed = startedAt && now - startedAt;
        return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
    };
}
exports.default = speedometer;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"covAO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
"use strict";
/**
 * Throttle decorator
 * @param {Function} fn
 * @param {Number} freq
 * @return {Function}
 */ function throttle(fn, freq) {
    let timestamp = 0;
    const threshold = 1000 / freq;
    let timer = null;
    return function throttled() {
        const force = this === true;
        const now = Date.now();
        if (force || now - timestamp > threshold) {
            if (timer) {
                clearTimeout(timer);
                timer = null;
            }
            timestamp = now;
            return fn.apply(null, arguments);
        }
        if (!timer) timer = setTimeout(()=>{
            timer = null;
            timestamp = Date.now();
            return fn.apply(null, arguments);
        }, threshold - (now - timestamp));
    };
}
exports.default = throttle;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"iI5md":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("../platform/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _isURLSameOriginJs = require("./isURLSameOrigin.js");
var _isURLSameOriginJsDefault = parcelHelpers.interopDefault(_isURLSameOriginJs);
var _cookiesJs = require("./cookies.js");
var _cookiesJsDefault = parcelHelpers.interopDefault(_cookiesJs);
var _buildFullPathJs = require("../core/buildFullPath.js");
var _buildFullPathJsDefault = parcelHelpers.interopDefault(_buildFullPathJs);
var _mergeConfigJs = require("../core/mergeConfig.js");
var _mergeConfigJsDefault = parcelHelpers.interopDefault(_mergeConfigJs);
var _axiosHeadersJs = require("../core/AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
var _buildURLJs = require("./buildURL.js");
var _buildURLJsDefault = parcelHelpers.interopDefault(_buildURLJs);
exports.default = (config)=>{
    const newConfig = (0, _mergeConfigJsDefault.default)({}, config);
    let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
    newConfig.headers = headers = (0, _axiosHeadersJsDefault.default).from(headers);
    newConfig.url = (0, _buildURLJsDefault.default)((0, _buildFullPathJsDefault.default)(newConfig.baseURL, newConfig.url), config.params, config.paramsSerializer);
    // HTTP basic authentication
    if (auth) headers.set("Authorization", "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : "")));
    let contentType;
    if ((0, _utilsJsDefault.default).isFormData(data)) {
        if ((0, _indexJsDefault.default).hasStandardBrowserEnv || (0, _indexJsDefault.default).hasStandardBrowserWebWorkerEnv) headers.setContentType(undefined); // Let the browser set it
        else if ((contentType = headers.getContentType()) !== false) {
            // fix semicolon duplication issue for ReactNative FormData implementation
            const [type, ...tokens] = contentType ? contentType.split(";").map((token)=>token.trim()).filter(Boolean) : [];
            headers.setContentType([
                type || "multipart/form-data",
                ...tokens
            ].join("; "));
        }
    }
    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if ((0, _indexJsDefault.default).hasStandardBrowserEnv) {
        withXSRFToken && (0, _utilsJsDefault.default).isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
        if (withXSRFToken || withXSRFToken !== false && (0, _isURLSameOriginJsDefault.default)(newConfig.url)) {
            // Add xsrf header
            const xsrfValue = xsrfHeaderName && xsrfCookieName && (0, _cookiesJsDefault.default).read(xsrfCookieName);
            if (xsrfValue) headers.set(xsrfHeaderName, xsrfValue);
        }
    }
    return newConfig;
};

},{"../platform/index.js":"gBMPY","../utils.js":"6pgCP","./isURLSameOrigin.js":"qz3Wj","./cookies.js":"geGcE","../core/buildFullPath.js":"39S5a","../core/mergeConfig.js":"hCK5X","../core/AxiosHeaders.js":"dG0u5","./buildURL.js":"5TCYf","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"qz3Wj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _indexJs = require("../platform/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
"use strict";
exports.default = (0, _indexJsDefault.default).hasStandardBrowserEnv ? // Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
function standardBrowserEnv() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    /**
    * Parse a URL to discover its components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */ function resolveURL(url) {
        let href = url;
        if (msie) {
            // IE needs attribute set twice to normalize properties
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
    }
    originURL = resolveURL(window.location.href);
    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */ return function isURLSameOrigin(requestURL) {
        const parsed = (0, _utilsJsDefault.default).isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
}() : // Non standard browser envs (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
        return true;
    };
}();

},{"./../utils.js":"6pgCP","../platform/index.js":"gBMPY","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"geGcE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _indexJs = require("../platform/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
exports.default = (0, _indexJsDefault.default).hasStandardBrowserEnv ? // Standard browser envs support document.cookie
{
    write (name, value, expires, path, domain, secure) {
        const cookie = [
            name + "=" + encodeURIComponent(value)
        ];
        (0, _utilsJsDefault.default).isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
        (0, _utilsJsDefault.default).isString(path) && cookie.push("path=" + path);
        (0, _utilsJsDefault.default).isString(domain) && cookie.push("domain=" + domain);
        secure === true && cookie.push("secure");
        document.cookie = cookie.join("; ");
    },
    read (name) {
        const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
        return match ? decodeURIComponent(match[3]) : null;
    },
    remove (name) {
        this.write(name, "", Date.now() - 86400000);
    }
} : // Non-standard browser env (web workers, react-native) lack needed support.
{
    write () {},
    read () {
        return null;
    },
    remove () {}
};

},{"./../utils.js":"6pgCP","../platform/index.js":"gBMPY","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"39S5a":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>buildFullPath);
var _isAbsoluteURLJs = require("../helpers/isAbsoluteURL.js");
var _isAbsoluteURLJsDefault = parcelHelpers.interopDefault(_isAbsoluteURLJs);
var _combineURLsJs = require("../helpers/combineURLs.js");
var _combineURLsJsDefault = parcelHelpers.interopDefault(_combineURLsJs);
"use strict";
function buildFullPath(baseURL, requestedURL) {
    if (baseURL && !(0, _isAbsoluteURLJsDefault.default)(requestedURL)) return (0, _combineURLsJsDefault.default)(baseURL, requestedURL);
    return requestedURL;
}

},{"../helpers/isAbsoluteURL.js":"aJMns","../helpers/combineURLs.js":"ko1YY","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"aJMns":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>isAbsoluteURL);
"use strict";
function isAbsoluteURL(url) {
    // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
    // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
    // by any combination of letters, digits, plus, period, or hyphen.
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"ko1YY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>combineURLs);
"use strict";
function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"hCK5X":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>mergeConfig);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _axiosHeadersJs = require("./AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
"use strict";
const headersToObject = (thing)=>thing instanceof (0, _axiosHeadersJsDefault.default) ? {
        ...thing
    } : thing;
function mergeConfig(config1, config2) {
    // eslint-disable-next-line no-param-reassign
    config2 = config2 || {};
    const config = {};
    function getMergedValue(target, source, caseless) {
        if ((0, _utilsJsDefault.default).isPlainObject(target) && (0, _utilsJsDefault.default).isPlainObject(source)) return (0, _utilsJsDefault.default).merge.call({
            caseless
        }, target, source);
        else if ((0, _utilsJsDefault.default).isPlainObject(source)) return (0, _utilsJsDefault.default).merge({}, source);
        else if ((0, _utilsJsDefault.default).isArray(source)) return source.slice();
        return source;
    }
    // eslint-disable-next-line consistent-return
    function mergeDeepProperties(a, b, caseless) {
        if (!(0, _utilsJsDefault.default).isUndefined(b)) return getMergedValue(a, b, caseless);
        else if (!(0, _utilsJsDefault.default).isUndefined(a)) return getMergedValue(undefined, a, caseless);
    }
    // eslint-disable-next-line consistent-return
    function valueFromConfig2(a, b) {
        if (!(0, _utilsJsDefault.default).isUndefined(b)) return getMergedValue(undefined, b);
    }
    // eslint-disable-next-line consistent-return
    function defaultToConfig2(a, b) {
        if (!(0, _utilsJsDefault.default).isUndefined(b)) return getMergedValue(undefined, b);
        else if (!(0, _utilsJsDefault.default).isUndefined(a)) return getMergedValue(undefined, a);
    }
    // eslint-disable-next-line consistent-return
    function mergeDirectKeys(a, b, prop) {
        if (prop in config2) return getMergedValue(a, b);
        else if (prop in config1) return getMergedValue(undefined, a);
    }
    const mergeMap = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        withXSRFToken: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys,
        headers: (a, b)=>mergeDeepProperties(headersToObject(a), headersToObject(b), true)
    };
    (0, _utilsJsDefault.default).forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
        const merge = mergeMap[prop] || mergeDeepProperties;
        const configValue = merge(config1[prop], config2[prop], prop);
        (0, _utilsJsDefault.default).isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
    });
    return config;
}

},{"../utils.js":"6pgCP","./AxiosHeaders.js":"dG0u5","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"h2AUA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("../platform/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
var _composeSignalsJs = require("../helpers/composeSignals.js");
var _composeSignalsJsDefault = parcelHelpers.interopDefault(_composeSignalsJs);
var _trackStreamJs = require("../helpers/trackStream.js");
var _axiosHeadersJs = require("../core/AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
var _progressEventReducerJs = require("../helpers/progressEventReducer.js");
var _progressEventReducerJsDefault = parcelHelpers.interopDefault(_progressEventReducerJs);
var _resolveConfigJs = require("../helpers/resolveConfig.js");
var _resolveConfigJsDefault = parcelHelpers.interopDefault(_resolveConfigJs);
var _settleJs = require("../core/settle.js");
var _settleJsDefault = parcelHelpers.interopDefault(_settleJs);
const fetchProgressDecorator = (total, fn)=>{
    const lengthComputable = total != null;
    return (loaded)=>setTimeout(()=>fn({
                lengthComputable,
                total,
                loaded
            }));
};
const isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
// used only inside the fetch adapter
const encodeText = isFetchSupported && (typeof TextEncoder === "function" ? ((encoder)=>(str)=>encoder.encode(str))(new TextEncoder()) : async (str)=>new Uint8Array(await new Response(str).arrayBuffer()));
const supportsRequestStream = isReadableStreamSupported && (()=>{
    let duplexAccessed = false;
    const hasContentType = new Request((0, _indexJsDefault.default).origin, {
        body: new ReadableStream(),
        method: "POST",
        get duplex () {
            duplexAccessed = true;
            return "half";
        }
    }).headers.has("Content-Type");
    return duplexAccessed && !hasContentType;
})();
const DEFAULT_CHUNK_SIZE = 65536;
const supportsResponseStream = isReadableStreamSupported && !!(()=>{
    try {
        return (0, _utilsJsDefault.default).isReadableStream(new Response("").body);
    } catch (err) {
    // return undefined
    }
})();
const resolvers = {
    stream: supportsResponseStream && ((res)=>res.body)
};
isFetchSupported && ((res)=>{
    [
        "text",
        "arrayBuffer",
        "blob",
        "formData",
        "stream"
    ].forEach((type)=>{
        !resolvers[type] && (resolvers[type] = (0, _utilsJsDefault.default).isFunction(res[type]) ? (res)=>res[type]() : (_, config)=>{
            throw new (0, _axiosErrorJsDefault.default)(`Response type '${type}' is not supported`, (0, _axiosErrorJsDefault.default).ERR_NOT_SUPPORT, config);
        });
    });
})(new Response);
const getBodyLength = async (body)=>{
    if (body == null) return 0;
    if ((0, _utilsJsDefault.default).isBlob(body)) return body.size;
    if ((0, _utilsJsDefault.default).isSpecCompliantForm(body)) return (await new Request(body).arrayBuffer()).byteLength;
    if ((0, _utilsJsDefault.default).isArrayBufferView(body)) return body.byteLength;
    if ((0, _utilsJsDefault.default).isURLSearchParams(body)) body = body + "";
    if ((0, _utilsJsDefault.default).isString(body)) return (await encodeText(body)).byteLength;
};
const resolveBodyLength = async (headers, body)=>{
    const length = (0, _utilsJsDefault.default).toFiniteNumber(headers.getContentLength());
    return length == null ? getBodyLength(body) : length;
};
exports.default = isFetchSupported && (async (config)=>{
    let { url, method, data, signal, cancelToken, timeout, onDownloadProgress, onUploadProgress, responseType, headers, withCredentials = "same-origin", fetchOptions } = (0, _resolveConfigJsDefault.default)(config);
    responseType = responseType ? (responseType + "").toLowerCase() : "text";
    let [composedSignal, stopTimeout] = signal || cancelToken || timeout ? (0, _composeSignalsJsDefault.default)([
        signal,
        cancelToken
    ], timeout) : [];
    let finished, request;
    const onFinish = ()=>{
        !finished && setTimeout(()=>{
            composedSignal && composedSignal.unsubscribe();
        });
        finished = true;
    };
    let requestContentLength;
    try {
        if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
            let _request = new Request(url, {
                method: "POST",
                body: data,
                duplex: "half"
            });
            let contentTypeHeader;
            if ((0, _utilsJsDefault.default).isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) headers.setContentType(contentTypeHeader);
            if (_request.body) data = (0, _trackStreamJs.trackStream)(_request.body, DEFAULT_CHUNK_SIZE, fetchProgressDecorator(requestContentLength, (0, _progressEventReducerJsDefault.default)(onUploadProgress)), null, encodeText);
        }
        if (!(0, _utilsJsDefault.default).isString(withCredentials)) withCredentials = withCredentials ? "cors" : "omit";
        request = new Request(url, {
            ...fetchOptions,
            signal: composedSignal,
            method: method.toUpperCase(),
            headers: headers.normalize().toJSON(),
            body: data,
            duplex: "half",
            withCredentials
        });
        let response = await fetch(request);
        const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
        if (supportsResponseStream && (onDownloadProgress || isStreamResponse)) {
            const options = {};
            [
                "status",
                "statusText",
                "headers"
            ].forEach((prop)=>{
                options[prop] = response[prop];
            });
            const responseContentLength = (0, _utilsJsDefault.default).toFiniteNumber(response.headers.get("content-length"));
            response = new Response((0, _trackStreamJs.trackStream)(response.body, DEFAULT_CHUNK_SIZE, onDownloadProgress && fetchProgressDecorator(responseContentLength, (0, _progressEventReducerJsDefault.default)(onDownloadProgress, true)), isStreamResponse && onFinish, encodeText), options);
        }
        responseType = responseType || "text";
        let responseData = await resolvers[(0, _utilsJsDefault.default).findKey(resolvers, responseType) || "text"](response, config);
        !isStreamResponse && onFinish();
        stopTimeout && stopTimeout();
        return await new Promise((resolve, reject)=>{
            (0, _settleJsDefault.default)(resolve, reject, {
                data: responseData,
                headers: (0, _axiosHeadersJsDefault.default).from(response.headers),
                status: response.status,
                statusText: response.statusText,
                config,
                request
            });
        });
    } catch (err) {
        onFinish();
        if (err && err.name === "TypeError" && /fetch/i.test(err.message)) throw Object.assign(new (0, _axiosErrorJsDefault.default)("Network Error", (0, _axiosErrorJsDefault.default).ERR_NETWORK, config, request), {
            cause: err.cause || err
        });
        throw (0, _axiosErrorJsDefault.default).from(err, err && err.code, config, request);
    }
});

},{"../platform/index.js":"gBMPY","../utils.js":"6pgCP","../core/AxiosError.js":"jWuNn","../helpers/composeSignals.js":"3R7cj","../helpers/trackStream.js":"gO1HQ","../core/AxiosHeaders.js":"dG0u5","../helpers/progressEventReducer.js":"a7KxU","../helpers/resolveConfig.js":"iI5md","../core/settle.js":"eklHb","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"3R7cj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _canceledErrorJs = require("../cancel/CanceledError.js");
var _canceledErrorJsDefault = parcelHelpers.interopDefault(_canceledErrorJs);
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
const composeSignals = (signals, timeout)=>{
    let controller = new AbortController();
    let aborted;
    const onabort = function(cancel) {
        if (!aborted) {
            aborted = true;
            unsubscribe();
            const err = cancel instanceof Error ? cancel : this.reason;
            controller.abort(err instanceof (0, _axiosErrorJsDefault.default) ? err : new (0, _canceledErrorJsDefault.default)(err instanceof Error ? err.message : err));
        }
    };
    let timer = timeout && setTimeout(()=>{
        onabort(new (0, _axiosErrorJsDefault.default)(`timeout ${timeout} of ms exceeded`, (0, _axiosErrorJsDefault.default).ETIMEDOUT));
    }, timeout);
    const unsubscribe = ()=>{
        if (signals) {
            timer && clearTimeout(timer);
            timer = null;
            signals.forEach((signal)=>{
                signal && (signal.removeEventListener ? signal.removeEventListener("abort", onabort) : signal.unsubscribe(onabort));
            });
            signals = null;
        }
    };
    signals.forEach((signal)=>signal && signal.addEventListener && signal.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = unsubscribe;
    return [
        signal,
        ()=>{
            timer && clearTimeout(timer);
            timer = null;
        }
    ];
};
exports.default = composeSignals;

},{"../cancel/CanceledError.js":"6Jxkj","../core/AxiosError.js":"jWuNn","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"gO1HQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "streamChunk", ()=>streamChunk);
parcelHelpers.export(exports, "readBytes", ()=>readBytes);
parcelHelpers.export(exports, "trackStream", ()=>trackStream);
const streamChunk = function*(chunk, chunkSize) {
    let len = chunk.byteLength;
    if (!chunkSize || len < chunkSize) {
        yield chunk;
        return;
    }
    let pos = 0;
    let end;
    while(pos < len){
        end = pos + chunkSize;
        yield chunk.slice(pos, end);
        pos = end;
    }
};
const readBytes = async function*(iterable, chunkSize, encode) {
    for await (const chunk of iterable)yield* streamChunk(ArrayBuffer.isView(chunk) ? chunk : await encode(String(chunk)), chunkSize);
};
const trackStream = (stream, chunkSize, onProgress, onFinish, encode)=>{
    const iterator = readBytes(stream, chunkSize, encode);
    let bytes = 0;
    return new ReadableStream({
        type: "bytes",
        async pull (controller) {
            const { done, value } = await iterator.next();
            if (done) {
                controller.close();
                onFinish();
                return;
            }
            let len = value.byteLength;
            onProgress && onProgress(bytes += len);
            controller.enqueue(new Uint8Array(value));
        },
        cancel (reason) {
            onFinish(reason);
            return iterator.return();
        }
    }, {
        highWaterMark: 2
    });
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"8TqqD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _dataJs = require("../env/data.js");
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
"use strict";
const validators = {};
// eslint-disable-next-line func-names
[
    "object",
    "boolean",
    "number",
    "function",
    "string",
    "symbol"
].forEach((type, i)=>{
    validators[type] = function validator(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
    };
});
const deprecatedWarnings = {};
/**
 * Transitional option validator
 *
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 *
 * @returns {function}
 */ validators.transitional = function transitional(validator, version, message) {
    function formatMessage(opt, desc) {
        return "[Axios v" + (0, _dataJs.VERSION) + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
    }
    // eslint-disable-next-line func-names
    return (value, opt, opts)=>{
        if (validator === false) throw new (0, _axiosErrorJsDefault.default)(formatMessage(opt, " has been removed" + (version ? " in " + version : "")), (0, _axiosErrorJsDefault.default).ERR_DEPRECATED);
        if (version && !deprecatedWarnings[opt]) {
            deprecatedWarnings[opt] = true;
            // eslint-disable-next-line no-console
            console.warn(formatMessage(opt, " has been deprecated since v" + version + " and will be removed in the near future"));
        }
        return validator ? validator(value, opt, opts) : true;
    };
};
/**
 * Assert object's properties type
 *
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 *
 * @returns {object}
 */ function assertOptions(options, schema, allowUnknown) {
    if (typeof options !== "object") throw new (0, _axiosErrorJsDefault.default)("options must be an object", (0, _axiosErrorJsDefault.default).ERR_BAD_OPTION_VALUE);
    const keys = Object.keys(options);
    let i = keys.length;
    while(i-- > 0){
        const opt = keys[i];
        const validator = schema[opt];
        if (validator) {
            const value = options[opt];
            const result = value === undefined || validator(value, opt, options);
            if (result !== true) throw new (0, _axiosErrorJsDefault.default)("option " + opt + " must be " + result, (0, _axiosErrorJsDefault.default).ERR_BAD_OPTION_VALUE);
            continue;
        }
        if (allowUnknown !== true) throw new (0, _axiosErrorJsDefault.default)("Unknown option " + opt, (0, _axiosErrorJsDefault.default).ERR_BAD_OPTION);
    }
}
exports.default = {
    assertOptions,
    validators
};

},{"../env/data.js":"2P4GS","../core/AxiosError.js":"jWuNn","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"2P4GS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VERSION", ()=>VERSION);
const VERSION = "1.7.2";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"45Qou":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _canceledErrorJs = require("./CanceledError.js");
var _canceledErrorJsDefault = parcelHelpers.interopDefault(_canceledErrorJs);
"use strict";
/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @param {Function} executor The executor function.
 *
 * @returns {CancelToken}
 */ class CancelToken {
    constructor(executor){
        if (typeof executor !== "function") throw new TypeError("executor must be a function.");
        let resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
            resolvePromise = resolve;
        });
        const token = this;
        // eslint-disable-next-line func-names
        this.promise.then((cancel)=>{
            if (!token._listeners) return;
            let i = token._listeners.length;
            while(i-- > 0)token._listeners[i](cancel);
            token._listeners = null;
        });
        // eslint-disable-next-line func-names
        this.promise.then = (onfulfilled)=>{
            let _resolve;
            // eslint-disable-next-line func-names
            const promise = new Promise((resolve)=>{
                token.subscribe(resolve);
                _resolve = resolve;
            }).then(onfulfilled);
            promise.cancel = function reject() {
                token.unsubscribe(_resolve);
            };
            return promise;
        };
        executor(function cancel(message, config, request) {
            if (token.reason) // Cancellation has already been requested
            return;
            token.reason = new (0, _canceledErrorJsDefault.default)(message, config, request);
            resolvePromise(token.reason);
        });
    }
    /**
   * Throws a `CanceledError` if cancellation has been requested.
   */ throwIfRequested() {
        if (this.reason) throw this.reason;
    }
    /**
   * Subscribe to the cancel signal
   */ subscribe(listener) {
        if (this.reason) {
            listener(this.reason);
            return;
        }
        if (this._listeners) this._listeners.push(listener);
        else this._listeners = [
            listener
        ];
    }
    /**
   * Unsubscribe from the cancel signal
   */ unsubscribe(listener) {
        if (!this._listeners) return;
        const index = this._listeners.indexOf(listener);
        if (index !== -1) this._listeners.splice(index, 1);
    }
    /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */ static source() {
        let cancel;
        const token = new CancelToken(function executor(c) {
            cancel = c;
        });
        return {
            token,
            cancel
        };
    }
}
exports.default = CancelToken;

},{"./CanceledError.js":"6Jxkj","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"lJWiD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>spread);
"use strict";
function spread(callback) {
    return function wrap(arr) {
        return callback.apply(null, arr);
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"96kwV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>isAxiosError);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
"use strict";
function isAxiosError(payload) {
    return (0, _utilsJsDefault.default).isObject(payload) && payload.isAxiosError === true;
}

},{"./../utils.js":"6pgCP","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"8evH5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const HttpStatusCode = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value])=>{
    HttpStatusCode[value] = key;
});
exports.default = HttpStatusCode;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"4TsiO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getAccessToken", ()=>getAccessToken);
parcelHelpers.export(exports, "getAuthHeaders", ()=>getAuthHeaders);
parcelHelpers.export(exports, "updateAuth", ()=>updateAuth);
var _constants = require("~lib/constants");
var _supabase = require("~lib/supabase");
var _utils = require("~lib/utils");
const getAccessToken = async ()=>{
    const { data } = await (0, _supabase.supabase).auth.getSession();
    if (data.session) return data.session.access_token;
    return undefined;
};
const getAuthHeaders = async ()=>{
    const token = await getAccessToken();
    if (!token) {
        chrome.runtime.openOptionsPage();
        throw "User not authenticated";
    }
    const config = {
        headers: {
            Authorization: `Bearer ${token}`
        }
    };
    return config;
};
const updateAuth = async ()=>{
    const { data } = await (0, _supabase.supabase).auth.getSession();
    const user = data.session?.user ?? null;
    console.log("Updating user data: ", user);
    await (0, _utils.localStorage)().set((0, _constants.LS_KEYS).USER_DATA, user);
};

},{"~lib/constants":"6KjBj","~lib/supabase":"fE3ox","~lib/utils":"6QCW4","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"fE3ox":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "supabase", ()=>supabase);
var _supabaseJs = require("@supabase/supabase-js");
var _utils = require("./utils");
class StorageWrapper {
    constructor(storage){
        this.storage = storage;
    }
    async getItem(key) {
        const result = await this.storage.getItem(key);
        return result !== undefined ? result : null;
    }
    setItem(key, value) {
        return this.storage.setItem(key, value);
    }
    removeItem(key) {
        return this.storage.removeItem(key);
    }
}
const supabase = (0, _supabaseJs.createClient)("https://auth.dendrite.se", "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inlkc3lvaGJuaXV0a2t5YmZuaG55Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3MDczODUyMDUsImV4cCI6MjAyMjk2MTIwNX0.6-k4n4G681GSmFWmjR_6A5oxZ86n91Vqfc0YgEfMFAk", {
    auth: {
        storage: new StorageWrapper((0, _utils.localStorage)()),
        autoRefreshToken: true,
        persistSession: true,
        detectSessionInUrl: true
    }
});

},{"@supabase/supabase-js":"fYRpQ","./utils":"6QCW4","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"fYRpQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FunctionsHttpError", ()=>(0, _functionsJs.FunctionsHttpError));
parcelHelpers.export(exports, "FunctionsFetchError", ()=>(0, _functionsJs.FunctionsFetchError));
parcelHelpers.export(exports, "FunctionsRelayError", ()=>(0, _functionsJs.FunctionsRelayError));
parcelHelpers.export(exports, "FunctionsError", ()=>(0, _functionsJs.FunctionsError));
parcelHelpers.export(exports, "FunctionRegion", ()=>(0, _functionsJs.FunctionRegion));
parcelHelpers.export(exports, "SupabaseClient", ()=>(0, _supabaseClientDefault.default));
parcelHelpers.export(exports, "createClient", ()=>createClient);
var _supabaseClient = require("./SupabaseClient");
var _supabaseClientDefault = parcelHelpers.interopDefault(_supabaseClient);
var _authJs = require("@supabase/auth-js");
parcelHelpers.exportAll(_authJs, exports);
var _functionsJs = require("@supabase/functions-js");
var _realtimeJs = require("@supabase/realtime-js");
parcelHelpers.exportAll(_realtimeJs, exports);
const createClient = (supabaseUrl, supabaseKey, options)=>{
    return new (0, _supabaseClientDefault.default)(supabaseUrl, supabaseKey, options);
};

},{"./SupabaseClient":"8YzbE","@supabase/auth-js":"ihxme","@supabase/functions-js":false,"@supabase/realtime-js":"gBhFF","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"8YzbE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _functionsJs = require("@supabase/functions-js");
var _postgrestJs = require("@supabase/postgrest-js");
var _realtimeJs = require("@supabase/realtime-js");
var _storageJs = require("@supabase/storage-js");
var _constants = require("./lib/constants");
var _fetch = require("./lib/fetch");
var _helpers = require("./lib/helpers");
var _supabaseAuthClient = require("./lib/SupabaseAuthClient");
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class SupabaseClient {
    /**
     * Create a new client for use in the browser.
     * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.
     * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.
     * @param options.db.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.
     * @param options.auth.autoRefreshToken Set to "true" if you want to automatically refresh the token before expiring.
     * @param options.auth.persistSession Set to "true" if you want to automatically save the user session into local storage.
     * @param options.auth.detectSessionInUrl Set to "true" if you want to automatically detects OAuth grants in the URL and signs in the user.
     * @param options.realtime Options passed along to realtime-js constructor.
     * @param options.global.fetch A custom fetch implementation.
     * @param options.global.headers Any additional headers to send with each network request.
     */ constructor(supabaseUrl, supabaseKey, options){
        var _a, _b, _c;
        this.supabaseUrl = supabaseUrl;
        this.supabaseKey = supabaseKey;
        if (!supabaseUrl) throw new Error("supabaseUrl is required.");
        if (!supabaseKey) throw new Error("supabaseKey is required.");
        const _supabaseUrl = (0, _helpers.stripTrailingSlash)(supabaseUrl);
        this.realtimeUrl = `${_supabaseUrl}/realtime/v1`.replace(/^http/i, "ws");
        this.authUrl = `${_supabaseUrl}/auth/v1`;
        this.storageUrl = `${_supabaseUrl}/storage/v1`;
        this.functionsUrl = `${_supabaseUrl}/functions/v1`;
        // default storage key uses the supabase project ref as a namespace
        const defaultStorageKey = `sb-${new URL(this.authUrl).hostname.split(".")[0]}-auth-token`;
        const DEFAULTS = {
            db: (0, _constants.DEFAULT_DB_OPTIONS),
            realtime: (0, _constants.DEFAULT_REALTIME_OPTIONS),
            auth: Object.assign(Object.assign({}, (0, _constants.DEFAULT_AUTH_OPTIONS)), {
                storageKey: defaultStorageKey
            }),
            global: (0, _constants.DEFAULT_GLOBAL_OPTIONS)
        };
        const settings = (0, _helpers.applySettingDefaults)(options !== null && options !== void 0 ? options : {}, DEFAULTS);
        this.storageKey = (_a = settings.auth.storageKey) !== null && _a !== void 0 ? _a : "";
        this.headers = (_b = settings.global.headers) !== null && _b !== void 0 ? _b : {};
        this.auth = this._initSupabaseAuthClient((_c = settings.auth) !== null && _c !== void 0 ? _c : {}, this.headers, settings.global.fetch);
        this.fetch = (0, _fetch.fetchWithAuth)(supabaseKey, this._getAccessToken.bind(this), settings.global.fetch);
        this.realtime = this._initRealtimeClient(Object.assign({
            headers: this.headers
        }, settings.realtime));
        this.rest = new (0, _postgrestJs.PostgrestClient)(`${_supabaseUrl}/rest/v1`, {
            headers: this.headers,
            schema: settings.db.schema,
            fetch: this.fetch
        });
        this._listenForAuthEvents();
    }
    /**
     * Supabase Functions allows you to deploy and invoke edge functions.
     */ get functions() {
        return new (0, _functionsJs.FunctionsClient)(this.functionsUrl, {
            headers: this.headers,
            customFetch: this.fetch
        });
    }
    /**
     * Supabase Storage allows you to manage user-generated content, such as photos or videos.
     */ get storage() {
        return new (0, _storageJs.StorageClient)(this.storageUrl, this.headers, this.fetch);
    }
    /**
     * Perform a query on a table or a view.
     *
     * @param relation - The table or view name to query
     */ from(relation) {
        return this.rest.from(relation);
    }
    // NOTE: signatures must be kept in sync with PostgrestClient.schema
    /**
     * Select a schema to query or perform an function (rpc) call.
     *
     * The schema needs to be on the list of exposed schemas inside Supabase.
     *
     * @param schema - The schema to query
     */ schema(schema) {
        return this.rest.schema(schema);
    }
    // NOTE: signatures must be kept in sync with PostgrestClient.rpc
    /**
     * Perform a function call.
     *
     * @param fn - The function name to call
     * @param args - The arguments to pass to the function call
     * @param options - Named parameters
     * @param options.head - When set to `true`, `data` will not be returned.
     * Useful if you only need the count.
     * @param options.get - When set to `true`, the function will be called with
     * read-only access mode.
     * @param options.count - Count algorithm to use to count rows returned by the
     * function. Only applicable for [set-returning
     * functions](https://www.postgresql.org/docs/current/functions-srf.html).
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     */ rpc(fn, args = {}, options = {}) {
        return this.rest.rpc(fn, args, options);
    }
    /**
     * Creates a Realtime channel with Broadcast, Presence, and Postgres Changes.
     *
     * @param {string} name - The name of the Realtime channel.
     * @param {Object} opts - The options to pass to the Realtime channel.
     *
     */ channel(name, opts = {
        config: {}
    }) {
        return this.realtime.channel(name, opts);
    }
    /**
     * Returns all Realtime channels.
     */ getChannels() {
        return this.realtime.getChannels();
    }
    /**
     * Unsubscribes and removes Realtime channel from Realtime client.
     *
     * @param {RealtimeChannel} channel - The name of the Realtime channel.
     *
     */ removeChannel(channel) {
        return this.realtime.removeChannel(channel);
    }
    /**
     * Unsubscribes and removes all Realtime channels from Realtime client.
     */ removeAllChannels() {
        return this.realtime.removeAllChannels();
    }
    _getAccessToken() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function*() {
            const { data } = yield this.auth.getSession();
            return (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : null;
        });
    }
    _initSupabaseAuthClient({ autoRefreshToken, persistSession, detectSessionInUrl, storage, storageKey, flowType, debug }, headers, fetch) {
        var _a;
        const authHeaders = {
            Authorization: `Bearer ${this.supabaseKey}`,
            apikey: `${this.supabaseKey}`
        };
        return new (0, _supabaseAuthClient.SupabaseAuthClient)({
            url: this.authUrl,
            headers: Object.assign(Object.assign({}, authHeaders), headers),
            storageKey: storageKey,
            autoRefreshToken,
            persistSession,
            detectSessionInUrl,
            storage,
            flowType,
            debug,
            fetch,
            // auth checks if there is a custom authorizaiton header using this flag
            // so it knows whether to return an error when getUser is called with no session
            hasCustomAuthorizationHeader: (_a = "Authorization" in this.headers, _a !== void 0) ? _a : false
        });
    }
    _initRealtimeClient(options) {
        return new (0, _realtimeJs.RealtimeClient)(this.realtimeUrl, Object.assign(Object.assign({}, options), {
            params: Object.assign({
                apikey: this.supabaseKey
            }, options === null || options === void 0 ? void 0 : options.params)
        }));
    }
    _listenForAuthEvents() {
        let data = this.auth.onAuthStateChange((event, session)=>{
            this._handleTokenChanged(event, "CLIENT", session === null || session === void 0 ? void 0 : session.access_token);
        });
        return data;
    }
    _handleTokenChanged(event, source, token) {
        if ((event === "TOKEN_REFRESHED" || event === "SIGNED_IN") && this.changedAccessToken !== token) {
            // Token has changed
            this.realtime.setAuth(token !== null && token !== void 0 ? token : null);
            this.changedAccessToken = token;
        } else if (event === "SIGNED_OUT") {
            // Token is removed
            this.realtime.setAuth(this.supabaseKey);
            if (source == "STORAGE") this.auth.signOut();
            this.changedAccessToken = undefined;
        }
    }
}
exports.default = SupabaseClient;

},{"@supabase/functions-js":"6lm0Q","@supabase/postgrest-js":"gRmrS","@supabase/realtime-js":"gBhFF","@supabase/storage-js":"fyr3A","./lib/constants":"f1CLa","./lib/fetch":"9LQK3","./lib/helpers":"feZlB","./lib/SupabaseAuthClient":"eSfHx","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"6lm0Q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FunctionsClient", ()=>(0, _functionsClient.FunctionsClient));
parcelHelpers.export(exports, "FunctionsError", ()=>(0, _types.FunctionsError));
parcelHelpers.export(exports, "FunctionsFetchError", ()=>(0, _types.FunctionsFetchError));
parcelHelpers.export(exports, "FunctionsHttpError", ()=>(0, _types.FunctionsHttpError));
parcelHelpers.export(exports, "FunctionsRelayError", ()=>(0, _types.FunctionsRelayError));
parcelHelpers.export(exports, "FunctionRegion", ()=>(0, _types.FunctionRegion));
var _functionsClient = require("./FunctionsClient");
var _types = require("./types");

},{"./FunctionsClient":"frpk4","./types":"j6aJ5","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"frpk4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FunctionsClient", ()=>FunctionsClient);
var _helper = require("./helper");
var _types = require("./types");
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class FunctionsClient {
    constructor(url, { headers = {}, customFetch, region = (0, _types.FunctionRegion).Any } = {}){
        this.url = url;
        this.headers = headers;
        this.region = region;
        this.fetch = (0, _helper.resolveFetch)(customFetch);
    }
    /**
     * Updates the authorization header
     * @param token - the new jwt token sent in the authorisation header
     */ setAuth(token) {
        this.headers.Authorization = `Bearer ${token}`;
    }
    /**
     * Invokes a function
     * @param functionName - The name of the Function to invoke.
     * @param options - Options for invoking the Function.
     */ invoke(functionName, options = {}) {
        var _a;
        return __awaiter(this, void 0, void 0, function*() {
            try {
                const { headers, method, body: functionArgs } = options;
                let _headers = {};
                let { region } = options;
                if (!region) region = this.region;
                if (region && region !== "any") _headers["x-region"] = region;
                let body;
                if (functionArgs && (headers && !Object.prototype.hasOwnProperty.call(headers, "Content-Type") || !headers)) {
                    if (typeof Blob !== "undefined" && functionArgs instanceof Blob || functionArgs instanceof ArrayBuffer) {
                        // will work for File as File inherits Blob
                        // also works for ArrayBuffer as it is the same underlying structure as a Blob
                        _headers["Content-Type"] = "application/octet-stream";
                        body = functionArgs;
                    } else if (typeof functionArgs === "string") {
                        // plain string
                        _headers["Content-Type"] = "text/plain";
                        body = functionArgs;
                    } else if (typeof FormData !== "undefined" && functionArgs instanceof FormData) // don't set content-type headers
                    // Request will automatically add the right boundary value
                    body = functionArgs;
                    else {
                        // default, assume this is JSON
                        _headers["Content-Type"] = "application/json";
                        body = JSON.stringify(functionArgs);
                    }
                }
                const response = yield this.fetch(`${this.url}/${functionName}`, {
                    method: method || "POST",
                    // headers priority is (high to low):
                    // 1. invoke-level headers
                    // 2. client-level headers
                    // 3. default Content-Type header
                    headers: Object.assign(Object.assign(Object.assign({}, _headers), this.headers), headers),
                    body
                }).catch((fetchError)=>{
                    throw new (0, _types.FunctionsFetchError)(fetchError);
                });
                const isRelayError = response.headers.get("x-relay-error");
                if (isRelayError && isRelayError === "true") throw new (0, _types.FunctionsRelayError)(response);
                if (!response.ok) throw new (0, _types.FunctionsHttpError)(response);
                let responseType = ((_a = response.headers.get("Content-Type")) !== null && _a !== void 0 ? _a : "text/plain").split(";")[0].trim();
                let data;
                if (responseType === "application/json") data = yield response.json();
                else if (responseType === "application/octet-stream") data = yield response.blob();
                else if (responseType === "text/event-stream") data = response;
                else if (responseType === "multipart/form-data") data = yield response.formData();
                else // default to text
                data = yield response.text();
                return {
                    data,
                    error: null
                };
            } catch (error) {
                return {
                    data: null,
                    error
                };
            }
        });
    }
}

},{"./helper":"20v0V","./types":"j6aJ5","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"20v0V":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "resolveFetch", ()=>resolveFetch);
const resolveFetch = (customFetch)=>{
    let _fetch;
    if (customFetch) _fetch = customFetch;
    else if (typeof fetch === "undefined") _fetch = (...args)=>require("db8a7a5aa4509164").then(({ default: fetch1 })=>fetch1(...args));
    else _fetch = fetch;
    return (...args)=>_fetch(...args);
};

},{"db8a7a5aa4509164":"cRjRL","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"cRjRL":[function(require,module,exports) {
module.exports = require("265625c7223e55fe")(require("8437f53261055443").getBundleURL("gL9HQ") + "../../browser.70b240a7.js" + "?" + Date.now()).catch((err)=>{
    delete module.bundle.cache[module.id];
    throw err;
}).then(()=>module.bundle.root("1YN43"));

},{"265625c7223e55fe":"9Ufja","8437f53261055443":"4lLQs"}],"9Ufja":[function(require,module,exports) {
"use strict";
/* global __parcel__importScripts__:readonly*/ var cacheLoader = require("e18e0f4b8102d3ab");
module.exports = cacheLoader(function(bundle) {
    return new Promise(function(resolve, reject) {
        try {
            importScripts(bundle);
            resolve();
        } catch (e) {
            reject(e);
        }
    });
});

},{"e18e0f4b8102d3ab":"8suT0"}],"8suT0":[function(require,module,exports) {
"use strict";
var cachedBundles = {};
var cachedPreloads = {};
var cachedPrefetches = {};
function getCache(type) {
    switch(type){
        case "preload":
            return cachedPreloads;
        case "prefetch":
            return cachedPrefetches;
        default:
            return cachedBundles;
    }
}
module.exports = function(loader, type) {
    return function(bundle) {
        var cache = getCache(type);
        if (cache[bundle]) return cache[bundle];
        return cache[bundle] = loader.apply(null, arguments).catch(function(e) {
            delete cache[bundle];
            throw e;
        });
    };
};

},{}],"4lLQs":[function(require,module,exports) {
"use strict";
var bundleURL = {};
function getBundleURLCached(id) {
    var value = bundleURL[id];
    if (!value) {
        value = getBundleURL();
        bundleURL[id] = value;
    }
    return value;
}
function getBundleURL() {
    try {
        throw new Error();
    } catch (err) {
        var matches = ("" + err.stack).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\/\/[^)\n]+/g);
        if (matches) // The first two stack frames will be this function and getBundleURLCached.
        // Use the 3rd one, which will be a runtime in the original bundle.
        return getBaseURL(matches[2]);
    }
    return "/";
}
function getBaseURL(url) {
    return ("" + url).replace(/^((?:https?|file|ftp|(chrome|moz|safari-web)-extension):\/\/.+)\/[^/]+$/, "$1") + "/";
} // TODO: Replace uses with `new URL(url).origin` when ie11 is no longer supported.
function getOrigin(url) {
    var matches = ("" + url).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\/\/[^/]+/);
    if (!matches) throw new Error("Origin not found");
    return matches[0];
}
exports.getBundleURL = getBundleURLCached;
exports.getBaseURL = getBaseURL;
exports.getOrigin = getOrigin;

},{}],"j6aJ5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FunctionsError", ()=>FunctionsError);
parcelHelpers.export(exports, "FunctionsFetchError", ()=>FunctionsFetchError);
parcelHelpers.export(exports, "FunctionsRelayError", ()=>FunctionsRelayError);
parcelHelpers.export(exports, "FunctionsHttpError", ()=>FunctionsHttpError);
parcelHelpers.export(exports, "FunctionRegion", ()=>FunctionRegion);
class FunctionsError extends Error {
    constructor(message, name = "FunctionsError", context){
        super(message);
        this.name = name;
        this.context = context;
    }
}
class FunctionsFetchError extends FunctionsError {
    constructor(context){
        super("Failed to send a request to the Edge Function", "FunctionsFetchError", context);
    }
}
class FunctionsRelayError extends FunctionsError {
    constructor(context){
        super("Relay Error invoking the Edge Function", "FunctionsRelayError", context);
    }
}
class FunctionsHttpError extends FunctionsError {
    constructor(context){
        super("Edge Function returned a non-2xx status code", "FunctionsHttpError", context);
    }
}
var FunctionRegion;
(function(FunctionRegion) {
    FunctionRegion["Any"] = "any";
    FunctionRegion["ApNortheast1"] = "ap-northeast-1";
    FunctionRegion["ApNortheast2"] = "ap-northeast-2";
    FunctionRegion["ApSouth1"] = "ap-south-1";
    FunctionRegion["ApSoutheast1"] = "ap-southeast-1";
    FunctionRegion["ApSoutheast2"] = "ap-southeast-2";
    FunctionRegion["CaCentral1"] = "ca-central-1";
    FunctionRegion["EuCentral1"] = "eu-central-1";
    FunctionRegion["EuWest1"] = "eu-west-1";
    FunctionRegion["EuWest2"] = "eu-west-2";
    FunctionRegion["EuWest3"] = "eu-west-3";
    FunctionRegion["SaEast1"] = "sa-east-1";
    FunctionRegion["UsEast1"] = "us-east-1";
    FunctionRegion["UsWest1"] = "us-west-1";
    FunctionRegion["UsWest2"] = "us-west-2";
})(FunctionRegion || (FunctionRegion = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"gRmrS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PostgrestBuilder", ()=>PostgrestBuilder);
parcelHelpers.export(exports, "PostgrestClient", ()=>PostgrestClient);
parcelHelpers.export(exports, "PostgrestFilterBuilder", ()=>PostgrestFilterBuilder);
parcelHelpers.export(exports, "PostgrestQueryBuilder", ()=>PostgrestQueryBuilder);
parcelHelpers.export(exports, "PostgrestTransformBuilder", ()=>PostgrestTransformBuilder);
var _indexJs = require("../cjs/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
const { PostgrestClient, PostgrestQueryBuilder, PostgrestFilterBuilder, PostgrestTransformBuilder, PostgrestBuilder } = (0, _indexJsDefault.default);
// compatibility with CJS output
exports.default = {
    PostgrestClient,
    PostgrestQueryBuilder,
    PostgrestFilterBuilder,
    PostgrestTransformBuilder,
    PostgrestBuilder
};

},{"../cjs/index.js":"7YAe2","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"7YAe2":[function(require,module,exports) {
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PostgrestBuilder = exports.PostgrestTransformBuilder = exports.PostgrestFilterBuilder = exports.PostgrestQueryBuilder = exports.PostgrestClient = void 0;
// Always update wrapper.mjs when updating this file.
const PostgrestClient_1 = __importDefault(require("f5e06a51982719bd"));
exports.PostgrestClient = PostgrestClient_1.default;
const PostgrestQueryBuilder_1 = __importDefault(require("df90e8e15649ad51"));
exports.PostgrestQueryBuilder = PostgrestQueryBuilder_1.default;
const PostgrestFilterBuilder_1 = __importDefault(require("599489c94cb82979"));
exports.PostgrestFilterBuilder = PostgrestFilterBuilder_1.default;
const PostgrestTransformBuilder_1 = __importDefault(require("f49dd89b70eda0a2"));
exports.PostgrestTransformBuilder = PostgrestTransformBuilder_1.default;
const PostgrestBuilder_1 = __importDefault(require("aab5557e345022fe"));
exports.PostgrestBuilder = PostgrestBuilder_1.default;
exports.default = {
    PostgrestClient: PostgrestClient_1.default,
    PostgrestQueryBuilder: PostgrestQueryBuilder_1.default,
    PostgrestFilterBuilder: PostgrestFilterBuilder_1.default,
    PostgrestTransformBuilder: PostgrestTransformBuilder_1.default,
    PostgrestBuilder: PostgrestBuilder_1.default
};

},{"f5e06a51982719bd":"4p33p","df90e8e15649ad51":"046JL","599489c94cb82979":"b4HnT","f49dd89b70eda0a2":"9geQQ","aab5557e345022fe":"hGptf"}],"4p33p":[function(require,module,exports) {
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
const PostgrestQueryBuilder_1 = __importDefault(require("46c45ba978d8f946"));
const PostgrestFilterBuilder_1 = __importDefault(require("a418b29a37404612"));
const constants_1 = require("56170df5c50b72a8");
/**
 * PostgREST client.
 *
 * @typeParam Database - Types for the schema from the [type
 * generator](https://supabase.com/docs/reference/javascript/next/typescript-support)
 *
 * @typeParam SchemaName - Postgres schema to switch to. Must be a string
 * literal, the same one passed to the constructor. If the schema is not
 * `"public"`, this must be supplied manually.
 */ class PostgrestClient {
    // TODO: Add back shouldThrowOnError once we figure out the typings
    /**
     * Creates a PostgREST client.
     *
     * @param url - URL of the PostgREST endpoint
     * @param options - Named parameters
     * @param options.headers - Custom headers
     * @param options.schema - Postgres schema to switch to
     * @param options.fetch - Custom fetch
     */ constructor(url, { headers = {}, schema, fetch } = {}){
        this.url = url;
        this.headers = Object.assign(Object.assign({}, constants_1.DEFAULT_HEADERS), headers);
        this.schemaName = schema;
        this.fetch = fetch;
    }
    /**
     * Perform a query on a table or a view.
     *
     * @param relation - The table or view name to query
     */ from(relation) {
        const url = new URL(`${this.url}/${relation}`);
        return new PostgrestQueryBuilder_1.default(url, {
            headers: Object.assign({}, this.headers),
            schema: this.schemaName,
            fetch: this.fetch
        });
    }
    /**
     * Select a schema to query or perform an function (rpc) call.
     *
     * The schema needs to be on the list of exposed schemas inside Supabase.
     *
     * @param schema - The schema to query
     */ schema(schema) {
        return new PostgrestClient(this.url, {
            headers: this.headers,
            schema,
            fetch: this.fetch
        });
    }
    /**
     * Perform a function call.
     *
     * @param fn - The function name to call
     * @param args - The arguments to pass to the function call
     * @param options - Named parameters
     * @param options.head - When set to `true`, `data` will not be returned.
     * Useful if you only need the count.
     * @param options.get - When set to `true`, the function will be called with
     * read-only access mode.
     * @param options.count - Count algorithm to use to count rows returned by the
     * function. Only applicable for [set-returning
     * functions](https://www.postgresql.org/docs/current/functions-srf.html).
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     */ rpc(fn, args = {}, { head = false, get = false, count } = {}) {
        let method;
        const url = new URL(`${this.url}/rpc/${fn}`);
        let body;
        if (head || get) {
            method = head ? "HEAD" : "GET";
            Object.entries(args)// params with undefined value needs to be filtered out, otherwise it'll
            // show up as `?param=undefined`
            .filter(([_, value])=>value !== undefined)// array values need special syntax
            .map(([name, value])=>[
                    name,
                    Array.isArray(value) ? `{${value.join(",")}}` : `${value}`
                ]).forEach(([name, value])=>{
                url.searchParams.append(name, value);
            });
        } else {
            method = "POST";
            body = args;
        }
        const headers = Object.assign({}, this.headers);
        if (count) headers["Prefer"] = `count=${count}`;
        return new PostgrestFilterBuilder_1.default({
            method,
            url,
            headers,
            schema: this.schemaName,
            body,
            fetch: this.fetch,
            allowEmpty: false
        });
    }
}
exports.default = PostgrestClient;

},{"46c45ba978d8f946":"046JL","a418b29a37404612":"b4HnT","56170df5c50b72a8":"6Yogt"}],"046JL":[function(require,module,exports) {
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
const PostgrestFilterBuilder_1 = __importDefault(require("d92f25ea3845826e"));
class PostgrestQueryBuilder {
    constructor(url, { headers = {}, schema, fetch }){
        this.url = url;
        this.headers = headers;
        this.schema = schema;
        this.fetch = fetch;
    }
    /**
     * Perform a SELECT query on the table or view.
     *
     * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`
     *
     * @param options - Named parameters
     *
     * @param options.head - When set to `true`, `data` will not be returned.
     * Useful if you only need the count.
     *
     * @param options.count - Count algorithm to use to count rows in the table or view.
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     */ select(columns, { head = false, count } = {}) {
        const method = head ? "HEAD" : "GET";
        // Remove whitespaces except when quoted
        let quoted = false;
        const cleanedColumns = (columns !== null && columns !== void 0 ? columns : "*").split("").map((c)=>{
            if (/\s/.test(c) && !quoted) return "";
            if (c === '"') quoted = !quoted;
            return c;
        }).join("");
        this.url.searchParams.set("select", cleanedColumns);
        if (count) this.headers["Prefer"] = `count=${count}`;
        return new PostgrestFilterBuilder_1.default({
            method,
            url: this.url,
            headers: this.headers,
            schema: this.schema,
            fetch: this.fetch,
            allowEmpty: false
        });
    }
    /**
     * Perform an INSERT into the table or view.
     *
     * By default, inserted rows are not returned. To return it, chain the call
     * with `.select()`.
     *
     * @param values - The values to insert. Pass an object to insert a single row
     * or an array to insert multiple rows.
     *
     * @param options - Named parameters
     *
     * @param options.count - Count algorithm to use to count inserted rows.
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     *
     * @param options.defaultToNull - Make missing fields default to `null`.
     * Otherwise, use the default value for the column. Only applies for bulk
     * inserts.
     */ insert(values, { count, defaultToNull = true } = {}) {
        const method = "POST";
        const prefersHeaders = [];
        if (this.headers["Prefer"]) prefersHeaders.push(this.headers["Prefer"]);
        if (count) prefersHeaders.push(`count=${count}`);
        if (!defaultToNull) prefersHeaders.push("missing=default");
        this.headers["Prefer"] = prefersHeaders.join(",");
        if (Array.isArray(values)) {
            const columns = values.reduce((acc, x)=>acc.concat(Object.keys(x)), []);
            if (columns.length > 0) {
                const uniqueColumns = [
                    ...new Set(columns)
                ].map((column)=>`"${column}"`);
                this.url.searchParams.set("columns", uniqueColumns.join(","));
            }
        }
        return new PostgrestFilterBuilder_1.default({
            method,
            url: this.url,
            headers: this.headers,
            schema: this.schema,
            body: values,
            fetch: this.fetch,
            allowEmpty: false
        });
    }
    /**
     * Perform an UPSERT on the table or view. Depending on the column(s) passed
     * to `onConflict`, `.upsert()` allows you to perform the equivalent of
     * `.insert()` if a row with the corresponding `onConflict` columns doesn't
     * exist, or if it does exist, perform an alternative action depending on
     * `ignoreDuplicates`.
     *
     * By default, upserted rows are not returned. To return it, chain the call
     * with `.select()`.
     *
     * @param values - The values to upsert with. Pass an object to upsert a
     * single row or an array to upsert multiple rows.
     *
     * @param options - Named parameters
     *
     * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how
     * duplicate rows are determined. Two rows are duplicates if all the
     * `onConflict` columns are equal.
     *
     * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If
     * `false`, duplicate rows are merged with existing rows.
     *
     * @param options.count - Count algorithm to use to count upserted rows.
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     *
     * @param options.defaultToNull - Make missing fields default to `null`.
     * Otherwise, use the default value for the column. This only applies when
     * inserting new rows, not when merging with existing rows under
     * `ignoreDuplicates: false`. This also only applies when doing bulk upserts.
     */ upsert(values, { onConflict, ignoreDuplicates = false, count, defaultToNull = true } = {}) {
        const method = "POST";
        const prefersHeaders = [
            `resolution=${ignoreDuplicates ? "ignore" : "merge"}-duplicates`
        ];
        if (onConflict !== undefined) this.url.searchParams.set("on_conflict", onConflict);
        if (this.headers["Prefer"]) prefersHeaders.push(this.headers["Prefer"]);
        if (count) prefersHeaders.push(`count=${count}`);
        if (!defaultToNull) prefersHeaders.push("missing=default");
        this.headers["Prefer"] = prefersHeaders.join(",");
        if (Array.isArray(values)) {
            const columns = values.reduce((acc, x)=>acc.concat(Object.keys(x)), []);
            if (columns.length > 0) {
                const uniqueColumns = [
                    ...new Set(columns)
                ].map((column)=>`"${column}"`);
                this.url.searchParams.set("columns", uniqueColumns.join(","));
            }
        }
        return new PostgrestFilterBuilder_1.default({
            method,
            url: this.url,
            headers: this.headers,
            schema: this.schema,
            body: values,
            fetch: this.fetch,
            allowEmpty: false
        });
    }
    /**
     * Perform an UPDATE on the table or view.
     *
     * By default, updated rows are not returned. To return it, chain the call
     * with `.select()` after filters.
     *
     * @param values - The values to update with
     *
     * @param options - Named parameters
     *
     * @param options.count - Count algorithm to use to count updated rows.
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     */ update(values, { count } = {}) {
        const method = "PATCH";
        const prefersHeaders = [];
        if (this.headers["Prefer"]) prefersHeaders.push(this.headers["Prefer"]);
        if (count) prefersHeaders.push(`count=${count}`);
        this.headers["Prefer"] = prefersHeaders.join(",");
        return new PostgrestFilterBuilder_1.default({
            method,
            url: this.url,
            headers: this.headers,
            schema: this.schema,
            body: values,
            fetch: this.fetch,
            allowEmpty: false
        });
    }
    /**
     * Perform a DELETE on the table or view.
     *
     * By default, deleted rows are not returned. To return it, chain the call
     * with `.select()` after filters.
     *
     * @param options - Named parameters
     *
     * @param options.count - Count algorithm to use to count deleted rows.
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     */ delete({ count } = {}) {
        const method = "DELETE";
        const prefersHeaders = [];
        if (count) prefersHeaders.push(`count=${count}`);
        if (this.headers["Prefer"]) prefersHeaders.unshift(this.headers["Prefer"]);
        this.headers["Prefer"] = prefersHeaders.join(",");
        return new PostgrestFilterBuilder_1.default({
            method,
            url: this.url,
            headers: this.headers,
            schema: this.schema,
            fetch: this.fetch,
            allowEmpty: false
        });
    }
}
exports.default = PostgrestQueryBuilder;

},{"d92f25ea3845826e":"b4HnT"}],"b4HnT":[function(require,module,exports) {
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
const PostgrestTransformBuilder_1 = __importDefault(require("f4f4faf3c6f1b259"));
class PostgrestFilterBuilder extends PostgrestTransformBuilder_1.default {
    /**
     * Match only rows where `column` is equal to `value`.
     *
     * To check if the value of `column` is NULL, you should use `.is()` instead.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */ eq(column, value) {
        this.url.searchParams.append(column, `eq.${value}`);
        return this;
    }
    /**
     * Match only rows where `column` is not equal to `value`.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */ neq(column, value) {
        this.url.searchParams.append(column, `neq.${value}`);
        return this;
    }
    /**
     * Match only rows where `column` is greater than `value`.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */ gt(column, value) {
        this.url.searchParams.append(column, `gt.${value}`);
        return this;
    }
    /**
     * Match only rows where `column` is greater than or equal to `value`.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */ gte(column, value) {
        this.url.searchParams.append(column, `gte.${value}`);
        return this;
    }
    /**
     * Match only rows where `column` is less than `value`.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */ lt(column, value) {
        this.url.searchParams.append(column, `lt.${value}`);
        return this;
    }
    /**
     * Match only rows where `column` is less than or equal to `value`.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */ lte(column, value) {
        this.url.searchParams.append(column, `lte.${value}`);
        return this;
    }
    /**
     * Match only rows where `column` matches `pattern` case-sensitively.
     *
     * @param column - The column to filter on
     * @param pattern - The pattern to match with
     */ like(column, pattern) {
        this.url.searchParams.append(column, `like.${pattern}`);
        return this;
    }
    /**
     * Match only rows where `column` matches all of `patterns` case-sensitively.
     *
     * @param column - The column to filter on
     * @param patterns - The patterns to match with
     */ likeAllOf(column, patterns) {
        this.url.searchParams.append(column, `like(all).{${patterns.join(",")}}`);
        return this;
    }
    /**
     * Match only rows where `column` matches any of `patterns` case-sensitively.
     *
     * @param column - The column to filter on
     * @param patterns - The patterns to match with
     */ likeAnyOf(column, patterns) {
        this.url.searchParams.append(column, `like(any).{${patterns.join(",")}}`);
        return this;
    }
    /**
     * Match only rows where `column` matches `pattern` case-insensitively.
     *
     * @param column - The column to filter on
     * @param pattern - The pattern to match with
     */ ilike(column, pattern) {
        this.url.searchParams.append(column, `ilike.${pattern}`);
        return this;
    }
    /**
     * Match only rows where `column` matches all of `patterns` case-insensitively.
     *
     * @param column - The column to filter on
     * @param patterns - The patterns to match with
     */ ilikeAllOf(column, patterns) {
        this.url.searchParams.append(column, `ilike(all).{${patterns.join(",")}}`);
        return this;
    }
    /**
     * Match only rows where `column` matches any of `patterns` case-insensitively.
     *
     * @param column - The column to filter on
     * @param patterns - The patterns to match with
     */ ilikeAnyOf(column, patterns) {
        this.url.searchParams.append(column, `ilike(any).{${patterns.join(",")}}`);
        return this;
    }
    /**
     * Match only rows where `column` IS `value`.
     *
     * For non-boolean columns, this is only relevant for checking if the value of
     * `column` is NULL by setting `value` to `null`.
     *
     * For boolean columns, you can also set `value` to `true` or `false` and it
     * will behave the same way as `.eq()`.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */ is(column, value) {
        this.url.searchParams.append(column, `is.${value}`);
        return this;
    }
    /**
     * Match only rows where `column` is included in the `values` array.
     *
     * @param column - The column to filter on
     * @param values - The values array to filter with
     */ in(column, values) {
        const cleanedValues = Array.from(new Set(values)).map((s)=>{
            // handle postgrest reserved characters
            // https://postgrest.org/en/v7.0.0/api.html#reserved-characters
            if (typeof s === "string" && new RegExp("[,()]").test(s)) return `"${s}"`;
            else return `${s}`;
        }).join(",");
        this.url.searchParams.append(column, `in.(${cleanedValues})`);
        return this;
    }
    /**
     * Only relevant for jsonb, array, and range columns. Match only rows where
     * `column` contains every element appearing in `value`.
     *
     * @param column - The jsonb, array, or range column to filter on
     * @param value - The jsonb, array, or range value to filter with
     */ contains(column, value) {
        if (typeof value === "string") // range types can be inclusive '[', ']' or exclusive '(', ')' so just
        // keep it simple and accept a string
        this.url.searchParams.append(column, `cs.${value}`);
        else if (Array.isArray(value)) // array
        this.url.searchParams.append(column, `cs.{${value.join(",")}}`);
        else // json
        this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`);
        return this;
    }
    /**
     * Only relevant for jsonb, array, and range columns. Match only rows where
     * every element appearing in `column` is contained by `value`.
     *
     * @param column - The jsonb, array, or range column to filter on
     * @param value - The jsonb, array, or range value to filter with
     */ containedBy(column, value) {
        if (typeof value === "string") // range
        this.url.searchParams.append(column, `cd.${value}`);
        else if (Array.isArray(value)) // array
        this.url.searchParams.append(column, `cd.{${value.join(",")}}`);
        else // json
        this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`);
        return this;
    }
    /**
     * Only relevant for range columns. Match only rows where every element in
     * `column` is greater than any element in `range`.
     *
     * @param column - The range column to filter on
     * @param range - The range to filter with
     */ rangeGt(column, range) {
        this.url.searchParams.append(column, `sr.${range}`);
        return this;
    }
    /**
     * Only relevant for range columns. Match only rows where every element in
     * `column` is either contained in `range` or greater than any element in
     * `range`.
     *
     * @param column - The range column to filter on
     * @param range - The range to filter with
     */ rangeGte(column, range) {
        this.url.searchParams.append(column, `nxl.${range}`);
        return this;
    }
    /**
     * Only relevant for range columns. Match only rows where every element in
     * `column` is less than any element in `range`.
     *
     * @param column - The range column to filter on
     * @param range - The range to filter with
     */ rangeLt(column, range) {
        this.url.searchParams.append(column, `sl.${range}`);
        return this;
    }
    /**
     * Only relevant for range columns. Match only rows where every element in
     * `column` is either contained in `range` or less than any element in
     * `range`.
     *
     * @param column - The range column to filter on
     * @param range - The range to filter with
     */ rangeLte(column, range) {
        this.url.searchParams.append(column, `nxr.${range}`);
        return this;
    }
    /**
     * Only relevant for range columns. Match only rows where `column` is
     * mutually exclusive to `range` and there can be no element between the two
     * ranges.
     *
     * @param column - The range column to filter on
     * @param range - The range to filter with
     */ rangeAdjacent(column, range) {
        this.url.searchParams.append(column, `adj.${range}`);
        return this;
    }
    /**
     * Only relevant for array and range columns. Match only rows where
     * `column` and `value` have an element in common.
     *
     * @param column - The array or range column to filter on
     * @param value - The array or range value to filter with
     */ overlaps(column, value) {
        if (typeof value === "string") // range
        this.url.searchParams.append(column, `ov.${value}`);
        else // array
        this.url.searchParams.append(column, `ov.{${value.join(",")}}`);
        return this;
    }
    /**
     * Only relevant for text and tsvector columns. Match only rows where
     * `column` matches the query string in `query`.
     *
     * @param column - The text or tsvector column to filter on
     * @param query - The query text to match with
     * @param options - Named parameters
     * @param options.config - The text search configuration to use
     * @param options.type - Change how the `query` text is interpreted
     */ textSearch(column, query, { config, type } = {}) {
        let typePart = "";
        if (type === "plain") typePart = "pl";
        else if (type === "phrase") typePart = "ph";
        else if (type === "websearch") typePart = "w";
        const configPart = config === undefined ? "" : `(${config})`;
        this.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`);
        return this;
    }
    /**
     * Match only rows where each column in `query` keys is equal to its
     * associated value. Shorthand for multiple `.eq()`s.
     *
     * @param query - The object to filter with, with column names as keys mapped
     * to their filter values
     */ match(query) {
        Object.entries(query).forEach(([column, value])=>{
            this.url.searchParams.append(column, `eq.${value}`);
        });
        return this;
    }
    /**
     * Match only rows which doesn't satisfy the filter.
     *
     * Unlike most filters, `opearator` and `value` are used as-is and need to
     * follow [PostgREST
     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
     * to make sure they are properly sanitized.
     *
     * @param column - The column to filter on
     * @param operator - The operator to be negated to filter with, following
     * PostgREST syntax
     * @param value - The value to filter with, following PostgREST syntax
     */ not(column, operator, value) {
        this.url.searchParams.append(column, `not.${operator}.${value}`);
        return this;
    }
    /**
     * Match only rows which satisfy at least one of the filters.
     *
     * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST
     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
     * to make sure it's properly sanitized.
     *
     * It's currently not possible to do an `.or()` filter across multiple tables.
     *
     * @param filters - The filters to use, following PostgREST syntax
     * @param options - Named parameters
     * @param options.referencedTable - Set this to filter on referenced tables
     * instead of the parent table
     * @param options.foreignTable - Deprecated, use `referencedTable` instead
     */ or(filters, { foreignTable, referencedTable = foreignTable } = {}) {
        const key = referencedTable ? `${referencedTable}.or` : "or";
        this.url.searchParams.append(key, `(${filters})`);
        return this;
    }
    /**
     * Match only rows which satisfy the filter. This is an escape hatch - you
     * should use the specific filter methods wherever possible.
     *
     * Unlike most filters, `opearator` and `value` are used as-is and need to
     * follow [PostgREST
     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
     * to make sure they are properly sanitized.
     *
     * @param column - The column to filter on
     * @param operator - The operator to filter with, following PostgREST syntax
     * @param value - The value to filter with, following PostgREST syntax
     */ filter(column, operator, value) {
        this.url.searchParams.append(column, `${operator}.${value}`);
        return this;
    }
}
exports.default = PostgrestFilterBuilder;

},{"f4f4faf3c6f1b259":"9geQQ"}],"9geQQ":[function(require,module,exports) {
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
const PostgrestBuilder_1 = __importDefault(require("389721aef4055205"));
class PostgrestTransformBuilder extends PostgrestBuilder_1.default {
    /**
     * Perform a SELECT on the query result.
     *
     * By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not
     * return modified rows. By calling this method, modified rows are returned in
     * `data`.
     *
     * @param columns - The columns to retrieve, separated by commas
     */ select(columns) {
        // Remove whitespaces except when quoted
        let quoted = false;
        const cleanedColumns = (columns !== null && columns !== void 0 ? columns : "*").split("").map((c)=>{
            if (/\s/.test(c) && !quoted) return "";
            if (c === '"') quoted = !quoted;
            return c;
        }).join("");
        this.url.searchParams.set("select", cleanedColumns);
        if (this.headers["Prefer"]) this.headers["Prefer"] += ",";
        this.headers["Prefer"] += "return=representation";
        return this;
    }
    /**
     * Order the query result by `column`.
     *
     * You can call this method multiple times to order by multiple columns.
     *
     * You can order referenced tables, but it only affects the ordering of the
     * parent table if you use `!inner` in the query.
     *
     * @param column - The column to order by
     * @param options - Named parameters
     * @param options.ascending - If `true`, the result will be in ascending order
     * @param options.nullsFirst - If `true`, `null`s appear first. If `false`,
     * `null`s appear last.
     * @param options.referencedTable - Set this to order a referenced table by
     * its columns
     * @param options.foreignTable - Deprecated, use `options.referencedTable`
     * instead
     */ order(column, { ascending = true, nullsFirst, foreignTable, referencedTable = foreignTable } = {}) {
        const key = referencedTable ? `${referencedTable}.order` : "order";
        const existingOrder = this.url.searchParams.get(key);
        this.url.searchParams.set(key, `${existingOrder ? `${existingOrder},` : ""}${column}.${ascending ? "asc" : "desc"}${nullsFirst === undefined ? "" : nullsFirst ? ".nullsfirst" : ".nullslast"}`);
        return this;
    }
    /**
     * Limit the query result by `count`.
     *
     * @param count - The maximum number of rows to return
     * @param options - Named parameters
     * @param options.referencedTable - Set this to limit rows of referenced
     * tables instead of the parent table
     * @param options.foreignTable - Deprecated, use `options.referencedTable`
     * instead
     */ limit(count, { foreignTable, referencedTable = foreignTable } = {}) {
        const key = typeof referencedTable === "undefined" ? "limit" : `${referencedTable}.limit`;
        this.url.searchParams.set(key, `${count}`);
        return this;
    }
    /**
     * Limit the query result by starting at an offset `from` and ending at the offset `to`.
     * Only records within this range are returned.
     * This respects the query order and if there is no order clause the range could behave unexpectedly.
     * The `from` and `to` values are 0-based and inclusive: `range(1, 3)` will include the second, third
     * and fourth rows of the query.
     *
     * @param from - The starting index from which to limit the result
     * @param to - The last index to which to limit the result
     * @param options - Named parameters
     * @param options.referencedTable - Set this to limit rows of referenced
     * tables instead of the parent table
     * @param options.foreignTable - Deprecated, use `options.referencedTable`
     * instead
     */ range(from, to, { foreignTable, referencedTable = foreignTable } = {}) {
        const keyOffset = typeof referencedTable === "undefined" ? "offset" : `${referencedTable}.offset`;
        const keyLimit = typeof referencedTable === "undefined" ? "limit" : `${referencedTable}.limit`;
        this.url.searchParams.set(keyOffset, `${from}`);
        // Range is inclusive, so add 1
        this.url.searchParams.set(keyLimit, `${to - from + 1}`);
        return this;
    }
    /**
     * Set the AbortSignal for the fetch request.
     *
     * @param signal - The AbortSignal to use for the fetch request
     */ abortSignal(signal) {
        this.signal = signal;
        return this;
    }
    /**
     * Return `data` as a single object instead of an array of objects.
     *
     * Query result must be one row (e.g. using `.limit(1)`), otherwise this
     * returns an error.
     */ single() {
        this.headers["Accept"] = "application/vnd.pgrst.object+json";
        return this;
    }
    /**
     * Return `data` as a single object instead of an array of objects.
     *
     * Query result must be zero or one row (e.g. using `.limit(1)`), otherwise
     * this returns an error.
     */ maybeSingle() {
        // Temporary partial fix for https://github.com/supabase/postgrest-js/issues/361
        // Issue persists e.g. for `.insert([...]).select().maybeSingle()`
        if (this.method === "GET") this.headers["Accept"] = "application/json";
        else this.headers["Accept"] = "application/vnd.pgrst.object+json";
        this.isMaybeSingle = true;
        return this;
    }
    /**
     * Return `data` as a string in CSV format.
     */ csv() {
        this.headers["Accept"] = "text/csv";
        return this;
    }
    /**
     * Return `data` as an object in [GeoJSON](https://geojson.org) format.
     */ geojson() {
        this.headers["Accept"] = "application/geo+json";
        return this;
    }
    /**
     * Return `data` as the EXPLAIN plan for the query.
     *
     * You need to enable the
     * [db_plan_enabled](https://supabase.com/docs/guides/database/debugging-performance#enabling-explain)
     * setting before using this method.
     *
     * @param options - Named parameters
     *
     * @param options.analyze - If `true`, the query will be executed and the
     * actual run time will be returned
     *
     * @param options.verbose - If `true`, the query identifier will be returned
     * and `data` will include the output columns of the query
     *
     * @param options.settings - If `true`, include information on configuration
     * parameters that affect query planning
     *
     * @param options.buffers - If `true`, include information on buffer usage
     *
     * @param options.wal - If `true`, include information on WAL record generation
     *
     * @param options.format - The format of the output, can be `"text"` (default)
     * or `"json"`
     */ explain({ analyze = false, verbose = false, settings = false, buffers = false, wal = false, format = "text" } = {}) {
        var _a;
        const options = [
            analyze ? "analyze" : null,
            verbose ? "verbose" : null,
            settings ? "settings" : null,
            buffers ? "buffers" : null,
            wal ? "wal" : null
        ].filter(Boolean).join("|");
        // An Accept header can carry multiple media types but postgrest-js always sends one
        const forMediatype = (_a = this.headers["Accept"]) !== null && _a !== void 0 ? _a : "application/json";
        this.headers["Accept"] = `application/vnd.pgrst.plan+${format}; for="${forMediatype}"; options=${options};`;
        if (format === "json") return this;
        else return this;
    }
    /**
     * Rollback the query.
     *
     * `data` will still be returned, but the query is not committed.
     */ rollback() {
        var _a;
        if (((_a = this.headers["Prefer"]) !== null && _a !== void 0 ? _a : "").trim().length > 0) this.headers["Prefer"] += ",tx=rollback";
        else this.headers["Prefer"] = "tx=rollback";
        return this;
    }
    /**
     * Override the type of the returned `data`.
     *
     * @typeParam NewResult - The new result type to override with
     */ returns() {
        return this;
    }
}
exports.default = PostgrestTransformBuilder;

},{"389721aef4055205":"hGptf"}],"hGptf":[function(require,module,exports) {
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
// @ts-ignore
const node_fetch_1 = __importDefault(require("a07474f6bfb42ff0"));
const PostgrestError_1 = __importDefault(require("d8f4708fc301a50"));
class PostgrestBuilder {
    constructor(builder){
        this.shouldThrowOnError = false;
        this.method = builder.method;
        this.url = builder.url;
        this.headers = builder.headers;
        this.schema = builder.schema;
        this.body = builder.body;
        this.shouldThrowOnError = builder.shouldThrowOnError;
        this.signal = builder.signal;
        this.isMaybeSingle = builder.isMaybeSingle;
        if (builder.fetch) this.fetch = builder.fetch;
        else if (typeof fetch === "undefined") this.fetch = node_fetch_1.default;
        else this.fetch = fetch;
    }
    /**
     * If there's an error with the query, throwOnError will reject the promise by
     * throwing the error instead of returning it as part of a successful response.
     *
     * {@link https://github.com/supabase/supabase-js/issues/92}
     */ throwOnError() {
        this.shouldThrowOnError = true;
        return this;
    }
    then(onfulfilled, onrejected) {
        // https://postgrest.org/en/stable/api.html#switching-schemas
        if (this.schema === undefined) ;
        else if ([
            "GET",
            "HEAD"
        ].includes(this.method)) this.headers["Accept-Profile"] = this.schema;
        else this.headers["Content-Profile"] = this.schema;
        if (this.method !== "GET" && this.method !== "HEAD") this.headers["Content-Type"] = "application/json";
        // NOTE: Invoke w/o `this` to avoid illegal invocation error.
        // https://github.com/supabase/postgrest-js/pull/247
        const _fetch = this.fetch;
        let res = _fetch(this.url.toString(), {
            method: this.method,
            headers: this.headers,
            body: JSON.stringify(this.body),
            signal: this.signal
        }).then(async (res)=>{
            var _a, _b, _c;
            let error = null;
            let data = null;
            let count = null;
            let status = res.status;
            let statusText = res.statusText;
            if (res.ok) {
                if (this.method !== "HEAD") {
                    const body = await res.text();
                    if (body === "") ;
                    else if (this.headers["Accept"] === "text/csv") data = body;
                    else if (this.headers["Accept"] && this.headers["Accept"].includes("application/vnd.pgrst.plan+text")) data = body;
                    else data = JSON.parse(body);
                }
                const countHeader = (_a = this.headers["Prefer"]) === null || _a === void 0 ? void 0 : _a.match(/count=(exact|planned|estimated)/);
                const contentRange = (_b = res.headers.get("content-range")) === null || _b === void 0 ? void 0 : _b.split("/");
                if (countHeader && contentRange && contentRange.length > 1) count = parseInt(contentRange[1]);
                // Temporary partial fix for https://github.com/supabase/postgrest-js/issues/361
                // Issue persists e.g. for `.insert([...]).select().maybeSingle()`
                if (this.isMaybeSingle && this.method === "GET" && Array.isArray(data)) {
                    if (data.length > 1) {
                        error = {
                            // https://github.com/PostgREST/postgrest/blob/a867d79c42419af16c18c3fb019eba8df992626f/src/PostgREST/Error.hs#L553
                            code: "PGRST116",
                            details: `Results contain ${data.length} rows, application/vnd.pgrst.object+json requires 1 row`,
                            hint: null,
                            message: "JSON object requested, multiple (or no) rows returned"
                        };
                        data = null;
                        count = null;
                        status = 406;
                        statusText = "Not Acceptable";
                    } else if (data.length === 1) data = data[0];
                    else data = null;
                }
            } else {
                const body = await res.text();
                try {
                    error = JSON.parse(body);
                    // Workaround for https://github.com/supabase/postgrest-js/issues/295
                    if (Array.isArray(error) && res.status === 404) {
                        data = [];
                        error = null;
                        status = 200;
                        statusText = "OK";
                    }
                } catch (_d) {
                    // Workaround for https://github.com/supabase/postgrest-js/issues/295
                    if (res.status === 404 && body === "") {
                        status = 204;
                        statusText = "No Content";
                    } else error = {
                        message: body
                    };
                }
                if (error && this.isMaybeSingle && ((_c = error === null || error === void 0 ? void 0 : error.details) === null || _c === void 0 ? void 0 : _c.includes("0 rows"))) {
                    error = null;
                    status = 200;
                    statusText = "OK";
                }
                if (error && this.shouldThrowOnError) throw new PostgrestError_1.default(error);
            }
            const postgrestResponse = {
                error,
                data,
                count,
                status,
                statusText
            };
            return postgrestResponse;
        });
        if (!this.shouldThrowOnError) res = res.catch((fetchError)=>{
            var _a, _b, _c;
            return {
                error: {
                    message: `${(_a = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _a !== void 0 ? _a : "FetchError"}: ${fetchError === null || fetchError === void 0 ? void 0 : fetchError.message}`,
                    details: `${(_b = fetchError === null || fetchError === void 0 ? void 0 : fetchError.stack) !== null && _b !== void 0 ? _b : ""}`,
                    hint: "",
                    code: `${(_c = fetchError === null || fetchError === void 0 ? void 0 : fetchError.code) !== null && _c !== void 0 ? _c : ""}`
                },
                data: null,
                count: null,
                status: 0,
                statusText: ""
            };
        });
        return res.then(onfulfilled, onrejected);
    }
}
exports.default = PostgrestBuilder;

},{"a07474f6bfb42ff0":"1YN43","d8f4708fc301a50":"jEkTo"}],"1YN43":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fetch", ()=>fetch);
parcelHelpers.export(exports, "Headers", ()=>Headers);
parcelHelpers.export(exports, "Request", ()=>Request);
parcelHelpers.export(exports, "Response", ()=>Response);
var global = arguments[3];
"use strict";
// ref: https://github.com/tc39/proposal-global
var getGlobal = function() {
    // the only reliable means to get the global object is
    // `Function('return this')()`
    // However, this causes CSP violations in Chrome apps.
    if (typeof self !== "undefined") return self;
    if (typeof window !== "undefined") return window;
    if (typeof global !== "undefined") return global;
    throw new Error("unable to locate global object");
};
var globalObject = getGlobal();
const fetch = globalObject.fetch;
exports.default = globalObject.fetch.bind(globalObject);
const Headers = globalObject.Headers;
const Request = globalObject.Request;
const Response = globalObject.Response;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"jEkTo":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
class PostgrestError extends Error {
    constructor(context){
        super(context.message);
        this.name = "PostgrestError";
        this.details = context.details;
        this.hint = context.hint;
        this.code = context.code;
    }
}
exports.default = PostgrestError;

},{}],"6Yogt":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DEFAULT_HEADERS = void 0;
const version_1 = require("f6ef08da709cffa4");
exports.DEFAULT_HEADERS = {
    "X-Client-Info": `postgrest-js/${version_1.version}`
};

},{"f6ef08da709cffa4":"lIeUp"}],"lIeUp":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.version = void 0;
exports.version = "0.0.0-automated";

},{}],"gBhFF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RealtimePresence", ()=>(0, _realtimePresenceDefault.default));
parcelHelpers.export(exports, "RealtimeChannel", ()=>(0, _realtimeChannelDefault.default));
parcelHelpers.export(exports, "RealtimeClient", ()=>(0, _realtimeClientDefault.default));
parcelHelpers.export(exports, "REALTIME_LISTEN_TYPES", ()=>(0, _realtimeChannel.REALTIME_LISTEN_TYPES));
parcelHelpers.export(exports, "REALTIME_POSTGRES_CHANGES_LISTEN_EVENT", ()=>(0, _realtimeChannel.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT));
parcelHelpers.export(exports, "REALTIME_PRESENCE_LISTEN_EVENTS", ()=>(0, _realtimePresence.REALTIME_PRESENCE_LISTEN_EVENTS));
parcelHelpers.export(exports, "REALTIME_SUBSCRIBE_STATES", ()=>(0, _realtimeChannel.REALTIME_SUBSCRIBE_STATES));
parcelHelpers.export(exports, "REALTIME_CHANNEL_STATES", ()=>(0, _realtimeChannel.REALTIME_CHANNEL_STATES));
var _realtimeClient = require("./RealtimeClient");
var _realtimeClientDefault = parcelHelpers.interopDefault(_realtimeClient);
var _realtimeChannel = require("./RealtimeChannel");
var _realtimeChannelDefault = parcelHelpers.interopDefault(_realtimeChannel);
var _realtimePresence = require("./RealtimePresence");
var _realtimePresenceDefault = parcelHelpers.interopDefault(_realtimePresence);

},{"./RealtimeClient":"7wfPu","./RealtimeChannel":"dLF83","./RealtimePresence":"iTBjS","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"7wfPu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _constants = require("./lib/constants");
var _serializer = require("./lib/serializer");
var _serializerDefault = parcelHelpers.interopDefault(_serializer);
var _timer = require("./lib/timer");
var _timerDefault = parcelHelpers.interopDefault(_timer);
var _transformers = require("./lib/transformers");
var _realtimeChannel = require("./RealtimeChannel");
var _realtimeChannelDefault = parcelHelpers.interopDefault(_realtimeChannel);
const noop = ()=>{};
const NATIVE_WEBSOCKET_AVAILABLE = typeof WebSocket !== "undefined";
class RealtimeClient {
    /**
     * Initializes the Socket.
     *
     * @param endPoint The string WebSocket endpoint, ie, "ws://example.com/socket", "wss://example.com", "/socket" (inherited host & protocol)
     * @param httpEndpoint The string HTTP endpoint, ie, "https://example.com", "/" (inherited host & protocol)
     * @param options.transport The Websocket Transport, for example WebSocket.
     * @param options.timeout The default timeout in milliseconds to trigger push timeouts.
     * @param options.params The optional params to pass when connecting.
     * @param options.headers The optional headers to pass when connecting.
     * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.
     * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }
     * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))
     * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.
     * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.
     */ constructor(endPoint, options){
        var _a;
        this.accessToken = null;
        this.apiKey = null;
        this.channels = [];
        this.endPoint = "";
        this.httpEndpoint = "";
        this.headers = (0, _constants.DEFAULT_HEADERS);
        this.params = {};
        this.timeout = (0, _constants.DEFAULT_TIMEOUT);
        this.heartbeatIntervalMs = 30000;
        this.heartbeatTimer = undefined;
        this.pendingHeartbeatRef = null;
        this.ref = 0;
        this.logger = noop;
        this.conn = null;
        this.sendBuffer = [];
        this.serializer = new (0, _serializerDefault.default)();
        this.stateChangeCallbacks = {
            open: [],
            close: [],
            error: [],
            message: []
        };
        /**
         * Use either custom fetch, if provided, or default fetch to make HTTP requests
         *
         * @internal
         */ this._resolveFetch = (customFetch)=>{
            let _fetch;
            if (customFetch) _fetch = customFetch;
            else if (typeof fetch === "undefined") _fetch = (...args)=>require("3ea8640035012c43").then(({ default: fetch1 })=>fetch1(...args));
            else _fetch = fetch;
            return (...args)=>_fetch(...args);
        };
        this.endPoint = `${endPoint}/${(0, _constants.TRANSPORTS).websocket}`;
        this.httpEndpoint = (0, _transformers.httpEndpointURL)(endPoint);
        if (options === null || options === void 0 ? void 0 : options.transport) this.transport = options.transport;
        else this.transport = null;
        if (options === null || options === void 0 ? void 0 : options.params) this.params = options.params;
        if (options === null || options === void 0 ? void 0 : options.headers) this.headers = Object.assign(Object.assign({}, this.headers), options.headers);
        if (options === null || options === void 0 ? void 0 : options.timeout) this.timeout = options.timeout;
        if (options === null || options === void 0 ? void 0 : options.logger) this.logger = options.logger;
        if (options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) this.heartbeatIntervalMs = options.heartbeatIntervalMs;
        const accessToken = (_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.apikey;
        if (accessToken) {
            this.accessToken = accessToken;
            this.apiKey = accessToken;
        }
        this.reconnectAfterMs = (options === null || options === void 0 ? void 0 : options.reconnectAfterMs) ? options.reconnectAfterMs : (tries)=>{
            return [
                1000,
                2000,
                5000,
                10000
            ][tries - 1] || 10000;
        };
        this.encode = (options === null || options === void 0 ? void 0 : options.encode) ? options.encode : (payload, callback)=>{
            return callback(JSON.stringify(payload));
        };
        this.decode = (options === null || options === void 0 ? void 0 : options.decode) ? options.decode : this.serializer.decode.bind(this.serializer);
        this.reconnectTimer = new (0, _timerDefault.default)(async ()=>{
            this.disconnect();
            this.connect();
        }, this.reconnectAfterMs);
        this.fetch = this._resolveFetch(options === null || options === void 0 ? void 0 : options.fetch);
    }
    /**
     * Connects the socket, unless already connected.
     */ connect() {
        if (this.conn) return;
        if (this.transport) {
            this.conn = new this.transport(this._endPointURL(), undefined, {
                headers: this.headers
            });
            return;
        }
        if (NATIVE_WEBSOCKET_AVAILABLE) {
            this.conn = new WebSocket(this._endPointURL());
            this.setupConnection();
            return;
        }
        this.conn = new WSWebSocketDummy(this._endPointURL(), undefined, {
            close: ()=>{
                this.conn = null;
            }
        });
        require("c4dfe9bfdd39a2b7").then(({ default: WS })=>{
            this.conn = new WS(this._endPointURL(), undefined, {
                headers: this.headers
            });
            this.setupConnection();
        });
    }
    /**
     * Disconnects the socket.
     *
     * @param code A numeric status code to send on disconnect.
     * @param reason A custom reason for the disconnect.
     */ disconnect(code, reason) {
        if (this.conn) {
            this.conn.onclose = function() {}; // noop
            if (code) this.conn.close(code, reason !== null && reason !== void 0 ? reason : "");
            else this.conn.close();
            this.conn = null;
            // remove open handles
            this.heartbeatTimer && clearInterval(this.heartbeatTimer);
            this.reconnectTimer.reset();
        }
    }
    /**
     * Returns all created channels
     */ getChannels() {
        return this.channels;
    }
    /**
     * Unsubscribes and removes a single channel
     * @param channel A RealtimeChannel instance
     */ async removeChannel(channel) {
        const status = await channel.unsubscribe();
        if (this.channels.length === 0) this.disconnect();
        return status;
    }
    /**
     * Unsubscribes and removes all channels
     */ async removeAllChannels() {
        const values_1 = await Promise.all(this.channels.map((channel)=>channel.unsubscribe()));
        this.disconnect();
        return values_1;
    }
    /**
     * Logs the message.
     *
     * For customized logging, `this.logger` can be overridden.
     */ log(kind, msg, data) {
        this.logger(kind, msg, data);
    }
    /**
     * Returns the current state of the socket.
     */ connectionState() {
        switch(this.conn && this.conn.readyState){
            case (0, _constants.SOCKET_STATES).connecting:
                return (0, _constants.CONNECTION_STATE).Connecting;
            case (0, _constants.SOCKET_STATES).open:
                return (0, _constants.CONNECTION_STATE).Open;
            case (0, _constants.SOCKET_STATES).closing:
                return (0, _constants.CONNECTION_STATE).Closing;
            default:
                return (0, _constants.CONNECTION_STATE).Closed;
        }
    }
    /**
     * Returns `true` is the connection is open.
     */ isConnected() {
        return this.connectionState() === (0, _constants.CONNECTION_STATE).Open;
    }
    channel(topic, params = {
        config: {}
    }) {
        const chan = new (0, _realtimeChannelDefault.default)(`realtime:${topic}`, params, this);
        this.channels.push(chan);
        return chan;
    }
    /**
     * Push out a message if the socket is connected.
     *
     * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.
     */ push(data) {
        const { topic, event, payload, ref } = data;
        const callback = ()=>{
            this.encode(data, (result)=>{
                var _a;
                (_a = this.conn) === null || _a === void 0 || _a.send(result);
            });
        };
        this.log("push", `${topic} ${event} (${ref})`, payload);
        if (this.isConnected()) callback();
        else this.sendBuffer.push(callback);
    }
    /**
     * Sets the JWT access token used for channel subscription authorization and Realtime RLS.
     *
     * @param token A JWT string.
     */ setAuth(token) {
        this.accessToken = token;
        this.channels.forEach((channel)=>{
            token && channel.updateJoinPayload({
                access_token: token
            });
            if (channel.joinedOnce && channel._isJoined()) channel._push((0, _constants.CHANNEL_EVENTS).access_token, {
                access_token: token
            });
        });
    }
    /**
     * Return the next message ref, accounting for overflows
     *
     * @internal
     */ _makeRef() {
        let newRef = this.ref + 1;
        if (newRef === this.ref) this.ref = 0;
        else this.ref = newRef;
        return this.ref.toString();
    }
    /**
     * Unsubscribe from channels with the specified topic.
     *
     * @internal
     */ _leaveOpenTopic(topic) {
        let dupChannel = this.channels.find((c)=>c.topic === topic && (c._isJoined() || c._isJoining()));
        if (dupChannel) {
            this.log("transport", `leaving duplicate topic "${topic}"`);
            dupChannel.unsubscribe();
        }
    }
    /**
     * Removes a subscription from the socket.
     *
     * @param channel An open subscription.
     *
     * @internal
     */ _remove(channel) {
        this.channels = this.channels.filter((c)=>c._joinRef() !== channel._joinRef());
    }
    /**
     * Sets up connection handlers.
     *
     * @internal
     */ setupConnection() {
        if (this.conn) {
            this.conn.binaryType = "arraybuffer";
            this.conn.onopen = ()=>this._onConnOpen();
            this.conn.onerror = (error)=>this._onConnError(error);
            this.conn.onmessage = (event)=>this._onConnMessage(event);
            this.conn.onclose = (event)=>this._onConnClose(event);
        }
    }
    /**
     * Returns the URL of the websocket.
     *
     * @internal
     */ _endPointURL() {
        return this._appendParams(this.endPoint, Object.assign({}, this.params, {
            vsn: (0, _constants.VSN)
        }));
    }
    /** @internal */ _onConnMessage(rawMessage) {
        this.decode(rawMessage.data, (msg)=>{
            let { topic, event, payload, ref } = msg;
            if (ref && ref === this.pendingHeartbeatRef || event === (payload === null || payload === void 0 ? void 0 : payload.type)) this.pendingHeartbeatRef = null;
            this.log("receive", `${payload.status || ""} ${topic} ${event} ${ref && "(" + ref + ")" || ""}`, payload);
            this.channels.filter((channel)=>channel._isMember(topic)).forEach((channel)=>channel._trigger(event, payload, ref));
            this.stateChangeCallbacks.message.forEach((callback)=>callback(msg));
        });
    }
    /** @internal */ _onConnOpen() {
        this.log("transport", `connected to ${this._endPointURL()}`);
        this._flushSendBuffer();
        this.reconnectTimer.reset();
        this.heartbeatTimer && clearInterval(this.heartbeatTimer);
        this.heartbeatTimer = setInterval(()=>this._sendHeartbeat(), this.heartbeatIntervalMs);
        this.stateChangeCallbacks.open.forEach((callback)=>callback());
    }
    /** @internal */ _onConnClose(event) {
        this.log("transport", "close", event);
        this._triggerChanError();
        this.heartbeatTimer && clearInterval(this.heartbeatTimer);
        this.reconnectTimer.scheduleTimeout();
        this.stateChangeCallbacks.close.forEach((callback)=>callback(event));
    }
    /** @internal */ _onConnError(error) {
        this.log("transport", error.message);
        this._triggerChanError();
        this.stateChangeCallbacks.error.forEach((callback)=>callback(error));
    }
    /** @internal */ _triggerChanError() {
        this.channels.forEach((channel)=>channel._trigger((0, _constants.CHANNEL_EVENTS).error));
    }
    /** @internal */ _appendParams(url, params) {
        if (Object.keys(params).length === 0) return url;
        const prefix = url.match(/\?/) ? "&" : "?";
        const query = new URLSearchParams(params);
        return `${url}${prefix}${query}`;
    }
    /** @internal */ _flushSendBuffer() {
        if (this.isConnected() && this.sendBuffer.length > 0) {
            this.sendBuffer.forEach((callback)=>callback());
            this.sendBuffer = [];
        }
    }
    /** @internal */ _sendHeartbeat() {
        var _a;
        if (!this.isConnected()) return;
        if (this.pendingHeartbeatRef) {
            this.pendingHeartbeatRef = null;
            this.log("transport", "heartbeat timeout. Attempting to re-establish connection");
            (_a = this.conn) === null || _a === void 0 || _a.close((0, _constants.WS_CLOSE_NORMAL), "hearbeat timeout");
            return;
        }
        this.pendingHeartbeatRef = this._makeRef();
        this.push({
            topic: "phoenix",
            event: "heartbeat",
            payload: {},
            ref: this.pendingHeartbeatRef
        });
        this.setAuth(this.accessToken);
    }
}
exports.default = RealtimeClient;
class WSWebSocketDummy {
    constructor(address, _protocols, options){
        this.binaryType = "arraybuffer";
        this.onclose = ()=>{};
        this.onerror = ()=>{};
        this.onmessage = ()=>{};
        this.onopen = ()=>{};
        this.readyState = (0, _constants.SOCKET_STATES).connecting;
        this.send = ()=>{};
        this.url = null;
        this.url = address;
        this.close = options.close;
    }
}

},{"./lib/constants":"khvTK","./lib/serializer":"ksGHz","./lib/timer":"6IaDA","./lib/transformers":"d7Tn4","./RealtimeChannel":"dLF83","3ea8640035012c43":"cRjRL","c4dfe9bfdd39a2b7":"41dP3","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"khvTK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DEFAULT_HEADERS", ()=>DEFAULT_HEADERS);
parcelHelpers.export(exports, "VSN", ()=>VSN);
parcelHelpers.export(exports, "DEFAULT_TIMEOUT", ()=>DEFAULT_TIMEOUT);
parcelHelpers.export(exports, "WS_CLOSE_NORMAL", ()=>WS_CLOSE_NORMAL);
parcelHelpers.export(exports, "SOCKET_STATES", ()=>SOCKET_STATES);
parcelHelpers.export(exports, "CHANNEL_STATES", ()=>CHANNEL_STATES);
parcelHelpers.export(exports, "CHANNEL_EVENTS", ()=>CHANNEL_EVENTS);
parcelHelpers.export(exports, "TRANSPORTS", ()=>TRANSPORTS);
parcelHelpers.export(exports, "CONNECTION_STATE", ()=>CONNECTION_STATE);
var _version = require("./version");
const DEFAULT_HEADERS = {
    "X-Client-Info": `realtime-js/${(0, _version.version)}`
};
const VSN = "1.0.0";
const DEFAULT_TIMEOUT = 10000;
const WS_CLOSE_NORMAL = 1000;
var SOCKET_STATES;
(function(SOCKET_STATES) {
    SOCKET_STATES[SOCKET_STATES["connecting"] = 0] = "connecting";
    SOCKET_STATES[SOCKET_STATES["open"] = 1] = "open";
    SOCKET_STATES[SOCKET_STATES["closing"] = 2] = "closing";
    SOCKET_STATES[SOCKET_STATES["closed"] = 3] = "closed";
})(SOCKET_STATES || (SOCKET_STATES = {}));
var CHANNEL_STATES;
(function(CHANNEL_STATES) {
    CHANNEL_STATES["closed"] = "closed";
    CHANNEL_STATES["errored"] = "errored";
    CHANNEL_STATES["joined"] = "joined";
    CHANNEL_STATES["joining"] = "joining";
    CHANNEL_STATES["leaving"] = "leaving";
})(CHANNEL_STATES || (CHANNEL_STATES = {}));
var CHANNEL_EVENTS;
(function(CHANNEL_EVENTS) {
    CHANNEL_EVENTS["close"] = "phx_close";
    CHANNEL_EVENTS["error"] = "phx_error";
    CHANNEL_EVENTS["join"] = "phx_join";
    CHANNEL_EVENTS["reply"] = "phx_reply";
    CHANNEL_EVENTS["leave"] = "phx_leave";
    CHANNEL_EVENTS["access_token"] = "access_token";
})(CHANNEL_EVENTS || (CHANNEL_EVENTS = {}));
var TRANSPORTS;
(function(TRANSPORTS) {
    TRANSPORTS["websocket"] = "websocket";
})(TRANSPORTS || (TRANSPORTS = {}));
var CONNECTION_STATE;
(function(CONNECTION_STATE) {
    CONNECTION_STATE["Connecting"] = "connecting";
    CONNECTION_STATE["Open"] = "open";
    CONNECTION_STATE["Closing"] = "closing";
    CONNECTION_STATE["Closed"] = "closed";
})(CONNECTION_STATE || (CONNECTION_STATE = {}));

},{"./version":"fMwUB","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"fMwUB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "2.10.2";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"ksGHz":[function(require,module,exports) {
// This file draws heavily from https://github.com/phoenixframework/phoenix/commit/cf098e9cf7a44ee6479d31d911a97d3c7430c6fe
// License: https://github.com/phoenixframework/phoenix/blob/master/LICENSE.md
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class Serializer {
    constructor(){
        this.HEADER_LENGTH = 1;
    }
    decode(rawPayload, callback) {
        if (rawPayload.constructor === ArrayBuffer) return callback(this._binaryDecode(rawPayload));
        if (typeof rawPayload === "string") return callback(JSON.parse(rawPayload));
        return callback({});
    }
    _binaryDecode(buffer) {
        const view = new DataView(buffer);
        const decoder = new TextDecoder();
        return this._decodeBroadcast(buffer, view, decoder);
    }
    _decodeBroadcast(buffer, view, decoder) {
        const topicSize = view.getUint8(1);
        const eventSize = view.getUint8(2);
        let offset = this.HEADER_LENGTH + 2;
        const topic = decoder.decode(buffer.slice(offset, offset + topicSize));
        offset = offset + topicSize;
        const event = decoder.decode(buffer.slice(offset, offset + eventSize));
        offset = offset + eventSize;
        const data = JSON.parse(decoder.decode(buffer.slice(offset, buffer.byteLength)));
        return {
            ref: null,
            topic: topic,
            event: event,
            payload: data
        };
    }
}
exports.default = Serializer;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"6IaDA":[function(require,module,exports) {
/**
 * Creates a timer that accepts a `timerCalc` function to perform calculated timeout retries, such as exponential backoff.
 *
 * @example
 *    let reconnectTimer = new Timer(() => this.connect(), function(tries){
 *      return [1000, 5000, 10000][tries - 1] || 10000
 *    })
 *    reconnectTimer.scheduleTimeout() // fires after 1000
 *    reconnectTimer.scheduleTimeout() // fires after 5000
 *    reconnectTimer.reset()
 *    reconnectTimer.scheduleTimeout() // fires after 1000
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class Timer {
    constructor(callback, timerCalc){
        this.callback = callback;
        this.timerCalc = timerCalc;
        this.timer = undefined;
        this.tries = 0;
        this.callback = callback;
        this.timerCalc = timerCalc;
    }
    reset() {
        this.tries = 0;
        clearTimeout(this.timer);
    }
    // Cancels any previous scheduleTimeout and schedules callback
    scheduleTimeout() {
        clearTimeout(this.timer);
        this.timer = setTimeout(()=>{
            this.tries = this.tries + 1;
            this.callback();
        }, this.timerCalc(this.tries + 1));
    }
}
exports.default = Timer;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"d7Tn4":[function(require,module,exports) {
/**
 * Helpers to convert the change Payload into native JS types.
 */ // Adapted from epgsql (src/epgsql_binary.erl), this module licensed under
// 3-clause BSD found here: https://raw.githubusercontent.com/epgsql/epgsql/devel/LICENSE
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PostgresTypes", ()=>PostgresTypes);
parcelHelpers.export(exports, "convertChangeData", ()=>convertChangeData);
parcelHelpers.export(exports, "convertColumn", ()=>convertColumn);
parcelHelpers.export(exports, "convertCell", ()=>convertCell);
parcelHelpers.export(exports, "toBoolean", ()=>toBoolean);
parcelHelpers.export(exports, "toNumber", ()=>toNumber);
parcelHelpers.export(exports, "toJson", ()=>toJson);
parcelHelpers.export(exports, "toArray", ()=>toArray);
parcelHelpers.export(exports, "toTimestampString", ()=>toTimestampString);
parcelHelpers.export(exports, "httpEndpointURL", ()=>httpEndpointURL);
var PostgresTypes;
(function(PostgresTypes) {
    PostgresTypes["abstime"] = "abstime";
    PostgresTypes["bool"] = "bool";
    PostgresTypes["date"] = "date";
    PostgresTypes["daterange"] = "daterange";
    PostgresTypes["float4"] = "float4";
    PostgresTypes["float8"] = "float8";
    PostgresTypes["int2"] = "int2";
    PostgresTypes["int4"] = "int4";
    PostgresTypes["int4range"] = "int4range";
    PostgresTypes["int8"] = "int8";
    PostgresTypes["int8range"] = "int8range";
    PostgresTypes["json"] = "json";
    PostgresTypes["jsonb"] = "jsonb";
    PostgresTypes["money"] = "money";
    PostgresTypes["numeric"] = "numeric";
    PostgresTypes["oid"] = "oid";
    PostgresTypes["reltime"] = "reltime";
    PostgresTypes["text"] = "text";
    PostgresTypes["time"] = "time";
    PostgresTypes["timestamp"] = "timestamp";
    PostgresTypes["timestamptz"] = "timestamptz";
    PostgresTypes["timetz"] = "timetz";
    PostgresTypes["tsrange"] = "tsrange";
    PostgresTypes["tstzrange"] = "tstzrange";
})(PostgresTypes || (PostgresTypes = {}));
const convertChangeData = (columns, record, options = {})=>{
    var _a;
    const skipTypes = (_a = options.skipTypes) !== null && _a !== void 0 ? _a : [];
    return Object.keys(record).reduce((acc, rec_key)=>{
        acc[rec_key] = convertColumn(rec_key, columns, record, skipTypes);
        return acc;
    }, {});
};
const convertColumn = (columnName, columns, record, skipTypes)=>{
    const column = columns.find((x)=>x.name === columnName);
    const colType = column === null || column === void 0 ? void 0 : column.type;
    const value = record[columnName];
    if (colType && !skipTypes.includes(colType)) return convertCell(colType, value);
    return noop(value);
};
const convertCell = (type, value)=>{
    // if data type is an array
    if (type.charAt(0) === "_") {
        const dataType = type.slice(1, type.length);
        return toArray(value, dataType);
    }
    // If not null, convert to correct type.
    switch(type){
        case PostgresTypes.bool:
            return toBoolean(value);
        case PostgresTypes.float4:
        case PostgresTypes.float8:
        case PostgresTypes.int2:
        case PostgresTypes.int4:
        case PostgresTypes.int8:
        case PostgresTypes.numeric:
        case PostgresTypes.oid:
            return toNumber(value);
        case PostgresTypes.json:
        case PostgresTypes.jsonb:
            return toJson(value);
        case PostgresTypes.timestamp:
            return toTimestampString(value); // Format to be consistent with PostgREST
        case PostgresTypes.abstime:
        case PostgresTypes.date:
        case PostgresTypes.daterange:
        case PostgresTypes.int4range:
        case PostgresTypes.int8range:
        case PostgresTypes.money:
        case PostgresTypes.reltime:
        case PostgresTypes.text:
        case PostgresTypes.time:
        case PostgresTypes.timestamptz:
        case PostgresTypes.timetz:
        case PostgresTypes.tsrange:
        case PostgresTypes.tstzrange:
            return noop(value);
        default:
            // Return the value for remaining types
            return noop(value);
    }
};
const noop = (value)=>{
    return value;
};
const toBoolean = (value)=>{
    switch(value){
        case "t":
            return true;
        case "f":
            return false;
        default:
            return value;
    }
};
const toNumber = (value)=>{
    if (typeof value === "string") {
        const parsedValue = parseFloat(value);
        if (!Number.isNaN(parsedValue)) return parsedValue;
    }
    return value;
};
const toJson = (value)=>{
    if (typeof value === "string") try {
        return JSON.parse(value);
    } catch (error) {
        console.log(`JSON parse error: ${error}`);
        return value;
    }
    return value;
};
const toArray = (value, type)=>{
    if (typeof value !== "string") return value;
    const lastIdx = value.length - 1;
    const closeBrace = value[lastIdx];
    const openBrace = value[0];
    // Confirm value is a Postgres array by checking curly brackets
    if (openBrace === "{" && closeBrace === "}") {
        let arr;
        const valTrim = value.slice(1, lastIdx);
        // TODO: find a better solution to separate Postgres array data
        try {
            arr = JSON.parse("[" + valTrim + "]");
        } catch (_) {
            // WARNING: splitting on comma does not cover all edge cases
            arr = valTrim ? valTrim.split(",") : [];
        }
        return arr.map((val)=>convertCell(type, val));
    }
    return value;
};
const toTimestampString = (value)=>{
    if (typeof value === "string") return value.replace(" ", "T");
    return value;
};
const httpEndpointURL = (socketUrl)=>{
    let url = socketUrl;
    url = url.replace(/^ws/i, "http");
    url = url.replace(/(\/socket\/websocket|\/socket|\/websocket)\/?$/i, "");
    return url.replace(/\/+$/, "");
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"dLF83":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "REALTIME_POSTGRES_CHANGES_LISTEN_EVENT", ()=>REALTIME_POSTGRES_CHANGES_LISTEN_EVENT);
parcelHelpers.export(exports, "REALTIME_LISTEN_TYPES", ()=>REALTIME_LISTEN_TYPES);
parcelHelpers.export(exports, "REALTIME_SUBSCRIBE_STATES", ()=>REALTIME_SUBSCRIBE_STATES);
parcelHelpers.export(exports, "REALTIME_CHANNEL_STATES", ()=>REALTIME_CHANNEL_STATES);
var _constants = require("./lib/constants");
var _push = require("./lib/push");
var _pushDefault = parcelHelpers.interopDefault(_push);
var _timer = require("./lib/timer");
var _timerDefault = parcelHelpers.interopDefault(_timer);
var _realtimePresence = require("./RealtimePresence");
var _realtimePresenceDefault = parcelHelpers.interopDefault(_realtimePresence);
var _transformers = require("./lib/transformers");
var REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;
(function(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT) {
    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT["ALL"] = "*";
    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT["INSERT"] = "INSERT";
    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT["UPDATE"] = "UPDATE";
    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT["DELETE"] = "DELETE";
})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));
var REALTIME_LISTEN_TYPES;
(function(REALTIME_LISTEN_TYPES) {
    REALTIME_LISTEN_TYPES["BROADCAST"] = "broadcast";
    REALTIME_LISTEN_TYPES["PRESENCE"] = "presence";
    /**
     * listen to Postgres changes.
     */ REALTIME_LISTEN_TYPES["POSTGRES_CHANGES"] = "postgres_changes";
})(REALTIME_LISTEN_TYPES || (REALTIME_LISTEN_TYPES = {}));
var REALTIME_SUBSCRIBE_STATES;
(function(REALTIME_SUBSCRIBE_STATES) {
    REALTIME_SUBSCRIBE_STATES["SUBSCRIBED"] = "SUBSCRIBED";
    REALTIME_SUBSCRIBE_STATES["TIMED_OUT"] = "TIMED_OUT";
    REALTIME_SUBSCRIBE_STATES["CLOSED"] = "CLOSED";
    REALTIME_SUBSCRIBE_STATES["CHANNEL_ERROR"] = "CHANNEL_ERROR";
})(REALTIME_SUBSCRIBE_STATES || (REALTIME_SUBSCRIBE_STATES = {}));
const REALTIME_CHANNEL_STATES = (0, _constants.CHANNEL_STATES);
class RealtimeChannel {
    constructor(/** Topic name can be any string. */ topic, params = {
        config: {}
    }, socket){
        this.topic = topic;
        this.params = params;
        this.socket = socket;
        this.bindings = {};
        this.state = (0, _constants.CHANNEL_STATES).closed;
        this.joinedOnce = false;
        this.pushBuffer = [];
        this.subTopic = topic.replace(/^realtime:/i, "");
        this.params.config = Object.assign({
            broadcast: {
                ack: false,
                self: false
            },
            presence: {
                key: ""
            },
            private: false
        }, params.config);
        this.timeout = this.socket.timeout;
        this.joinPush = new (0, _pushDefault.default)(this, (0, _constants.CHANNEL_EVENTS).join, this.params, this.timeout);
        this.rejoinTimer = new (0, _timerDefault.default)(()=>this._rejoinUntilConnected(), this.socket.reconnectAfterMs);
        this.joinPush.receive("ok", ()=>{
            this.state = (0, _constants.CHANNEL_STATES).joined;
            this.rejoinTimer.reset();
            this.pushBuffer.forEach((pushEvent)=>pushEvent.send());
            this.pushBuffer = [];
        });
        this._onClose(()=>{
            this.rejoinTimer.reset();
            this.socket.log("channel", `close ${this.topic} ${this._joinRef()}`);
            this.state = (0, _constants.CHANNEL_STATES).closed;
            this.socket._remove(this);
        });
        this._onError((reason)=>{
            if (this._isLeaving() || this._isClosed()) return;
            this.socket.log("channel", `error ${this.topic}`, reason);
            this.state = (0, _constants.CHANNEL_STATES).errored;
            this.rejoinTimer.scheduleTimeout();
        });
        this.joinPush.receive("timeout", ()=>{
            if (!this._isJoining()) return;
            this.socket.log("channel", `timeout ${this.topic}`, this.joinPush.timeout);
            this.state = (0, _constants.CHANNEL_STATES).errored;
            this.rejoinTimer.scheduleTimeout();
        });
        this._on((0, _constants.CHANNEL_EVENTS).reply, {}, (payload, ref)=>{
            this._trigger(this._replyEventName(ref), payload);
        });
        this.presence = new (0, _realtimePresenceDefault.default)(this);
        this.broadcastEndpointURL = (0, _transformers.httpEndpointURL)(this.socket.endPoint) + "/api/broadcast";
    }
    /** Subscribe registers your client with the server */ subscribe(callback, timeout = this.timeout) {
        var _a, _b;
        if (!this.socket.isConnected()) this.socket.connect();
        if (this.joinedOnce) throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`;
        else {
            const { config: { broadcast, presence, private: isPrivate } } = this.params;
            this._onError((e)=>callback && callback("CHANNEL_ERROR", e));
            this._onClose(()=>callback && callback("CLOSED"));
            const accessTokenPayload = {};
            const config = {
                broadcast,
                presence,
                postgres_changes: (_b = (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.map((r)=>r.filter)) !== null && _b !== void 0 ? _b : [],
                private: isPrivate
            };
            if (this.socket.accessToken) accessTokenPayload.access_token = this.socket.accessToken;
            this.updateJoinPayload(Object.assign({
                config
            }, accessTokenPayload));
            this.joinedOnce = true;
            this._rejoin(timeout);
            this.joinPush.receive("ok", ({ postgres_changes: serverPostgresFilters })=>{
                var _a;
                this.socket.accessToken && this.socket.setAuth(this.socket.accessToken);
                if (serverPostgresFilters === undefined) {
                    callback && callback("SUBSCRIBED");
                    return;
                } else {
                    const clientPostgresBindings = this.bindings.postgres_changes;
                    const bindingsLen = (_a = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a !== void 0 ? _a : 0;
                    const newPostgresBindings = [];
                    for(let i = 0; i < bindingsLen; i++){
                        const clientPostgresBinding = clientPostgresBindings[i];
                        const { filter: { event, schema, table, filter } } = clientPostgresBinding;
                        const serverPostgresFilter = serverPostgresFilters && serverPostgresFilters[i];
                        if (serverPostgresFilter && serverPostgresFilter.event === event && serverPostgresFilter.schema === schema && serverPostgresFilter.table === table && serverPostgresFilter.filter === filter) newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), {
                            id: serverPostgresFilter.id
                        }));
                        else {
                            this.unsubscribe();
                            callback && callback("CHANNEL_ERROR", new Error("mismatch between server and client bindings for postgres changes"));
                            return;
                        }
                    }
                    this.bindings.postgres_changes = newPostgresBindings;
                    callback && callback("SUBSCRIBED");
                    return;
                }
            }).receive("error", (error)=>{
                callback && callback("CHANNEL_ERROR", new Error(JSON.stringify(Object.values(error).join(", ") || "error")));
                return;
            }).receive("timeout", ()=>{
                callback && callback("TIMED_OUT");
                return;
            });
        }
        return this;
    }
    presenceState() {
        return this.presence.state;
    }
    async track(payload, opts = {}) {
        return await this.send({
            type: "presence",
            event: "track",
            payload
        }, opts.timeout || this.timeout);
    }
    async untrack(opts = {}) {
        return await this.send({
            type: "presence",
            event: "untrack"
        }, opts);
    }
    on(type, filter, callback) {
        return this._on(type, filter, callback);
    }
    /**
     * Sends a message into the channel.
     *
     * @param args Arguments to send to channel
     * @param args.type The type of event to send
     * @param args.event The name of the event being sent
     * @param args.payload Payload to be sent
     * @param opts Options to be used during the send process
     */ async send(args, opts = {}) {
        var _a, _b;
        if (!this._canPush() && args.type === "broadcast") {
            const { event, payload: endpoint_payload } = args;
            const options = {
                method: "POST",
                headers: {
                    Authorization: this.socket.accessToken ? `Bearer ${this.socket.accessToken}` : "",
                    apikey: this.socket.apiKey ? this.socket.apiKey : "",
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    messages: [
                        {
                            topic: this.subTopic,
                            event,
                            payload: endpoint_payload
                        }
                    ]
                })
            };
            try {
                const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a = opts.timeout) !== null && _a !== void 0 ? _a : this.timeout);
                await ((_b = response.body) === null || _b === void 0 ? void 0 : _b.cancel());
                return response.ok ? "ok" : "error";
            } catch (error) {
                if (error.name === "AbortError") return "timed out";
                else return "error";
            }
        } else return new Promise((resolve)=>{
            var _a, _b, _c;
            const push = this._push(args.type, args, opts.timeout || this.timeout);
            if (args.type === "broadcast" && !((_c = (_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) resolve("ok");
            push.receive("ok", ()=>resolve("ok"));
            push.receive("error", ()=>resolve("error"));
            push.receive("timeout", ()=>resolve("timed out"));
        });
    }
    updateJoinPayload(payload) {
        this.joinPush.updatePayload(payload);
    }
    /**
     * Leaves the channel.
     *
     * Unsubscribes from server events, and instructs channel to terminate on server.
     * Triggers onClose() hooks.
     *
     * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:
     * channel.unsubscribe().receive("ok", () => alert("left!") )
     */ unsubscribe(timeout = this.timeout) {
        this.state = (0, _constants.CHANNEL_STATES).leaving;
        const onClose = ()=>{
            this.socket.log("channel", `leave ${this.topic}`);
            this._trigger((0, _constants.CHANNEL_EVENTS).close, "leave", this._joinRef());
        };
        this.rejoinTimer.reset();
        // Destroy joinPush to avoid connection timeouts during unscription phase
        this.joinPush.destroy();
        return new Promise((resolve)=>{
            const leavePush = new (0, _pushDefault.default)(this, (0, _constants.CHANNEL_EVENTS).leave, {}, timeout);
            leavePush.receive("ok", ()=>{
                onClose();
                resolve("ok");
            }).receive("timeout", ()=>{
                onClose();
                resolve("timed out");
            }).receive("error", ()=>{
                resolve("error");
            });
            leavePush.send();
            if (!this._canPush()) leavePush.trigger("ok", {});
        });
    }
    /** @internal */ async _fetchWithTimeout(url, options, timeout) {
        const controller = new AbortController();
        const id = setTimeout(()=>controller.abort(), timeout);
        const response = await this.socket.fetch(url, Object.assign(Object.assign({}, options), {
            signal: controller.signal
        }));
        clearTimeout(id);
        return response;
    }
    /** @internal */ _push(event, payload, timeout = this.timeout) {
        if (!this.joinedOnce) throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;
        let pushEvent = new (0, _pushDefault.default)(this, event, payload, timeout);
        if (this._canPush()) pushEvent.send();
        else {
            pushEvent.startTimeout();
            this.pushBuffer.push(pushEvent);
        }
        return pushEvent;
    }
    /**
     * Overridable message hook
     *
     * Receives all events for specialized message handling before dispatching to the channel callbacks.
     * Must return the payload, modified or unmodified.
     *
     * @internal
     */ _onMessage(_event, payload, _ref) {
        return payload;
    }
    /** @internal */ _isMember(topic) {
        return this.topic === topic;
    }
    /** @internal */ _joinRef() {
        return this.joinPush.ref;
    }
    /** @internal */ _trigger(type, payload, ref) {
        var _a, _b;
        const typeLower = type.toLocaleLowerCase();
        const { close, error, leave, join } = (0, _constants.CHANNEL_EVENTS);
        const events = [
            close,
            error,
            leave,
            join
        ];
        if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) return;
        let handledPayload = this._onMessage(typeLower, payload, ref);
        if (payload && !handledPayload) throw "channel onMessage callbacks must return the payload, modified or unmodified";
        if ([
            "insert",
            "update",
            "delete"
        ].includes(typeLower)) (_a = this.bindings.postgres_changes) === null || _a === void 0 || _a.filter((bind)=>{
            var _a, _b, _c;
            return ((_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event) === "*" || ((_c = (_b = bind.filter) === null || _b === void 0 ? void 0 : _b.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower;
        }).map((bind)=>bind.callback(handledPayload, ref));
        else (_b = this.bindings[typeLower]) === null || _b === void 0 || _b.filter((bind)=>{
            var _a, _b, _c, _d, _e, _f;
            if ([
                "broadcast",
                "presence",
                "postgres_changes"
            ].includes(typeLower)) {
                if ("id" in bind) {
                    const bindId = bind.id;
                    const bindEvent = (_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event;
                    return bindId && ((_b = payload.ids) === null || _b === void 0 ? void 0 : _b.includes(bindId)) && (bindEvent === "*" || (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) === ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase()));
                } else {
                    const bindEvent = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();
                    return bindEvent === "*" || bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase());
                }
            } else return bind.type.toLocaleLowerCase() === typeLower;
        }).map((bind)=>{
            if (typeof handledPayload === "object" && "ids" in handledPayload) {
                const postgresChanges = handledPayload.data;
                const { schema, table, commit_timestamp, type, errors } = postgresChanges;
                const enrichedPayload = {
                    schema: schema,
                    table: table,
                    commit_timestamp: commit_timestamp,
                    eventType: type,
                    new: {},
                    old: {},
                    errors: errors
                };
                handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));
            }
            bind.callback(handledPayload, ref);
        });
    }
    /** @internal */ _isClosed() {
        return this.state === (0, _constants.CHANNEL_STATES).closed;
    }
    /** @internal */ _isJoined() {
        return this.state === (0, _constants.CHANNEL_STATES).joined;
    }
    /** @internal */ _isJoining() {
        return this.state === (0, _constants.CHANNEL_STATES).joining;
    }
    /** @internal */ _isLeaving() {
        return this.state === (0, _constants.CHANNEL_STATES).leaving;
    }
    /** @internal */ _replyEventName(ref) {
        return `chan_reply_${ref}`;
    }
    /** @internal */ _on(type, filter, callback) {
        const typeLower = type.toLocaleLowerCase();
        const binding = {
            type: typeLower,
            filter: filter,
            callback: callback
        };
        if (this.bindings[typeLower]) this.bindings[typeLower].push(binding);
        else this.bindings[typeLower] = [
            binding
        ];
        return this;
    }
    /** @internal */ _off(type, filter) {
        const typeLower = type.toLocaleLowerCase();
        this.bindings[typeLower] = this.bindings[typeLower].filter((bind)=>{
            var _a;
            return !(((_a = bind.type) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) === typeLower && RealtimeChannel.isEqual(bind.filter, filter));
        });
        return this;
    }
    /** @internal */ static isEqual(obj1, obj2) {
        if (Object.keys(obj1).length !== Object.keys(obj2).length) return false;
        for(const k in obj1){
            if (obj1[k] !== obj2[k]) return false;
        }
        return true;
    }
    /** @internal */ _rejoinUntilConnected() {
        this.rejoinTimer.scheduleTimeout();
        if (this.socket.isConnected()) this._rejoin();
    }
    /**
     * Registers a callback that will be executed when the channel closes.
     *
     * @internal
     */ _onClose(callback) {
        this._on((0, _constants.CHANNEL_EVENTS).close, {}, callback);
    }
    /**
     * Registers a callback that will be executed when the channel encounteres an error.
     *
     * @internal
     */ _onError(callback) {
        this._on((0, _constants.CHANNEL_EVENTS).error, {}, (reason)=>callback(reason));
    }
    /**
     * Returns `true` if the socket is connected and the channel has been joined.
     *
     * @internal
     */ _canPush() {
        return this.socket.isConnected() && this._isJoined();
    }
    /** @internal */ _rejoin(timeout = this.timeout) {
        if (this._isLeaving()) return;
        this.socket._leaveOpenTopic(this.topic);
        this.state = (0, _constants.CHANNEL_STATES).joining;
        this.joinPush.resend(timeout);
    }
    /** @internal */ _getPayloadRecords(payload) {
        const records = {
            new: {},
            old: {}
        };
        if (payload.type === "INSERT" || payload.type === "UPDATE") records.new = _transformers.convertChangeData(payload.columns, payload.record);
        if (payload.type === "UPDATE" || payload.type === "DELETE") records.old = _transformers.convertChangeData(payload.columns, payload.old_record);
        return records;
    }
}
exports.default = RealtimeChannel;

},{"./lib/constants":"khvTK","./lib/push":"gXoFg","./lib/timer":"6IaDA","./RealtimePresence":"iTBjS","./lib/transformers":"d7Tn4","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"gXoFg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _constants = require("../lib/constants");
class Push {
    /**
     * Initializes the Push
     *
     * @param channel The Channel
     * @param event The event, for example `"phx_join"`
     * @param payload The payload, for example `{user_id: 123}`
     * @param timeout The push timeout in milliseconds
     */ constructor(channel, event, payload = {}, timeout = (0, _constants.DEFAULT_TIMEOUT)){
        this.channel = channel;
        this.event = event;
        this.payload = payload;
        this.timeout = timeout;
        this.sent = false;
        this.timeoutTimer = undefined;
        this.ref = "";
        this.receivedResp = null;
        this.recHooks = [];
        this.refEvent = null;
    }
    resend(timeout) {
        this.timeout = timeout;
        this._cancelRefEvent();
        this.ref = "";
        this.refEvent = null;
        this.receivedResp = null;
        this.sent = false;
        this.send();
    }
    send() {
        if (this._hasReceived("timeout")) return;
        this.startTimeout();
        this.sent = true;
        this.channel.socket.push({
            topic: this.channel.topic,
            event: this.event,
            payload: this.payload,
            ref: this.ref,
            join_ref: this.channel._joinRef()
        });
    }
    updatePayload(payload) {
        this.payload = Object.assign(Object.assign({}, this.payload), payload);
    }
    receive(status, callback) {
        var _a;
        if (this._hasReceived(status)) callback((_a = this.receivedResp) === null || _a === void 0 ? void 0 : _a.response);
        this.recHooks.push({
            status,
            callback
        });
        return this;
    }
    startTimeout() {
        if (this.timeoutTimer) return;
        this.ref = this.channel.socket._makeRef();
        this.refEvent = this.channel._replyEventName(this.ref);
        const callback = (payload)=>{
            this._cancelRefEvent();
            this._cancelTimeout();
            this.receivedResp = payload;
            this._matchReceive(payload);
        };
        this.channel._on(this.refEvent, {}, callback);
        this.timeoutTimer = setTimeout(()=>{
            this.trigger("timeout", {});
        }, this.timeout);
    }
    trigger(status, response) {
        if (this.refEvent) this.channel._trigger(this.refEvent, {
            status,
            response
        });
    }
    destroy() {
        this._cancelRefEvent();
        this._cancelTimeout();
    }
    _cancelRefEvent() {
        if (!this.refEvent) return;
        this.channel._off(this.refEvent, {});
    }
    _cancelTimeout() {
        clearTimeout(this.timeoutTimer);
        this.timeoutTimer = undefined;
    }
    _matchReceive({ status, response }) {
        this.recHooks.filter((h)=>h.status === status).forEach((h)=>h.callback(response));
    }
    _hasReceived(status) {
        return this.receivedResp && this.receivedResp.status === status;
    }
}
exports.default = Push;

},{"../lib/constants":"khvTK","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"iTBjS":[function(require,module,exports) {
/*
  This file draws heavily from https://github.com/phoenixframework/phoenix/blob/d344ec0a732ab4ee204215b31de69cf4be72e3bf/assets/js/phoenix/presence.js
  License: https://github.com/phoenixframework/phoenix/blob/d344ec0a732ab4ee204215b31de69cf4be72e3bf/LICENSE.md
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "REALTIME_PRESENCE_LISTEN_EVENTS", ()=>REALTIME_PRESENCE_LISTEN_EVENTS);
var REALTIME_PRESENCE_LISTEN_EVENTS;
(function(REALTIME_PRESENCE_LISTEN_EVENTS) {
    REALTIME_PRESENCE_LISTEN_EVENTS["SYNC"] = "sync";
    REALTIME_PRESENCE_LISTEN_EVENTS["JOIN"] = "join";
    REALTIME_PRESENCE_LISTEN_EVENTS["LEAVE"] = "leave";
})(REALTIME_PRESENCE_LISTEN_EVENTS || (REALTIME_PRESENCE_LISTEN_EVENTS = {}));
class RealtimePresence {
    /**
     * Initializes the Presence.
     *
     * @param channel - The RealtimeChannel
     * @param opts - The options,
     *        for example `{events: {state: 'state', diff: 'diff'}}`
     */ constructor(channel, opts){
        this.channel = channel;
        this.state = {};
        this.pendingDiffs = [];
        this.joinRef = null;
        this.caller = {
            onJoin: ()=>{},
            onLeave: ()=>{},
            onSync: ()=>{}
        };
        const events = (opts === null || opts === void 0 ? void 0 : opts.events) || {
            state: "presence_state",
            diff: "presence_diff"
        };
        this.channel._on(events.state, {}, (newState)=>{
            const { onJoin, onLeave, onSync } = this.caller;
            this.joinRef = this.channel._joinRef();
            this.state = RealtimePresence.syncState(this.state, newState, onJoin, onLeave);
            this.pendingDiffs.forEach((diff)=>{
                this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);
            });
            this.pendingDiffs = [];
            onSync();
        });
        this.channel._on(events.diff, {}, (diff)=>{
            const { onJoin, onLeave, onSync } = this.caller;
            if (this.inPendingSyncState()) this.pendingDiffs.push(diff);
            else {
                this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);
                onSync();
            }
        });
        this.onJoin((key, currentPresences, newPresences)=>{
            this.channel._trigger("presence", {
                event: "join",
                key,
                currentPresences,
                newPresences
            });
        });
        this.onLeave((key, currentPresences, leftPresences)=>{
            this.channel._trigger("presence", {
                event: "leave",
                key,
                currentPresences,
                leftPresences
            });
        });
        this.onSync(()=>{
            this.channel._trigger("presence", {
                event: "sync"
            });
        });
    }
    /**
     * Used to sync the list of presences on the server with the
     * client's state.
     *
     * An optional `onJoin` and `onLeave` callback can be provided to
     * react to changes in the client's local presences across
     * disconnects and reconnects with the server.
     *
     * @internal
     */ static syncState(currentState, newState, onJoin, onLeave) {
        const state = this.cloneDeep(currentState);
        const transformedState = this.transformState(newState);
        const joins = {};
        const leaves = {};
        this.map(state, (key, presences)=>{
            if (!transformedState[key]) leaves[key] = presences;
        });
        this.map(transformedState, (key, newPresences)=>{
            const currentPresences = state[key];
            if (currentPresences) {
                const newPresenceRefs = newPresences.map((m)=>m.presence_ref);
                const curPresenceRefs = currentPresences.map((m)=>m.presence_ref);
                const joinedPresences = newPresences.filter((m)=>curPresenceRefs.indexOf(m.presence_ref) < 0);
                const leftPresences = currentPresences.filter((m)=>newPresenceRefs.indexOf(m.presence_ref) < 0);
                if (joinedPresences.length > 0) joins[key] = joinedPresences;
                if (leftPresences.length > 0) leaves[key] = leftPresences;
            } else joins[key] = newPresences;
        });
        return this.syncDiff(state, {
            joins,
            leaves
        }, onJoin, onLeave);
    }
    /**
     * Used to sync a diff of presence join and leave events from the
     * server, as they happen.
     *
     * Like `syncState`, `syncDiff` accepts optional `onJoin` and
     * `onLeave` callbacks to react to a user joining or leaving from a
     * device.
     *
     * @internal
     */ static syncDiff(state, diff, onJoin, onLeave) {
        const { joins, leaves } = {
            joins: this.transformState(diff.joins),
            leaves: this.transformState(diff.leaves)
        };
        if (!onJoin) onJoin = ()=>{};
        if (!onLeave) onLeave = ()=>{};
        this.map(joins, (key, newPresences)=>{
            var _a;
            const currentPresences = (_a = state[key]) !== null && _a !== void 0 ? _a : [];
            state[key] = this.cloneDeep(newPresences);
            if (currentPresences.length > 0) {
                const joinedPresenceRefs = state[key].map((m)=>m.presence_ref);
                const curPresences = currentPresences.filter((m)=>joinedPresenceRefs.indexOf(m.presence_ref) < 0);
                state[key].unshift(...curPresences);
            }
            onJoin(key, currentPresences, newPresences);
        });
        this.map(leaves, (key, leftPresences)=>{
            let currentPresences = state[key];
            if (!currentPresences) return;
            const presenceRefsToRemove = leftPresences.map((m)=>m.presence_ref);
            currentPresences = currentPresences.filter((m)=>presenceRefsToRemove.indexOf(m.presence_ref) < 0);
            state[key] = currentPresences;
            onLeave(key, currentPresences, leftPresences);
            if (currentPresences.length === 0) delete state[key];
        });
        return state;
    }
    /** @internal */ static map(obj, func) {
        return Object.getOwnPropertyNames(obj).map((key)=>func(key, obj[key]));
    }
    /**
     * Remove 'metas' key
     * Change 'phx_ref' to 'presence_ref'
     * Remove 'phx_ref' and 'phx_ref_prev'
     *
     * @example
     * // returns {
     *  abc123: [
     *    { presence_ref: '2', user_id: 1 },
     *    { presence_ref: '3', user_id: 2 }
     *  ]
     * }
     * RealtimePresence.transformState({
     *  abc123: {
     *    metas: [
     *      { phx_ref: '2', phx_ref_prev: '1' user_id: 1 },
     *      { phx_ref: '3', user_id: 2 }
     *    ]
     *  }
     * })
     *
     * @internal
     */ static transformState(state) {
        state = this.cloneDeep(state);
        return Object.getOwnPropertyNames(state).reduce((newState, key)=>{
            const presences = state[key];
            if ("metas" in presences) newState[key] = presences.metas.map((presence)=>{
                presence["presence_ref"] = presence["phx_ref"];
                delete presence["phx_ref"];
                delete presence["phx_ref_prev"];
                return presence;
            });
            else newState[key] = presences;
            return newState;
        }, {});
    }
    /** @internal */ static cloneDeep(obj) {
        return JSON.parse(JSON.stringify(obj));
    }
    /** @internal */ onJoin(callback) {
        this.caller.onJoin = callback;
    }
    /** @internal */ onLeave(callback) {
        this.caller.onLeave = callback;
    }
    /** @internal */ onSync(callback) {
        this.caller.onSync = callback;
    }
    /** @internal */ inPendingSyncState() {
        return !this.joinRef || this.joinRef !== this.channel._joinRef();
    }
}
exports.default = RealtimePresence;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"41dP3":[function(require,module,exports) {
module.exports = require("b746677036fd662d")(require("eceffa85477377fb").getBundleURL("gL9HQ") + "../../browser.101b828b.js" + "?" + Date.now()).catch((err)=>{
    delete module.bundle.cache[module.id];
    throw err;
}).then(()=>module.bundle.root("boRQ9"));

},{"b746677036fd662d":"9Ufja","eceffa85477377fb":"4lLQs"}],"fyr3A":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "StorageClient", ()=>(0, _storageClient.StorageClient));
var _storageClient = require("./StorageClient");
var _types = require("./lib/types");
parcelHelpers.exportAll(_types, exports);
var _errors = require("./lib/errors");
parcelHelpers.exportAll(_errors, exports);

},{"./StorageClient":"2Mm83","./lib/types":"4w9CV","./lib/errors":"gZo2B","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"2Mm83":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "StorageClient", ()=>StorageClient);
var _storageFileApi = require("./packages/StorageFileApi");
var _storageFileApiDefault = parcelHelpers.interopDefault(_storageFileApi);
var _storageBucketApi = require("./packages/StorageBucketApi");
var _storageBucketApiDefault = parcelHelpers.interopDefault(_storageBucketApi);
class StorageClient extends (0, _storageBucketApiDefault.default) {
    constructor(url, headers = {}, fetch){
        super(url, headers, fetch);
    }
    /**
     * Perform file operation in a bucket.
     *
     * @param id The bucket id to operate on.
     */ from(id) {
        return new (0, _storageFileApiDefault.default)(this.url, this.headers, id, this.fetch);
    }
}

},{"./packages/StorageFileApi":"kE682","./packages/StorageBucketApi":"irtTV","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"kE682":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _errors = require("../lib/errors");
var _fetch = require("../lib/fetch");
var _helpers = require("../lib/helpers");
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const DEFAULT_SEARCH_OPTIONS = {
    limit: 100,
    offset: 0,
    sortBy: {
        column: "name",
        order: "asc"
    }
};
const DEFAULT_FILE_OPTIONS = {
    cacheControl: "3600",
    contentType: "text/plain;charset=UTF-8",
    upsert: false
};
class StorageFileApi {
    constructor(url, headers = {}, bucketId, fetch){
        this.url = url;
        this.headers = headers;
        this.bucketId = bucketId;
        this.fetch = (0, _helpers.resolveFetch)(fetch);
    }
    /**
     * Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.
     *
     * @param method HTTP method.
     * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
     * @param fileBody The body of the file to be stored in the bucket.
     */ uploadOrUpdate(method, path, fileBody, fileOptions) {
        return __awaiter(this, void 0, void 0, function*() {
            try {
                let body;
                const options = Object.assign(Object.assign({}, DEFAULT_FILE_OPTIONS), fileOptions);
                const headers = Object.assign(Object.assign({}, this.headers), method === "POST" && {
                    "x-upsert": String(options.upsert)
                });
                if (typeof Blob !== "undefined" && fileBody instanceof Blob) {
                    body = new FormData();
                    body.append("cacheControl", options.cacheControl);
                    body.append("", fileBody);
                } else if (typeof FormData !== "undefined" && fileBody instanceof FormData) {
                    body = fileBody;
                    body.append("cacheControl", options.cacheControl);
                } else {
                    body = fileBody;
                    headers["cache-control"] = `max-age=${options.cacheControl}`;
                    headers["content-type"] = options.contentType;
                }
                const cleanPath = this._removeEmptyFolders(path);
                const _path = this._getFinalPath(cleanPath);
                const res = yield this.fetch(`${this.url}/object/${_path}`, Object.assign({
                    method,
                    body: body,
                    headers
                }, (options === null || options === void 0 ? void 0 : options.duplex) ? {
                    duplex: options.duplex
                } : {}));
                const data = yield res.json();
                if (res.ok) return {
                    data: {
                        path: cleanPath,
                        id: data.Id,
                        fullPath: data.Key
                    },
                    error: null
                };
                else {
                    const error = data;
                    return {
                        data: null,
                        error
                    };
                }
            } catch (error) {
                if ((0, _errors.isStorageError)(error)) return {
                    data: null,
                    error
                };
                throw error;
            }
        });
    }
    /**
     * Uploads a file to an existing bucket.
     *
     * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
     * @param fileBody The body of the file to be stored in the bucket.
     */ upload(path, fileBody, fileOptions) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.uploadOrUpdate("POST", path, fileBody, fileOptions);
        });
    }
    /**
     * Upload a file with a token generated from `createSignedUploadUrl`.
     * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
     * @param token The token generated from `createSignedUploadUrl`
     * @param fileBody The body of the file to be stored in the bucket.
     */ uploadToSignedUrl(path, token, fileBody, fileOptions) {
        return __awaiter(this, void 0, void 0, function*() {
            const cleanPath = this._removeEmptyFolders(path);
            const _path = this._getFinalPath(cleanPath);
            const url = new URL(this.url + `/object/upload/sign/${_path}`);
            url.searchParams.set("token", token);
            try {
                let body;
                const options = Object.assign({
                    upsert: DEFAULT_FILE_OPTIONS.upsert
                }, fileOptions);
                const headers = Object.assign(Object.assign({}, this.headers), {
                    "x-upsert": String(options.upsert)
                });
                if (typeof Blob !== "undefined" && fileBody instanceof Blob) {
                    body = new FormData();
                    body.append("cacheControl", options.cacheControl);
                    body.append("", fileBody);
                } else if (typeof FormData !== "undefined" && fileBody instanceof FormData) {
                    body = fileBody;
                    body.append("cacheControl", options.cacheControl);
                } else {
                    body = fileBody;
                    headers["cache-control"] = `max-age=${options.cacheControl}`;
                    headers["content-type"] = options.contentType;
                }
                const res = yield this.fetch(url.toString(), {
                    method: "PUT",
                    body: body,
                    headers
                });
                const data = yield res.json();
                if (res.ok) return {
                    data: {
                        path: cleanPath,
                        fullPath: data.Key
                    },
                    error: null
                };
                else {
                    const error = data;
                    return {
                        data: null,
                        error
                    };
                }
            } catch (error) {
                if ((0, _errors.isStorageError)(error)) return {
                    data: null,
                    error
                };
                throw error;
            }
        });
    }
    /**
     * Creates a signed upload URL.
     * Signed upload URLs can be used to upload files to the bucket without further authentication.
     * They are valid for 2 hours.
     * @param path The file path, including the current file name. For example `folder/image.png`.
     * @param options.upsert If set to true, allows the file to be overwritten if it already exists.
     */ createSignedUploadUrl(path, options) {
        return __awaiter(this, void 0, void 0, function*() {
            try {
                let _path = this._getFinalPath(path);
                const headers = Object.assign({}, this.headers);
                if (options === null || options === void 0 ? void 0 : options.upsert) headers["x-upsert"] = "true";
                const data = yield (0, _fetch.post)(this.fetch, `${this.url}/object/upload/sign/${_path}`, {}, {
                    headers
                });
                const url = new URL(this.url + data.url);
                const token = url.searchParams.get("token");
                if (!token) throw new (0, _errors.StorageError)("No token returned by API");
                return {
                    data: {
                        signedUrl: url.toString(),
                        path,
                        token
                    },
                    error: null
                };
            } catch (error) {
                if ((0, _errors.isStorageError)(error)) return {
                    data: null,
                    error
                };
                throw error;
            }
        });
    }
    /**
     * Replaces an existing file at the specified path with a new one.
     *
     * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to update.
     * @param fileBody The body of the file to be stored in the bucket.
     */ update(path, fileBody, fileOptions) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.uploadOrUpdate("PUT", path, fileBody, fileOptions);
        });
    }
    /**
     * Moves an existing file to a new path in the same bucket.
     *
     * @param fromPath The original file path, including the current file name. For example `folder/image.png`.
     * @param toPath The new file path, including the new file name. For example `folder/image-new.png`.
     * @param options The destination options.
     */ move(fromPath, toPath, options) {
        return __awaiter(this, void 0, void 0, function*() {
            try {
                const data = yield (0, _fetch.post)(this.fetch, `${this.url}/object/move`, {
                    bucketId: this.bucketId,
                    sourceKey: fromPath,
                    destinationKey: toPath,
                    destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket
                }, {
                    headers: this.headers
                });
                return {
                    data,
                    error: null
                };
            } catch (error) {
                if ((0, _errors.isStorageError)(error)) return {
                    data: null,
                    error
                };
                throw error;
            }
        });
    }
    /**
     * Copies an existing file to a new path in the same bucket.
     *
     * @param fromPath The original file path, including the current file name. For example `folder/image.png`.
     * @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.
     * @param options The destination options.
     */ copy(fromPath, toPath, options) {
        return __awaiter(this, void 0, void 0, function*() {
            try {
                const data = yield (0, _fetch.post)(this.fetch, `${this.url}/object/copy`, {
                    bucketId: this.bucketId,
                    sourceKey: fromPath,
                    destinationKey: toPath,
                    destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket
                }, {
                    headers: this.headers
                });
                return {
                    data: {
                        path: data.Key
                    },
                    error: null
                };
            } catch (error) {
                if ((0, _errors.isStorageError)(error)) return {
                    data: null,
                    error
                };
                throw error;
            }
        });
    }
    /**
     * Creates a signed URL. Use a signed URL to share a file for a fixed amount of time.
     *
     * @param path The file path, including the current file name. For example `folder/image.png`.
     * @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.
     * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
     * @param options.transform Transform the asset before serving it to the client.
     */ createSignedUrl(path, expiresIn, options) {
        return __awaiter(this, void 0, void 0, function*() {
            try {
                let _path = this._getFinalPath(path);
                let data = yield (0, _fetch.post)(this.fetch, `${this.url}/object/sign/${_path}`, Object.assign({
                    expiresIn
                }, (options === null || options === void 0 ? void 0 : options.transform) ? {
                    transform: options.transform
                } : {}), {
                    headers: this.headers
                });
                const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? "" : options.download}` : "";
                const signedUrl = encodeURI(`${this.url}${data.signedURL}${downloadQueryParam}`);
                data = {
                    signedUrl
                };
                return {
                    data,
                    error: null
                };
            } catch (error) {
                if ((0, _errors.isStorageError)(error)) return {
                    data: null,
                    error
                };
                throw error;
            }
        });
    }
    /**
     * Creates multiple signed URLs. Use a signed URL to share a file for a fixed amount of time.
     *
     * @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.
     * @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.
     * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
     */ createSignedUrls(paths, expiresIn, options) {
        return __awaiter(this, void 0, void 0, function*() {
            try {
                const data = yield (0, _fetch.post)(this.fetch, `${this.url}/object/sign/${this.bucketId}`, {
                    expiresIn,
                    paths
                }, {
                    headers: this.headers
                });
                const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? "" : options.download}` : "";
                return {
                    data: data.map((datum)=>Object.assign(Object.assign({}, datum), {
                            signedUrl: datum.signedURL ? encodeURI(`${this.url}${datum.signedURL}${downloadQueryParam}`) : null
                        })),
                    error: null
                };
            } catch (error) {
                if ((0, _errors.isStorageError)(error)) return {
                    data: null,
                    error
                };
                throw error;
            }
        });
    }
    /**
     * Downloads a file from a private bucket. For public buckets, make a request to the URL returned from `getPublicUrl` instead.
     *
     * @param path The full path and file name of the file to be downloaded. For example `folder/image.png`.
     * @param options.transform Transform the asset before serving it to the client.
     */ download(path, options) {
        return __awaiter(this, void 0, void 0, function*() {
            const wantsTransformation = typeof (options === null || options === void 0 ? void 0 : options.transform) !== "undefined";
            const renderPath = wantsTransformation ? "render/image/authenticated" : "object";
            const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});
            const queryString = transformationQuery ? `?${transformationQuery}` : "";
            try {
                const _path = this._getFinalPath(path);
                const res = yield (0, _fetch.get)(this.fetch, `${this.url}/${renderPath}/${_path}${queryString}`, {
                    headers: this.headers,
                    noResolveJson: true
                });
                const data = yield res.blob();
                return {
                    data,
                    error: null
                };
            } catch (error) {
                if ((0, _errors.isStorageError)(error)) return {
                    data: null,
                    error
                };
                throw error;
            }
        });
    }
    /**
     * A simple convenience function to get the URL for an asset in a public bucket. If you do not want to use this function, you can construct the public URL by concatenating the bucket URL with the path to the asset.
     * This function does not verify if the bucket is public. If a public URL is created for a bucket which is not public, you will not be able to download the asset.
     *
     * @param path The path and name of the file to generate the public URL for. For example `folder/image.png`.
     * @param options.download Triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
     * @param options.transform Transform the asset before serving it to the client.
     */ getPublicUrl(path, options) {
        const _path = this._getFinalPath(path);
        const _queryString = [];
        const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `download=${options.download === true ? "" : options.download}` : "";
        if (downloadQueryParam !== "") _queryString.push(downloadQueryParam);
        const wantsTransformation = typeof (options === null || options === void 0 ? void 0 : options.transform) !== "undefined";
        const renderPath = wantsTransformation ? "render/image" : "object";
        const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});
        if (transformationQuery !== "") _queryString.push(transformationQuery);
        let queryString = _queryString.join("&");
        if (queryString !== "") queryString = `?${queryString}`;
        return {
            data: {
                publicUrl: encodeURI(`${this.url}/${renderPath}/public/${_path}${queryString}`)
            }
        };
    }
    /**
     * Deletes files within the same bucket
     *
     * @param paths An array of files to delete, including the path and file name. For example [`'folder/image.png'`].
     */ remove(paths) {
        return __awaiter(this, void 0, void 0, function*() {
            try {
                const data = yield (0, _fetch.remove)(this.fetch, `${this.url}/object/${this.bucketId}`, {
                    prefixes: paths
                }, {
                    headers: this.headers
                });
                return {
                    data,
                    error: null
                };
            } catch (error) {
                if ((0, _errors.isStorageError)(error)) return {
                    data: null,
                    error
                };
                throw error;
            }
        });
    }
    /**
     * Get file metadata
     * @param id the file id to retrieve metadata
     */ // async getMetadata(
    //   id: string
    // ): Promise<
    //   | {
    //       data: Metadata
    //       error: null
    //     }
    //   | {
    //       data: null
    //       error: StorageError
    //     }
    // > {
    //   try {
    //     const data = await get(this.fetch, `${this.url}/metadata/${id}`, { headers: this.headers })
    //     return { data, error: null }
    //   } catch (error) {
    //     if (isStorageError(error)) {
    //       return { data: null, error }
    //     }
    //     throw error
    //   }
    // }
    /**
     * Update file metadata
     * @param id the file id to update metadata
     * @param meta the new file metadata
     */ // async updateMetadata(
    //   id: string,
    //   meta: Metadata
    // ): Promise<
    //   | {
    //       data: Metadata
    //       error: null
    //     }
    //   | {
    //       data: null
    //       error: StorageError
    //     }
    // > {
    //   try {
    //     const data = await post(
    //       this.fetch,
    //       `${this.url}/metadata/${id}`,
    //       { ...meta },
    //       { headers: this.headers }
    //     )
    //     return { data, error: null }
    //   } catch (error) {
    //     if (isStorageError(error)) {
    //       return { data: null, error }
    //     }
    //     throw error
    //   }
    // }
    /**
     * Lists all the files within a bucket.
     * @param path The folder path.
     */ list(path, options, parameters) {
        return __awaiter(this, void 0, void 0, function*() {
            try {
                const body = Object.assign(Object.assign(Object.assign({}, DEFAULT_SEARCH_OPTIONS), options), {
                    prefix: path || ""
                });
                const data = yield (0, _fetch.post)(this.fetch, `${this.url}/object/list/${this.bucketId}`, body, {
                    headers: this.headers
                }, parameters);
                return {
                    data,
                    error: null
                };
            } catch (error) {
                if ((0, _errors.isStorageError)(error)) return {
                    data: null,
                    error
                };
                throw error;
            }
        });
    }
    _getFinalPath(path) {
        return `${this.bucketId}/${path}`;
    }
    _removeEmptyFolders(path) {
        return path.replace(/^\/|\/$/g, "").replace(/\/+/g, "/");
    }
    transformOptsToQueryString(transform) {
        const params = [];
        if (transform.width) params.push(`width=${transform.width}`);
        if (transform.height) params.push(`height=${transform.height}`);
        if (transform.resize) params.push(`resize=${transform.resize}`);
        if (transform.format) params.push(`format=${transform.format}`);
        if (transform.quality) params.push(`quality=${transform.quality}`);
        return params.join("&");
    }
}
exports.default = StorageFileApi;

},{"../lib/errors":"gZo2B","../lib/fetch":"9GQQr","../lib/helpers":"2SkIv","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"gZo2B":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "StorageError", ()=>StorageError);
parcelHelpers.export(exports, "isStorageError", ()=>isStorageError);
parcelHelpers.export(exports, "StorageApiError", ()=>StorageApiError);
parcelHelpers.export(exports, "StorageUnknownError", ()=>StorageUnknownError);
class StorageError extends Error {
    constructor(message){
        super(message);
        this.__isStorageError = true;
        this.name = "StorageError";
    }
}
function isStorageError(error) {
    return typeof error === "object" && error !== null && "__isStorageError" in error;
}
class StorageApiError extends StorageError {
    constructor(message, status){
        super(message);
        this.name = "StorageApiError";
        this.status = status;
    }
    toJSON() {
        return {
            name: this.name,
            message: this.message,
            status: this.status
        };
    }
}
class StorageUnknownError extends StorageError {
    constructor(message, originalError){
        super(message);
        this.name = "StorageUnknownError";
        this.originalError = originalError;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"9GQQr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "get", ()=>get);
parcelHelpers.export(exports, "post", ()=>post);
parcelHelpers.export(exports, "put", ()=>put);
parcelHelpers.export(exports, "remove", ()=>remove);
var _errors = require("./errors");
var _helpers = require("./helpers");
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const _getErrorMessage = (err)=>err.msg || err.message || err.error_description || err.error || JSON.stringify(err);
const handleError = (error, reject)=>__awaiter(void 0, void 0, void 0, function*() {
        const Res = yield (0, _helpers.resolveResponse)();
        if (error instanceof Res) error.json().then((err)=>{
            reject(new (0, _errors.StorageApiError)(_getErrorMessage(err), error.status || 500));
        }).catch((err)=>{
            reject(new (0, _errors.StorageUnknownError)(_getErrorMessage(err), err));
        });
        else reject(new (0, _errors.StorageUnknownError)(_getErrorMessage(error), error));
    });
const _getRequestParams = (method, options, parameters, body)=>{
    const params = {
        method,
        headers: (options === null || options === void 0 ? void 0 : options.headers) || {}
    };
    if (method === "GET") return params;
    params.headers = Object.assign({
        "Content-Type": "application/json"
    }, options === null || options === void 0 ? void 0 : options.headers);
    params.body = JSON.stringify(body);
    return Object.assign(Object.assign({}, params), parameters);
};
function _handleRequest(fetcher, method, url, options, parameters, body) {
    return __awaiter(this, void 0, void 0, function*() {
        return new Promise((resolve, reject)=>{
            fetcher(url, _getRequestParams(method, options, parameters, body)).then((result)=>{
                if (!result.ok) throw result;
                if (options === null || options === void 0 ? void 0 : options.noResolveJson) return result;
                return result.json();
            }).then((data)=>resolve(data)).catch((error)=>handleError(error, reject));
        });
    });
}
function get(fetcher, url, options, parameters) {
    return __awaiter(this, void 0, void 0, function*() {
        return _handleRequest(fetcher, "GET", url, options, parameters);
    });
}
function post(fetcher, url, body, options, parameters) {
    return __awaiter(this, void 0, void 0, function*() {
        return _handleRequest(fetcher, "POST", url, options, parameters, body);
    });
}
function put(fetcher, url, body, options, parameters) {
    return __awaiter(this, void 0, void 0, function*() {
        return _handleRequest(fetcher, "PUT", url, options, parameters, body);
    });
}
function remove(fetcher, url, body, options, parameters) {
    return __awaiter(this, void 0, void 0, function*() {
        return _handleRequest(fetcher, "DELETE", url, options, parameters, body);
    });
}

},{"./errors":"gZo2B","./helpers":"2SkIv","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"2SkIv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "resolveFetch", ()=>resolveFetch);
parcelHelpers.export(exports, "resolveResponse", ()=>resolveResponse);
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const resolveFetch = (customFetch)=>{
    let _fetch;
    if (customFetch) _fetch = customFetch;
    else if (typeof fetch === "undefined") _fetch = (...args)=>require("d0262cf6b6e3064e").then(({ default: fetch1 })=>fetch1(...args));
    else _fetch = fetch;
    return (...args)=>_fetch(...args);
};
const resolveResponse = ()=>__awaiter(void 0, void 0, void 0, function*() {
        if (typeof Response === "undefined") // @ts-ignore
        return (yield require("d0262cf6b6e3064e")).Response;
        return Response;
    });

},{"d0262cf6b6e3064e":"cRjRL","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"irtTV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _constants = require("../lib/constants");
var _errors = require("../lib/errors");
var _fetch = require("../lib/fetch");
var _helpers = require("../lib/helpers");
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class StorageBucketApi {
    constructor(url, headers = {}, fetch){
        this.url = url;
        this.headers = Object.assign(Object.assign({}, (0, _constants.DEFAULT_HEADERS)), headers);
        this.fetch = (0, _helpers.resolveFetch)(fetch);
    }
    /**
     * Retrieves the details of all Storage buckets within an existing project.
     */ listBuckets() {
        return __awaiter(this, void 0, void 0, function*() {
            try {
                const data = yield (0, _fetch.get)(this.fetch, `${this.url}/bucket`, {
                    headers: this.headers
                });
                return {
                    data,
                    error: null
                };
            } catch (error) {
                if ((0, _errors.isStorageError)(error)) return {
                    data: null,
                    error
                };
                throw error;
            }
        });
    }
    /**
     * Retrieves the details of an existing Storage bucket.
     *
     * @param id The unique identifier of the bucket you would like to retrieve.
     */ getBucket(id) {
        return __awaiter(this, void 0, void 0, function*() {
            try {
                const data = yield (0, _fetch.get)(this.fetch, `${this.url}/bucket/${id}`, {
                    headers: this.headers
                });
                return {
                    data,
                    error: null
                };
            } catch (error) {
                if ((0, _errors.isStorageError)(error)) return {
                    data: null,
                    error
                };
                throw error;
            }
        });
    }
    /**
     * Creates a new Storage bucket
     *
     * @param id A unique identifier for the bucket you are creating.
     * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations. By default, buckets are private.
     * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.
     * The global file size limit takes precedence over this value.
     * The default value is null, which doesn't set a per bucket file size limit.
     * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.
     * The default value is null, which allows files with all mime types to be uploaded.
     * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.
     * @returns newly created bucket id
     */ createBucket(id, options = {
        public: false
    }) {
        return __awaiter(this, void 0, void 0, function*() {
            try {
                const data = yield (0, _fetch.post)(this.fetch, `${this.url}/bucket`, {
                    id,
                    name: id,
                    public: options.public,
                    file_size_limit: options.fileSizeLimit,
                    allowed_mime_types: options.allowedMimeTypes
                }, {
                    headers: this.headers
                });
                return {
                    data,
                    error: null
                };
            } catch (error) {
                if ((0, _errors.isStorageError)(error)) return {
                    data: null,
                    error
                };
                throw error;
            }
        });
    }
    /**
     * Updates a Storage bucket
     *
     * @param id A unique identifier for the bucket you are updating.
     * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations.
     * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.
     * The global file size limit takes precedence over this value.
     * The default value is null, which doesn't set a per bucket file size limit.
     * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.
     * The default value is null, which allows files with all mime types to be uploaded.
     * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.
     */ updateBucket(id, options) {
        return __awaiter(this, void 0, void 0, function*() {
            try {
                const data = yield (0, _fetch.put)(this.fetch, `${this.url}/bucket/${id}`, {
                    id,
                    name: id,
                    public: options.public,
                    file_size_limit: options.fileSizeLimit,
                    allowed_mime_types: options.allowedMimeTypes
                }, {
                    headers: this.headers
                });
                return {
                    data,
                    error: null
                };
            } catch (error) {
                if ((0, _errors.isStorageError)(error)) return {
                    data: null,
                    error
                };
                throw error;
            }
        });
    }
    /**
     * Removes all objects inside a single bucket.
     *
     * @param id The unique identifier of the bucket you would like to empty.
     */ emptyBucket(id) {
        return __awaiter(this, void 0, void 0, function*() {
            try {
                const data = yield (0, _fetch.post)(this.fetch, `${this.url}/bucket/${id}/empty`, {}, {
                    headers: this.headers
                });
                return {
                    data,
                    error: null
                };
            } catch (error) {
                if ((0, _errors.isStorageError)(error)) return {
                    data: null,
                    error
                };
                throw error;
            }
        });
    }
    /**
     * Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.
     * You must first `empty()` the bucket.
     *
     * @param id The unique identifier of the bucket you would like to delete.
     */ deleteBucket(id) {
        return __awaiter(this, void 0, void 0, function*() {
            try {
                const data = yield (0, _fetch.remove)(this.fetch, `${this.url}/bucket/${id}`, {}, {
                    headers: this.headers
                });
                return {
                    data,
                    error: null
                };
            } catch (error) {
                if ((0, _errors.isStorageError)(error)) return {
                    data: null,
                    error
                };
                throw error;
            }
        });
    }
}
exports.default = StorageBucketApi;

},{"../lib/constants":"gGBVF","../lib/errors":"gZo2B","../lib/fetch":"9GQQr","../lib/helpers":"2SkIv","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"gGBVF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DEFAULT_HEADERS", ()=>DEFAULT_HEADERS);
var _version = require("./version");
const DEFAULT_HEADERS = {
    "X-Client-Info": `storage-js/${(0, _version.version)}`
};

},{"./version":"eQqv0","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"eQqv0":[function(require,module,exports) {
// generated by genversion
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "2.6.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"4w9CV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"f1CLa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DEFAULT_HEADERS", ()=>DEFAULT_HEADERS);
parcelHelpers.export(exports, "DEFAULT_GLOBAL_OPTIONS", ()=>DEFAULT_GLOBAL_OPTIONS);
parcelHelpers.export(exports, "DEFAULT_DB_OPTIONS", ()=>DEFAULT_DB_OPTIONS);
parcelHelpers.export(exports, "DEFAULT_AUTH_OPTIONS", ()=>DEFAULT_AUTH_OPTIONS);
parcelHelpers.export(exports, "DEFAULT_REALTIME_OPTIONS", ()=>DEFAULT_REALTIME_OPTIONS);
var _version = require("./version");
let JS_ENV = "";
// @ts-ignore
if (typeof Deno !== "undefined") JS_ENV = "deno";
else if (typeof document !== "undefined") JS_ENV = "web";
else if (typeof navigator !== "undefined" && navigator.product === "ReactNative") JS_ENV = "react-native";
else JS_ENV = "node";
const DEFAULT_HEADERS = {
    "X-Client-Info": `supabase-js-${JS_ENV}/${(0, _version.version)}`
};
const DEFAULT_GLOBAL_OPTIONS = {
    headers: DEFAULT_HEADERS
};
const DEFAULT_DB_OPTIONS = {
    schema: "public"
};
const DEFAULT_AUTH_OPTIONS = {
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: true,
    flowType: "implicit"
};
const DEFAULT_REALTIME_OPTIONS = {};

},{"./version":"d6OnP","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"d6OnP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "2.44.4";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"9LQK3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "resolveFetch", ()=>resolveFetch);
parcelHelpers.export(exports, "resolveHeadersConstructor", ()=>resolveHeadersConstructor);
parcelHelpers.export(exports, "fetchWithAuth", ()=>fetchWithAuth);
// @ts-ignore
var _nodeFetch = require("@supabase/node-fetch");
var _nodeFetchDefault = parcelHelpers.interopDefault(_nodeFetch);
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const resolveFetch = (customFetch)=>{
    let _fetch;
    if (customFetch) _fetch = customFetch;
    else if (typeof fetch === "undefined") _fetch = (0, _nodeFetchDefault.default);
    else _fetch = fetch;
    return (...args)=>_fetch(...args);
};
const resolveHeadersConstructor = ()=>{
    if (typeof Headers === "undefined") return 0, _nodeFetch.Headers;
    return Headers;
};
const fetchWithAuth = (supabaseKey, getAccessToken, customFetch)=>{
    const fetch1 = resolveFetch(customFetch);
    const HeadersConstructor = resolveHeadersConstructor();
    return (input, init)=>__awaiter(void 0, void 0, void 0, function*() {
            var _a;
            const accessToken = (_a = yield getAccessToken()) !== null && _a !== void 0 ? _a : supabaseKey;
            let headers = new HeadersConstructor(init === null || init === void 0 ? void 0 : init.headers);
            if (!headers.has("apikey")) headers.set("apikey", supabaseKey);
            if (!headers.has("Authorization")) headers.set("Authorization", `Bearer ${accessToken}`);
            return fetch1(input, Object.assign(Object.assign({}, init), {
                headers
            }));
        });
};

},{"@supabase/node-fetch":"1YN43","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"feZlB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "uuid", ()=>uuid);
parcelHelpers.export(exports, "stripTrailingSlash", ()=>stripTrailingSlash);
parcelHelpers.export(exports, "isBrowser", ()=>isBrowser);
parcelHelpers.export(exports, "applySettingDefaults", ()=>applySettingDefaults);
function uuid() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
        var r = Math.random() * 16 | 0, v = c == "x" ? r : r & 0x3 | 0x8;
        return v.toString(16);
    });
}
function stripTrailingSlash(url) {
    return url.replace(/\/$/, "");
}
const isBrowser = ()=>typeof window !== "undefined";
function applySettingDefaults(options, defaults) {
    const { db: dbOptions, auth: authOptions, realtime: realtimeOptions, global: globalOptions } = options;
    const { db: DEFAULT_DB_OPTIONS, auth: DEFAULT_AUTH_OPTIONS, realtime: DEFAULT_REALTIME_OPTIONS, global: DEFAULT_GLOBAL_OPTIONS } = defaults;
    return {
        db: Object.assign(Object.assign({}, DEFAULT_DB_OPTIONS), dbOptions),
        auth: Object.assign(Object.assign({}, DEFAULT_AUTH_OPTIONS), authOptions),
        realtime: Object.assign(Object.assign({}, DEFAULT_REALTIME_OPTIONS), realtimeOptions),
        global: Object.assign(Object.assign({}, DEFAULT_GLOBAL_OPTIONS), globalOptions)
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"eSfHx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SupabaseAuthClient", ()=>SupabaseAuthClient);
var _authJs = require("@supabase/auth-js");
class SupabaseAuthClient extends (0, _authJs.AuthClient) {
    constructor(options){
        super(options);
    }
}

},{"@supabase/auth-js":"ihxme","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"ihxme":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "navigatorLock", ()=>(0, _locks.navigatorLock));
parcelHelpers.export(exports, "NavigatorLockAcquireTimeoutError", ()=>(0, _locks.NavigatorLockAcquireTimeoutError));
parcelHelpers.export(exports, "lockInternals", ()=>(0, _locks.internals));
parcelHelpers.export(exports, "GoTrueAdminApi", ()=>(0, _goTrueAdminApiDefault.default));
parcelHelpers.export(exports, "GoTrueClient", ()=>(0, _goTrueClientDefault.default));
parcelHelpers.export(exports, "AuthAdminApi", ()=>(0, _authAdminApiDefault.default));
parcelHelpers.export(exports, "AuthClient", ()=>(0, _authClientDefault.default));
var _goTrueAdminApi = require("./GoTrueAdminApi");
var _goTrueAdminApiDefault = parcelHelpers.interopDefault(_goTrueAdminApi);
var _goTrueClient = require("./GoTrueClient");
var _goTrueClientDefault = parcelHelpers.interopDefault(_goTrueClient);
var _authAdminApi = require("./AuthAdminApi");
var _authAdminApiDefault = parcelHelpers.interopDefault(_authAdminApi);
var _authClient = require("./AuthClient");
var _authClientDefault = parcelHelpers.interopDefault(_authClient);
var _types = require("./lib/types");
parcelHelpers.exportAll(_types, exports);
var _errors = require("./lib/errors");
parcelHelpers.exportAll(_errors, exports);
var _locks = require("./lib/locks");

},{"./GoTrueAdminApi":"21Azt","./GoTrueClient":"1GHqN","./AuthAdminApi":"220Qq","./AuthClient":"741DW","./lib/types":"goPpM","./lib/errors":"3HhMS","./lib/locks":"enUQ5","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"21Azt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _fetch = require("./lib/fetch");
var _helpers = require("./lib/helpers");
var _errors = require("./lib/errors");
var __rest = undefined && undefined.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") {
        for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
class GoTrueAdminApi {
    constructor({ url = "", headers = {}, fetch }){
        this.url = url;
        this.headers = headers;
        this.fetch = (0, _helpers.resolveFetch)(fetch);
        this.mfa = {
            listFactors: this._listFactors.bind(this),
            deleteFactor: this._deleteFactor.bind(this)
        };
    }
    /**
     * Removes a logged-in session.
     * @param jwt A valid, logged-in JWT.
     * @param scope The logout sope.
     */ async signOut(jwt, scope = "global") {
        try {
            await (0, _fetch._request)(this.fetch, "POST", `${this.url}/logout?scope=${scope}`, {
                headers: this.headers,
                jwt,
                noResolveJson: true
            });
            return {
                data: null,
                error: null
            };
        } catch (error) {
            if ((0, _errors.isAuthError)(error)) return {
                data: null,
                error
            };
            throw error;
        }
    }
    /**
     * Sends an invite link to an email address.
     * @param email The email address of the user.
     * @param options Additional options to be included when inviting.
     */ async inviteUserByEmail(email, options = {}) {
        try {
            return await (0, _fetch._request)(this.fetch, "POST", `${this.url}/invite`, {
                body: {
                    email,
                    data: options.data
                },
                headers: this.headers,
                redirectTo: options.redirectTo,
                xform: (0, _fetch._userResponse)
            });
        } catch (error) {
            if ((0, _errors.isAuthError)(error)) return {
                data: {
                    user: null
                },
                error
            };
            throw error;
        }
    }
    /**
     * Generates email links and OTPs to be sent via a custom email provider.
     * @param email The user's email.
     * @param options.password User password. For signup only.
     * @param options.data Optional user metadata. For signup only.
     * @param options.redirectTo The redirect url which should be appended to the generated link
     */ async generateLink(params) {
        try {
            const { options } = params, rest = __rest(params, [
                "options"
            ]);
            const body = Object.assign(Object.assign({}, rest), options);
            if ("newEmail" in rest) {
                // replace newEmail with new_email in request body
                body.new_email = rest === null || rest === void 0 ? void 0 : rest.newEmail;
                delete body["newEmail"];
            }
            return await (0, _fetch._request)(this.fetch, "POST", `${this.url}/admin/generate_link`, {
                body: body,
                headers: this.headers,
                xform: (0, _fetch._generateLinkResponse),
                redirectTo: options === null || options === void 0 ? void 0 : options.redirectTo
            });
        } catch (error) {
            if ((0, _errors.isAuthError)(error)) return {
                data: {
                    properties: null,
                    user: null
                },
                error
            };
            throw error;
        }
    }
    // User Admin API
    /**
     * Creates a new user.
     * This function should only be called on a server. Never expose your `service_role` key in the browser.
     */ async createUser(attributes) {
        try {
            return await (0, _fetch._request)(this.fetch, "POST", `${this.url}/admin/users`, {
                body: attributes,
                headers: this.headers,
                xform: (0, _fetch._userResponse)
            });
        } catch (error) {
            if ((0, _errors.isAuthError)(error)) return {
                data: {
                    user: null
                },
                error
            };
            throw error;
        }
    }
    /**
     * Get a list of users.
     *
     * This function should only be called on a server. Never expose your `service_role` key in the browser.
     * @param params An object which supports `page` and `perPage` as numbers, to alter the paginated results.
     */ async listUsers(params) {
        var _a, _b, _c, _d, _e, _f, _g;
        try {
            const pagination = {
                nextPage: null,
                lastPage: 0,
                total: 0
            };
            const response = await (0, _fetch._request)(this.fetch, "GET", `${this.url}/admin/users`, {
                headers: this.headers,
                noResolveJson: true,
                query: {
                    page: (_b = (_a = params === null || params === void 0 ? void 0 : params.page) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : "",
                    per_page: (_d = (_c = params === null || params === void 0 ? void 0 : params.perPage) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""
                },
                xform: (0, _fetch._noResolveJsonResponse)
            });
            if (response.error) throw response.error;
            const users = await response.json();
            const total = (_e = response.headers.get("x-total-count")) !== null && _e !== void 0 ? _e : 0;
            const links = (_g = (_f = response.headers.get("link")) === null || _f === void 0 ? void 0 : _f.split(",")) !== null && _g !== void 0 ? _g : [];
            if (links.length > 0) {
                links.forEach((link)=>{
                    const page = parseInt(link.split(";")[0].split("=")[1].substring(0, 1));
                    const rel = JSON.parse(link.split(";")[1].split("=")[1]);
                    pagination[`${rel}Page`] = page;
                });
                pagination.total = parseInt(total);
            }
            return {
                data: Object.assign(Object.assign({}, users), pagination),
                error: null
            };
        } catch (error) {
            if ((0, _errors.isAuthError)(error)) return {
                data: {
                    users: []
                },
                error
            };
            throw error;
        }
    }
    /**
     * Get user by id.
     *
     * @param uid The user's unique identifier
     *
     * This function should only be called on a server. Never expose your `service_role` key in the browser.
     */ async getUserById(uid) {
        try {
            return await (0, _fetch._request)(this.fetch, "GET", `${this.url}/admin/users/${uid}`, {
                headers: this.headers,
                xform: (0, _fetch._userResponse)
            });
        } catch (error) {
            if ((0, _errors.isAuthError)(error)) return {
                data: {
                    user: null
                },
                error
            };
            throw error;
        }
    }
    /**
     * Updates the user data.
     *
     * @param attributes The data you want to update.
     *
     * This function should only be called on a server. Never expose your `service_role` key in the browser.
     */ async updateUserById(uid, attributes) {
        try {
            return await (0, _fetch._request)(this.fetch, "PUT", `${this.url}/admin/users/${uid}`, {
                body: attributes,
                headers: this.headers,
                xform: (0, _fetch._userResponse)
            });
        } catch (error) {
            if ((0, _errors.isAuthError)(error)) return {
                data: {
                    user: null
                },
                error
            };
            throw error;
        }
    }
    /**
     * Delete a user. Requires a `service_role` key.
     *
     * @param id The user id you want to remove.
     * @param shouldSoftDelete If true, then the user will be soft-deleted (setting `deleted_at` to the current timestamp and disabling their account while preserving their data) from the auth schema.
     * Defaults to false for backward compatibility.
     *
     * This function should only be called on a server. Never expose your `service_role` key in the browser.
     */ async deleteUser(id, shouldSoftDelete = false) {
        try {
            return await (0, _fetch._request)(this.fetch, "DELETE", `${this.url}/admin/users/${id}`, {
                headers: this.headers,
                body: {
                    should_soft_delete: shouldSoftDelete
                },
                xform: (0, _fetch._userResponse)
            });
        } catch (error) {
            if ((0, _errors.isAuthError)(error)) return {
                data: {
                    user: null
                },
                error
            };
            throw error;
        }
    }
    async _listFactors(params) {
        try {
            const { data, error } = await (0, _fetch._request)(this.fetch, "GET", `${this.url}/admin/users/${params.userId}/factors`, {
                headers: this.headers,
                xform: (factors)=>{
                    return {
                        data: {
                            factors
                        },
                        error: null
                    };
                }
            });
            return {
                data,
                error
            };
        } catch (error) {
            if ((0, _errors.isAuthError)(error)) return {
                data: null,
                error
            };
            throw error;
        }
    }
    async _deleteFactor(params) {
        try {
            const data = await (0, _fetch._request)(this.fetch, "DELETE", `${this.url}/admin/users/${params.userId}/factors/${params.id}`, {
                headers: this.headers
            });
            return {
                data,
                error: null
            };
        } catch (error) {
            if ((0, _errors.isAuthError)(error)) return {
                data: null,
                error
            };
            throw error;
        }
    }
}
exports.default = GoTrueAdminApi;

},{"./lib/fetch":"eYrde","./lib/helpers":"2kQpc","./lib/errors":"3HhMS","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"eYrde":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "handleError", ()=>handleError);
parcelHelpers.export(exports, "_request", ()=>_request);
parcelHelpers.export(exports, "_sessionResponse", ()=>_sessionResponse);
parcelHelpers.export(exports, "_sessionResponsePassword", ()=>_sessionResponsePassword);
parcelHelpers.export(exports, "_userResponse", ()=>_userResponse);
parcelHelpers.export(exports, "_ssoResponse", ()=>_ssoResponse);
parcelHelpers.export(exports, "_generateLinkResponse", ()=>_generateLinkResponse);
parcelHelpers.export(exports, "_noResolveJsonResponse", ()=>_noResolveJsonResponse);
var _constants = require("./constants");
var _helpers = require("./helpers");
var _errors = require("./errors");
var __rest = undefined && undefined.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") {
        for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
const _getErrorMessage = (err)=>err.msg || err.message || err.error_description || err.error || JSON.stringify(err);
const NETWORK_ERROR_CODES = [
    502,
    503,
    504
];
async function handleError(error) {
    var _a;
    if (!(0, _helpers.looksLikeFetchResponse)(error)) throw new (0, _errors.AuthRetryableFetchError)(_getErrorMessage(error), 0);
    if (NETWORK_ERROR_CODES.includes(error.status)) // status in 500...599 range - server had an error, request might be retryed.
    throw new (0, _errors.AuthRetryableFetchError)(_getErrorMessage(error), error.status);
    let data;
    try {
        data = await error.json();
    } catch (e) {
        throw new (0, _errors.AuthUnknownError)(_getErrorMessage(e), e);
    }
    let errorCode = undefined;
    const responseAPIVersion = (0, _helpers.parseResponseAPIVersion)(error);
    if (responseAPIVersion && responseAPIVersion.getTime() >= (0, _constants.API_VERSIONS)["2024-01-01"].timestamp && typeof data === "object" && data && typeof data.code === "string") errorCode = data.code;
    else if (typeof data === "object" && data && typeof data.error_code === "string") errorCode = data.error_code;
    if (!errorCode) {
        // Legacy support for weak password errors, when there were no error codes
        if (typeof data === "object" && data && typeof data.weak_password === "object" && data.weak_password && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.reasons.reduce((a, i)=>a && typeof i === "string", true)) throw new (0, _errors.AuthWeakPasswordError)(_getErrorMessage(data), error.status, data.weak_password.reasons);
    } else if (errorCode === "weak_password") throw new (0, _errors.AuthWeakPasswordError)(_getErrorMessage(data), error.status, ((_a = data.weak_password) === null || _a === void 0 ? void 0 : _a.reasons) || []);
    throw new (0, _errors.AuthApiError)(_getErrorMessage(data), error.status || 500, errorCode);
}
const _getRequestParams = (method, options, parameters, body)=>{
    const params = {
        method,
        headers: (options === null || options === void 0 ? void 0 : options.headers) || {}
    };
    if (method === "GET") return params;
    params.headers = Object.assign({
        "Content-Type": "application/json;charset=UTF-8"
    }, options === null || options === void 0 ? void 0 : options.headers);
    params.body = JSON.stringify(body);
    return Object.assign(Object.assign({}, params), parameters);
};
async function _request(fetcher, method, url, options) {
    var _a;
    const headers = Object.assign({}, options === null || options === void 0 ? void 0 : options.headers);
    if (!headers[0, _constants.API_VERSION_HEADER_NAME]) headers[0, _constants.API_VERSION_HEADER_NAME] = (0, _constants.API_VERSIONS)["2024-01-01"].name;
    if (options === null || options === void 0 ? void 0 : options.jwt) headers["Authorization"] = `Bearer ${options.jwt}`;
    const qs = (_a = options === null || options === void 0 ? void 0 : options.query) !== null && _a !== void 0 ? _a : {};
    if (options === null || options === void 0 ? void 0 : options.redirectTo) qs["redirect_to"] = options.redirectTo;
    const queryString = Object.keys(qs).length ? "?" + new URLSearchParams(qs).toString() : "";
    const data = await _handleRequest(fetcher, method, url + queryString, {
        headers,
        noResolveJson: options === null || options === void 0 ? void 0 : options.noResolveJson
    }, {}, options === null || options === void 0 ? void 0 : options.body);
    return (options === null || options === void 0 ? void 0 : options.xform) ? options === null || options === void 0 ? void 0 : options.xform(data) : {
        data: Object.assign({}, data),
        error: null
    };
}
async function _handleRequest(fetcher, method, url, options, parameters, body) {
    const requestParams = _getRequestParams(method, options, parameters, body);
    let result;
    try {
        result = await fetcher(url, Object.assign({}, requestParams));
    } catch (e) {
        console.error(e);
        // fetch failed, likely due to a network or CORS error
        throw new (0, _errors.AuthRetryableFetchError)(_getErrorMessage(e), 0);
    }
    if (!result.ok) await handleError(result);
    if (options === null || options === void 0 ? void 0 : options.noResolveJson) return result;
    try {
        return await result.json();
    } catch (e) {
        await handleError(e);
    }
}
function _sessionResponse(data) {
    var _a;
    let session = null;
    if (hasSession(data)) {
        session = Object.assign({}, data);
        if (!data.expires_at) session.expires_at = (0, _helpers.expiresAt)(data.expires_in);
    }
    const user = (_a = data.user) !== null && _a !== void 0 ? _a : data;
    return {
        data: {
            session,
            user
        },
        error: null
    };
}
function _sessionResponsePassword(data) {
    const response = _sessionResponse(data);
    if (!response.error && data.weak_password && typeof data.weak_password === "object" && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.message && typeof data.weak_password.message === "string" && data.weak_password.reasons.reduce((a, i)=>a && typeof i === "string", true)) response.data.weak_password = data.weak_password;
    return response;
}
function _userResponse(data) {
    var _a;
    const user = (_a = data.user) !== null && _a !== void 0 ? _a : data;
    return {
        data: {
            user
        },
        error: null
    };
}
function _ssoResponse(data) {
    return {
        data,
        error: null
    };
}
function _generateLinkResponse(data) {
    const { action_link, email_otp, hashed_token, redirect_to, verification_type } = data, rest = __rest(data, [
        "action_link",
        "email_otp",
        "hashed_token",
        "redirect_to",
        "verification_type"
    ]);
    const properties = {
        action_link,
        email_otp,
        hashed_token,
        redirect_to,
        verification_type
    };
    const user = Object.assign({}, rest);
    return {
        data: {
            properties,
            user
        },
        error: null
    };
}
function _noResolveJsonResponse(data) {
    return data;
}
/**
 * hasSession checks if the response object contains a valid session
 * @param data A response object
 * @returns true if a session is in the response
 */ function hasSession(data) {
    return data.access_token && data.refresh_token && data.expires_in;
}

},{"./constants":"ja2Dg","./helpers":"2kQpc","./errors":"3HhMS","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"ja2Dg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "GOTRUE_URL", ()=>GOTRUE_URL);
parcelHelpers.export(exports, "STORAGE_KEY", ()=>STORAGE_KEY);
parcelHelpers.export(exports, "AUDIENCE", ()=>AUDIENCE);
parcelHelpers.export(exports, "DEFAULT_HEADERS", ()=>DEFAULT_HEADERS);
parcelHelpers.export(exports, "EXPIRY_MARGIN", ()=>EXPIRY_MARGIN);
parcelHelpers.export(exports, "NETWORK_FAILURE", ()=>NETWORK_FAILURE);
parcelHelpers.export(exports, "API_VERSION_HEADER_NAME", ()=>API_VERSION_HEADER_NAME);
parcelHelpers.export(exports, "API_VERSIONS", ()=>API_VERSIONS);
var _version = require("./version");
const GOTRUE_URL = "http://localhost:9999";
const STORAGE_KEY = "supabase.auth.token";
const AUDIENCE = "";
const DEFAULT_HEADERS = {
    "X-Client-Info": `gotrue-js/${(0, _version.version)}`
};
const EXPIRY_MARGIN = 10; // in seconds
const NETWORK_FAILURE = {
    MAX_RETRIES: 10,
    RETRY_INTERVAL: 2
};
const API_VERSION_HEADER_NAME = "X-Supabase-Api-Version";
const API_VERSIONS = {
    "2024-01-01": {
        timestamp: Date.parse("2024-01-01T00:00:00.0Z"),
        name: "2024-01-01"
    }
};

},{"./version":"hxRK8","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"hxRK8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "2.64.4";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"2kQpc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "expiresAt", ()=>expiresAt);
parcelHelpers.export(exports, "uuid", ()=>uuid);
parcelHelpers.export(exports, "isBrowser", ()=>isBrowser);
parcelHelpers.export(exports, "supportsLocalStorage", ()=>supportsLocalStorage);
/**
 * Extracts parameters encoded in the URL both in the query and fragment.
 */ parcelHelpers.export(exports, "parseParametersFromURL", ()=>parseParametersFromURL);
parcelHelpers.export(exports, "resolveFetch", ()=>resolveFetch);
parcelHelpers.export(exports, "looksLikeFetchResponse", ()=>looksLikeFetchResponse);
parcelHelpers.export(exports, "setItemAsync", ()=>setItemAsync);
parcelHelpers.export(exports, "getItemAsync", ()=>getItemAsync);
parcelHelpers.export(exports, "removeItemAsync", ()=>removeItemAsync);
parcelHelpers.export(exports, "decodeBase64URL", ()=>decodeBase64URL);
/**
 * A deferred represents some asynchronous work that is not yet finished, which
 * may or may not culminate in a value.
 * Taken from: https://github.com/mike-north/types/blob/master/src/async.ts
 */ parcelHelpers.export(exports, "Deferred", ()=>Deferred);
// Taken from: https://stackoverflow.com/questions/38552003/how-to-decode-jwt-token-in-javascript-without-using-a-library
parcelHelpers.export(exports, "decodeJWTPayload", ()=>decodeJWTPayload);
/**
 * Creates a promise that resolves to null after some time.
 */ parcelHelpers.export(exports, "sleep", ()=>sleep);
/**
 * Converts the provided async function into a retryable function. Each result
 * or thrown error is sent to the isRetryable function which should return true
 * if the function should run again.
 */ parcelHelpers.export(exports, "retryable", ()=>retryable);
// Functions below taken from: https://stackoverflow.com/questions/63309409/creating-a-code-verifier-and-challenge-for-pkce-auth-on-spotify-api-in-reactjs
parcelHelpers.export(exports, "generatePKCEVerifier", ()=>generatePKCEVerifier);
parcelHelpers.export(exports, "generatePKCEChallenge", ()=>generatePKCEChallenge);
parcelHelpers.export(exports, "getCodeChallengeAndMethod", ()=>getCodeChallengeAndMethod);
parcelHelpers.export(exports, "parseResponseAPIVersion", ()=>parseResponseAPIVersion);
var _constants = require("./constants");
function expiresAt(expiresIn) {
    const timeNow = Math.round(Date.now() / 1000);
    return timeNow + expiresIn;
}
function uuid() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
        const r = Math.random() * 16 | 0, v = c == "x" ? r : r & 0x3 | 0x8;
        return v.toString(16);
    });
}
const isBrowser = ()=>typeof document !== "undefined";
const localStorageWriteTests = {
    tested: false,
    writable: false
};
const supportsLocalStorage = ()=>{
    if (!isBrowser()) return false;
    try {
        if (typeof globalThis.localStorage !== "object") return false;
    } catch (e) {
        // DOM exception when accessing `localStorage`
        return false;
    }
    if (localStorageWriteTests.tested) return localStorageWriteTests.writable;
    const randomKey = `lswt-${Math.random()}${Math.random()}`;
    try {
        globalThis.localStorage.setItem(randomKey, randomKey);
        globalThis.localStorage.removeItem(randomKey);
        localStorageWriteTests.tested = true;
        localStorageWriteTests.writable = true;
    } catch (e) {
        // localStorage can't be written to
        // https://www.chromium.org/for-testers/bug-reporting-guidelines/uncaught-securityerror-failed-to-read-the-localstorage-property-from-window-access-is-denied-for-this-document
        localStorageWriteTests.tested = true;
        localStorageWriteTests.writable = false;
    }
    return localStorageWriteTests.writable;
};
function parseParametersFromURL(href) {
    const result = {};
    const url = new URL(href);
    if (url.hash && url.hash[0] === "#") try {
        const hashSearchParams = new URLSearchParams(url.hash.substring(1));
        hashSearchParams.forEach((value, key)=>{
            result[key] = value;
        });
    } catch (e) {
    // hash is not a query string
    }
    // search parameters take precedence over hash parameters
    url.searchParams.forEach((value, key)=>{
        result[key] = value;
    });
    return result;
}
const resolveFetch = (customFetch)=>{
    let _fetch;
    if (customFetch) _fetch = customFetch;
    else if (typeof fetch === "undefined") _fetch = (...args)=>require("b14de0e012a619af").then(({ default: fetch1 })=>fetch1(...args));
    else _fetch = fetch;
    return (...args)=>_fetch(...args);
};
const looksLikeFetchResponse = (maybeResponse)=>{
    return typeof maybeResponse === "object" && maybeResponse !== null && "status" in maybeResponse && "ok" in maybeResponse && "json" in maybeResponse && typeof maybeResponse.json === "function";
};
const setItemAsync = async (storage, key, data)=>{
    await storage.setItem(key, JSON.stringify(data));
};
const getItemAsync = async (storage, key)=>{
    const value = await storage.getItem(key);
    if (!value) return null;
    try {
        return JSON.parse(value);
    } catch (_a) {
        return value;
    }
};
const removeItemAsync = async (storage, key)=>{
    await storage.removeItem(key);
};
function decodeBase64URL(value) {
    const key = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    let base64 = "";
    let chr1, chr2, chr3;
    let enc1, enc2, enc3, enc4;
    let i = 0;
    value = value.replace("-", "+").replace("_", "/");
    while(i < value.length){
        enc1 = key.indexOf(value.charAt(i++));
        enc2 = key.indexOf(value.charAt(i++));
        enc3 = key.indexOf(value.charAt(i++));
        enc4 = key.indexOf(value.charAt(i++));
        chr1 = enc1 << 2 | enc2 >> 4;
        chr2 = (enc2 & 15) << 4 | enc3 >> 2;
        chr3 = (enc3 & 3) << 6 | enc4;
        base64 = base64 + String.fromCharCode(chr1);
        if (enc3 != 64 && chr2 != 0) base64 = base64 + String.fromCharCode(chr2);
        if (enc4 != 64 && chr3 != 0) base64 = base64 + String.fromCharCode(chr3);
    }
    return base64;
}
class Deferred {
    constructor(){
        this.promise = new Deferred.promiseConstructor((res, rej)=>{
            this.resolve = res;
            this.reject = rej;
        });
    }
}
Deferred.promiseConstructor = Promise;
function decodeJWTPayload(token) {
    // Regex checks for base64url format
    const base64UrlRegex = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}=?$|[a-z0-9_-]{2}(==)?$)$/i;
    const parts = token.split(".");
    if (parts.length !== 3) throw new Error("JWT is not valid: not a JWT structure");
    if (!base64UrlRegex.test(parts[1])) throw new Error("JWT is not valid: payload is not in base64url format");
    const base64Url = parts[1];
    return JSON.parse(decodeBase64URL(base64Url));
}
async function sleep(time) {
    return await new Promise((accept)=>{
        setTimeout(()=>accept(null), time);
    });
}
function retryable(fn, isRetryable) {
    const promise = new Promise((accept, reject)=>{
        (async ()=>{
            for(let attempt = 0; attempt < Infinity; attempt++)try {
                const result = await fn(attempt);
                if (!isRetryable(attempt, null, result)) {
                    accept(result);
                    return;
                }
            } catch (e) {
                if (!isRetryable(attempt, e)) {
                    reject(e);
                    return;
                }
            }
        })();
    });
    return promise;
}
function dec2hex(dec) {
    return ("0" + dec.toString(16)).substr(-2);
}
function generatePKCEVerifier() {
    const verifierLength = 56;
    const array = new Uint32Array(verifierLength);
    if (typeof crypto === "undefined") {
        const charSet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~";
        const charSetLen = charSet.length;
        let verifier = "";
        for(let i = 0; i < verifierLength; i++)verifier += charSet.charAt(Math.floor(Math.random() * charSetLen));
        return verifier;
    }
    crypto.getRandomValues(array);
    return Array.from(array, dec2hex).join("");
}
async function sha256(randomString) {
    const encoder = new TextEncoder();
    const encodedData = encoder.encode(randomString);
    const hash = await crypto.subtle.digest("SHA-256", encodedData);
    const bytes = new Uint8Array(hash);
    return Array.from(bytes).map((c)=>String.fromCharCode(c)).join("");
}
function base64urlencode(str) {
    return btoa(str).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
async function generatePKCEChallenge(verifier) {
    const hasCryptoSupport = typeof crypto !== "undefined" && typeof crypto.subtle !== "undefined" && typeof TextEncoder !== "undefined";
    if (!hasCryptoSupport) {
        console.warn("WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256.");
        return verifier;
    }
    const hashed = await sha256(verifier);
    return base64urlencode(hashed);
}
async function getCodeChallengeAndMethod(storage, storageKey, isPasswordRecovery = false) {
    const codeVerifier = generatePKCEVerifier();
    let storedCodeVerifier = codeVerifier;
    if (isPasswordRecovery) storedCodeVerifier += "/PASSWORD_RECOVERY";
    await setItemAsync(storage, `${storageKey}-code-verifier`, storedCodeVerifier);
    const codeChallenge = await generatePKCEChallenge(codeVerifier);
    const codeChallengeMethod = codeVerifier === codeChallenge ? "plain" : "s256";
    return [
        codeChallenge,
        codeChallengeMethod
    ];
}
/** Parses the API version which is 2YYY-MM-DD. */ const API_VERSION_REGEX = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;
function parseResponseAPIVersion(response) {
    const apiVersion = response.headers.get((0, _constants.API_VERSION_HEADER_NAME));
    if (!apiVersion) return null;
    if (!apiVersion.match(API_VERSION_REGEX)) return null;
    try {
        const date = new Date(`${apiVersion}T00:00:00.0Z`);
        return date;
    } catch (e) {
        return null;
    }
}

},{"./constants":"ja2Dg","b14de0e012a619af":"cRjRL","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"3HhMS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AuthError", ()=>AuthError);
parcelHelpers.export(exports, "isAuthError", ()=>isAuthError);
parcelHelpers.export(exports, "AuthApiError", ()=>AuthApiError);
parcelHelpers.export(exports, "isAuthApiError", ()=>isAuthApiError);
parcelHelpers.export(exports, "AuthUnknownError", ()=>AuthUnknownError);
parcelHelpers.export(exports, "CustomAuthError", ()=>CustomAuthError);
parcelHelpers.export(exports, "AuthSessionMissingError", ()=>AuthSessionMissingError);
parcelHelpers.export(exports, "AuthInvalidTokenResponseError", ()=>AuthInvalidTokenResponseError);
parcelHelpers.export(exports, "AuthInvalidCredentialsError", ()=>AuthInvalidCredentialsError);
parcelHelpers.export(exports, "AuthImplicitGrantRedirectError", ()=>AuthImplicitGrantRedirectError);
parcelHelpers.export(exports, "AuthPKCEGrantCodeExchangeError", ()=>AuthPKCEGrantCodeExchangeError);
parcelHelpers.export(exports, "AuthRetryableFetchError", ()=>AuthRetryableFetchError);
parcelHelpers.export(exports, "isAuthRetryableFetchError", ()=>isAuthRetryableFetchError);
/**
 * This error is thrown on certain methods when the password used is deemed
 * weak. Inspect the reasons to identify what password strength rules are
 * inadequate.
 */ parcelHelpers.export(exports, "AuthWeakPasswordError", ()=>AuthWeakPasswordError);
parcelHelpers.export(exports, "isAuthWeakPasswordError", ()=>isAuthWeakPasswordError);
class AuthError extends Error {
    constructor(message, status, code){
        super(message);
        this.__isAuthError = true;
        this.name = "AuthError";
        this.status = status;
        this.code = code;
    }
}
function isAuthError(error) {
    return typeof error === "object" && error !== null && "__isAuthError" in error;
}
class AuthApiError extends AuthError {
    constructor(message, status, code){
        super(message, status, code);
        this.name = "AuthApiError";
        this.status = status;
        this.code = code;
    }
}
function isAuthApiError(error) {
    return isAuthError(error) && error.name === "AuthApiError";
}
class AuthUnknownError extends AuthError {
    constructor(message, originalError){
        super(message);
        this.name = "AuthUnknownError";
        this.originalError = originalError;
    }
}
class CustomAuthError extends AuthError {
    constructor(message, name, status, code){
        super(message, status, code);
        this.name = name;
        this.status = status;
    }
}
class AuthSessionMissingError extends CustomAuthError {
    constructor(){
        super("Auth session missing!", "AuthSessionMissingError", 400, undefined);
    }
}
class AuthInvalidTokenResponseError extends CustomAuthError {
    constructor(){
        super("Auth session or user missing", "AuthInvalidTokenResponseError", 500, undefined);
    }
}
class AuthInvalidCredentialsError extends CustomAuthError {
    constructor(message){
        super(message, "AuthInvalidCredentialsError", 400, undefined);
    }
}
class AuthImplicitGrantRedirectError extends CustomAuthError {
    constructor(message, details = null){
        super(message, "AuthImplicitGrantRedirectError", 500, undefined);
        this.details = null;
        this.details = details;
    }
    toJSON() {
        return {
            name: this.name,
            message: this.message,
            status: this.status,
            details: this.details
        };
    }
}
class AuthPKCEGrantCodeExchangeError extends CustomAuthError {
    constructor(message, details = null){
        super(message, "AuthPKCEGrantCodeExchangeError", 500, undefined);
        this.details = null;
        this.details = details;
    }
    toJSON() {
        return {
            name: this.name,
            message: this.message,
            status: this.status,
            details: this.details
        };
    }
}
class AuthRetryableFetchError extends CustomAuthError {
    constructor(message, status){
        super(message, "AuthRetryableFetchError", status, undefined);
    }
}
function isAuthRetryableFetchError(error) {
    return isAuthError(error) && error.name === "AuthRetryableFetchError";
}
class AuthWeakPasswordError extends CustomAuthError {
    constructor(message, status, reasons){
        super(message, "AuthWeakPasswordError", status, "weak_password");
        this.reasons = reasons;
    }
}
function isAuthWeakPasswordError(error) {
    return isAuthError(error) && error.name === "AuthWeakPasswordError";
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"1GHqN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _goTrueAdminApi = require("./GoTrueAdminApi");
var _goTrueAdminApiDefault = parcelHelpers.interopDefault(_goTrueAdminApi);
var _constants = require("./lib/constants");
var _errors = require("./lib/errors");
var _fetch = require("./lib/fetch");
var _helpers = require("./lib/helpers");
var _localStorage = require("./lib/local-storage");
var _polyfills = require("./lib/polyfills");
var _version = require("./lib/version");
var _locks = require("./lib/locks");
(0, _polyfills.polyfillGlobalThis)(); // Make "globalThis" available
const DEFAULT_OPTIONS = {
    url: (0, _constants.GOTRUE_URL),
    storageKey: (0, _constants.STORAGE_KEY),
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: true,
    headers: (0, _constants.DEFAULT_HEADERS),
    flowType: "implicit",
    debug: false,
    hasCustomAuthorizationHeader: false
};
/** Current session will be checked for refresh at this interval. */ const AUTO_REFRESH_TICK_DURATION = 30000;
/**
 * A token refresh will be attempted this many ticks before the current session expires. */ const AUTO_REFRESH_TICK_THRESHOLD = 3;
async function lockNoOp(name, acquireTimeout, fn) {
    return await fn();
}
class GoTrueClient {
    /**
     * Create a new client for use in the browser.
     */ constructor(options){
        var _a, _b;
        this.memoryStorage = null;
        this.stateChangeEmitters = new Map();
        this.autoRefreshTicker = null;
        this.visibilityChangedCallback = null;
        this.refreshingDeferred = null;
        /**
         * Keeps track of the async client initialization.
         * When null or not yet resolved the auth state is `unknown`
         * Once resolved the the auth state is known and it's save to call any further client methods.
         * Keep extra care to never reject or throw uncaught errors
         */ this.initializePromise = null;
        this.detectSessionInUrl = true;
        this.hasCustomAuthorizationHeader = false;
        this.suppressGetSessionWarning = false;
        this.lockAcquired = false;
        this.pendingInLock = [];
        /**
         * Used to broadcast state change events to other tabs listening.
         */ this.broadcastChannel = null;
        this.logger = console.log;
        this.instanceID = GoTrueClient.nextInstanceID;
        GoTrueClient.nextInstanceID += 1;
        if (this.instanceID > 0 && (0, _helpers.isBrowser)()) console.warn("Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.");
        const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);
        this.logDebugMessages = !!settings.debug;
        if (typeof settings.debug === "function") this.logger = settings.debug;
        this.persistSession = settings.persistSession;
        this.storageKey = settings.storageKey;
        this.autoRefreshToken = settings.autoRefreshToken;
        this.admin = new (0, _goTrueAdminApiDefault.default)({
            url: settings.url,
            headers: settings.headers,
            fetch: settings.fetch
        });
        this.url = settings.url;
        this.headers = settings.headers;
        this.fetch = (0, _helpers.resolveFetch)(settings.fetch);
        this.lock = settings.lock || lockNoOp;
        this.detectSessionInUrl = settings.detectSessionInUrl;
        this.flowType = settings.flowType;
        this.hasCustomAuthorizationHeader = settings.hasCustomAuthorizationHeader;
        if (settings.lock) this.lock = settings.lock;
        else if ((0, _helpers.isBrowser)() && ((_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.navigator) === null || _a === void 0 ? void 0 : _a.locks)) this.lock = (0, _locks.navigatorLock);
        else this.lock = lockNoOp;
        this.mfa = {
            verify: this._verify.bind(this),
            enroll: this._enroll.bind(this),
            unenroll: this._unenroll.bind(this),
            challenge: this._challenge.bind(this),
            listFactors: this._listFactors.bind(this),
            challengeAndVerify: this._challengeAndVerify.bind(this),
            getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this)
        };
        if (this.persistSession) {
            if (settings.storage) this.storage = settings.storage;
            else if ((0, _helpers.supportsLocalStorage)()) this.storage = (0, _localStorage.localStorageAdapter);
            else {
                this.memoryStorage = {};
                this.storage = (0, _localStorage.memoryLocalStorageAdapter)(this.memoryStorage);
            }
        } else {
            this.memoryStorage = {};
            this.storage = (0, _localStorage.memoryLocalStorageAdapter)(this.memoryStorage);
        }
        if ((0, _helpers.isBrowser)() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {
            try {
                this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey);
            } catch (e) {
                console.error("Failed to create a new BroadcastChannel, multi-tab state changes will not be available", e);
            }
            (_b = this.broadcastChannel) === null || _b === void 0 || _b.addEventListener("message", async (event)=>{
                this._debug("received broadcast notification from other tab or client", event);
                await this._notifyAllSubscribers(event.data.event, event.data.session, false); // broadcast = false so we don't get an endless loop of messages
            });
        }
        this.initialize();
    }
    _debug(...args) {
        if (this.logDebugMessages) this.logger(`GoTrueClient@${this.instanceID} (${(0, _version.version)}) ${new Date().toISOString()}`, ...args);
        return this;
    }
    /**
     * Initializes the client session either from the url or from storage.
     * This method is automatically called when instantiating the client, but should also be called
     * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).
     */ async initialize() {
        if (this.initializePromise) return await this.initializePromise;
        this.initializePromise = (async ()=>{
            return await this._acquireLock(-1, async ()=>{
                return await this._initialize();
            });
        })();
        return await this.initializePromise;
    }
    /**
     * IMPORTANT:
     * 1. Never throw in this method, as it is called from the constructor
     * 2. Never return a session from this method as it would be cached over
     *    the whole lifetime of the client
     */ async _initialize() {
        try {
            const isPKCEFlow = (0, _helpers.isBrowser)() ? await this._isPKCEFlow() : false;
            this._debug("#_initialize()", "begin", "is PKCE flow", isPKCEFlow);
            if (isPKCEFlow || this.detectSessionInUrl && this._isImplicitGrantFlow()) {
                const { data, error } = await this._getSessionFromURL(isPKCEFlow);
                if (error) {
                    this._debug("#_initialize()", "error detecting session from URL", error);
                    // hacky workaround to keep the existing session if there's an error returned from identity linking
                    // TODO: once error codes are ready, we should match against it instead of the message
                    if ((error === null || error === void 0 ? void 0 : error.message) === "Identity is already linked" || (error === null || error === void 0 ? void 0 : error.message) === "Identity is already linked to another user") return {
                        error
                    };
                    // failed login attempt via url,
                    // remove old session as in verifyOtp, signUp and signInWith*
                    await this._removeSession();
                    return {
                        error
                    };
                }
                const { session, redirectType } = data;
                this._debug("#_initialize()", "detected session in URL", session, "redirect type", redirectType);
                await this._saveSession(session);
                setTimeout(async ()=>{
                    if (redirectType === "recovery") await this._notifyAllSubscribers("PASSWORD_RECOVERY", session);
                    else await this._notifyAllSubscribers("SIGNED_IN", session);
                }, 0);
                return {
                    error: null
                };
            }
            // no login attempt via callback url try to recover session from storage
            await this._recoverAndRefresh();
            return {
                error: null
            };
        } catch (error) {
            if ((0, _errors.isAuthError)(error)) return {
                error
            };
            return {
                error: new (0, _errors.AuthUnknownError)("Unexpected error during initialization", error)
            };
        } finally{
            await this._handleVisibilityChange();
            this._debug("#_initialize()", "end");
        }
    }
    /**
     * Creates a new anonymous user.
     *
     * @returns A session where the is_anonymous claim in the access token JWT set to true
     */ async signInAnonymously(credentials) {
        var _a, _b, _c;
        try {
            const res = await (0, _fetch._request)(this.fetch, "POST", `${this.url}/signup`, {
                headers: this.headers,
                body: {
                    data: (_b = (_a = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _a === void 0 ? void 0 : _a.data) !== null && _b !== void 0 ? _b : {},
                    gotrue_meta_security: {
                        captcha_token: (_c = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _c === void 0 ? void 0 : _c.captchaToken
                    }
                },
                xform: (0, _fetch._sessionResponse)
            });
            const { data, error } = res;
            if (error || !data) return {
                data: {
                    user: null,
                    session: null
                },
                error: error
            };
            const session = data.session;
            const user = data.user;
            if (data.session) {
                await this._saveSession(data.session);
                await this._notifyAllSubscribers("SIGNED_IN", session);
            }
            return {
                data: {
                    user,
                    session
                },
                error: null
            };
        } catch (error) {
            if ((0, _errors.isAuthError)(error)) return {
                data: {
                    user: null,
                    session: null
                },
                error
            };
            throw error;
        }
    }
    /**
     * Creates a new user.
     *
     * Be aware that if a user account exists in the system you may get back an
     * error message that attempts to hide this information from the user.
     * This method has support for PKCE via email signups. The PKCE flow cannot be used when autoconfirm is enabled.
     *
     * @returns A logged-in session if the server has "autoconfirm" ON
     * @returns A user if the server has "autoconfirm" OFF
     */ async signUp(credentials) {
        var _a, _b, _c;
        try {
            let res;
            if ("email" in credentials) {
                const { email, password, options } = credentials;
                let codeChallenge = null;
                let codeChallengeMethod = null;
                if (this.flowType === "pkce") [codeChallenge, codeChallengeMethod] = await (0, _helpers.getCodeChallengeAndMethod)(this.storage, this.storageKey);
                res = await (0, _fetch._request)(this.fetch, "POST", `${this.url}/signup`, {
                    headers: this.headers,
                    redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,
                    body: {
                        email,
                        password,
                        data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},
                        gotrue_meta_security: {
                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken
                        },
                        code_challenge: codeChallenge,
                        code_challenge_method: codeChallengeMethod
                    },
                    xform: (0, _fetch._sessionResponse)
                });
            } else if ("phone" in credentials) {
                const { phone, password, options } = credentials;
                res = await (0, _fetch._request)(this.fetch, "POST", `${this.url}/signup`, {
                    headers: this.headers,
                    body: {
                        phone,
                        password,
                        data: (_b = options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : {},
                        channel: (_c = options === null || options === void 0 ? void 0 : options.channel) !== null && _c !== void 0 ? _c : "sms",
                        gotrue_meta_security: {
                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken
                        }
                    },
                    xform: (0, _fetch._sessionResponse)
                });
            } else throw new (0, _errors.AuthInvalidCredentialsError)("You must provide either an email or phone number and a password");
            const { data, error } = res;
            if (error || !data) return {
                data: {
                    user: null,
                    session: null
                },
                error: error
            };
            const session = data.session;
            const user = data.user;
            if (data.session) {
                await this._saveSession(data.session);
                await this._notifyAllSubscribers("SIGNED_IN", session);
            }
            return {
                data: {
                    user,
                    session
                },
                error: null
            };
        } catch (error) {
            if ((0, _errors.isAuthError)(error)) return {
                data: {
                    user: null,
                    session: null
                },
                error
            };
            throw error;
        }
    }
    /**
     * Log in an existing user with an email and password or phone and password.
     *
     * Be aware that you may get back an error message that will not distinguish
     * between the cases where the account does not exist or that the
     * email/phone and password combination is wrong or that the account can only
     * be accessed via social login.
     */ async signInWithPassword(credentials) {
        try {
            let res;
            if ("email" in credentials) {
                const { email, password, options } = credentials;
                res = await (0, _fetch._request)(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
                    headers: this.headers,
                    body: {
                        email,
                        password,
                        gotrue_meta_security: {
                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken
                        }
                    },
                    xform: (0, _fetch._sessionResponsePassword)
                });
            } else if ("phone" in credentials) {
                const { phone, password, options } = credentials;
                res = await (0, _fetch._request)(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
                    headers: this.headers,
                    body: {
                        phone,
                        password,
                        gotrue_meta_security: {
                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken
                        }
                    },
                    xform: (0, _fetch._sessionResponsePassword)
                });
            } else throw new (0, _errors.AuthInvalidCredentialsError)("You must provide either an email or phone number and a password");
            const { data, error } = res;
            if (error) return {
                data: {
                    user: null,
                    session: null
                },
                error
            };
            else if (!data || !data.session || !data.user) return {
                data: {
                    user: null,
                    session: null
                },
                error: new (0, _errors.AuthInvalidTokenResponseError)()
            };
            if (data.session) {
                await this._saveSession(data.session);
                await this._notifyAllSubscribers("SIGNED_IN", data.session);
            }
            return {
                data: Object.assign({
                    user: data.user,
                    session: data.session
                }, data.weak_password ? {
                    weakPassword: data.weak_password
                } : null),
                error
            };
        } catch (error) {
            if ((0, _errors.isAuthError)(error)) return {
                data: {
                    user: null,
                    session: null
                },
                error
            };
            throw error;
        }
    }
    /**
     * Log in an existing user via a third-party provider.
     * This method supports the PKCE flow.
     */ async signInWithOAuth(credentials) {
        var _a, _b, _c, _d;
        return await this._handleProviderSignIn(credentials.provider, {
            redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,
            scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,
            queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,
            skipBrowserRedirect: (_d = credentials.options) === null || _d === void 0 ? void 0 : _d.skipBrowserRedirect
        });
    }
    /**
     * Log in an existing user by exchanging an Auth Code issued during the PKCE flow.
     */ async exchangeCodeForSession(authCode) {
        await this.initializePromise;
        return this._acquireLock(-1, async ()=>{
            return this._exchangeCodeForSession(authCode);
        });
    }
    async _exchangeCodeForSession(authCode) {
        const storageItem = await (0, _helpers.getItemAsync)(this.storage, `${this.storageKey}-code-verifier`);
        const [codeVerifier, redirectType] = (storageItem !== null && storageItem !== void 0 ? storageItem : "").split("/");
        const { data, error } = await (0, _fetch._request)(this.fetch, "POST", `${this.url}/token?grant_type=pkce`, {
            headers: this.headers,
            body: {
                auth_code: authCode,
                code_verifier: codeVerifier
            },
            xform: (0, _fetch._sessionResponse)
        });
        await (0, _helpers.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);
        if (error) return {
            data: {
                user: null,
                session: null,
                redirectType: null
            },
            error
        };
        else if (!data || !data.session || !data.user) return {
            data: {
                user: null,
                session: null,
                redirectType: null
            },
            error: new (0, _errors.AuthInvalidTokenResponseError)()
        };
        if (data.session) {
            await this._saveSession(data.session);
            await this._notifyAllSubscribers("SIGNED_IN", data.session);
        }
        return {
            data: Object.assign(Object.assign({}, data), {
                redirectType: redirectType !== null && redirectType !== void 0 ? redirectType : null
            }),
            error
        };
    }
    /**
     * Allows signing in with an OIDC ID token. The authentication provider used
     * should be enabled and configured.
     */ async signInWithIdToken(credentials) {
        try {
            const { options, provider, token, access_token, nonce } = credentials;
            const res = await (0, _fetch._request)(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, {
                headers: this.headers,
                body: {
                    provider,
                    id_token: token,
                    access_token,
                    nonce,
                    gotrue_meta_security: {
                        captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken
                    }
                },
                xform: (0, _fetch._sessionResponse)
            });
            const { data, error } = res;
            if (error) return {
                data: {
                    user: null,
                    session: null
                },
                error
            };
            else if (!data || !data.session || !data.user) return {
                data: {
                    user: null,
                    session: null
                },
                error: new (0, _errors.AuthInvalidTokenResponseError)()
            };
            if (data.session) {
                await this._saveSession(data.session);
                await this._notifyAllSubscribers("SIGNED_IN", data.session);
            }
            return {
                data,
                error
            };
        } catch (error) {
            if ((0, _errors.isAuthError)(error)) return {
                data: {
                    user: null,
                    session: null
                },
                error
            };
            throw error;
        }
    }
    /**
     * Log in a user using magiclink or a one-time password (OTP).
     *
     * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.
     * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.
     * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.
     *
     * Be aware that you may get back an error message that will not distinguish
     * between the cases where the account does not exist or, that the account
     * can only be accessed via social login.
     *
     * Do note that you will need to configure a Whatsapp sender on Twilio
     * if you are using phone sign in with the 'whatsapp' channel. The whatsapp
     * channel is not supported on other providers
     * at this time.
     * This method supports PKCE when an email is passed.
     */ async signInWithOtp(credentials) {
        var _a, _b, _c, _d, _e;
        try {
            if ("email" in credentials) {
                const { email, options } = credentials;
                let codeChallenge = null;
                let codeChallengeMethod = null;
                if (this.flowType === "pkce") [codeChallenge, codeChallengeMethod] = await (0, _helpers.getCodeChallengeAndMethod)(this.storage, this.storageKey);
                const { error } = await (0, _fetch._request)(this.fetch, "POST", `${this.url}/otp`, {
                    headers: this.headers,
                    body: {
                        email,
                        data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},
                        create_user: (_b = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b !== void 0 ? _b : true,
                        gotrue_meta_security: {
                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken
                        },
                        code_challenge: codeChallenge,
                        code_challenge_method: codeChallengeMethod
                    },
                    redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo
                });
                return {
                    data: {
                        user: null,
                        session: null
                    },
                    error
                };
            }
            if ("phone" in credentials) {
                const { phone, options } = credentials;
                const { data, error } = await (0, _fetch._request)(this.fetch, "POST", `${this.url}/otp`, {
                    headers: this.headers,
                    body: {
                        phone,
                        data: (_c = options === null || options === void 0 ? void 0 : options.data) !== null && _c !== void 0 ? _c : {},
                        create_user: (_d = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _d !== void 0 ? _d : true,
                        gotrue_meta_security: {
                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken
                        },
                        channel: (_e = options === null || options === void 0 ? void 0 : options.channel) !== null && _e !== void 0 ? _e : "sms"
                    }
                });
                return {
                    data: {
                        user: null,
                        session: null,
                        messageId: data === null || data === void 0 ? void 0 : data.message_id
                    },
                    error
                };
            }
            throw new (0, _errors.AuthInvalidCredentialsError)("You must provide either an email or phone number.");
        } catch (error) {
            if ((0, _errors.isAuthError)(error)) return {
                data: {
                    user: null,
                    session: null
                },
                error
            };
            throw error;
        }
    }
    /**
     * Log in a user given a User supplied OTP or TokenHash received through mobile or email.
     */ async verifyOtp(params) {
        var _a, _b;
        try {
            let redirectTo = undefined;
            let captchaToken = undefined;
            if ("options" in params) {
                redirectTo = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo;
                captchaToken = (_b = params.options) === null || _b === void 0 ? void 0 : _b.captchaToken;
            }
            const { data, error } = await (0, _fetch._request)(this.fetch, "POST", `${this.url}/verify`, {
                headers: this.headers,
                body: Object.assign(Object.assign({}, params), {
                    gotrue_meta_security: {
                        captcha_token: captchaToken
                    }
                }),
                redirectTo,
                xform: (0, _fetch._sessionResponse)
            });
            if (error) throw error;
            if (!data) throw new Error("An error occurred on token verification.");
            const session = data.session;
            const user = data.user;
            if (session === null || session === void 0 ? void 0 : session.access_token) {
                await this._saveSession(session);
                await this._notifyAllSubscribers(params.type == "recovery" ? "PASSWORD_RECOVERY" : "SIGNED_IN", session);
            }
            return {
                data: {
                    user,
                    session
                },
                error: null
            };
        } catch (error) {
            if ((0, _errors.isAuthError)(error)) return {
                data: {
                    user: null,
                    session: null
                },
                error
            };
            throw error;
        }
    }
    /**
     * Attempts a single-sign on using an enterprise Identity Provider. A
     * successful SSO attempt will redirect the current page to the identity
     * provider authorization page. The redirect URL is implementation and SSO
     * protocol specific.
     *
     * You can use it by providing a SSO domain. Typically you can extract this
     * domain by asking users for their email address. If this domain is
     * registered on the Auth instance the redirect will use that organization's
     * currently active SSO Identity Provider for the login.
     *
     * If you have built an organization-specific login page, you can use the
     * organization's SSO Identity Provider UUID directly instead.
     */ async signInWithSSO(params) {
        var _a, _b, _c;
        try {
            let codeChallenge = null;
            let codeChallengeMethod = null;
            if (this.flowType === "pkce") [codeChallenge, codeChallengeMethod] = await (0, _helpers.getCodeChallengeAndMethod)(this.storage, this.storageKey);
            return await (0, _fetch._request)(this.fetch, "POST", `${this.url}/sso`, {
                body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, "providerId" in params ? {
                    provider_id: params.providerId
                } : null), "domain" in params ? {
                    domain: params.domain
                } : null), {
                    redirect_to: (_b = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo) !== null && _b !== void 0 ? _b : undefined
                }), ((_c = params === null || params === void 0 ? void 0 : params.options) === null || _c === void 0 ? void 0 : _c.captchaToken) ? {
                    gotrue_meta_security: {
                        captcha_token: params.options.captchaToken
                    }
                } : null), {
                    skip_http_redirect: true,
                    code_challenge: codeChallenge,
                    code_challenge_method: codeChallengeMethod
                }),
                headers: this.headers,
                xform: (0, _fetch._ssoResponse)
            });
        } catch (error) {
            if ((0, _errors.isAuthError)(error)) return {
                data: null,
                error
            };
            throw error;
        }
    }
    /**
     * Sends a reauthentication OTP to the user's email or phone number.
     * Requires the user to be signed-in.
     */ async reauthenticate() {
        await this.initializePromise;
        return await this._acquireLock(-1, async ()=>{
            return await this._reauthenticate();
        });
    }
    async _reauthenticate() {
        try {
            return await this._useSession(async (result)=>{
                const { data: { session }, error: sessionError } = result;
                if (sessionError) throw sessionError;
                if (!session) throw new (0, _errors.AuthSessionMissingError)();
                const { error } = await (0, _fetch._request)(this.fetch, "GET", `${this.url}/reauthenticate`, {
                    headers: this.headers,
                    jwt: session.access_token
                });
                return {
                    data: {
                        user: null,
                        session: null
                    },
                    error
                };
            });
        } catch (error) {
            if ((0, _errors.isAuthError)(error)) return {
                data: {
                    user: null,
                    session: null
                },
                error
            };
            throw error;
        }
    }
    /**
     * Resends an existing signup confirmation email, email change email, SMS OTP or phone change OTP.
     */ async resend(credentials) {
        try {
            const endpoint = `${this.url}/resend`;
            if ("email" in credentials) {
                const { email, type, options } = credentials;
                const { error } = await (0, _fetch._request)(this.fetch, "POST", endpoint, {
                    headers: this.headers,
                    body: {
                        email,
                        type,
                        gotrue_meta_security: {
                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken
                        }
                    },
                    redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo
                });
                return {
                    data: {
                        user: null,
                        session: null
                    },
                    error
                };
            } else if ("phone" in credentials) {
                const { phone, type, options } = credentials;
                const { data, error } = await (0, _fetch._request)(this.fetch, "POST", endpoint, {
                    headers: this.headers,
                    body: {
                        phone,
                        type,
                        gotrue_meta_security: {
                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken
                        }
                    }
                });
                return {
                    data: {
                        user: null,
                        session: null,
                        messageId: data === null || data === void 0 ? void 0 : data.message_id
                    },
                    error
                };
            }
            throw new (0, _errors.AuthInvalidCredentialsError)("You must provide either an email or phone number and a type");
        } catch (error) {
            if ((0, _errors.isAuthError)(error)) return {
                data: {
                    user: null,
                    session: null
                },
                error
            };
            throw error;
        }
    }
    /**
     * Returns the session, refreshing it if necessary.
     *
     * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.
     *
     * **IMPORTANT:** This method loads values directly from the storage attached
     * to the client. If that storage is based on request cookies for example,
     * the values in it may not be authentic and therefore it's strongly advised
     * against using this method and its results in such circumstances. A warning
     * will be emitted if this is detected. Use {@link #getUser()} instead.
     */ async getSession() {
        await this.initializePromise;
        const result = await this._acquireLock(-1, async ()=>{
            return this._useSession(async (result)=>{
                return result;
            });
        });
        return result;
    }
    /**
     * Acquires a global lock based on the storage key.
     */ async _acquireLock(acquireTimeout, fn) {
        this._debug("#_acquireLock", "begin", acquireTimeout);
        try {
            if (this.lockAcquired) {
                const last = this.pendingInLock.length ? this.pendingInLock[this.pendingInLock.length - 1] : Promise.resolve();
                const result = (async ()=>{
                    await last;
                    return await fn();
                })();
                this.pendingInLock.push((async ()=>{
                    try {
                        await result;
                    } catch (e) {
                    // we just care if it finished
                    }
                })());
                return result;
            }
            return await this.lock(`lock:${this.storageKey}`, acquireTimeout, async ()=>{
                this._debug("#_acquireLock", "lock acquired for storage key", this.storageKey);
                try {
                    this.lockAcquired = true;
                    const result = fn();
                    this.pendingInLock.push((async ()=>{
                        try {
                            await result;
                        } catch (e) {
                        // we just care if it finished
                        }
                    })());
                    await result;
                    // keep draining the queue until there's nothing to wait on
                    while(this.pendingInLock.length){
                        const waitOn = [
                            ...this.pendingInLock
                        ];
                        await Promise.all(waitOn);
                        this.pendingInLock.splice(0, waitOn.length);
                    }
                    return await result;
                } finally{
                    this._debug("#_acquireLock", "lock released for storage key", this.storageKey);
                    this.lockAcquired = false;
                }
            });
        } finally{
            this._debug("#_acquireLock", "end");
        }
    }
    /**
     * Use instead of {@link #getSession} inside the library. It is
     * semantically usually what you want, as getting a session involves some
     * processing afterwards that requires only one client operating on the
     * session at once across multiple tabs or processes.
     */ async _useSession(fn) {
        this._debug("#_useSession", "begin");
        try {
            // the use of __loadSession here is the only correct use of the function!
            const result = await this.__loadSession();
            return await fn(result);
        } finally{
            this._debug("#_useSession", "end");
        }
    }
    /**
     * NEVER USE DIRECTLY!
     *
     * Always use {@link #_useSession}.
     */ async __loadSession() {
        this._debug("#__loadSession()", "begin");
        if (!this.lockAcquired) this._debug("#__loadSession()", "used outside of an acquired lock!", new Error().stack);
        try {
            let currentSession = null;
            const maybeSession = await (0, _helpers.getItemAsync)(this.storage, this.storageKey);
            this._debug("#getSession()", "session from storage", maybeSession);
            if (maybeSession !== null) {
                if (this._isValidSession(maybeSession)) currentSession = maybeSession;
                else {
                    this._debug("#getSession()", "session from storage is not valid");
                    await this._removeSession();
                }
            }
            if (!currentSession) return {
                data: {
                    session: null
                },
                error: null
            };
            const hasExpired = currentSession.expires_at ? currentSession.expires_at <= Date.now() / 1000 : false;
            this._debug("#__loadSession()", `session has${hasExpired ? "" : " not"} expired`, "expires_at", currentSession.expires_at);
            if (!hasExpired) {
                if (this.storage.isServer) {
                    let suppressWarning = this.suppressGetSessionWarning;
                    const proxySession = new Proxy(currentSession, {
                        get: (target, prop, receiver)=>{
                            if (!suppressWarning && prop === "user") {
                                // only show warning when the user object is being accessed from the server
                                console.warn("Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and many not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server.");
                                suppressWarning = true; // keeps this proxy instance from logging additional warnings
                                this.suppressGetSessionWarning = true; // keeps this client's future proxy instances from warning
                            }
                            return Reflect.get(target, prop, receiver);
                        }
                    });
                    currentSession = proxySession;
                }
                return {
                    data: {
                        session: currentSession
                    },
                    error: null
                };
            }
            const { session, error } = await this._callRefreshToken(currentSession.refresh_token);
            if (error) return {
                data: {
                    session: null
                },
                error
            };
            return {
                data: {
                    session
                },
                error: null
            };
        } finally{
            this._debug("#__loadSession()", "end");
        }
    }
    /**
     * Gets the current user details if there is an existing session. This method
     * performs a network request to the Supabase Auth server, so the returned
     * value is authentic and can be used to base authorization rules on.
     *
     * @param jwt Takes in an optional access token JWT. If no JWT is provided, the JWT from the current session is used.
     */ async getUser(jwt) {
        if (jwt) return await this._getUser(jwt);
        await this.initializePromise;
        const result = await this._acquireLock(-1, async ()=>{
            return await this._getUser();
        });
        return result;
    }
    async _getUser(jwt) {
        try {
            if (jwt) return await (0, _fetch._request)(this.fetch, "GET", `${this.url}/user`, {
                headers: this.headers,
                jwt: jwt,
                xform: (0, _fetch._userResponse)
            });
            return await this._useSession(async (result)=>{
                var _a, _b, _c;
                const { data, error } = result;
                if (error) throw error;
                // returns an error if there is no access_token or custom authorization header
                if (!((_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) && !this.hasCustomAuthorizationHeader) return {
                    data: {
                        user: null
                    },
                    error: new (0, _errors.AuthSessionMissingError)()
                };
                return await (0, _fetch._request)(this.fetch, "GET", `${this.url}/user`, {
                    headers: this.headers,
                    jwt: (_c = (_b = data.session) === null || _b === void 0 ? void 0 : _b.access_token) !== null && _c !== void 0 ? _c : undefined,
                    xform: (0, _fetch._userResponse)
                });
            });
        } catch (error) {
            if ((0, _errors.isAuthError)(error)) return {
                data: {
                    user: null
                },
                error
            };
            throw error;
        }
    }
    /**
     * Updates user data for a logged in user.
     */ async updateUser(attributes, options = {}) {
        await this.initializePromise;
        return await this._acquireLock(-1, async ()=>{
            return await this._updateUser(attributes, options);
        });
    }
    async _updateUser(attributes, options = {}) {
        try {
            return await this._useSession(async (result)=>{
                const { data: sessionData, error: sessionError } = result;
                if (sessionError) throw sessionError;
                if (!sessionData.session) throw new (0, _errors.AuthSessionMissingError)();
                const session = sessionData.session;
                let codeChallenge = null;
                let codeChallengeMethod = null;
                if (this.flowType === "pkce" && attributes.email != null) [codeChallenge, codeChallengeMethod] = await (0, _helpers.getCodeChallengeAndMethod)(this.storage, this.storageKey);
                const { data, error: userError } = await (0, _fetch._request)(this.fetch, "PUT", `${this.url}/user`, {
                    headers: this.headers,
                    redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,
                    body: Object.assign(Object.assign({}, attributes), {
                        code_challenge: codeChallenge,
                        code_challenge_method: codeChallengeMethod
                    }),
                    jwt: session.access_token,
                    xform: (0, _fetch._userResponse)
                });
                if (userError) throw userError;
                session.user = data.user;
                await this._saveSession(session);
                await this._notifyAllSubscribers("USER_UPDATED", session);
                return {
                    data: {
                        user: session.user
                    },
                    error: null
                };
            });
        } catch (error) {
            if ((0, _errors.isAuthError)(error)) return {
                data: {
                    user: null
                },
                error
            };
            throw error;
        }
    }
    /**
     * Decodes a JWT (without performing any validation).
     */ _decodeJWT(jwt) {
        return (0, _helpers.decodeJWTPayload)(jwt);
    }
    /**
     * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.
     * If the refresh token or access token in the current session is invalid, an error will be thrown.
     * @param currentSession The current session that minimally contains an access token and refresh token.
     */ async setSession(currentSession) {
        await this.initializePromise;
        return await this._acquireLock(-1, async ()=>{
            return await this._setSession(currentSession);
        });
    }
    async _setSession(currentSession) {
        try {
            if (!currentSession.access_token || !currentSession.refresh_token) throw new (0, _errors.AuthSessionMissingError)();
            const timeNow = Date.now() / 1000;
            let expiresAt = timeNow;
            let hasExpired = true;
            let session = null;
            const payload = (0, _helpers.decodeJWTPayload)(currentSession.access_token);
            if (payload.exp) {
                expiresAt = payload.exp;
                hasExpired = expiresAt <= timeNow;
            }
            if (hasExpired) {
                const { session: refreshedSession, error } = await this._callRefreshToken(currentSession.refresh_token);
                if (error) return {
                    data: {
                        user: null,
                        session: null
                    },
                    error: error
                };
                if (!refreshedSession) return {
                    data: {
                        user: null,
                        session: null
                    },
                    error: null
                };
                session = refreshedSession;
            } else {
                const { data, error } = await this._getUser(currentSession.access_token);
                if (error) throw error;
                session = {
                    access_token: currentSession.access_token,
                    refresh_token: currentSession.refresh_token,
                    user: data.user,
                    token_type: "bearer",
                    expires_in: expiresAt - timeNow,
                    expires_at: expiresAt
                };
                await this._saveSession(session);
                await this._notifyAllSubscribers("SIGNED_IN", session);
            }
            return {
                data: {
                    user: session.user,
                    session
                },
                error: null
            };
        } catch (error) {
            if ((0, _errors.isAuthError)(error)) return {
                data: {
                    session: null,
                    user: null
                },
                error
            };
            throw error;
        }
    }
    /**
     * Returns a new session, regardless of expiry status.
     * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().
     * If the current session's refresh token is invalid, an error will be thrown.
     * @param currentSession The current session. If passed in, it must contain a refresh token.
     */ async refreshSession(currentSession) {
        await this.initializePromise;
        return await this._acquireLock(-1, async ()=>{
            return await this._refreshSession(currentSession);
        });
    }
    async _refreshSession(currentSession) {
        try {
            return await this._useSession(async (result)=>{
                var _a;
                if (!currentSession) {
                    const { data, error } = result;
                    if (error) throw error;
                    currentSession = (_a = data.session) !== null && _a !== void 0 ? _a : undefined;
                }
                if (!(currentSession === null || currentSession === void 0 ? void 0 : currentSession.refresh_token)) throw new (0, _errors.AuthSessionMissingError)();
                const { session, error } = await this._callRefreshToken(currentSession.refresh_token);
                if (error) return {
                    data: {
                        user: null,
                        session: null
                    },
                    error: error
                };
                if (!session) return {
                    data: {
                        user: null,
                        session: null
                    },
                    error: null
                };
                return {
                    data: {
                        user: session.user,
                        session
                    },
                    error: null
                };
            });
        } catch (error) {
            if ((0, _errors.isAuthError)(error)) return {
                data: {
                    user: null,
                    session: null
                },
                error
            };
            throw error;
        }
    }
    /**
     * Gets the session data from a URL string
     */ async _getSessionFromURL(isPKCEFlow) {
        try {
            if (!(0, _helpers.isBrowser)()) throw new (0, _errors.AuthImplicitGrantRedirectError)("No browser detected.");
            if (this.flowType === "implicit" && !this._isImplicitGrantFlow()) throw new (0, _errors.AuthImplicitGrantRedirectError)("Not a valid implicit grant flow url.");
            else if (this.flowType == "pkce" && !isPKCEFlow) throw new (0, _errors.AuthPKCEGrantCodeExchangeError)("Not a valid PKCE flow url.");
            const params = (0, _helpers.parseParametersFromURL)(window.location.href);
            if (isPKCEFlow) {
                if (!params.code) throw new (0, _errors.AuthPKCEGrantCodeExchangeError)("No code detected.");
                const { data, error } = await this._exchangeCodeForSession(params.code);
                if (error) throw error;
                const url = new URL(window.location.href);
                url.searchParams.delete("code");
                window.history.replaceState(window.history.state, "", url.toString());
                return {
                    data: {
                        session: data.session,
                        redirectType: null
                    },
                    error: null
                };
            }
            if (params.error || params.error_description || params.error_code) throw new (0, _errors.AuthImplicitGrantRedirectError)(params.error_description || "Error in URL with unspecified error_description", {
                error: params.error || "unspecified_error",
                code: params.error_code || "unspecified_code"
            });
            const { provider_token, provider_refresh_token, access_token, refresh_token, expires_in, expires_at, token_type } = params;
            if (!access_token || !expires_in || !refresh_token || !token_type) throw new (0, _errors.AuthImplicitGrantRedirectError)("No session defined in URL");
            const timeNow = Math.round(Date.now() / 1000);
            const expiresIn = parseInt(expires_in);
            let expiresAt = timeNow + expiresIn;
            if (expires_at) expiresAt = parseInt(expires_at);
            const actuallyExpiresIn = expiresAt - timeNow;
            if (actuallyExpiresIn * 1000 <= AUTO_REFRESH_TICK_DURATION) console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${actuallyExpiresIn}s, should have been closer to ${expiresIn}s`);
            const issuedAt = expiresAt - expiresIn;
            if (timeNow - issuedAt >= 120) console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale", issuedAt, expiresAt, timeNow);
            else if (timeNow - issuedAt < 0) console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clok for skew", issuedAt, expiresAt, timeNow);
            const { data, error } = await this._getUser(access_token);
            if (error) throw error;
            const session = {
                provider_token,
                provider_refresh_token,
                access_token,
                expires_in: expiresIn,
                expires_at: expiresAt,
                refresh_token,
                token_type,
                user: data.user
            };
            // Remove tokens from URL
            window.location.hash = "";
            this._debug("#_getSessionFromURL()", "clearing window.location.hash");
            return {
                data: {
                    session,
                    redirectType: params.type
                },
                error: null
            };
        } catch (error) {
            if ((0, _errors.isAuthError)(error)) return {
                data: {
                    session: null,
                    redirectType: null
                },
                error
            };
            throw error;
        }
    }
    /**
     * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)
     */ _isImplicitGrantFlow() {
        const params = (0, _helpers.parseParametersFromURL)(window.location.href);
        return !!((0, _helpers.isBrowser)() && (params.access_token || params.error_description));
    }
    /**
     * Checks if the current URL and backing storage contain parameters given by a PKCE flow
     */ async _isPKCEFlow() {
        const params = (0, _helpers.parseParametersFromURL)(window.location.href);
        const currentStorageContent = await (0, _helpers.getItemAsync)(this.storage, `${this.storageKey}-code-verifier`);
        return !!(params.code && currentStorageContent);
    }
    /**
     * Inside a browser context, `signOut()` will remove the logged in user from the browser session and log them out - removing all items from localstorage and then trigger a `"SIGNED_OUT"` event.
     *
     * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.
     * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.
     *
     * If using `others` scope, no `SIGNED_OUT` event is fired!
     */ async signOut(options = {
        scope: "global"
    }) {
        await this.initializePromise;
        return await this._acquireLock(-1, async ()=>{
            return await this._signOut(options);
        });
    }
    async _signOut({ scope } = {
        scope: "global"
    }) {
        return await this._useSession(async (result)=>{
            var _a;
            const { data, error: sessionError } = result;
            if (sessionError) return {
                error: sessionError
            };
            const accessToken = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token;
            if (accessToken) {
                const { error } = await this.admin.signOut(accessToken, scope);
                if (error) {
                    // ignore 404s since user might not exist anymore
                    // ignore 401s since an invalid or expired JWT should sign out the current session
                    if (!((0, _errors.isAuthApiError)(error) && (error.status === 404 || error.status === 401 || error.status === 403))) return {
                        error
                    };
                }
            }
            if (scope !== "others") {
                await this._removeSession();
                await (0, _helpers.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);
                await this._notifyAllSubscribers("SIGNED_OUT", null);
            }
            return {
                error: null
            };
        });
    }
    /**
     * Receive a notification every time an auth event happens.
     * @param callback A callback function to be invoked when an auth event happens.
     */ onAuthStateChange(callback) {
        const id = (0, _helpers.uuid)();
        const subscription = {
            id,
            callback,
            unsubscribe: ()=>{
                this._debug("#unsubscribe()", "state change callback with id removed", id);
                this.stateChangeEmitters.delete(id);
            }
        };
        this._debug("#onAuthStateChange()", "registered callback with id", id);
        this.stateChangeEmitters.set(id, subscription);
        (async ()=>{
            await this.initializePromise;
            await this._acquireLock(-1, async ()=>{
                this._emitInitialSession(id);
            });
        })();
        return {
            data: {
                subscription
            }
        };
    }
    async _emitInitialSession(id) {
        return await this._useSession(async (result)=>{
            var _a, _b;
            try {
                const { data: { session }, error } = result;
                if (error) throw error;
                await ((_a = this.stateChangeEmitters.get(id)) === null || _a === void 0 ? void 0 : _a.callback("INITIAL_SESSION", session));
                this._debug("INITIAL_SESSION", "callback id", id, "session", session);
            } catch (err) {
                await ((_b = this.stateChangeEmitters.get(id)) === null || _b === void 0 ? void 0 : _b.callback("INITIAL_SESSION", null));
                this._debug("INITIAL_SESSION", "callback id", id, "error", err);
                console.error(err);
            }
        });
    }
    /**
     * Sends a password reset request to an email address. This method supports the PKCE flow.
     *
     * @param email The email address of the user.
     * @param options.redirectTo The URL to send the user to after they click the password reset link.
     * @param options.captchaToken Verification token received when the user completes the captcha on the site.
     */ async resetPasswordForEmail(email, options = {}) {
        let codeChallenge = null;
        let codeChallengeMethod = null;
        if (this.flowType === "pkce") [codeChallenge, codeChallengeMethod] = await (0, _helpers.getCodeChallengeAndMethod)(this.storage, this.storageKey, true // isPasswordRecovery
        );
        try {
            return await (0, _fetch._request)(this.fetch, "POST", `${this.url}/recover`, {
                body: {
                    email,
                    code_challenge: codeChallenge,
                    code_challenge_method: codeChallengeMethod,
                    gotrue_meta_security: {
                        captcha_token: options.captchaToken
                    }
                },
                headers: this.headers,
                redirectTo: options.redirectTo
            });
        } catch (error) {
            if ((0, _errors.isAuthError)(error)) return {
                data: null,
                error
            };
            throw error;
        }
    }
    /**
     * Gets all the identities linked to a user.
     */ async getUserIdentities() {
        var _a;
        try {
            const { data, error } = await this.getUser();
            if (error) throw error;
            return {
                data: {
                    identities: (_a = data.user.identities) !== null && _a !== void 0 ? _a : []
                },
                error: null
            };
        } catch (error) {
            if ((0, _errors.isAuthError)(error)) return {
                data: null,
                error
            };
            throw error;
        }
    }
    /**
     * Links an oauth identity to an existing user.
     * This method supports the PKCE flow.
     */ async linkIdentity(credentials) {
        var _a;
        try {
            const { data, error } = await this._useSession(async (result)=>{
                var _a, _b, _c, _d, _e;
                const { data, error } = result;
                if (error) throw error;
                const url = await this._getUrlForProvider(`${this.url}/user/identities/authorize`, credentials.provider, {
                    redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,
                    scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,
                    queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,
                    skipBrowserRedirect: true
                });
                return await (0, _fetch._request)(this.fetch, "GET", url, {
                    headers: this.headers,
                    jwt: (_e = (_d = data.session) === null || _d === void 0 ? void 0 : _d.access_token) !== null && _e !== void 0 ? _e : undefined
                });
            });
            if (error) throw error;
            if ((0, _helpers.isBrowser)() && !((_a = credentials.options) === null || _a === void 0 ? void 0 : _a.skipBrowserRedirect)) window.location.assign(data === null || data === void 0 ? void 0 : data.url);
            return {
                data: {
                    provider: credentials.provider,
                    url: data === null || data === void 0 ? void 0 : data.url
                },
                error: null
            };
        } catch (error) {
            if ((0, _errors.isAuthError)(error)) return {
                data: {
                    provider: credentials.provider,
                    url: null
                },
                error
            };
            throw error;
        }
    }
    /**
     * Unlinks an identity from a user by deleting it. The user will no longer be able to sign in with that identity once it's unlinked.
     */ async unlinkIdentity(identity) {
        try {
            return await this._useSession(async (result)=>{
                var _a, _b;
                const { data, error } = result;
                if (error) throw error;
                return await (0, _fetch._request)(this.fetch, "DELETE", `${this.url}/user/identities/${identity.identity_id}`, {
                    headers: this.headers,
                    jwt: (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : undefined
                });
            });
        } catch (error) {
            if ((0, _errors.isAuthError)(error)) return {
                data: null,
                error
            };
            throw error;
        }
    }
    /**
     * Generates a new JWT.
     * @param refreshToken A valid refresh token that was returned on login.
     */ async _refreshAccessToken(refreshToken) {
        const debugName = `#_refreshAccessToken(${refreshToken.substring(0, 5)}...)`;
        this._debug(debugName, "begin");
        try {
            const startedAt = Date.now();
            // will attempt to refresh the token with exponential backoff
            return await (0, _helpers.retryable)(async (attempt)=>{
                if (attempt > 0) await (0, _helpers.sleep)(200 * Math.pow(2, attempt - 1)); // 200, 400, 800, ...
                this._debug(debugName, "refreshing attempt", attempt);
                return await (0, _fetch._request)(this.fetch, "POST", `${this.url}/token?grant_type=refresh_token`, {
                    body: {
                        refresh_token: refreshToken
                    },
                    headers: this.headers,
                    xform: (0, _fetch._sessionResponse)
                });
            }, (attempt, error)=>{
                const nextBackOffInterval = 200 * Math.pow(2, attempt);
                return error && (0, _errors.isAuthRetryableFetchError)(error) && // retryable only if the request can be sent before the backoff overflows the tick duration
                Date.now() + nextBackOffInterval - startedAt < AUTO_REFRESH_TICK_DURATION;
            });
        } catch (error) {
            this._debug(debugName, "error", error);
            if ((0, _errors.isAuthError)(error)) return {
                data: {
                    session: null,
                    user: null
                },
                error
            };
            throw error;
        } finally{
            this._debug(debugName, "end");
        }
    }
    _isValidSession(maybeSession) {
        const isValidSession = typeof maybeSession === "object" && maybeSession !== null && "access_token" in maybeSession && "refresh_token" in maybeSession && "expires_at" in maybeSession;
        return isValidSession;
    }
    async _handleProviderSignIn(provider, options) {
        const url = await this._getUrlForProvider(`${this.url}/authorize`, provider, {
            redirectTo: options.redirectTo,
            scopes: options.scopes,
            queryParams: options.queryParams
        });
        this._debug("#_handleProviderSignIn()", "provider", provider, "options", options, "url", url);
        // try to open on the browser
        if ((0, _helpers.isBrowser)() && !options.skipBrowserRedirect) window.location.assign(url);
        return {
            data: {
                provider,
                url
            },
            error: null
        };
    }
    /**
     * Recovers the session from LocalStorage and refreshes
     * Note: this method is async to accommodate for AsyncStorage e.g. in React native.
     */ async _recoverAndRefresh() {
        var _a;
        const debugName = "#_recoverAndRefresh()";
        this._debug(debugName, "begin");
        try {
            const currentSession = await (0, _helpers.getItemAsync)(this.storage, this.storageKey);
            this._debug(debugName, "session from storage", currentSession);
            if (!this._isValidSession(currentSession)) {
                this._debug(debugName, "session is not valid");
                if (currentSession !== null) await this._removeSession();
                return;
            }
            const timeNow = Math.round(Date.now() / 1000);
            const expiresWithMargin = ((_a = currentSession.expires_at) !== null && _a !== void 0 ? _a : Infinity) < timeNow + (0, _constants.EXPIRY_MARGIN);
            this._debug(debugName, `session has${expiresWithMargin ? "" : " not"} expired with margin of ${(0, _constants.EXPIRY_MARGIN)}s`);
            if (expiresWithMargin) {
                if (this.autoRefreshToken && currentSession.refresh_token) {
                    const { error } = await this._callRefreshToken(currentSession.refresh_token);
                    if (error) {
                        console.error(error);
                        if (!(0, _errors.isAuthRetryableFetchError)(error)) {
                            this._debug(debugName, "refresh failed with a non-retryable error, removing the session", error);
                            await this._removeSession();
                        }
                    }
                }
            } else // no need to persist currentSession again, as we just loaded it from
            // local storage; persisting it again may overwrite a value saved by
            // another client with access to the same local storage
            await this._notifyAllSubscribers("SIGNED_IN", currentSession);
        } catch (err) {
            this._debug(debugName, "error", err);
            console.error(err);
            return;
        } finally{
            this._debug(debugName, "end");
        }
    }
    async _callRefreshToken(refreshToken) {
        var _a, _b;
        if (!refreshToken) throw new (0, _errors.AuthSessionMissingError)();
        // refreshing is already in progress
        if (this.refreshingDeferred) return this.refreshingDeferred.promise;
        const debugName = `#_callRefreshToken(${refreshToken.substring(0, 5)}...)`;
        this._debug(debugName, "begin");
        try {
            this.refreshingDeferred = new (0, _helpers.Deferred)();
            const { data, error } = await this._refreshAccessToken(refreshToken);
            if (error) throw error;
            if (!data.session) throw new (0, _errors.AuthSessionMissingError)();
            await this._saveSession(data.session);
            await this._notifyAllSubscribers("TOKEN_REFRESHED", data.session);
            const result = {
                session: data.session,
                error: null
            };
            this.refreshingDeferred.resolve(result);
            return result;
        } catch (error) {
            this._debug(debugName, "error", error);
            if ((0, _errors.isAuthError)(error)) {
                const result = {
                    session: null,
                    error
                };
                if (!(0, _errors.isAuthRetryableFetchError)(error)) {
                    await this._removeSession();
                    await this._notifyAllSubscribers("SIGNED_OUT", null);
                }
                (_a = this.refreshingDeferred) === null || _a === void 0 || _a.resolve(result);
                return result;
            }
            (_b = this.refreshingDeferred) === null || _b === void 0 || _b.reject(error);
            throw error;
        } finally{
            this.refreshingDeferred = null;
            this._debug(debugName, "end");
        }
    }
    async _notifyAllSubscribers(event, session, broadcast = true) {
        const debugName = `#_notifyAllSubscribers(${event})`;
        this._debug(debugName, "begin", session, `broadcast = ${broadcast}`);
        try {
            if (this.broadcastChannel && broadcast) this.broadcastChannel.postMessage({
                event,
                session
            });
            const errors = [];
            const promises = Array.from(this.stateChangeEmitters.values()).map(async (x)=>{
                try {
                    await x.callback(event, session);
                } catch (e) {
                    errors.push(e);
                }
            });
            await Promise.all(promises);
            if (errors.length > 0) {
                for(let i = 0; i < errors.length; i += 1)console.error(errors[i]);
                throw errors[0];
            }
        } finally{
            this._debug(debugName, "end");
        }
    }
    /**
     * set currentSession and currentUser
     * process to _startAutoRefreshToken if possible
     */ async _saveSession(session) {
        this._debug("#_saveSession()", session);
        // _saveSession is always called whenever a new session has been acquired
        // so we can safely suppress the warning returned by future getSession calls
        this.suppressGetSessionWarning = true;
        await (0, _helpers.setItemAsync)(this.storage, this.storageKey, session);
    }
    async _removeSession() {
        this._debug("#_removeSession()");
        await (0, _helpers.removeItemAsync)(this.storage, this.storageKey);
    }
    /**
     * Removes any registered visibilitychange callback.
     *
     * {@see #startAutoRefresh}
     * {@see #stopAutoRefresh}
     */ _removeVisibilityChangedCallback() {
        this._debug("#_removeVisibilityChangedCallback()");
        const callback = this.visibilityChangedCallback;
        this.visibilityChangedCallback = null;
        try {
            if (callback && (0, _helpers.isBrowser)() && (window === null || window === void 0 ? void 0 : window.removeEventListener)) window.removeEventListener("visibilitychange", callback);
        } catch (e) {
            console.error("removing visibilitychange callback failed", e);
        }
    }
    /**
     * This is the private implementation of {@link #startAutoRefresh}. Use this
     * within the library.
     */ async _startAutoRefresh() {
        await this._stopAutoRefresh();
        this._debug("#_startAutoRefresh()");
        const ticker = setInterval(()=>this._autoRefreshTokenTick(), AUTO_REFRESH_TICK_DURATION);
        this.autoRefreshTicker = ticker;
        if (ticker && typeof ticker === "object" && typeof ticker.unref === "function") // ticker is a NodeJS Timeout object that has an `unref` method
        // https://nodejs.org/api/timers.html#timeoutunref
        // When auto refresh is used in NodeJS (like for testing) the
        // `setInterval` is preventing the process from being marked as
        // finished and tests run endlessly. This can be prevented by calling
        // `unref()` on the returned object.
        ticker.unref();
        else if (typeof Deno !== "undefined" && typeof Deno.unrefTimer === "function") // similar like for NodeJS, but with the Deno API
        // https://deno.land/api@latest?unstable&s=Deno.unrefTimer
        // @ts-ignore
        Deno.unrefTimer(ticker);
        // run the tick immediately, but in the next pass of the event loop so that
        // #_initialize can be allowed to complete without recursively waiting on
        // itself
        setTimeout(async ()=>{
            await this.initializePromise;
            await this._autoRefreshTokenTick();
        }, 0);
    }
    /**
     * This is the private implementation of {@link #stopAutoRefresh}. Use this
     * within the library.
     */ async _stopAutoRefresh() {
        this._debug("#_stopAutoRefresh()");
        const ticker = this.autoRefreshTicker;
        this.autoRefreshTicker = null;
        if (ticker) clearInterval(ticker);
    }
    /**
     * Starts an auto-refresh process in the background. The session is checked
     * every few seconds. Close to the time of expiration a process is started to
     * refresh the session. If refreshing fails it will be retried for as long as
     * necessary.
     *
     * If you set the {@link GoTrueClientOptions#autoRefreshToken} you don't need
     * to call this function, it will be called for you.
     *
     * On browsers the refresh process works only when the tab/window is in the
     * foreground to conserve resources as well as prevent race conditions and
     * flooding auth with requests. If you call this method any managed
     * visibility change callback will be removed and you must manage visibility
     * changes on your own.
     *
     * On non-browser platforms the refresh process works *continuously* in the
     * background, which may not be desirable. You should hook into your
     * platform's foreground indication mechanism and call these methods
     * appropriately to conserve resources.
     *
     * {@see #stopAutoRefresh}
     */ async startAutoRefresh() {
        this._removeVisibilityChangedCallback();
        await this._startAutoRefresh();
    }
    /**
     * Stops an active auto refresh process running in the background (if any).
     *
     * If you call this method any managed visibility change callback will be
     * removed and you must manage visibility changes on your own.
     *
     * See {@link #startAutoRefresh} for more details.
     */ async stopAutoRefresh() {
        this._removeVisibilityChangedCallback();
        await this._stopAutoRefresh();
    }
    /**
     * Runs the auto refresh token tick.
     */ async _autoRefreshTokenTick() {
        this._debug("#_autoRefreshTokenTick()", "begin");
        try {
            await this._acquireLock(0, async ()=>{
                try {
                    const now = Date.now();
                    try {
                        return await this._useSession(async (result)=>{
                            const { data: { session } } = result;
                            if (!session || !session.refresh_token || !session.expires_at) {
                                this._debug("#_autoRefreshTokenTick()", "no session");
                                return;
                            }
                            // session will expire in this many ticks (or has already expired if <= 0)
                            const expiresInTicks = Math.floor((session.expires_at * 1000 - now) / AUTO_REFRESH_TICK_DURATION);
                            this._debug("#_autoRefreshTokenTick()", `access token expires in ${expiresInTicks} ticks, a tick lasts ${AUTO_REFRESH_TICK_DURATION}ms, refresh threshold is ${AUTO_REFRESH_TICK_THRESHOLD} ticks`);
                            if (expiresInTicks <= AUTO_REFRESH_TICK_THRESHOLD) await this._callRefreshToken(session.refresh_token);
                        });
                    } catch (e) {
                        console.error("Auto refresh tick failed with error. This is likely a transient error.", e);
                    }
                } finally{
                    this._debug("#_autoRefreshTokenTick()", "end");
                }
            });
        } catch (e) {
            if (e.isAcquireTimeout || e instanceof (0, _locks.LockAcquireTimeoutError)) this._debug("auto refresh token tick lock not available");
            else throw e;
        }
    }
    /**
     * Registers callbacks on the browser / platform, which in-turn run
     * algorithms when the browser window/tab are in foreground. On non-browser
     * platforms it assumes always foreground.
     */ async _handleVisibilityChange() {
        this._debug("#_handleVisibilityChange()");
        if (!(0, _helpers.isBrowser)() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {
            if (this.autoRefreshToken) // in non-browser environments the refresh token ticker runs always
            this.startAutoRefresh();
            return false;
        }
        try {
            this.visibilityChangedCallback = async ()=>await this._onVisibilityChanged(false);
            window === null || window === void 0 || window.addEventListener("visibilitychange", this.visibilityChangedCallback);
            // now immediately call the visbility changed callback to setup with the
            // current visbility state
            await this._onVisibilityChanged(true); // initial call
        } catch (error) {
            console.error("_handleVisibilityChange", error);
        }
    }
    /**
     * Callback registered with `window.addEventListener('visibilitychange')`.
     */ async _onVisibilityChanged(calledFromInitialize) {
        const methodName = `#_onVisibilityChanged(${calledFromInitialize})`;
        this._debug(methodName, "visibilityState", document.visibilityState);
        if (document.visibilityState === "visible") {
            if (this.autoRefreshToken) // in browser environments the refresh token ticker runs only on focused tabs
            // which prevents race conditions
            this._startAutoRefresh();
            if (!calledFromInitialize) {
                // called when the visibility has changed, i.e. the browser
                // transitioned from hidden -> visible so we need to see if the session
                // should be recovered immediately... but to do that we need to acquire
                // the lock first asynchronously
                await this.initializePromise;
                await this._acquireLock(-1, async ()=>{
                    if (document.visibilityState !== "visible") {
                        this._debug(methodName, "acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting");
                        // visibility has changed while waiting for the lock, abort
                        return;
                    }
                    // recover the session
                    await this._recoverAndRefresh();
                });
            }
        } else if (document.visibilityState === "hidden") {
            if (this.autoRefreshToken) this._stopAutoRefresh();
        }
    }
    /**
     * Generates the relevant login URL for a third-party provider.
     * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.
     * @param options.scopes A space-separated list of scopes granted to the OAuth application.
     * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.
     */ async _getUrlForProvider(url, provider, options) {
        const urlParams = [
            `provider=${encodeURIComponent(provider)}`
        ];
        if (options === null || options === void 0 ? void 0 : options.redirectTo) urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);
        if (options === null || options === void 0 ? void 0 : options.scopes) urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);
        if (this.flowType === "pkce") {
            const [codeChallenge, codeChallengeMethod] = await (0, _helpers.getCodeChallengeAndMethod)(this.storage, this.storageKey);
            const flowParams = new URLSearchParams({
                code_challenge: `${encodeURIComponent(codeChallenge)}`,
                code_challenge_method: `${encodeURIComponent(codeChallengeMethod)}`
            });
            urlParams.push(flowParams.toString());
        }
        if (options === null || options === void 0 ? void 0 : options.queryParams) {
            const query = new URLSearchParams(options.queryParams);
            urlParams.push(query.toString());
        }
        if (options === null || options === void 0 ? void 0 : options.skipBrowserRedirect) urlParams.push(`skip_http_redirect=${options.skipBrowserRedirect}`);
        return `${url}?${urlParams.join("&")}`;
    }
    async _unenroll(params) {
        try {
            return await this._useSession(async (result)=>{
                var _a;
                const { data: sessionData, error: sessionError } = result;
                if (sessionError) return {
                    data: null,
                    error: sessionError
                };
                return await (0, _fetch._request)(this.fetch, "DELETE", `${this.url}/factors/${params.factorId}`, {
                    headers: this.headers,
                    jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token
                });
            });
        } catch (error) {
            if ((0, _errors.isAuthError)(error)) return {
                data: null,
                error
            };
            throw error;
        }
    }
    /**
     * {@see GoTrueMFAApi#enroll}
     */ async _enroll(params) {
        try {
            return await this._useSession(async (result)=>{
                var _a, _b;
                const { data: sessionData, error: sessionError } = result;
                if (sessionError) return {
                    data: null,
                    error: sessionError
                };
                const { data, error } = await (0, _fetch._request)(this.fetch, "POST", `${this.url}/factors`, {
                    body: {
                        friendly_name: params.friendlyName,
                        factor_type: params.factorType,
                        issuer: params.issuer
                    },
                    headers: this.headers,
                    jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token
                });
                if (error) return {
                    data: null,
                    error
                };
                if ((_b = data === null || data === void 0 ? void 0 : data.totp) === null || _b === void 0 ? void 0 : _b.qr_code) data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`;
                return {
                    data,
                    error: null
                };
            });
        } catch (error) {
            if ((0, _errors.isAuthError)(error)) return {
                data: null,
                error
            };
            throw error;
        }
    }
    /**
     * {@see GoTrueMFAApi#verify}
     */ async _verify(params) {
        return this._acquireLock(-1, async ()=>{
            try {
                return await this._useSession(async (result)=>{
                    var _a;
                    const { data: sessionData, error: sessionError } = result;
                    if (sessionError) return {
                        data: null,
                        error: sessionError
                    };
                    const { data, error } = await (0, _fetch._request)(this.fetch, "POST", `${this.url}/factors/${params.factorId}/verify`, {
                        body: {
                            code: params.code,
                            challenge_id: params.challengeId
                        },
                        headers: this.headers,
                        jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token
                    });
                    if (error) return {
                        data: null,
                        error
                    };
                    await this._saveSession(Object.assign({
                        expires_at: Math.round(Date.now() / 1000) + data.expires_in
                    }, data));
                    await this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED", data);
                    return {
                        data,
                        error
                    };
                });
            } catch (error) {
                if ((0, _errors.isAuthError)(error)) return {
                    data: null,
                    error
                };
                throw error;
            }
        });
    }
    /**
     * {@see GoTrueMFAApi#challenge}
     */ async _challenge(params) {
        return this._acquireLock(-1, async ()=>{
            try {
                return await this._useSession(async (result)=>{
                    var _a;
                    const { data: sessionData, error: sessionError } = result;
                    if (sessionError) return {
                        data: null,
                        error: sessionError
                    };
                    return await (0, _fetch._request)(this.fetch, "POST", `${this.url}/factors/${params.factorId}/challenge`, {
                        headers: this.headers,
                        jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token
                    });
                });
            } catch (error) {
                if ((0, _errors.isAuthError)(error)) return {
                    data: null,
                    error
                };
                throw error;
            }
        });
    }
    /**
     * {@see GoTrueMFAApi#challengeAndVerify}
     */ async _challengeAndVerify(params) {
        // both _challenge and _verify independently acquire the lock, so no need
        // to acquire it here
        const { data: challengeData, error: challengeError } = await this._challenge({
            factorId: params.factorId
        });
        if (challengeError) return {
            data: null,
            error: challengeError
        };
        return await this._verify({
            factorId: params.factorId,
            challengeId: challengeData.id,
            code: params.code
        });
    }
    /**
     * {@see GoTrueMFAApi#listFactors}
     */ async _listFactors() {
        // use #getUser instead of #_getUser as the former acquires a lock
        const { data: { user }, error: userError } = await this.getUser();
        if (userError) return {
            data: null,
            error: userError
        };
        const factors = (user === null || user === void 0 ? void 0 : user.factors) || [];
        const totp = factors.filter((factor)=>factor.factor_type === "totp" && factor.status === "verified");
        return {
            data: {
                all: factors,
                totp
            },
            error: null
        };
    }
    /**
     * {@see GoTrueMFAApi#getAuthenticatorAssuranceLevel}
     */ async _getAuthenticatorAssuranceLevel() {
        return this._acquireLock(-1, async ()=>{
            return await this._useSession(async (result)=>{
                var _a, _b;
                const { data: { session }, error: sessionError } = result;
                if (sessionError) return {
                    data: null,
                    error: sessionError
                };
                if (!session) return {
                    data: {
                        currentLevel: null,
                        nextLevel: null,
                        currentAuthenticationMethods: []
                    },
                    error: null
                };
                const payload = this._decodeJWT(session.access_token);
                let currentLevel = null;
                if (payload.aal) currentLevel = payload.aal;
                let nextLevel = currentLevel;
                const verifiedFactors = (_b = (_a = session.user.factors) === null || _a === void 0 ? void 0 : _a.filter((factor)=>factor.status === "verified")) !== null && _b !== void 0 ? _b : [];
                if (verifiedFactors.length > 0) nextLevel = "aal2";
                const currentAuthenticationMethods = payload.amr || [];
                return {
                    data: {
                        currentLevel,
                        nextLevel,
                        currentAuthenticationMethods
                    },
                    error: null
                };
            });
        });
    }
}
exports.default = GoTrueClient;
GoTrueClient.nextInstanceID = 0;

},{"./GoTrueAdminApi":"21Azt","./lib/constants":"ja2Dg","./lib/errors":"3HhMS","./lib/fetch":"eYrde","./lib/helpers":"2kQpc","./lib/local-storage":"2M47F","./lib/polyfills":"13vvu","./lib/version":"hxRK8","./lib/locks":"enUQ5","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"2M47F":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "localStorageAdapter", ()=>localStorageAdapter);
/**
 * Returns a localStorage-like object that stores the key-value pairs in
 * memory.
 */ parcelHelpers.export(exports, "memoryLocalStorageAdapter", ()=>memoryLocalStorageAdapter);
var _helpers = require("./helpers");
const localStorageAdapter = {
    getItem: (key)=>{
        if (!(0, _helpers.supportsLocalStorage)()) return null;
        return globalThis.localStorage.getItem(key);
    },
    setItem: (key, value)=>{
        if (!(0, _helpers.supportsLocalStorage)()) return;
        globalThis.localStorage.setItem(key, value);
    },
    removeItem: (key)=>{
        if (!(0, _helpers.supportsLocalStorage)()) return;
        globalThis.localStorage.removeItem(key);
    }
};
function memoryLocalStorageAdapter(store = {}) {
    return {
        getItem: (key)=>{
            return store[key] || null;
        },
        setItem: (key, value)=>{
            store[key] = value;
        },
        removeItem: (key)=>{
            delete store[key];
        }
    };
}

},{"./helpers":"2kQpc","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"13vvu":[function(require,module,exports) {
/**
 * https://mathiasbynens.be/notes/globalthis
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "polyfillGlobalThis", ()=>polyfillGlobalThis);
function polyfillGlobalThis() {
    if (typeof globalThis === "object") return;
    try {
        Object.defineProperty(Object.prototype, "__magic__", {
            get: function() {
                return this;
            },
            configurable: true
        });
        // @ts-expect-error 'Allow access to magic'
        __magic__.globalThis = __magic__;
        // @ts-expect-error 'Allow access to magic'
        delete Object.prototype.__magic__;
    } catch (e) {
        if (typeof self !== "undefined") // @ts-expect-error 'Allow access to globals'
        self.globalThis = self;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"enUQ5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "internals", ()=>internals);
/**
 * An error thrown when a lock cannot be acquired after some amount of time.
 *
 * Use the {@link #isAcquireTimeout} property instead of checking with `instanceof`.
 */ parcelHelpers.export(exports, "LockAcquireTimeoutError", ()=>LockAcquireTimeoutError);
parcelHelpers.export(exports, "NavigatorLockAcquireTimeoutError", ()=>NavigatorLockAcquireTimeoutError);
/**
 * Implements a global exclusive lock using the Navigator LockManager API. It
 * is available on all browsers released after 2022-03-15 with Safari being the
 * last one to release support. If the API is not available, this function will
 * throw. Make sure you check availablility before configuring {@link
 * GoTrueClient}.
 *
 * You can turn on debugging by setting the `supabase.gotrue-js.locks.debug`
 * local storage item to `true`.
 *
 * Internals:
 *
 * Since the LockManager API does not preserve stack traces for the async
 * function passed in the `request` method, a trick is used where acquiring the
 * lock releases a previously started promise to run the operation in the `fn`
 * function. The lock waits for that promise to finish (with or without error),
 * while the function will finally wait for the result anyway.
 *
 * @param name Name of the lock to be acquired.
 * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if
 *                       the lock can't be acquired without waiting. If positive, the lock acquire
 *                       will time out after so many milliseconds. An error is
 *                       a timeout if it has `isAcquireTimeout` set to true.
 * @param fn The operation to run once the lock is acquired.
 */ parcelHelpers.export(exports, "navigatorLock", ()=>navigatorLock);
var _helpers = require("./helpers");
const internals = {
    /**
     * @experimental
     */ debug: !!(globalThis && (0, _helpers.supportsLocalStorage)() && globalThis.localStorage && globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug") === "true")
};
class LockAcquireTimeoutError extends Error {
    constructor(message){
        super(message);
        this.isAcquireTimeout = true;
    }
}
class NavigatorLockAcquireTimeoutError extends LockAcquireTimeoutError {
}
async function navigatorLock(name, acquireTimeout, fn) {
    if (internals.debug) console.log("@supabase/gotrue-js: navigatorLock: acquire lock", name, acquireTimeout);
    const abortController = new globalThis.AbortController();
    if (acquireTimeout > 0) setTimeout(()=>{
        abortController.abort();
        if (internals.debug) console.log("@supabase/gotrue-js: navigatorLock acquire timed out", name);
    }, acquireTimeout);
    // MDN article: https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request
    return await globalThis.navigator.locks.request(name, acquireTimeout === 0 ? {
        mode: "exclusive",
        ifAvailable: true
    } : {
        mode: "exclusive",
        signal: abortController.signal
    }, async (lock)=>{
        if (lock) {
            if (internals.debug) console.log("@supabase/gotrue-js: navigatorLock: acquired", name, lock.name);
            try {
                return await fn();
            } finally{
                if (internals.debug) console.log("@supabase/gotrue-js: navigatorLock: released", name, lock.name);
            }
        } else if (acquireTimeout === 0) {
            if (internals.debug) console.log("@supabase/gotrue-js: navigatorLock: not immediately available", name);
            throw new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock "${name}" immediately failed`);
        } else {
            if (internals.debug) try {
                const result = await globalThis.navigator.locks.query();
                console.log("@supabase/gotrue-js: Navigator LockManager state", JSON.stringify(result, null, "  "));
            } catch (e) {
                console.warn("@supabase/gotrue-js: Error when querying Navigator LockManager state", e);
            }
            // Browser is not following the Navigator LockManager spec, it
            // returned a null lock when we didn't use ifAvailable. So we can
            // pretend the lock is acquired in the name of backward compatibility
            // and user experience and just run the function.
            console.warn("@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request");
            return await fn();
        }
    });
}

},{"./helpers":"2kQpc","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"220Qq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _goTrueAdminApi = require("./GoTrueAdminApi");
var _goTrueAdminApiDefault = parcelHelpers.interopDefault(_goTrueAdminApi);
const AuthAdminApi = (0, _goTrueAdminApiDefault.default);
exports.default = AuthAdminApi;

},{"./GoTrueAdminApi":"21Azt","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"741DW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _goTrueClient = require("./GoTrueClient");
var _goTrueClientDefault = parcelHelpers.interopDefault(_goTrueClient);
const AuthClient = (0, _goTrueClientDefault.default);
exports.default = AuthClient;

},{"./GoTrueClient":"1GHqN","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"goPpM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"6QCW4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "localStorage", ()=>localStorage);
parcelHelpers.export(exports, "generateRandomID", ()=>generateRandomID);
parcelHelpers.export(exports, "errorMessage", ()=>errorMessage);
parcelHelpers.export(exports, "getHostnameWithoutSubdomain", ()=>getHostnameWithoutSubdomain);
var _storage = require("@plasmohq/storage");
const localStorage = ()=>new (0, _storage.Storage)({
        area: "local"
    });
const generateRandomID = (length = 20)=>{
    const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    let result = "";
    for(let i = 0; i < length; i++)result += characters.charAt(Math.floor(Math.random() * characters.length));
    return result;
};
const errorMessage = (err, fallback)=>typeof err === "string" ? err : fallback ?? "Something went wrong";
const getHostnameWithoutSubdomain = (url)=>{
    const multiPartTLDs = [
        "co.uk",
        "gov.uk",
        "ac.uk",
        "com.au",
        "edu.au",
        "gov.au",
        "co.jp",
        "or.jp",
        "co.in",
        "net.in"
    ];
    const hostname = new URL(url).hostname;
    const parts = hostname.split(".");
    const matchTLD = multiPartTLDs.find((tld)=>hostname.endsWith(tld));
    if (matchTLD) return parts.slice(-matchTLD.split(".").length - 1).join(".");
    return parts.length <= 2 ? hostname : parts.slice(-2).join(".");
};

},{"@plasmohq/storage":"i0YkM","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"i0YkM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BaseStorage", ()=>o);
parcelHelpers.export(exports, "Storage", ()=>g);
var _pify = require("pify");
var _pifyDefault = parcelHelpers.interopDefault(_pify);
var l = ()=>{
    try {
        let e = globalThis.navigator?.userAgent.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
        if (e[1] === "Chrome") return parseInt(e[2]) < 100 || globalThis.chrome.runtime?.getManifest()?.manifest_version === 2;
    } catch  {
        return !1;
    }
    return !1;
};
var o = class {
    #r;
    #e;
    get primaryClient() {
        return this.#e;
    }
    #t;
    get secondaryClient() {
        return this.#t;
    }
    #a;
    get area() {
        return this.#a;
    }
    get hasWebApi() {
        try {
            return typeof window < "u" && !!window.localStorage;
        } catch (e) {
            return console.error(e), !1;
        }
    }
    #s = new Map;
    #i;
    get copiedKeySet() {
        return this.#i;
    }
    isCopied = (e)=>this.hasWebApi && (this.allCopied || this.copiedKeySet.has(e));
    #n = !1;
    get allCopied() {
        return this.#n;
    }
    getExtStorageApi = ()=>globalThis.browser?.storage || globalThis.chrome?.storage;
    get hasExtensionApi() {
        try {
            return !!this.getExtStorageApi();
        } catch (e) {
            return console.error(e), !1;
        }
    }
    isWatchSupported = ()=>this.hasExtensionApi;
    keyNamespace = "";
    isValidKey = (e)=>e.startsWith(this.keyNamespace);
    getNamespacedKey = (e)=>`${this.keyNamespace}${e}`;
    getUnnamespacedKey = (e)=>e.slice(this.keyNamespace.length);
    serde = {
        serializer: JSON.stringify,
        deserializer: JSON.parse
    };
    constructor({ area: e = "sync", allCopied: t = !1, copiedKeyList: s = [], serde: r = {} } = {}){
        this.setCopiedKeySet(s), this.#a = e, this.#n = t, this.serde = {
            ...this.serde,
            ...r
        };
        try {
            this.hasWebApi && (t || s.length > 0) && (this.#t = window.localStorage);
        } catch  {}
        try {
            this.hasExtensionApi && (this.#r = this.getExtStorageApi(), l() ? this.#e = (0, _pifyDefault.default)(this.#r[this.area], {
                exclude: [
                    "getBytesInUse"
                ],
                errorFirst: !1
            }) : this.#e = this.#r[this.area]);
        } catch  {}
    }
    setCopiedKeySet(e) {
        this.#i = new Set(e);
    }
    rawGetAll = ()=>this.#e?.get();
    getAll = async ()=>{
        let e = await this.rawGetAll();
        return Object.entries(e).filter(([t])=>this.isValidKey(t)).reduce((t, [s, r])=>(t[this.getUnnamespacedKey(s)] = r, t), {});
    };
    copy = async (e)=>{
        let t = e === void 0;
        if (!t && !this.copiedKeySet.has(e) || !this.allCopied || !this.hasExtensionApi) return !1;
        let s = this.allCopied ? await this.rawGetAll() : await this.#e.get((t ? [
            ...this.copiedKeySet
        ] : [
            e
        ]).map(this.getNamespacedKey));
        if (!s) return !1;
        let r = !1;
        for(let a in s){
            let i = s[a], n = this.#t?.getItem(a);
            this.#t?.setItem(a, i), r ||= i !== n;
        }
        return r;
    };
    rawGet = async (e)=>this.hasExtensionApi ? (await this.#e.get(e))[e] : this.isCopied(e) ? this.#t?.getItem(e) : null;
    rawSet = async (e, t)=>(this.isCopied(e) && this.#t?.setItem(e, t), this.hasExtensionApi && await this.#e.set({
            [e]: t
        }), null);
    clear = async (e = !1)=>{
        e && this.#t?.clear(), await this.#e.clear();
    };
    rawRemove = async (e)=>{
        this.isCopied(e) && this.#t?.removeItem(e), this.hasExtensionApi && await this.#e.remove(e);
    };
    removeAll = async ()=>{
        let e = await this.getAll(), t = Object.keys(e);
        await Promise.all(t.map(this.remove));
    };
    watch = (e)=>{
        let t = this.isWatchSupported();
        return t && this.#o(e), t;
    };
    #o = (e)=>{
        for(let t in e){
            let s = this.getNamespacedKey(t), r = this.#s.get(s)?.callbackSet || new Set;
            if (r.add(e[t]), r.size > 1) continue;
            let a = (i, n)=>{
                if (n !== this.area || !i[s]) return;
                let h = this.#s.get(s);
                if (!h) throw new Error(`Storage comms does not exist for nsKey: ${s}`);
                Promise.all([
                    this.parseValue(i[s].newValue),
                    this.parseValue(i[s].oldValue)
                ]).then(([p, d])=>{
                    for (let m of h.callbackSet)m({
                        newValue: p,
                        oldValue: d
                    }, n);
                });
            };
            this.#r.onChanged.addListener(a), this.#s.set(s, {
                callbackSet: r,
                listener: a
            });
        }
    };
    unwatch = (e)=>{
        let t = this.isWatchSupported();
        return t && this.#c(e), t;
    };
    #c(e) {
        for(let t in e){
            let s = this.getNamespacedKey(t), r = e[t], a = this.#s.get(s);
            a && (a.callbackSet.delete(r), a.callbackSet.size === 0 && (this.#s.delete(s), this.#r.onChanged.removeListener(a.listener)));
        }
    }
    unwatchAll = ()=>this.#h();
    #h() {
        this.#s.forEach(({ listener: e })=>this.#r.onChanged.removeListener(e)), this.#s.clear();
    }
    async getItem(e) {
        return this.get(e);
    }
    async setItem(e, t) {
        await this.set(e, t);
    }
    async removeItem(e) {
        return this.remove(e);
    }
}, g = class extends o {
    get = async (e)=>{
        let t = this.getNamespacedKey(e), s = await this.rawGet(t);
        return this.parseValue(s);
    };
    set = async (e, t)=>{
        let s = this.getNamespacedKey(e), r = this.serde.serializer(t);
        return this.rawSet(s, r);
    };
    remove = async (e)=>{
        let t = this.getNamespacedKey(e);
        return this.rawRemove(t);
    };
    setNamespace = (e)=>{
        this.keyNamespace = e;
    };
    parseValue = async (e)=>{
        try {
            if (e !== void 0) return this.serde.deserializer(e);
        } catch (t) {
            console.error(t);
        }
    };
};

},{"pify":"6Hkib","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"6Hkib":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>pify);
const processFunction = (function_, options, proxy, unwrapped)=>function(...arguments_) {
        const P = options.promiseModule;
        return new P((resolve, reject)=>{
            if (options.multiArgs) arguments_.push((...result)=>{
                if (options.errorFirst) {
                    if (result[0]) reject(result);
                    else {
                        result.shift();
                        resolve(result);
                    }
                } else resolve(result);
            });
            else if (options.errorFirst) arguments_.push((error, result)=>{
                if (error) reject(error);
                else resolve(result);
            });
            else arguments_.push(resolve);
            const self = this === proxy ? unwrapped : this;
            Reflect.apply(function_, self, arguments_);
        });
    };
const filterCache = new WeakMap();
function pify(input, options) {
    options = {
        exclude: [
            /.+(?:Sync|Stream)$/
        ],
        errorFirst: true,
        promiseModule: Promise,
        ...options
    };
    const objectType = typeof input;
    if (!(input !== null && (objectType === "object" || objectType === "function"))) throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${input === null ? "null" : objectType}\``);
    const filter = (target, key)=>{
        let cached = filterCache.get(target);
        if (!cached) {
            cached = {};
            filterCache.set(target, cached);
        }
        if (key in cached) return cached[key];
        const match = (pattern)=>typeof pattern === "string" || typeof key === "symbol" ? key === pattern : pattern.test(key);
        const descriptor = Reflect.getOwnPropertyDescriptor(target, key);
        const writableOrConfigurableOwn = descriptor === undefined || descriptor.writable || descriptor.configurable;
        const included = options.include ? options.include.some((element)=>match(element)) : !options.exclude.some((element)=>match(element));
        const shouldFilter = included && writableOrConfigurableOwn;
        cached[key] = shouldFilter;
        return shouldFilter;
    };
    const cache = new WeakMap();
    const proxy = new Proxy(input, {
        apply (target, thisArg, args) {
            const cached = cache.get(target);
            if (cached) return Reflect.apply(cached, thisArg, args);
            const pified = options.excludeMain ? target : processFunction(target, options, proxy, target);
            cache.set(target, pified);
            return Reflect.apply(pified, thisArg, args);
        },
        get (target, key) {
            const property = target[key];
            // eslint-disable-next-line no-use-extend-native/no-use-extend-native
            if (!filter(target, key) || property === Function.prototype[key]) return property;
            const cached = cache.get(property);
            if (cached) return cached;
            if (typeof property === "function") {
                const pified = processFunction(property, options, proxy, target);
                cache.set(property, pified);
                return pified;
            }
            return property;
        }
    });
    return proxy;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"leaNT":[function(require,module,exports) {
var _supabase = require("~lib/supabase");
chrome.runtime.onInstalled.addListener(async (details)=>{
    const { data, error } = await (0, _supabase.supabase).auth.getSession();
    console.log("Auth session:", data);
    if (!data.session) chrome.runtime.openOptionsPage();
    if (error) console.error(error);
});

},{"~lib/supabase":"fE3ox"}]},["3YyNe","8oeFb"], "8oeFb", "parcelRequireb337")

//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RSxDQUFDLEdBQUUsR0FBRSxHQUFFO0lBQUssSUFBRyxLQUFHLE9BQU8sS0FBRyxZQUFVLE9BQU8sS0FBRyxZQUFXLEtBQUksSUFBSSxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsS0FBSyxHQUFFLE1BQUksTUFBSSxLQUFHLEVBQUUsR0FBRSxHQUFFO1FBQUMsS0FBSSxJQUFJLENBQUMsQ0FBQyxFQUFFO1FBQUMsWUFBVyxDQUFFLENBQUEsSUFBRSxHQUFHLEdBQUUsRUFBQyxLQUFJLEVBQUU7SUFBVTtJQUFHLE9BQU87QUFBQyxHQUFFLElBQUUsQ0FBQyxHQUFFLEdBQUUsSUFBSyxDQUFBLEVBQUUsR0FBRSxHQUFFLFlBQVcsS0FBRyxFQUFFLEdBQUUsR0FBRSxVQUFTLEdBQUcsSUFBRSxDQUFDLEdBQUUsR0FBRSxJQUFLLENBQUEsSUFBRSxLQUFHLE9BQUssR0FBRyxHQUFHLE1BQUksQ0FBQyxHQUFFLEVBQUUsS0FBRyxDQUFDLEtBQUcsQ0FBQyxFQUFFLGFBQVcsRUFBRSxHQUFFLFdBQVU7UUFBQyxPQUFNO1FBQUUsWUFBVyxDQUFDO0lBQUMsS0FBRyxHQUFFLEVBQUMsR0FBRyxLQUFHLENBQUEsSUFBRyxFQUFFLEVBQUUsQ0FBQyxHQUFFLGNBQWE7UUFBQyxPQUFNLENBQUM7SUFBQyxJQUFHO0FBQUcsSUFBSSxJQUFFLEVBQUUsQ0FBQTtJQUFJO0lBQWEsRUFBRSxhQUFXO0lBQUcsRUFBRSxjQUFZO0lBQUcsRUFBRSxnQkFBYztJQUFHLElBQUksSUFBRSxFQUFFLEVBQUMsSUFBRSxFQUFFLEVBQUMsS0FBRyxPQUFPLGFBQVcsTUFBSSxhQUFXLE9BQU0sSUFBRTtJQUFtRSxJQUFJLElBQUUsR0FBRSxJQUFFLEVBQUUsUUFBTyxJQUFFLEdBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBRSxXQUFXLEdBQUcsR0FBQztJQUFFLElBQUksR0FBRTtJQUFFLENBQUMsQ0FBQyxJQUFJLFdBQVcsR0FBRyxHQUFDO0lBQUcsQ0FBQyxDQUFDLElBQUksV0FBVyxHQUFHLEdBQUM7SUFBRyxTQUFTLEVBQUUsQ0FBQztRQUFFLElBQUksSUFBRSxFQUFFO1FBQU8sSUFBRyxJQUFFLElBQUUsR0FBRSxNQUFNLElBQUksTUFBTTtRQUFrRCxJQUFJLElBQUUsRUFBRSxRQUFRO1FBQUssTUFBSSxNQUFLLENBQUEsSUFBRSxDQUFBO1FBQUcsSUFBSSxJQUFFLE1BQUksSUFBRSxJQUFFLElBQUUsSUFBRTtRQUFFLE9BQU07WUFBQztZQUFFO1NBQUU7SUFBQTtJQUFDLFNBQVMsR0FBRyxDQUFDO1FBQUUsSUFBSSxJQUFFLEVBQUUsSUFBRyxJQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUMsSUFBRSxDQUFDLENBQUMsRUFBRTtRQUFDLE9BQU0sQUFBQyxDQUFBLElBQUUsQ0FBQSxJQUFHLElBQUUsSUFBRTtJQUFDO0lBQUMsU0FBUyxHQUFHLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLE9BQU0sQUFBQyxDQUFBLElBQUUsQ0FBQSxJQUFHLElBQUUsSUFBRTtJQUFDO0lBQUMsU0FBUyxHQUFHLENBQUM7UUFBRSxJQUFJLEdBQUUsSUFBRSxFQUFFLElBQUcsSUFBRSxDQUFDLENBQUMsRUFBRSxFQUFDLElBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBQyxJQUFFLElBQUksR0FBRyxHQUFHLEdBQUUsR0FBRSxLQUFJLElBQUUsR0FBRSxJQUFFLElBQUUsSUFBRSxJQUFFLElBQUUsR0FBRTtRQUFFLElBQUksSUFBRSxHQUFFLElBQUUsR0FBRSxLQUFHLEVBQUUsSUFBRSxDQUFDLENBQUMsRUFBRSxXQUFXLEdBQUcsSUFBRSxLQUFHLENBQUMsQ0FBQyxFQUFFLFdBQVcsSUFBRSxHQUFHLElBQUUsS0FBRyxDQUFDLENBQUMsRUFBRSxXQUFXLElBQUUsR0FBRyxJQUFFLElBQUUsQ0FBQyxDQUFDLEVBQUUsV0FBVyxJQUFFLEdBQUcsRUFBQyxDQUFDLENBQUMsSUFBSSxHQUFDLEtBQUcsS0FBRyxLQUFJLENBQUMsQ0FBQyxJQUFJLEdBQUMsS0FBRyxJQUFFLEtBQUksQ0FBQyxDQUFDLElBQUksR0FBQyxJQUFFO1FBQUksT0FBTyxNQUFJLEtBQUksQ0FBQSxJQUFFLENBQUMsQ0FBQyxFQUFFLFdBQVcsR0FBRyxJQUFFLElBQUUsQ0FBQyxDQUFDLEVBQUUsV0FBVyxJQUFFLEdBQUcsSUFBRSxHQUFFLENBQUMsQ0FBQyxJQUFJLEdBQUMsSUFBRSxHQUFFLEdBQUcsTUFBSSxLQUFJLENBQUEsSUFBRSxDQUFDLENBQUMsRUFBRSxXQUFXLEdBQUcsSUFBRSxLQUFHLENBQUMsQ0FBQyxFQUFFLFdBQVcsSUFBRSxHQUFHLElBQUUsSUFBRSxDQUFDLENBQUMsRUFBRSxXQUFXLElBQUUsR0FBRyxJQUFFLEdBQUUsQ0FBQyxDQUFDLElBQUksR0FBQyxLQUFHLElBQUUsS0FBSSxDQUFDLENBQUMsSUFBSSxHQUFDLElBQUUsR0FBRSxHQUFHO0lBQUM7SUFBQyxTQUFTLEdBQUcsQ0FBQztRQUFFLE9BQU8sQ0FBQyxDQUFDLEtBQUcsS0FBRyxHQUFHLEdBQUMsQ0FBQyxDQUFDLEtBQUcsS0FBRyxHQUFHLEdBQUMsQ0FBQyxDQUFDLEtBQUcsSUFBRSxHQUFHLEdBQUMsQ0FBQyxDQUFDLElBQUUsR0FBRztJQUFBO0lBQUMsU0FBUyxHQUFHLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLElBQUksSUFBSSxHQUFFLElBQUUsRUFBRSxFQUFDLElBQUUsR0FBRSxJQUFFLEdBQUUsS0FBRyxFQUFFLElBQUUsQUFBQyxDQUFBLENBQUMsQ0FBQyxFQUFFLElBQUUsS0FBRyxRQUFPLElBQUksQ0FBQSxDQUFDLENBQUMsSUFBRSxFQUFFLElBQUUsSUFBRSxLQUFJLElBQUksQ0FBQSxDQUFDLENBQUMsSUFBRSxFQUFFLEdBQUMsR0FBRSxHQUFHLEVBQUUsS0FBSyxHQUFHO1FBQUksT0FBTyxFQUFFLEtBQUs7SUFBRztJQUFDLFNBQVMsR0FBRyxDQUFDO1FBQUUsSUFBSSxJQUFJLEdBQUUsSUFBRSxFQUFFLFFBQU8sSUFBRSxJQUFFLEdBQUUsSUFBRSxFQUFFLEVBQUMsSUFBRSxPQUFNLElBQUUsR0FBRSxJQUFFLElBQUUsR0FBRSxJQUFFLEdBQUUsS0FBRyxFQUFFLEVBQUUsS0FBSyxHQUFHLEdBQUUsR0FBRSxJQUFFLElBQUUsSUFBRSxJQUFFLElBQUU7UUFBSSxPQUFPLE1BQUksSUFBRyxDQUFBLElBQUUsQ0FBQyxDQUFDLElBQUUsRUFBRSxFQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsS0FBRyxFQUFFLEdBQUMsQ0FBQyxDQUFDLEtBQUcsSUFBRSxHQUFHLEdBQUMsS0FBSSxJQUFHLE1BQUksS0FBSSxDQUFBLElBQUUsQUFBQyxDQUFBLENBQUMsQ0FBQyxJQUFFLEVBQUUsSUFBRSxDQUFBLElBQUcsQ0FBQyxDQUFDLElBQUUsRUFBRSxFQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsS0FBRyxHQUFHLEdBQUMsQ0FBQyxDQUFDLEtBQUcsSUFBRSxHQUFHLEdBQUMsQ0FBQyxDQUFDLEtBQUcsSUFBRSxHQUFHLEdBQUMsSUFBRyxHQUFHLEVBQUUsS0FBSztJQUFHO0FBQUM7QUFBRyxJQUFJLElBQUUsRUFBRSxDQUFBO0lBQUksRUFBRSxPQUFLLFNBQVMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxJQUFJLEdBQUUsR0FBRSxJQUFFLElBQUUsSUFBRSxJQUFFLEdBQUUsSUFBRSxBQUFDLENBQUEsS0FBRyxDQUFBLElBQUcsR0FBRSxJQUFFLEtBQUcsR0FBRSxJQUFFLElBQUcsSUFBRSxJQUFFLElBQUUsSUFBRSxHQUFFLElBQUUsSUFBRSxLQUFHLEdBQUUsSUFBRSxDQUFDLENBQUMsSUFBRSxFQUFFO1FBQUMsSUFBSSxLQUFHLEdBQUUsSUFBRSxJQUFFLEFBQUMsQ0FBQSxLQUFHLENBQUMsQ0FBQSxJQUFHLEdBQUUsTUFBSSxDQUFDLEdBQUUsS0FBRyxHQUFFLElBQUUsR0FBRSxJQUFFLElBQUUsTUFBSSxDQUFDLENBQUMsSUFBRSxFQUFFLEVBQUMsS0FBRyxHQUFFLEtBQUc7UUFBRyxJQUFJLElBQUUsSUFBRSxBQUFDLENBQUEsS0FBRyxDQUFDLENBQUEsSUFBRyxHQUFFLE1BQUksQ0FBQyxHQUFFLEtBQUcsR0FBRSxJQUFFLEdBQUUsSUFBRSxJQUFFLE1BQUksQ0FBQyxDQUFDLElBQUUsRUFBRSxFQUFDLEtBQUcsR0FBRSxLQUFHO1FBQUcsSUFBRyxNQUFJLEdBQUUsSUFBRSxJQUFFO2FBQU07WUFBQyxJQUFHLE1BQUksR0FBRSxPQUFPLElBQUUsTUFBSSxBQUFDLENBQUEsSUFBRSxLQUFHLENBQUEsSUFBSSxDQUFBLElBQUUsQ0FBQTtZQUFHLElBQUUsSUFBRSxLQUFLLElBQUksR0FBRSxJQUFHLElBQUUsSUFBRTtRQUFDO1FBQUMsT0FBTSxBQUFDLENBQUEsSUFBRSxLQUFHLENBQUEsSUFBRyxJQUFFLEtBQUssSUFBSSxHQUFFLElBQUU7SUFBRTtJQUFFLEVBQUUsUUFBTSxTQUFTLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLElBQUksR0FBRSxHQUFFLEdBQUUsSUFBRSxJQUFFLElBQUUsSUFBRSxHQUFFLElBQUUsQUFBQyxDQUFBLEtBQUcsQ0FBQSxJQUFHLEdBQUUsSUFBRSxLQUFHLEdBQUUsSUFBRSxNQUFJLEtBQUcsS0FBSyxJQUFJLEdBQUUsT0FBSyxLQUFLLElBQUksR0FBRSxPQUFLLEdBQUUsSUFBRSxJQUFFLElBQUUsSUFBRSxHQUFFLElBQUUsSUFBRSxJQUFFLElBQUcsS0FBRyxJQUFFLEtBQUcsTUFBSSxLQUFHLElBQUUsSUFBRSxJQUFFLElBQUU7UUFBRSxJQUFJLElBQUUsS0FBSyxJQUFJLElBQUcsTUFBTSxNQUFJLE1BQUksSUFBRSxJQUFHLENBQUEsSUFBRSxNQUFNLEtBQUcsSUFBRSxHQUFFLElBQUUsQ0FBQSxJQUFJLENBQUEsSUFBRSxLQUFLLE1BQU0sS0FBSyxJQUFJLEtBQUcsS0FBSyxNQUFLLElBQUcsQ0FBQSxJQUFFLEtBQUssSUFBSSxHQUFFLENBQUMsRUFBQyxJQUFHLEtBQUksQ0FBQSxLQUFJLEtBQUcsQ0FBQSxHQUFHLElBQUUsS0FBRyxJQUFFLEtBQUcs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SyxJQUFFLElBQUUsSUFBSSxXQUFXLEtBQUcsTUFBSSxLQUFLLElBQUUsSUFBRSxJQUFJLFdBQVcsR0FBRSxLQUFHLElBQUUsSUFBSSxXQUFXLEdBQUUsR0FBRSxJQUFHLE9BQU8sZUFBZSxHQUFFLEVBQUUsWUFBVztJQUFDO0lBQUMsU0FBUyxHQUFHLENBQUM7UUFBRSxJQUFHLEVBQUUsU0FBUyxJQUFHO1lBQUMsSUFBSSxJQUFFLEVBQUUsRUFBRSxVQUFRLEdBQUUsSUFBRSxFQUFFO1lBQUcsT0FBTyxFQUFFLFdBQVMsS0FBRyxFQUFFLEtBQUssR0FBRSxHQUFFLEdBQUUsSUFBRztRQUFDO1FBQUMsSUFBRyxFQUFFLFdBQVMsS0FBSyxHQUFFLE9BQU8sT0FBTyxFQUFFLFVBQVEsWUFBVSxFQUFFLEVBQUUsVUFBUSxFQUFFLEtBQUcsRUFBRTtRQUFHLElBQUcsRUFBRSxTQUFPLFlBQVUsTUFBTSxRQUFRLEVBQUUsT0FBTSxPQUFPLEVBQUUsRUFBRTtJQUFLO0lBQUMsU0FBUyxFQUFFLENBQUM7UUFBRSxJQUFHLEtBQUcsR0FBRSxNQUFNLElBQUksV0FBVyw0REFBMEQsRUFBRSxTQUFTLE1BQUk7UUFBVSxPQUFPLElBQUU7SUFBQztJQUFDLFNBQVMsR0FBRyxDQUFDO1FBQUUsT0FBTSxDQUFDLEtBQUcsS0FBSSxDQUFBLElBQUUsQ0FBQSxHQUFHLEVBQUUsTUFBTSxDQUFDO0lBQUU7SUFBQyxFQUFFLFdBQVMsU0FBUyxDQUFDO1FBQUUsT0FBTyxLQUFHLFFBQU0sRUFBRSxjQUFZLENBQUMsS0FBRyxNQUFJLEVBQUU7SUFBUztJQUFFLEVBQUUsVUFBUSxTQUFTLENBQUMsRUFBQyxDQUFDO1FBQUUsSUFBRyxFQUFFLEdBQUUsZUFBYyxDQUFBLElBQUUsRUFBRSxLQUFLLEdBQUUsRUFBRSxRQUFPLEVBQUUsV0FBVSxHQUFHLEVBQUUsR0FBRSxlQUFjLENBQUEsSUFBRSxFQUFFLEtBQUssR0FBRSxFQUFFLFFBQU8sRUFBRSxXQUFVLEdBQUcsQ0FBQyxFQUFFLFNBQVMsTUFBSSxDQUFDLEVBQUUsU0FBUyxJQUFHLE1BQU0sSUFBSSxVQUFVO1FBQXlFLElBQUcsTUFBSSxHQUFFLE9BQU87UUFBRSxJQUFJLElBQUUsRUFBRSxRQUFPLElBQUUsRUFBRTtRQUFPLElBQUksSUFBSSxJQUFFLEdBQUUsSUFBRSxLQUFLLElBQUksR0FBRSxJQUFHLElBQUUsR0FBRSxFQUFFLEVBQUUsSUFBRyxDQUFDLENBQUMsRUFBRSxLQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUM7WUFBQyxJQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUMsSUFBRSxDQUFDLENBQUMsRUFBRTtZQUFDO1FBQUs7UUFBQyxPQUFPLElBQUUsSUFBRSxLQUFHLElBQUUsSUFBRSxJQUFFO0lBQUM7SUFBRSxFQUFFLGFBQVcsU0FBUyxDQUFDO1FBQUUsT0FBTyxPQUFPLEdBQUc7WUFBZSxLQUFJO1lBQU0sS0FBSTtZQUFPLEtBQUk7WUFBUSxLQUFJO1lBQVEsS0FBSTtZQUFTLEtBQUk7WUFBUyxLQUFJO1lBQVMsS0FBSTtZQUFPLEtBQUk7WUFBUSxLQUFJO1lBQVUsS0FBSTtnQkFBVyxPQUFNLENBQUM7WUFBRTtnQkFBUSxPQUFNLENBQUM7UUFBQztJQUFDO0lBQUUsRUFBRSxTQUFPLFNBQVMsQ0FBQyxFQUFDLENBQUM7UUFBRSxJQUFHLENBQUMsTUFBTSxRQUFRLElBQUcsTUFBTSxJQUFJLFVBQVU7UUFBK0MsSUFBRyxFQUFFLFdBQVMsR0FBRSxPQUFPLEVBQUUsTUFBTTtRQUFHLElBQUk7UUFBRSxJQUFHLE1BQUksS0FBSyxHQUFFLElBQUksSUFBRSxHQUFFLElBQUUsR0FBRSxJQUFFLEVBQUUsUUFBTyxFQUFFLEVBQUUsS0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDO1FBQU8sSUFBSSxJQUFFLEVBQUUsWUFBWSxJQUFHLElBQUU7UUFBRSxJQUFJLElBQUUsR0FBRSxJQUFFLEVBQUUsUUFBTyxFQUFFLEVBQUU7WUFBQyxJQUFJLElBQUUsQ0FBQyxDQUFDLEVBQUU7WUFBQyxJQUFHLEVBQUUsR0FBRSxhQUFZLElBQUUsRUFBRSxTQUFPLEVBQUUsU0FBUSxDQUFBLEVBQUUsU0FBUyxNQUFLLENBQUEsSUFBRSxFQUFFLEtBQUssRUFBQyxHQUFHLEVBQUUsS0FBSyxHQUFFLEVBQUMsSUFBRyxXQUFXLFVBQVUsSUFBSSxLQUFLLEdBQUUsR0FBRTtpQkFBUSxJQUFHLEVBQUUsU0FBUyxJQUFHLEVBQUUsS0FBSyxHQUFFO2lCQUFRLE1BQU0sSUFBSSxVQUFVO1lBQStDLEtBQUcsRUFBRTtRQUFNO1FBQUMsT0FBTztJQUFDO0lBQUUsU0FBUyxHQUFHLENBQUMsRUFBQyxDQUFDO1FBQUUsSUFBRyxFQUFFLFNBQVMsSUFBRyxPQUFPLEVBQUU7UUFBTyxJQUFHLFlBQVksT0FBTyxNQUFJLEVBQUUsR0FBRSxjQUFhLE9BQU8sRUFBRTtRQUFXLElBQUcsT0FBTyxLQUFHLFVBQVMsTUFBTSxJQUFJLFVBQVUsNkZBQTJGLE9BQU87UUFBRyxJQUFJLElBQUUsRUFBRSxRQUFPLElBQUUsVUFBVSxTQUFPLEtBQUcsU0FBUyxDQUFDLEVBQUUsS0FBRyxDQUFDO1FBQUUsSUFBRyxDQUFDLEtBQUcsTUFBSSxHQUFFLE9BQU87UUFBRSxJQUFJLElBQUUsQ0FBQztRQUFFLE9BQU8sT0FBTztZQUFHLEtBQUk7WUFBUSxLQUFJO1lBQVMsS0FBSTtnQkFBUyxPQUFPO1lBQUUsS0FBSTtZQUFPLEtBQUk7Z0JBQVEsT0FBTyxFQUFFLEdBQUc7WUFBTyxLQUFJO1lBQU8sS0FBSTtZQUFRLEtBQUk7WUFBVSxLQUFJO2dCQUFXLE9BQU8sSUFBRTtZQUFFLEtBQUk7Z0JBQU0sT0FBTyxNQUFJO1lBQUUsS0FBSTtnQkFBUyxPQUFPLEdBQUcsR0FBRztZQUFPO2dCQUFRLElBQUcsR0FBRSxPQUFPLElBQUUsS0FBRyxFQUFFLEdBQUc7Z0JBQU8sSUFBRSxBQUFDLENBQUEsS0FBRyxDQUFBLEVBQUcsZUFBYyxJQUFFLENBQUM7UUFBQztJQUFDO0lBQUMsRUFBRSxhQUFXO0lBQUcsU0FBUyxHQUFHLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLElBQUksSUFBRSxDQUFDO1FBQUUsSUFBRyxBQUFDLENBQUEsTUFBSSxLQUFLLEtBQUcsSUFBRSxDQUFBLEtBQUssQ0FBQSxJQUFFLENBQUEsR0FBRyxJQUFFLElBQUksQ0FBQyxVQUFTLENBQUEsQUFBQyxDQUFBLE1BQUksS0FBSyxLQUFHLElBQUUsSUFBSSxDQUFDLE1BQUssS0FBSyxDQUFBLElBQUUsSUFBSSxDQUFDLE1BQUssR0FBRyxLQUFHLENBQUEsS0FBSyxDQUFBLE9BQUssR0FBRSxPQUFLLEdBQUUsS0FBRyxDQUFBLEdBQUcsT0FBTTtRQUFHLElBQUksS0FBSSxDQUFBLElBQUUsTUFBSyxJQUFLLE9BQU87WUFBRyxLQUFJO2dCQUFNLE9BQU8sR0FBRyxJQUFJLEVBQUMsR0FBRTtZQUFHLEtBQUk7WUFBTyxLQUFJO2dCQUFRLE9BQU8sR0FBRyxJQUFJLEVBQUMsR0FBRTtZQUFHLEtBQUk7Z0JBQVEsT0FBTyxHQUFHLElBQUksRUFBQyxHQUFFO1lBQUcsS0FBSTtZQUFTLEtBQUk7Z0JBQVMsT0FBTyxHQUFHLElBQUksRUFBQyxHQUFFO1lBQUcsS0FBSTtnQkFBUyxPQUFPLEdBQUcsSUFBSSxFQUFDLEdBQUU7WUFBRyxLQUFJO1lBQU8sS0FBSTtZQUFRLEtBQUk7WUFBVSxLQUFJO2dCQUFXLE9BQU8sR0FBRyxJQUFJLEVBQUMsR0FBRTtZQUFHO2dCQUFRLElBQUcsR0FBRSxNQUFNLElBQUksVUFBVSx1QkFBcUI7Z0JBQUcsSUFBRSxBQUFDLENBQUEsSUFBRSxFQUFDLEVBQUcsZUFBYyxJQUFFLENBQUM7UUFBQztJQUFDO0lBQUMsRUFBRSxVQUFVLFlBQVUsQ0FBQztJQUFFLFNBQVMsRUFBRSxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxJQUFJLElBQUUsQ0FBQyxDQUFDLEVBQUU7UUFBQyxDQUFDLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBQztJQUFDO0lBQUMsRUFBRSxVQUFVLFNBQU87UUFBVyxJQUFJLElBQUUsSUFBSSxDQUFDO1FBQU8sSUFBRyxJQUFFLE1BQUksR0FBRSxNQUFNLElBQUksV0FBVztRQUE2QyxJQUFJLElBQUksSUFBRSxHQUFFLElBQUUsR0FBRSxLQUFHLEVBQUUsRUFBRSxJQUFJLEVBQUMsR0FBRSxJQUFFO1FBQUcsT0FBTyxJQUFJO0lBQUE7SUFBRSxFQUFFLFVBQVUsU0FBTztRQUFXLElBQUksSUFBRSxJQUFJLENBQUM7UUFBTyxJQUFHLElBQUUsTUFBSSxHQUFFLE1BQU0sSUFBSSxXQUFXO1FBQTZDLElBQUksSUFBSSxJQUFFLEdBQUUsSUFBRSxHQUFFLEtBQUcsRUFBRSxFQUFFLElBQUksRUFBQyxHQUFFLElBQUUsSUFBRyxFQUFFLElBQUksRUFBQyxJQUFFLEdBQUUsSUFBRTtRQUFHLE9BQU8sSUFBSTtJQUFBO0lBQUUsRUFBRSxVQUFVLFNBQU87UUFBVyxJQUFJLElBQUUsSUFBSSxDQUFDO1FBQU8sSUFBRyxJQUFFLE1BQUksR0FBRSxNQUFNLElBQUksV0FBVztRQUE2QyxJQUFJLElBQUksSUFBRSxHQUFFLElBQUUsR0FBRSxLQUFHLEVBQUUsRUFBRSxJQUFJLEVBQUMsR0FBRSxJQUFFLElBQUcsRUFBRSxJQUFJLEVBQUMsSUFBRSxHQUFFLElBQUUsSUFBRyxFQUFFLElBQUksRUFBQyxJQUFFLEdBQUUsSUFBRSxJQUFHLEVBQUUsSUFBSSxFQUFDLElBQUUsR0FBRSxJQUFFO1FBQUcsT0FBTyxJQUFJO0lBQUE7SUFBRSxFQUFFLFVBQVUsV0FBUztRQUFXLElBQUksSUFBRSxJQUFJLENBQUM7UUFBTyxPQUFPLE1BQUksSUFBRSxLQUFHLFVBQVUsV0FBUyxJQUFFLEdBQUcsSUFBSSxFQUFDLEdBQUUsS0FBRyxHQUFHLE1BQU0sSUFBSSxFQUFDO0lBQVU7SUFBRSxFQUFFLFVBQVUsaUJBQWUsRUFBRSxVQUFVO0lBQVMsRUFBRSxVQUFVLFNBQU8sU0FBUyxDQUFDO1FBQUUsSUFBRyxDQUFDLEVBQUUsU0FBUyxJQUFHLE1BQU0sSUFBSSxVQUFVO1FBQTZCLE9BQU8sSUFBSSxLQUFHLElBQUUsQ0FBQyxJQUFFLEVBQUUsUUFBUSxJQUFJLEVBQUMsT0FBSztJQUFDO0lBQUUsRUFBRSxVQUFVLFVBQVE7UUFBVyxJQUFJLElBQUUsSUFBRyxJQUFFLEVBQUU7UUFBa0IsT0FBTyxJQUFFLElBQUksQ0FBQyxTQUFTLE9BQU0sR0FBRSxHQUFHLFFBQVEsV0FBVSxPQUFPLFFBQU8sSUFBSSxDQUFDLFNBQU8sS0FBSSxDQUFBLEtBQUcsT0FBTSxHQUFHLGFBQVcsSUFBRTtJQUFHO0lBQUUsTUFBSyxDQUFBLEVBQUUsU0FBUyxDQUFDLEdBQUcsR0FBQyxFQUFFLFVBQVUsT0FBTTtJQUFHLEVBQUUsVUFBVSxVQUFRLFNBQVMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxJQUFHLEVBQUUsR0FBRSxlQUFjLENBQUEsSUFBRSxFQUFFLEtBQUssR0FBRSxFQUFFLFFBQU8sRUFBRSxXQUFVLEdBQUcsQ0FBQyxFQUFFLFNBQVMsSUFBRyxNQUFNLElBQUksVUFBVSxtRkFBaUYsT0FBTztRQUFHLElBQUcsTUFBSSxLQUFLLEtBQUksQ0FBQSxJQUFFLENBQUEsR0FBRyxNQUFJLEtBQUssS0FBSSxDQUFBLElBQUUsSUFBRSxFQUFFLFNBQU8sQ0FBQSxHQUFHLE1BQUksS0FBSyxLQUFJLENBQUEsSUFBRSxDQUFBLEdBQUcsTUFBSSxLQUFLLEtBQUksQ0FBQSxJQUFFLElBQUksQ0FBQyxNQUFLLEdBQUcsSUFBRSxLQUFHLElBQUUsRUFBRSxVQUFRLElBQUUsS0FBRyxJQUFFLElBQUksQ0FBQyxRQUFPLE1BQU0sSUFBSSxXQUFXO1FBQXNCLElBQUcsS0FBRyxLQUFHLEtBQUcsR0FBRSxPQUFPO1FBQUUsSUFBRyxLQUFHLEdBQUUsT0FBTTtRQUFHLElBQUcsS0FBRyxHQUFFLE9BQU87UUFBRSxJQUFHLE9BQUssR0FBRSxPQUFLLEdBQUUsT0FBSyxHQUFFLE9BQUssR0FBRSxJQUFJLEtBQUcsR0FBRSxPQUFPO1FBQUUsSUFBSSxJQUFFLElBQUUsR0FBRSxJQUFFLElBQUUsR0FBRSxJQUFFLEtBQUssSUFBSSxHQUFFLElBQUcsSUFBRSxJQUFJLENBQUMsTUFBTSxHQUFFLElBQUcsSUFBRSxFQUFFLE1BQU0sR0FBRTtRQUFHLElBQUksSUFBSSxJQUFFLEdBQUUsSUFBRSxHQUFFLEVBQUUsRUFBRSxJQUFHLENBQUMsQ0FBQyxFQUFFLEtBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBQztZQUFDLElBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBQyxJQUFFLENBQUMsQ0FBQyxFQUFFO1lBQUM7UUFBSztRQUFDLE9BQU8sSUFBRSxJQUFFLEtBQUcsSUFBRSxJQUFFLElBQUU7SUFBQztJQUFFLFNBQVMsR0FBRyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLElBQUcsRUFBRSxXQUFTLEdBQUUsT0FBTTtRQUFHLElBQUcsT0FBTyxLQUFHLFdBQVUsQ0FBQSxJQUFFLEdBQUUsSUFBRSxDQUFBLElBQUcsSUFBRSxhQUFXLElBQUUsYUFBVyxJQUFFLGVBQWMsQ0FBQSxJQUFFLFdBQVUsR0FBRyxJQUFFLENBQUMsR0FBRSxFQUFFLE1BQUssQ0FBQSxJQUFFLElBQUUsSUFBRSxFQUFFLFNBQU8sQ0FBQSxHQUFHLElBQUUsS0FBSSxDQUFBLElBQUUsRUFBRSxTQUFPLENBQUEsR0FBRyxLQUFHLEVBQUUsUUFBTztZQUFDLElBQUcsR0FBRSxPQUFNO1lBQUcsSUFBRSxFQUFFLFNBQU87UUFBQyxPQUFNLElBQUcsSUFBRTtZQUFFLElBQUcsR0FBRSxJQUFFO2lCQUFPLE9BQU07O1FBQUcsSUFBRyxPQUFPLEtBQUcsWUFBVyxDQUFBLElBQUUsRUFBRSxLQUFLLEdBQUUsRUFBQyxHQUFHLEVBQUUsU0FBUyxJQUFHLE9BQU8sRUFBRSxXQUFTLElBQUUsS0FBRyxHQUFHLEdBQUUsR0FBRSxHQUFFLEdBQUU7UUFBRyxJQUFHLE9BQU8sS0FBRyxVQUFTLE9BQU8sSUFBRSxJQUFFLEtBQUksT0FBTyxXQUFXLFVBQVUsV0FBUyxhQUFXLElBQUUsV0FBVyxVQUFVLFFBQVEsS0FBSyxHQUFFLEdBQUUsS0FBRyxXQUFXLFVBQVUsWUFBWSxLQUFLLEdBQUUsR0FBRSxLQUFHLEdBQUcsR0FBRTtZQUFDO1NBQUUsRUFBQyxHQUFFLEdBQUU7UUFBRyxNQUFNLElBQUksVUFBVTtJQUF1QztJQUFDLFNBQVMsR0FBRyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLElBQUksSUFBRSxHQUFFLElBQUUsRUFBRSxRQUFPLElBQUUsRUFBRTtRQUFPLElBQUcsTUFBSSxLQUFLLEtBQUksQ0FBQSxJQUFFLE9BQU8sR0FBRyxlQUFjLE1BQUksVUFBUSxNQUFJLFdBQVMsTUFBSSxhQUFXLE1BQUksVUFBUyxHQUFHO1lBQUMsSUFBRyxFQUFFLFNBQU8sS0FBRyxFQUFFLFNBQU8sR0FBRSxPQUFNO1lBQUcsSUFBRSxHQUFFLEtBQUcsR0FBRSxLQUFHLEdBQUUsS0FBRztRQUFDO1FBQUMsU0FBUyxFQUFFLENBQUMsRUFBQyxDQUFDO1lBQUUsT0FBTyxNQUFJLElBQUUsQ0FBQyxDQUFDLEVBQUUsR0FBQyxFQUFFLGFBQWEsSUFBRTtRQUFFO1FBQUMsSUFBSTtRQUFFLElBQUcsR0FBRTtZQUFDLElBQUksSUFBRTtZQUFHLElBQUksSUFBRSxHQUFFLElBQUUsR0FBRSxJQUFJLElBQUcsRUFBRSxHQUFFLE9BQUssRUFBRSxHQUFFLE1BQUksS0FBRyxJQUFFLElBQUUsSUFBRztnQkFBQyxJQUFHLE1BQUksTUFBSyxDQUFBLElBQUUsQ0FBQSxHQUFHLElBQUUsSUFBRSxNQUFJLEdBQUUsT0FBTyxJQUFFO1lBQUMsT0FBTSxNQUFJLE1BQUssQ0FBQSxLQUFHLElBQUUsQ0FBQSxHQUFHLElBQUU7UUFBRSxPQUFNLElBQUksSUFBRSxJQUFFLEtBQUksQ0FBQSxJQUFFLElBQUUsQ0FBQSxHQUFHLElBQUUsR0FBRSxLQUFHLEdBQUUsSUFBSTtZQUFDLElBQUksSUFBRSxDQUFDO1lBQUUsSUFBSSxJQUFJLElBQUUsR0FBRSxJQUFFLEdBQUUsSUFBSSxJQUFHLEVBQUUsR0FBRSxJQUFFLE9BQUssRUFBRSxHQUFFLElBQUc7Z0JBQUMsSUFBRSxDQUFDO2dCQUFFO1lBQUs7WUFBQyxJQUFHLEdBQUUsT0FBTztRQUFDO1FBQUMsT0FBTTtJQUFFO0lBQUMsRUFBRSxVQUFVLFdBQVMsU0FBUyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxPQUFPLElBQUksQ0FBQyxRQUFRLEdBQUUsR0FBRSxPQUFLO0lBQUU7SUFBRSxFQUFFLFVBQVUsVUFBUSxTQUFTLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLE9BQU8sR0FBRyxJQUFJLEVBQUMsR0FBRSxHQUFFLEdBQUUsQ0FBQztJQUFFO0lBQUUsRUFBRSxVQUFVLGNBQVksU0FBUyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxPQUFPLEdBQUcsSUFBSSxFQUFDLEdBQUUsR0FBRSxHQUFFLENBQUM7SUFBRTtJQUFFLFNBQVMsR0FBRyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsSUFBRSxPQUFPLE1BQUk7UUFBRSxJQUFJLElBQUUsRUFBRSxTQUFPO1FBQUUsSUFBRyxDQUFBLElBQUUsT0FBTyxJQUFHLElBQUUsS0FBSSxDQUFBLElBQUUsQ0FBQSxDQUFDLElBQUcsSUFBRTtRQUFFLElBQUksSUFBRSxFQUFFO1FBQU8sSUFBRSxJQUFFLEtBQUksQ0FBQSxJQUFFLElBQUUsQ0FBQTtRQUFHLElBQUk7UUFBRSxJQUFJLElBQUUsR0FBRSxJQUFFLEdBQUUsRUFBRSxFQUFFO1lBQUMsSUFBSSxJQUFFLFNBQVMsRUFBRSxPQUFPLElBQUUsR0FBRSxJQUFHO1lBQUksSUFBRyxFQUFFLElBQUcsT0FBTztZQUFFLENBQUMsQ0FBQyxJQUFFLEVBQUUsR0FBQztRQUFDO1FBQUMsT0FBTztJQUFDO0lBQUMsU0FBUyxHQUFHLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxPQUFPLEVBQUUsRUFBRSxHQUFFLEVBQUUsU0FBTyxJQUFHLEdBQUUsR0FBRTtJQUFFO0lBQUMsU0FBUyxHQUFHLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxPQUFPLEVBQUUsR0FBRyxJQUFHLEdBQUUsR0FBRTtJQUFFO0lBQUMsU0FBUyxHQUFHLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxPQUFPLEVBQUUsR0FBRyxJQUFHLEdBQUUsR0FBRTtJQUFFO0lBQUMsU0FBUyxHQUFHLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxPQUFPLEVBQUUsR0FBRyxHQUFFLEVBQUUsU0FBTyxJQUFHLEdBQUUsR0FBRTtJQUFFO0lBQUMsRUFBRSxVQUFVLFFBQU0sU0FBUyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsSUFBRyxNQUFJLEtBQUssR0FBRSxJQUFFLFFBQU8sSUFBRSxJQUFJLENBQUMsUUFBTyxJQUFFO2FBQU8sSUFBRyxNQUFJLEtBQUssS0FBRyxPQUFPLEtBQUcsVUFBUyxJQUFFLEdBQUUsSUFBRSxJQUFJLENBQUMsUUFBTyxJQUFFO2FBQU8sSUFBRyxTQUFTLElBQUcsSUFBRSxNQUFJLEdBQUUsU0FBUyxLQUFJLENBQUEsSUFBRSxNQUFJLEdBQUUsTUFBSSxLQUFLLEtBQUksQ0FBQSxJQUFFLE1BQUssQ0FBQyxJQUFJLENBQUEsSUFBRSxHQUFFLElBQUUsS0FBSyxDQUFBO2FBQVEsTUFBTSxJQUFJLE1BQU07UUFBMkUsSUFBSSxJQUFFLElBQUksQ0FBQyxTQUFPO1FBQUUsSUFBRyxBQUFDLENBQUEsTUFBSSxLQUFLLEtBQUcsSUFBRSxDQUFBLEtBQUssQ0FBQSxJQUFFLENBQUEsR0FBRyxFQUFFLFNBQU8sS0FBSSxDQUFBLElBQUUsS0FBRyxJQUFFLENBQUEsS0FBSSxJQUFFLElBQUksQ0FBQyxRQUFPLE1BQU0sSUFBSSxXQUFXO1FBQTBDLEtBQUksQ0FBQSxJQUFFLE1BQUs7UUFBRyxJQUFJLElBQUUsQ0FBQztRQUFFLE9BQU8sT0FBTztZQUFHLEtBQUk7Z0JBQU0sT0FBTyxHQUFHLElBQUksRUFBQyxHQUFFLEdBQUU7WUFBRyxLQUFJO1lBQU8sS0FBSTtnQkFBUSxPQUFPLEdBQUcsSUFBSSxFQUFDLEdBQUUsR0FBRTtZQUFHLEtBQUk7WUFBUSxLQUFJO1lBQVMsS0FBSTtnQkFBUyxPQUFPLEdBQUcsSUFBSSxFQUFDLEdBQUUsR0FBRTtZQUFHLEtBQUk7Z0JBQVMsT0FBTyxHQUFHLElBQUksRUFBQyxHQUFFLEdBQUU7WUFBRyxLQUFJO1lBQU8sS0FBSTtZQUFRLEtBQUk7WUFBVSxLQUFJO2dCQUFXLE9BQU8sR0FBRyxJQUFJLEVBQUMsR0FBRSxHQUFFO1lBQUc7Z0JBQVEsSUFBRyxHQUFFLE1BQU0sSUFBSSxVQUFVLHVCQUFxQjtnQkFBRyxJQUFFLEFBQUMsQ0FBQSxLQUFHLENBQUEsRUFBRyxlQUFjLElBQUUsQ0FBQztRQUFDO0lBQUM7SUFBRSxFQUFFLFVBQVUsU0FBTztRQUFXLE9BQU07WUFBQyxNQUFLO1lBQVMsTUFBSyxNQUFNLFVBQVUsTUFBTSxLQUFLLElBQUksQ0FBQyxRQUFNLElBQUksRUFBQztRQUFFO0lBQUM7SUFBRSxTQUFTLEdBQUcsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsT0FBTyxNQUFJLEtBQUcsTUFBSSxFQUFFLFNBQU8sRUFBRSxjQUFjLEtBQUcsRUFBRSxjQUFjLEVBQUUsTUFBTSxHQUFFO0lBQUc7SUFBQyxTQUFTLEdBQUcsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsSUFBRSxLQUFLLElBQUksRUFBRSxRQUFPO1FBQUcsSUFBSSxJQUFFLEVBQUUsRUFBQyxJQUFFO1FBQUUsTUFBSyxJQUFFLEdBQUc7WUFBQyxJQUFJLElBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBQyxJQUFFLE1BQUssSUFBRSxJQUFFLE1BQUksSUFBRSxJQUFFLE1BQUksSUFBRSxJQUFFLE1BQUksSUFBRTtZQUFFLElBQUcsSUFBRSxLQUFHLEdBQUU7Z0JBQUMsSUFBSSxHQUFFLEdBQUUsR0FBRTtnQkFBRSxPQUFPO29CQUFHLEtBQUs7d0JBQUUsSUFBRSxPQUFNLENBQUEsSUFBRSxDQUFBO3dCQUFHO29CQUFNLEtBQUs7d0JBQUUsSUFBRSxDQUFDLENBQUMsSUFBRSxFQUFFLEVBQUMsQUFBQyxDQUFBLElBQUUsR0FBRSxNQUFLLE9BQU0sQ0FBQSxJQUFFLEFBQUMsQ0FBQSxJQUFFLEVBQUMsS0FBSSxJQUFFLElBQUUsSUFBRyxJQUFFLE9BQU0sQ0FBQSxJQUFFLENBQUEsQ0FBQzt3QkFBRztvQkFBTSxLQUFLO3dCQUFFLElBQUUsQ0FBQyxDQUFDLElBQUUsRUFBRSxFQUFDLElBQUUsQ0FBQyxDQUFDLElBQUUsRUFBRSxFQUFDLEFBQUMsQ0FBQSxJQUFFLEdBQUUsTUFBSyxPQUFLLEFBQUMsQ0FBQSxJQUFFLEdBQUUsTUFBSyxPQUFNLENBQUEsSUFBRSxBQUFDLENBQUEsSUFBRSxFQUFDLEtBQUksS0FBRyxBQUFDLENBQUEsSUFBRSxFQUFDLEtBQUksSUFBRSxJQUFFLElBQUcsSUFBRSxRQUFPLENBQUEsSUFBRSxTQUFPLElBQUUsS0FBSSxLQUFLLENBQUEsSUFBRSxDQUFBLENBQUM7d0JBQUc7b0JBQU0sS0FBSzt3QkFBRSxJQUFFLENBQUMsQ0FBQyxJQUFFLEVBQUUsRUFBQyxJQUFFLENBQUMsQ0FBQyxJQUFFLEVBQUUsRUFBQyxJQUFFLENBQUMsQ0FBQyxJQUFFLEVBQUUsRUFBQyxBQUFDLENBQUEsSUFBRSxHQUFFLE1BQUssT0FBSyxBQUFDLENBQUEsSUFBRSxHQUFFLE1BQUssT0FBSyxBQUFDLENBQUEsSUFBRSxHQUFFLE1BQUssT0FBTSxDQUFBLElBQUUsQUFBQyxDQUFBLElBQUUsRUFBQyxLQUFJLEtBQUcsQUFBQyxDQUFBLElBQUUsRUFBQyxLQUFJLEtBQUcsQUFBQyxDQUFBLElBQUUsRUFBQyxLQUFJLElBQUUsSUFBRSxJQUFHLElBQUUsU0FBTyxJQUFFLFdBQVUsQ0FBQSxJQUFFLENBQUEsQ0FBQztnQkFBRTtZQUFDO1lBQUMsTUFBSSxPQUFNLENBQUEsSUFBRSxPQUFNLElBQUUsQ0FBQSxJQUFHLElBQUUsU0FBUSxDQUFBLEtBQUcsT0FBTSxFQUFFLEtBQUssTUFBSSxLQUFHLE9BQUssUUFBTyxJQUFFLFFBQU0sSUFBRSxJQUFHLEdBQUcsRUFBRSxLQUFLLElBQUcsS0FBRztRQUFDO1FBQUMsT0FBTyxHQUFHO0lBQUU7SUFBQyxJQUFJLEtBQUc7SUFBSyxTQUFTLEdBQUcsQ0FBQztRQUFFLElBQUksSUFBRSxFQUFFO1FBQU8sSUFBRyxLQUFHLElBQUcsT0FBTyxPQUFPLGFBQWEsTUFBTSxRQUFPO1FBQUcsSUFBSSxJQUFFLElBQUcsSUFBRTtRQUFFLE1BQUssSUFBRSxHQUFHLEtBQUcsT0FBTyxhQUFhLE1BQU0sUUFBTyxFQUFFLE1BQU0sR0FBRSxLQUFHO1FBQUssT0FBTztJQUFDO0lBQUMsU0FBUyxHQUFHLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLElBQUksSUFBRTtRQUFHLElBQUUsS0FBSyxJQUFJLEVBQUUsUUFBTztRQUFHLElBQUksSUFBSSxJQUFFLEdBQUUsSUFBRSxHQUFFLEVBQUUsRUFBRSxLQUFHLE9BQU8sYUFBYSxDQUFDLENBQUMsRUFBRSxHQUFDO1FBQUssT0FBTztJQUFDO0lBQUMsU0FBUyxHQUFHLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLElBQUksSUFBRTtRQUFHLElBQUUsS0FBSyxJQUFJLEVBQUUsUUFBTztRQUFHLElBQUksSUFBSSxJQUFFLEdBQUUsSUFBRSxHQUFFLEVBQUUsRUFBRSxLQUFHLE9BQU8sYUFBYSxDQUFDLENBQUMsRUFBRTtRQUFFLE9BQU87SUFBQztJQUFDLFNBQVMsR0FBRyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxJQUFJLElBQUUsRUFBRTtRQUFRLENBQUEsQ0FBQyxLQUFHLElBQUUsQ0FBQSxLQUFLLENBQUEsSUFBRSxDQUFBLEdBQUcsQUFBQyxDQUFBLENBQUMsS0FBRyxJQUFFLEtBQUcsSUFBRSxDQUFBLEtBQUssQ0FBQSxJQUFFLENBQUE7UUFBRyxJQUFJLElBQUU7UUFBRyxJQUFJLElBQUksSUFBRSxHQUFFLElBQUUsR0FBRSxFQUFFLEVBQUUsS0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUFDLE9BQU87SUFBQztJQUFDLFNBQVMsR0FBRyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxJQUFJLElBQUUsRUFBRSxNQUFNLEdBQUUsSUFBRyxJQUFFO1FBQUcsSUFBSSxJQUFJLElBQUUsR0FBRSxJQUFFLEVBQUUsU0FBTyxHQUFFLEtBQUcsRUFBRSxLQUFHLE9BQU8sYUFBYSxDQUFDLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxJQUFFLEVBQUUsR0FBQztRQUFLLE9BQU87SUFBQztJQUFDLEVBQUUsVUFBVSxRQUFNLFNBQVMsQ0FBQyxFQUFDLENBQUM7UUFBRSxJQUFJLElBQUUsSUFBSSxDQUFDO1FBQU8sSUFBRSxDQUFDLENBQUMsR0FBRSxJQUFFLE1BQUksS0FBSyxJQUFFLElBQUUsQ0FBQyxDQUFDLEdBQUUsSUFBRSxJQUFHLENBQUEsS0FBRyxHQUFFLElBQUUsS0FBSSxDQUFBLElBQUUsQ0FBQSxDQUFDLElBQUcsSUFBRSxLQUFJLENBQUEsSUFBRSxDQUFBLEdBQUcsSUFBRSxJQUFHLENBQUEsS0FBRyxHQUFFLElBQUUsS0FBSSxDQUFBLElBQUUsQ0FBQSxDQUFDLElBQUcsSUFBRSxLQUFJLENBQUEsSUFBRSxDQUFBLEdBQUcsSUFBRSxLQUFJLENBQUEsSUFBRSxDQUFBO1FBQUcsSUFBSSxJQUFFLElBQUksQ0FBQyxTQUFTLEdBQUU7UUFBRyxPQUFPLE9BQU8sZUFBZSxHQUFFLEVBQUUsWUFBVztJQUFDO0lBQUUsU0FBUyxFQUFFLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLElBQUcsSUFBRSxNQUFJLEtBQUcsSUFBRSxHQUFFLE1BQU0sSUFBSSxXQUFXO1FBQXNCLElBQUcsSUFBRSxJQUFFLEdBQUUsTUFBTSxJQUFJLFdBQVc7SUFBd0M7SUFBQyxFQUFFLFVBQVUsYUFBVyxFQUFFLFVBQVUsYUFBVyxTQUFTLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLElBQUUsTUFBSSxHQUFFLElBQUUsTUFBSSxHQUFFLEtBQUcsRUFBRSxHQUFFLEdBQUUsSUFBSSxDQUFDO1FBQVEsSUFBSSxJQUFFLElBQUksQ0FBQyxFQUFFLEVBQUMsSUFBRSxHQUFFLElBQUU7UUFBRSxNQUFLLEVBQUUsSUFBRSxLQUFJLENBQUEsS0FBRyxHQUFFLEdBQUksS0FBRyxJQUFJLENBQUMsSUFBRSxFQUFFLEdBQUM7UUFBRSxPQUFPO0lBQUM7SUFBRSxFQUFFLFVBQVUsYUFBVyxFQUFFLFVBQVUsYUFBVyxTQUFTLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLElBQUUsTUFBSSxHQUFFLElBQUUsTUFBSSxHQUFFLEtBQUcsRUFBRSxHQUFFLEdBQUUsSUFBSSxDQUFDO1FBQVEsSUFBSSxJQUFFLElBQUksQ0FBQyxJQUFFLEVBQUUsRUFBRSxFQUFDLElBQUU7UUFBRSxNQUFLLElBQUUsS0FBSSxDQUFBLEtBQUcsR0FBRSxHQUFJLEtBQUcsSUFBSSxDQUFDLElBQUUsRUFBRSxFQUFFLEdBQUM7UUFBRSxPQUFPO0lBQUM7SUFBRSxFQUFFLFVBQVUsWUFBVSxFQUFFLFVBQVUsWUFBVSxTQUFTLENBQUMsRUFBQyxDQUFDO1FBQUUsT0FBTyxJQUFFLE1BQUksR0FBRSxLQUFHLEVBQUUsR0FBRSxHQUFFLElBQUksQ0FBQyxTQUFRLElBQUksQ0FBQyxFQUFFO0lBQUE7SUFBRSxFQUFFLFVBQVUsZUFBYSxFQUFFLFVBQVUsZUFBYSxTQUFTLENBQUMsRUFBQyxDQUFDO1FBQUUsT0FBTyxJQUFFLE1BQUksR0FBRSxLQUFHLEVBQUUsR0FBRSxHQUFFLElBQUksQ0FBQyxTQUFRLElBQUksQ0FBQyxFQUFFLEdBQUMsSUFBSSxDQUFDLElBQUUsRUFBRSxJQUFFO0lBQUM7SUFBRSxFQUFFLFVBQVUsZUFBYSxFQUFFLFVBQVUsZUFBYSxTQUFTLENBQUMsRUFBQyxDQUFDO1FBQUUsT0FBTyxJQUFFLE1BQUksR0FBRSxLQUFHLEVBQUUsR0FBRSxHQUFFLElBQUksQ0FBQyxTQUFRLElBQUksQ0FBQyxFQUFFLElBQUUsSUFBRSxJQUFJLENBQUMsSUFBRSxFQUFFO0lBQUE7SUFBRSxFQUFFLFVBQVUsZUFBYSxFQUFFLFVBQVUsZUFBYSxTQUFTLENBQUMsRUFBQyxDQUFDO1FBQUUsT0FBTyxJQUFFLE1BQUksR0FBRSxLQUFHLEVBQUUsR0FBRSxHQUFFLElBQUksQ0FBQyxTQUFRLEFBQUMsQ0FBQSxJQUFJLENBQUMsRUFBRSxHQUFDLElBQUksQ0FBQyxJQUFFLEVBQUUsSUFBRSxJQUFFLElBQUksQ0FBQyxJQUFFLEVBQUUsSUFBRSxFQUFDLElBQUcsSUFBSSxDQUFDLElBQUUsRUFBRSxHQUFDO0lBQVE7SUFBRSxFQUFFLFVBQVUsZUFBYSxFQUFFLFVBQVUsZUFBYSxTQUFTLENBQUMsRUFBQyxDQUFDO1FBQUUsT0FBTyxJQUFFLE1BQUksR0FBRSxLQUFHLEVBQUUsR0FBRSxHQUFFLElBQUksQ0FBQyxTQUFRLElBQUksQ0FBQyxFQUFFLEdBQUMsV0FBVSxDQUFBLElBQUksQ0FBQyxJQUFFLEVBQUUsSUFBRSxLQUFHLElBQUksQ0FBQyxJQUFFLEVBQUUsSUFBRSxJQUFFLElBQUksQ0FBQyxJQUFFLEVBQUUsQUFBRDtJQUFFO0lBQUUsRUFBRSxVQUFVLGtCQUFnQixFQUFFLFNBQVMsQ0FBQztRQUFFLElBQUUsTUFBSSxHQUFFLEVBQUUsR0FBRTtRQUFVLElBQUksSUFBRSxJQUFJLENBQUMsRUFBRSxFQUFDLElBQUUsSUFBSSxDQUFDLElBQUUsRUFBRTtRQUFFLENBQUEsTUFBSSxLQUFLLEtBQUcsTUFBSSxLQUFLLENBQUEsS0FBSSxFQUFFLEdBQUUsSUFBSSxDQUFDLFNBQU87UUFBRyxJQUFJLElBQUUsSUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFLEdBQUMsTUFBSyxJQUFJLENBQUMsRUFBRSxFQUFFLEdBQUMsS0FBRyxLQUFHLElBQUksQ0FBQyxFQUFFLEVBQUUsR0FBQyxLQUFHLElBQUcsSUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFLEdBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxHQUFDLE1BQUssSUFBSSxDQUFDLEVBQUUsRUFBRSxHQUFDLEtBQUcsS0FBRyxJQUFFLEtBQUc7UUFBRyxPQUFPLE9BQU8sS0FBSSxDQUFBLE9BQU8sTUFBSSxPQUFPLEdBQUU7SUFBRTtJQUFHLEVBQUUsVUFBVSxrQkFBZ0IsRUFBRSxTQUFTLENBQUM7UUFBRSxJQUFFLE1BQUksR0FBRSxFQUFFLEdBQUU7UUFBVSxJQUFJLElBQUUsSUFBSSxDQUFDLEVBQUUsRUFBQyxJQUFFLElBQUksQ0FBQyxJQUFFLEVBQUU7UUFBRSxDQUFBLE1BQUksS0FBSyxLQUFHLE1BQUksS0FBSyxDQUFBLEtBQUksRUFBRSxHQUFFLElBQUksQ0FBQyxTQUFPO1FBQUcsSUFBSSxJQUFFLElBQUUsS0FBRyxLQUFHLElBQUksQ0FBQyxFQUFFLEVBQUUsR0FBQyxLQUFHLEtBQUcsSUFBSSxDQUFDLEVBQUUsRUFBRSxHQUFDLE1BQUssSUFBSSxDQUFDLEVBQUUsRUFBRSxFQUFDLElBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRSxHQUFDLEtBQUcsS0FBRyxJQUFJLENBQUMsRUFBRSxFQUFFLEdBQUMsS0FBRyxLQUFHLElBQUksQ0FBQyxFQUFFLEVBQUUsR0FBQyxNQUFLO1FBQUUsT0FBTSxBQUFDLENBQUEsT0FBTyxNQUFJLE9BQU8sR0FBRSxJQUFHLE9BQU87SUFBRTtJQUFHLEVBQUUsVUFBVSxZQUFVLFNBQVMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsSUFBRSxNQUFJLEdBQUUsSUFBRSxNQUFJLEdBQUUsS0FBRyxFQUFFLEdBQUUsR0FBRSxJQUFJLENBQUM7UUFBUSxJQUFJLElBQUUsSUFBSSxDQUFDLEVBQUUsRUFBQyxJQUFFLEdBQUUsSUFBRTtRQUFFLE1BQUssRUFBRSxJQUFFLEtBQUksQ0FBQSxLQUFHLEdBQUUsR0FBSSxLQUFHLElBQUksQ0FBQyxJQUFFLEVBQUUsR0FBQztRQUFFLE9BQU8sS0FBRyxLQUFJLEtBQUcsS0FBSSxDQUFBLEtBQUcsS0FBSyxJQUFJLEdBQUUsSUFBRSxFQUFDLEdBQUc7SUFBQztJQUFFLEVBQUUsVUFBVSxZQUFVLFNBQVMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsSUFBRSxNQUFJLEdBQUUsSUFBRSxNQUFJLEdBQUUsS0FBRyxFQUFFLEdBQUUsR0FBRSxJQUFJLENBQUM7UUFBUSxJQUFJLElBQUUsR0FBRSxJQUFFLEdBQUUsSUFBRSxJQUFJLENBQUMsSUFBRSxFQUFFLEVBQUU7UUFBQyxNQUFLLElBQUUsS0FBSSxDQUFBLEtBQUcsR0FBRSxHQUFJLEtBQUcsSUFBSSxDQUFDLElBQUUsRUFBRSxFQUFFLEdBQUM7UUFBRSxPQUFPLEtBQUcsS0FBSSxLQUFHLEtBQUksQ0FBQSxLQUFHLEtBQUssSUFBSSxHQUFFLElBQUUsRUFBQyxHQUFHO0lBQUM7SUFBRSxFQUFFLFVBQVUsV0FBUyxTQUFTLENBQUMsRUFBQyxDQUFDO1FBQUUsT0FBTyxJQUFFLE1BQUksR0FBRSxLQUFHLEVBQUUsR0FBRSxHQUFFLElBQUksQ0FBQyxTQUFRLElBQUksQ0FBQyxFQUFFLEdBQUMsTUFBSSxBQUFDLENBQUEsTUFBSSxJQUFJLENBQUMsRUFBRSxHQUFDLENBQUEsSUFBRyxLQUFHLElBQUksQ0FBQyxFQUFFO0lBQUE7SUFBRSxFQUFFLFVBQVUsY0FBWSxTQUFTLENBQUMsRUFBQyxDQUFDO1FBQUUsSUFBRSxNQUFJLEdBQUUsS0FBRyxFQUFFLEdBQUUsR0FBRSxJQUFJLENBQUM7UUFBUSxJQUFJLElBQUUsSUFBSSxDQUFDLEVBQUUsR0FBQyxJQUFJLENBQUMsSUFBRSxFQUFFLElBQUU7UUFBRSxPQUFPLElBQUUsUUFBTSxJQUFFLGFBQVc7SUFBQztJQUFFLEVBQUUsVUFBVSxjQUFZLFNBQVMsQ0FBQyxFQUFDLENBQUM7UUFBRSxJQUFFLE1BQUksR0FBRSxLQUFHLEVBQUUsR0FBRSxHQUFFLElBQUksQ0FBQztRQUFRLElBQUksSUFBRSxJQUFJLENBQUMsSUFBRSxFQUFFLEdBQUMsSUFBSSxDQUFDLEVBQUUsSUFBRTtRQUFFLE9BQU8sSUFBRSxRQUFNLElBQUUsYUFBVztJQUFDO0lBQUUsRUFBRSxVQUFVLGNBQVksU0FBUyxDQUFDLEVBQUMsQ0FBQztRQUFFLE9BQU8sSUFBRSxNQUFJLEdBQUUsS0FBRyxFQUFFLEdBQUUsR0FBRSxJQUFJLENBQUMsU0FBUSxJQUFJLENBQUMsRUFBRSxHQUFDLElBQUksQ0FBQyxJQUFFLEVBQUUsSUFBRSxJQUFFLElBQUksQ0FBQyxJQUFFLEVBQUUsSUFBRSxLQUFHLElBQUksQ0FBQyxJQUFFLEVBQUUsSUFBRTtJQUFFO0lBQUUsRUFBRSxVQUFVLGNBQVksU0FBUyxDQUFDLEVBQUMsQ0FBQztRQUFFLE9BQU8sSUFBRSxNQUFJLEdBQUUsS0FBRyxFQUFFLEdBQUUsR0FBRSxJQUFJLENBQUMsU0FBUSxJQUFJLENBQUMsRUFBRSxJQUFFLEtBQUcsSUFBSSxDQUFDLElBQUUsRUFBRSxJQUFFLEtBQUcsSUFBSSxDQUFDLElBQUUsRUFBRSxJQUFFLElBQUUsSUFBSSxDQUFDLElBQUUsRUFBRTtJQUFBO0lBQUUsRUFBRSxVQUFVLGlCQUFlLEVBQUUsU0FBUyxDQUFDO1FBQUUsSUFBRSxNQUFJLEdBQUUsRUFBRSxHQUFFO1FBQVUsSUFBSSxJQUFFLElBQUksQ0FBQyxFQUFFLEVBQUMsSUFBRSxJQUFJLENBQUMsSUFBRSxFQUFFO1FBQUUsQ0FBQSxNQUFJLEtBQUssS0FBRyxNQUFJLEtBQUssQ0FBQSxLQUFJLEVBQUUsR0FBRSxJQUFJLENBQUMsU0FBTztRQUFHLElBQUksSUFBRSxJQUFJLENBQUMsSUFBRSxFQUFFLEdBQUMsSUFBSSxDQUFDLElBQUUsRUFBRSxHQUFDLE1BQUssSUFBSSxDQUFDLElBQUUsRUFBRSxHQUFDLEtBQUcsS0FBSSxDQUFBLEtBQUcsRUFBQztRQUFHLE9BQU0sQUFBQyxDQUFBLE9BQU8sTUFBSSxPQUFPLEdBQUUsSUFBRyxPQUFPLElBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRSxHQUFDLE1BQUssSUFBSSxDQUFDLEVBQUUsRUFBRSxHQUFDLEtBQUcsS0FBRyxJQUFJLENBQUMsRUFBRSxFQUFFLEdBQUMsS0FBRztJQUFHO0lBQUcsRUFBRSxVQUFVLGlCQUFlLEVBQUUsU0FBUyxDQUFDO1FBQUUsSUFBRSxNQUFJLEdBQUUsRUFBRSxHQUFFO1FBQVUsSUFBSSxJQUFFLElBQUksQ0FBQyxFQUFFLEVBQUMsSUFBRSxJQUFJLENBQUMsSUFBRSxFQUFFO1FBQUUsQ0FBQSxNQUFJLEtBQUssS0FBRyxNQUFJLEtBQUssQ0FBQSxLQUFJLEVBQUUsR0FBRSxJQUFJLENBQUMsU0FBTztRQUFHLElBQUksSUFBRSxBQUFDLENBQUEsS0FBRyxFQUFDLElBQUcsSUFBSSxDQUFDLEVBQUUsRUFBRSxHQUFDLEtBQUcsS0FBRyxJQUFJLENBQUMsRUFBRSxFQUFFLEdBQUMsTUFBSyxJQUFJLENBQUMsRUFBRSxFQUFFO1FBQUMsT0FBTSxBQUFDLENBQUEsT0FBTyxNQUFJLE9BQU8sR0FBRSxJQUFHLE9BQU8sSUFBSSxDQUFDLEVBQUUsRUFBRSxHQUFDLEtBQUcsS0FBRyxJQUFJLENBQUMsRUFBRSxFQUFFLEdBQUMsS0FBRyxLQUFHLElBQUksQ0FBQyxFQUFFLEVBQUUsR0FBQyxNQUFLO0lBQUU7SUFBRyxFQUFFLFVBQVUsY0FBWSxTQUFTLENBQUMsRUFBQyxDQUFDO1FBQUUsT0FBTyxJQUFFLE1BQUksR0FBRSxLQUFHLEVBQUUsR0FBRSxHQUFFLElBQUksQ0FBQyxTQUFRLEVBQUUsS0FBSyxJQUFJLEVBQUMsR0FBRSxDQUFDLEdBQUUsSUFBRztJQUFFO0lBQUUsRUFBRSxVQUFVLGNBQVksU0FBUyxDQUFDLEVBQUMsQ0FBQztRQUFFLE9BQU8sSUFBRSxNQUFJLEdBQUUsS0FBRyxFQUFFLEdBQUUsR0FBRSxJQUFJLENBQUMsU0FBUSxFQUFFLEtBQUssSUFBSSxFQUFDLEdBQUUsQ0FBQyxHQUFFLElBQUc7SUFBRTtJQUFFLEVBQUUsVUFBVSxlQUFhLFNBQVMsQ0FBQyxFQUFDLENBQUM7UUFBRSxPQUFPLElBQUUsTUFBSSxHQUFFLEtBQUcsRUFBRSxHQUFFLEdBQUUsSUFBSSxDQUFDLFNBQVEsRUFBRSxLQUFLLElBQUksRUFBQyxHQUFFLENBQUMsR0FBRSxJQUFHO0lBQUU7SUFBRSxFQUFFLFVBQVUsZUFBYSxTQUFTLENBQUMsRUFBQyxDQUFDO1FBQUUsT0FBTyxJQUFFLE1BQUksR0FBRSxLQUFHLEVBQUUsR0FBRSxHQUFFLElBQUksQ0FBQyxTQUFRLEVBQUUsS0FBSyxJQUFJLEVBQUMsR0FBRSxDQUFDLEdBQUUsSUFBRztJQUFFO0lBQUUsU0FBUyxFQUFFLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLElBQUcsQ0FBQyxFQUFFLFNBQVMsSUFBRyxNQUFNLElBQUksVUFBVTtRQUErQyxJQUFHLElBQUUsS0FBRyxJQUFFLEdBQUUsTUFBTSxJQUFJLFdBQVc7UUFBcUMsSUFBRyxJQUFFLElBQUUsRUFBRSxRQUFPLE1BQU0sSUFBSSxXQUFXO0lBQXFCO0lBQUMsRUFBRSxVQUFVLGNBQVksRUFBRSxVQUFVLGNBQVksU0FBUyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsSUFBRyxJQUFFLENBQUMsR0FBRSxJQUFFLE1BQUksR0FBRSxJQUFFLE1BQUksR0FBRSxDQUFDLEdBQUU7WUFBQyxJQUFJLElBQUUsS0FBSyxJQUFJLEdBQUUsSUFBRSxLQUFHO1lBQUUsRUFBRSxJQUFJLEVBQUMsR0FBRSxHQUFFLEdBQUUsR0FBRTtRQUFFO1FBQUMsSUFBSSxJQUFFLEdBQUUsSUFBRTtRQUFFLElBQUksSUFBSSxDQUFDLEVBQUUsR0FBQyxJQUFFLEtBQUksRUFBRSxJQUFFLEtBQUksQ0FBQSxLQUFHLEdBQUUsR0FBSSxJQUFJLENBQUMsSUFBRSxFQUFFLEdBQUMsSUFBRSxJQUFFO1FBQUksT0FBTyxJQUFFO0lBQUM7SUFBRSxFQUFFLFVBQVUsY0FBWSxFQUFFLFVBQVUsY0FBWSxTQUFTLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxJQUFHLElBQUUsQ0FBQyxHQUFFLElBQUUsTUFBSSxHQUFFLElBQUUsTUFBSSxHQUFFLENBQUMsR0FBRTtZQUFDLElBQUksSUFBRSxLQUFLLElBQUksR0FBRSxJQUFFLEtBQUc7WUFBRSxFQUFFLElBQUksRUFBQyxHQUFFLEdBQUUsR0FBRSxHQUFFO1FBQUU7UUFBQyxJQUFJLElBQUUsSUFBRSxHQUFFLElBQUU7UUFBRSxJQUFJLElBQUksQ0FBQyxJQUFFLEVBQUUsR0FBQyxJQUFFLEtBQUksRUFBRSxLQUFHLEtBQUksQ0FBQSxLQUFHLEdBQUUsR0FBSSxJQUFJLENBQUMsSUFBRSxFQUFFLEdBQUMsSUFBRSxJQUFFO1FBQUksT0FBTyxJQUFFO0lBQUM7SUFBRSxFQUFFLFVBQVUsYUFBVyxFQUFFLFVBQVUsYUFBVyxTQUFTLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLE9BQU8sSUFBRSxDQUFDLEdBQUUsSUFBRSxNQUFJLEdBQUUsS0FBRyxFQUFFLElBQUksRUFBQyxHQUFFLEdBQUUsR0FBRSxLQUFJLElBQUcsSUFBSSxDQUFDLEVBQUUsR0FBQyxJQUFFLEtBQUksSUFBRTtJQUFDO0lBQUUsRUFBRSxVQUFVLGdCQUFjLEVBQUUsVUFBVSxnQkFBYyxTQUFTLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLE9BQU8sSUFBRSxDQUFDLEdBQUUsSUFBRSxNQUFJLEdBQUUsS0FBRyxFQUFFLElBQUksRUFBQyxHQUFFLEdBQUUsR0FBRSxPQUFNLElBQUcsSUFBSSxDQUFDLEVBQUUsR0FBQyxJQUFFLEtBQUksSUFBSSxDQUFDLElBQUUsRUFBRSxHQUFDLE1BQUksR0FBRSxJQUFFO0lBQUM7SUFBRSxFQUFFLFVBQVUsZ0JBQWMsRUFBRSxVQUFVLGdCQUFjLFNBQVMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsT0FBTyxJQUFFLENBQUMsR0FBRSxJQUFFLE1BQUksR0FBRSxLQUFHLEVBQUUsSUFBSSxFQUFDLEdBQUUsR0FBRSxHQUFFLE9BQU0sSUFBRyxJQUFJLENBQUMsRUFBRSxHQUFDLE1BQUksR0FBRSxJQUFJLENBQUMsSUFBRSxFQUFFLEdBQUMsSUFBRSxLQUFJLElBQUU7SUFBQztJQUFFLEVBQUUsVUFBVSxnQkFBYyxFQUFFLFVBQVUsZ0JBQWMsU0FBUyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxPQUFPLElBQUUsQ0FBQyxHQUFFLElBQUUsTUFBSSxHQUFFLEtBQUcsRUFBRSxJQUFJLEVBQUMsR0FBRSxHQUFFLEdBQUUsWUFBVyxJQUFHLElBQUksQ0FBQyxJQUFFLEVBQUUsR0FBQyxNQUFJLElBQUcsSUFBSSxDQUFDLElBQUUsRUFBRSxHQUFDLE1BQUksSUFBRyxJQUFJLENBQUMsSUFBRSxFQUFFLEdBQUMsTUFBSSxHQUFFLElBQUksQ0FBQyxFQUFFLEdBQUMsSUFBRSxLQUFJLElBQUU7SUFBQztJQUFFLEVBQUUsVUFBVSxnQkFBYyxFQUFFLFVBQVUsZ0JBQWMsU0FBUyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxPQUFPLElBQUUsQ0FBQyxHQUFFLElBQUUsTUFBSSxHQUFFLEtBQUcsRUFBRSxJQUFJLEVBQUMsR0FBRSxHQUFFLEdBQUUsWUFBVyxJQUFHLElBQUksQ0FBQyxFQUFFLEdBQUMsTUFBSSxJQUFHLElBQUksQ0FBQyxJQUFFLEVBQUUsR0FBQyxNQUFJLElBQUcsSUFBSSxDQUFDLElBQUUsRUFBRSxHQUFDLE1BQUksR0FBRSxJQUFJLENBQUMsSUFBRSxFQUFFLEdBQUMsSUFBRSxLQUFJLElBQUU7SUFBQztJQUFFLFNBQVMsR0FBRyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLEdBQUcsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFO1FBQUcsSUFBSSxJQUFFLE9BQU8sSUFBRSxPQUFPO1FBQWEsQ0FBQyxDQUFDLElBQUksR0FBQyxHQUFFLElBQUUsS0FBRyxHQUFFLENBQUMsQ0FBQyxJQUFJLEdBQUMsR0FBRSxJQUFFLEtBQUcsR0FBRSxDQUFDLENBQUMsSUFBSSxHQUFDLEdBQUUsSUFBRSxLQUFHLEdBQUUsQ0FBQyxDQUFDLElBQUksR0FBQztRQUFFLElBQUksSUFBRSxPQUFPLEtBQUcsT0FBTyxNQUFJLE9BQU87UUFBYSxPQUFPLENBQUMsQ0FBQyxJQUFJLEdBQUMsR0FBRSxJQUFFLEtBQUcsR0FBRSxDQUFDLENBQUMsSUFBSSxHQUFDLEdBQUUsSUFBRSxLQUFHLEdBQUUsQ0FBQyxDQUFDLElBQUksR0FBQyxHQUFFLElBQUUsS0FBRyxHQUFFLENBQUMsQ0FBQyxJQUFJLEdBQUMsR0FBRTtJQUFDO0lBQUMsU0FBUyxHQUFHLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsR0FBRyxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUU7UUFBRyxJQUFJLElBQUUsT0FBTyxJQUFFLE9BQU87UUFBYSxDQUFDLENBQUMsSUFBRSxFQUFFLEdBQUMsR0FBRSxJQUFFLEtBQUcsR0FBRSxDQUFDLENBQUMsSUFBRSxFQUFFLEdBQUMsR0FBRSxJQUFFLEtBQUcsR0FBRSxDQUFDLENBQUMsSUFBRSxFQUFFLEdBQUMsR0FBRSxJQUFFLEtBQUcsR0FBRSxDQUFDLENBQUMsSUFBRSxFQUFFLEdBQUM7UUFBRSxJQUFJLElBQUUsT0FBTyxLQUFHLE9BQU8sTUFBSSxPQUFPO1FBQWEsT0FBTyxDQUFDLENBQUMsSUFBRSxFQUFFLEdBQUMsR0FBRSxJQUFFLEtBQUcsR0FBRSxDQUFDLENBQUMsSUFBRSxFQUFFLEdBQUMsR0FBRSxJQUFFLEtBQUcsR0FBRSxDQUFDLENBQUMsSUFBRSxFQUFFLEdBQUMsR0FBRSxJQUFFLEtBQUcsR0FBRSxDQUFDLENBQUMsRUFBRSxHQUFDLEdBQUUsSUFBRTtJQUFDO0lBQUMsRUFBRSxVQUFVLG1CQUFpQixFQUFFLFNBQVMsQ0FBQyxFQUFDLElBQUUsQ0FBQztRQUFFLE9BQU8sR0FBRyxJQUFJLEVBQUMsR0FBRSxHQUFFLE9BQU8sSUFBRyxPQUFPO0lBQXNCO0lBQUcsRUFBRSxVQUFVLG1CQUFpQixFQUFFLFNBQVMsQ0FBQyxFQUFDLElBQUUsQ0FBQztRQUFFLE9BQU8sR0FBRyxJQUFJLEVBQUMsR0FBRSxHQUFFLE9BQU8sSUFBRyxPQUFPO0lBQXNCO0lBQUcsRUFBRSxVQUFVLGFBQVcsU0FBUyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsSUFBRyxJQUFFLENBQUMsR0FBRSxJQUFFLE1BQUksR0FBRSxDQUFDLEdBQUU7WUFBQyxJQUFJLElBQUUsS0FBSyxJQUFJLEdBQUUsSUFBRSxJQUFFO1lBQUcsRUFBRSxJQUFJLEVBQUMsR0FBRSxHQUFFLEdBQUUsSUFBRSxHQUFFLENBQUM7UUFBRTtRQUFDLElBQUksSUFBRSxHQUFFLElBQUUsR0FBRSxJQUFFO1FBQUUsSUFBSSxJQUFJLENBQUMsRUFBRSxHQUFDLElBQUUsS0FBSSxFQUFFLElBQUUsS0FBSSxDQUFBLEtBQUcsR0FBRSxHQUFJLElBQUUsS0FBRyxNQUFJLEtBQUcsSUFBSSxDQUFDLElBQUUsSUFBRSxFQUFFLEtBQUcsS0FBSSxDQUFBLElBQUUsQ0FBQSxHQUFHLElBQUksQ0FBQyxJQUFFLEVBQUUsR0FBQyxBQUFDLENBQUEsSUFBRSxLQUFHLENBQUEsSUFBRyxJQUFFO1FBQUksT0FBTyxJQUFFO0lBQUM7SUFBRSxFQUFFLFVBQVUsYUFBVyxTQUFTLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxJQUFHLElBQUUsQ0FBQyxHQUFFLElBQUUsTUFBSSxHQUFFLENBQUMsR0FBRTtZQUFDLElBQUksSUFBRSxLQUFLLElBQUksR0FBRSxJQUFFLElBQUU7WUFBRyxFQUFFLElBQUksRUFBQyxHQUFFLEdBQUUsR0FBRSxJQUFFLEdBQUUsQ0FBQztRQUFFO1FBQUMsSUFBSSxJQUFFLElBQUUsR0FBRSxJQUFFLEdBQUUsSUFBRTtRQUFFLElBQUksSUFBSSxDQUFDLElBQUUsRUFBRSxHQUFDLElBQUUsS0FBSSxFQUFFLEtBQUcsS0FBSSxDQUFBLEtBQUcsR0FBRSxHQUFJLElBQUUsS0FBRyxNQUFJLEtBQUcsSUFBSSxDQUFDLElBQUUsSUFBRSxFQUFFLEtBQUcsS0FBSSxDQUFBLElBQUUsQ0FBQSxHQUFHLElBQUksQ0FBQyxJQUFFLEVBQUUsR0FBQyxBQUFDLENBQUEsSUFBRSxLQUFHLENBQUEsSUFBRyxJQUFFO1FBQUksT0FBTyxJQUFFO0lBQUM7SUFBRSxFQUFFLFVBQVUsWUFBVSxTQUFTLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLE9BQU8sSUFBRSxDQUFDLEdBQUUsSUFBRSxNQUFJLEdBQUUsS0FBRyxFQUFFLElBQUksRUFBQyxHQUFFLEdBQUUsR0FBRSxLQUFJLE9BQU0sSUFBRSxLQUFJLENBQUEsSUFBRSxNQUFJLElBQUUsQ0FBQSxHQUFHLElBQUksQ0FBQyxFQUFFLEdBQUMsSUFBRSxLQUFJLElBQUU7SUFBQztJQUFFLEVBQUUsVUFBVSxlQUFhLFNBQVMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsT0FBTyxJQUFFLENBQUMsR0FBRSxJQUFFLE1BQUksR0FBRSxLQUFHLEVBQUUsSUFBSSxFQUFDLEdBQUUsR0FBRSxHQUFFLE9BQU0sU0FBUSxJQUFJLENBQUMsRUFBRSxHQUFDLElBQUUsS0FBSSxJQUFJLENBQUMsSUFBRSxFQUFFLEdBQUMsTUFBSSxHQUFFLElBQUU7SUFBQztJQUFFLEVBQUUsVUFBVSxlQUFhLFNBQVMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsT0FBTyxJQUFFLENBQUMsR0FBRSxJQUFFLE1BQUksR0FBRSxLQUFHLEVBQUUsSUFBSSxFQUFDLEdBQUUsR0FBRSxHQUFFLE9BQU0sU0FBUSxJQUFJLENBQUMsRUFBRSxHQUFDLE1BQUksR0FBRSxJQUFJLENBQUMsSUFBRSxFQUFFLEdBQUMsSUFBRSxLQUFJLElBQUU7SUFBQztJQUFFLEVBQUUsVUFBVSxlQUFhLFNBQVMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsT0FBTyxJQUFFLENBQUMsR0FBRSxJQUFFLE1BQUksR0FBRSxLQUFHLEVBQUUsSUFBSSxFQUFDLEdBQUUsR0FBRSxHQUFFLFlBQVcsY0FBYSxJQUFJLENBQUMsRUFBRSxHQUFDLElBQUUsS0FBSSxJQUFJLENBQUMsSUFBRSxFQUFFLEdBQUMsTUFBSSxHQUFFLElBQUksQ0FBQyxJQUFFLEVBQUUsR0FBQyxNQUFJLElBQUcsSUFBSSxDQUFDLElBQUUsRUFBRSxHQUFDLE1BQUksSUFBRyxJQUFFO0lBQUM7SUFBRSxFQUFFLFVBQVUsZUFBYSxTQUFTLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLE9BQU8sSUFBRSxDQUFDLEdBQUUsSUFBRSxNQUFJLEdBQUUsS0FBRyxFQUFFLElBQUks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LEtBQUk7WUFBSyxJQUFHLElBQUUsTUFBSyxJQUFFLEtBQUk7Z0JBQUMsSUFBRyxBQUFDLENBQUEsS0FBRyxDQUFBLElBQUcsR0FBRTtnQkFBTSxFQUFFLEtBQUs7WUFBRSxPQUFNLElBQUcsSUFBRSxNQUFLO2dCQUFDLElBQUcsQUFBQyxDQUFBLEtBQUcsQ0FBQSxJQUFHLEdBQUU7Z0JBQU0sRUFBRSxLQUFLLEtBQUcsSUFBRSxLQUFJLElBQUUsS0FBRztZQUFJLE9BQU0sSUFBRyxJQUFFLE9BQU07Z0JBQUMsSUFBRyxBQUFDLENBQUEsS0FBRyxDQUFBLElBQUcsR0FBRTtnQkFBTSxFQUFFLEtBQUssS0FBRyxLQUFHLEtBQUksS0FBRyxJQUFFLEtBQUcsS0FBSSxJQUFFLEtBQUc7WUFBSSxPQUFNLElBQUcsSUFBRSxTQUFRO2dCQUFDLElBQUcsQUFBQyxDQUFBLEtBQUcsQ0FBQSxJQUFHLEdBQUU7Z0JBQU0sRUFBRSxLQUFLLEtBQUcsS0FBRyxLQUFJLEtBQUcsS0FBRyxLQUFHLEtBQUksS0FBRyxJQUFFLEtBQUcsS0FBSSxJQUFFLEtBQUc7WUFBSSxPQUFNLE1BQU0sSUFBSSxNQUFNO1FBQXFCO1FBQUMsT0FBTztJQUFDO0lBQUMsU0FBUyxHQUFHLENBQUM7UUFBRSxJQUFJLElBQUUsRUFBRTtRQUFDLElBQUksSUFBSSxJQUFFLEdBQUUsSUFBRSxFQUFFLFFBQU8sRUFBRSxFQUFFLEVBQUUsS0FBSyxFQUFFLFdBQVcsS0FBRztRQUFLLE9BQU87SUFBQztJQUFDLFNBQVMsR0FBRyxDQUFDLEVBQUMsQ0FBQztRQUFFLElBQUksR0FBRSxHQUFFLEdBQUUsSUFBRSxFQUFFO1FBQUMsSUFBSSxJQUFJLElBQUUsR0FBRSxJQUFFLEVBQUUsVUFBUSxDQUFFLENBQUEsQUFBQyxDQUFBLEtBQUcsQ0FBQSxJQUFHLENBQUEsR0FBRyxFQUFFLEVBQUUsSUFBRSxFQUFFLFdBQVcsSUFBRyxJQUFFLEtBQUcsR0FBRSxJQUFFLElBQUUsS0FBSSxFQUFFLEtBQUssSUFBRyxFQUFFLEtBQUs7UUFBRyxPQUFPO0lBQUM7SUFBQyxTQUFTLEdBQUcsQ0FBQztRQUFFLE9BQU8sRUFBRSxZQUFZLEdBQUc7SUFBRztJQUFDLFNBQVMsRUFBRSxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsSUFBSTtRQUFFLElBQUksSUFBRSxHQUFFLElBQUUsS0FBRyxDQUFFLENBQUEsSUFBRSxLQUFHLEVBQUUsVUFBUSxLQUFHLEVBQUUsTUFBSyxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUMsSUFBRSxFQUFFLEdBQUMsQ0FBQyxDQUFDLEVBQUU7UUFBQyxPQUFPO0lBQUM7SUFBQyxTQUFTLEVBQUUsQ0FBQyxFQUFDLENBQUM7UUFBRSxPQUFPLGFBQWEsS0FBRyxLQUFHLFFBQU0sRUFBRSxlQUFhLFFBQU0sRUFBRSxZQUFZLFFBQU0sUUFBTSxFQUFFLFlBQVksU0FBTyxFQUFFO0lBQUk7SUFBQyxTQUFTLEVBQUUsQ0FBQztRQUFFLE9BQU8sTUFBSTtJQUFDO0lBQUMsSUFBSSxLQUFHO1FBQVcsSUFBSSxJQUFFLG9CQUFtQixJQUFFLElBQUksTUFBTTtRQUFLLElBQUksSUFBSSxJQUFFLEdBQUUsSUFBRSxJQUFHLEVBQUUsRUFBRTtZQUFDLElBQUksSUFBRSxJQUFFO1lBQUcsSUFBSSxJQUFJLElBQUUsR0FBRSxJQUFFLElBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQyxJQUFFLEVBQUUsR0FBQyxDQUFDLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxFQUFFO1FBQUE7UUFBQyxPQUFPO0lBQUM7SUFBSSxTQUFTLEVBQUUsQ0FBQztRQUFFLE9BQU8sT0FBTyxTQUFPLE1BQUksS0FBRztJQUFDO0lBQUMsU0FBUztRQUFLLE1BQU0sSUFBSSxNQUFNO0lBQXVCO0FBQUM7QUFBRyxJQUFJLElBQUUsQ0FBQztBQUFFLEdBQUcsR0FBRTtJQUFDLFNBQVEsSUFBSTtBQUFFO0FBQUcsT0FBTyxVQUFRLEdBQUc7QUFBRyxJQUFJLEtBQUcsRUFBRTtBQUFLLEVBQUUsR0FBRSxFQUFFLE1BQUssT0FBTztBQUFTLElBQUksS0FBRyxHQUFHLFNB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O1lBRS9CLElBQUksQ0FBQyxxQkFBcUI7UUFDM0IsT0FBTSxJQUFJLFVBQVUsY0FBYztZQUNqQyxtQkFBbUI7WUFDbkIsSUFBSSxDQUFDLFNBQVMsUUFBUSxJQUFJLENBQUM7WUFDM0IsSUFBSSxVQUFVLFdBQVcsSUFBSSxDQUFDLEtBQUs7WUFDbkMsSUFBSSxDQUFDLHFCQUFxQjtRQUMzQjtJQUNIO0FBQ0Q7a0JBalNvQjs7Ozs7QUU5QnJCO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURBO0FBQ0E7Ozs7O0FFVUEscURBQWE7QUFYYjtBQUNBO0EsSSxZLGEsVSxhLFMsTyxFLFUsRSxDLEUsUztJLFMsTSxLO1EsTyxpQixJLFEsSSxFLFMsTztZLFE7UTtJO0ksTyxJLEMsSyxDLEksTyxDLEUsUyxPLEUsTTtRLFMsVSxLO1ksSTtnQixLLFUsSztZLEUsTyxHO2dCLE87WTtRO1EsUyxTLEs7WSxJO2dCLEssUyxDLFEsQztZLEUsTyxHO2dCLE87WTtRO1EsUyxLLE07WSxPLE8sUSxPLFMsTSxPLE8sSyxXO1E7USxLLEEsQyxZLFUsTSxTLGMsRSxDLEU7STtBO0FBVU0sTUFBTztJQU1YLFlBQ0UsR0FBVyxFQUNYLEVBQ0UsVUFBVSxDQUFBLENBQUUsRUFDWixXQUFXLEVBQ1gsU0FBUyxDQUFBLEdBQUEscUJBQUEsRUFBZSxHQUFHLEVBQUEsR0FLekIsQ0FBQSxDQUFFLENBVlI7UUFZRSxJQUFJLENBQUMsTUFBTTtRQUNYLElBQUksQ0FBQyxVQUFVO1FBQ2YsSUFBSSxDQUFDLFNBQVM7UUFDZCxJQUFJLENBQUMsUUFBUSxDQUFBLEdBQUEsb0JBQUEsRUFBYTtJQUM1QjtJQUVBOzs7S0FHRyxHQUNILFFBQVEsS0FBYSxFQUFyQjtRQUNFLElBQUksQ0FBQyxRQUFRLGdCQUFnQixDQUFBLE9BQUEsRUFBVSxNQUFLLENBQUU7SUFDaEQ7SUFFQTs7OztLQUlHLEdBQ0csT0FDSixZQUFvQixFQUNwQixVQUFpQyxDQUFBLENBQUUsRUFGL0I7USxJO1EsTyxVLEksRSxLLEcsSyxHO1lBSUosSUFBSTtnQkFDRixN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LENBQS9FO1FBQ0UsS0FBSyxDQUFDLEtBQUssU0FBUztJQUN0QjtJQUVBOzs7O0tBSUcsR0FDSCxLQUFLLEVBQVUsRUFBZjtRQUNFLE9BQU8sSUFBSSxDQUFBLEdBQUEsOEJBQUEsRUFBZSxJQUFJLENBQUMsS0FBSyxJQUFJLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQztJQUM3RDtBQUNEOzs7OztBRWpCRDtBQUNBO0FBQ0E7QSxJLFksYSxVLGEsUyxPLEUsVSxFLEMsRSxTO0ksUyxNLEs7USxPLGlCLEksUSxJLEUsUyxPO1ksUTtRO0k7SSxPLEksQyxLLEMsSSxPLEMsRSxTLE8sRSxNO1EsUyxVLEs7WSxJO2dCLEssVSxLO1ksRSxPLEc7Z0IsTztZO1E7USxTLFMsSztZLEk7Z0IsSyxTLEMsUSxDO1ksRSxPLEc7Z0IsTztZO1E7USxTLEssTTtZLE8sTyxRLE8sUyxNLE8sTyxLLFc7UTtRLEssQSxDLFksVSxNLFMsYyxFLEMsRTtJO0E7QUFVQSxNQUFNLHlCQUF5QjtJQUM3QixPQUFPO0lBQ1AsUUFBUTtJQUNSLFFBQVE7UUFDTixRQUFRO1FBQ1IsT0FBTztJQUNSO0FBQ0Y7QUFFRCxNQUFNLHVCQUFvQztJQUN4QyxjQUFjO0lBQ2QsYUFBYTtJQUNiLFFBQVE7QUFDVDtBQWNhLE1BQU87SUFNbkIsWUFDRSxHQUFXLEVBQ1gsVUFBcUMsQ0FBQSxDQUFFLEVBQ3ZDLFFBQWlCLEVBQ2pCLEtBQWEsQ0FKZjtRQU1FLElBQUksQ0FBQyxNQUFNO1FBQ1gsSUFBSSxDQUFDLFVBQVU7UUFDZixJQUFJLENBQUMsV0FBVztRQUNoQixJQUFJLENBQUMsUUFBUSxDQUFBLEdBQUEscUJBQUEsRUFBYTtJQUM1QjtJQUVBOzs7Ozs7S0FNRyxHQUNXLGVBQ1osTUFBc0IsRUFDdEIsSUFBWSxFQUNaLFFBQWtCLEVBQ2xCLFdBQXlCLEVBSmI7USxPLFUsSSxFLEssRyxLLEc7WUFlWixJQUFJO2dCQUNGLElBQUk7Z0JBQ0osTUFBTSxVQUFPLE9BQUEsT0FBQSxPQUFBLE9BQUEsQ0FBQSxHQUFRLHVCQUF5QjtnQkFDOUMsTUFB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QUssQ0FBQyxPQUFTLFFBQVEsT0FDdkIsTUFBTSxDQUFDLFFBQVUsWUFBWSxPQUFPO1FBQ3pDO0lBQ0Y7QUFBQztBQUVLLFNBQWdCLElBQ3BCLE9BQWMsRUFDZCxHQUFXLEVBQ1gsT0FBc0IsRUFDdEIsVUFBNEI7SSxPLFUsSSxFLEssRyxLLEc7UUFFNUIsT0FBTyxlQUFlLFNBQVMsT0FBTyxLQUFLLFNBQVM7SUFDdEQ7QUFBQztBQUVLLFNBQWdCLEtBQ3BCLE9BQWMsRUFDZCxHQUFXLEVBQ1gsSUFBWSxFQUNaLE9BQXNCLEVBQ3RCLFVBQTRCO0ksTyxVLEksRSxLLEcsSyxHO1FBRTVCLE9BQU8sZUFBZSxTQUFTLFFBQVEsS0FBSyxTQUFTLFlBQVk7SUFDbkU7QUFBQztBQUVLLFNBQWdCLElBQ3BCLE9BQWMsRUFDZCxHQUFXLEVBQ1gsSUFBWSxFQUNaLE9BQXNCLEVBQ3RCLFVBQTRCO0ksTyxVLEksRSxLLEcsSyxHO1FBRTVCLE9BQU8sZUFBZSxTQUFTLE9BQU8sS0FBSyxTQUFTLFlBQVk7SUFDbEU7QUFBQztBQUVLLFNBQWdCLE9BQ3BCLE9BQWMsRUFDZCxHQUFXLEVBQ1gsSUFBWSxFQUNaLE9BQXNCLEVBQ3RCLFVBQTRCO0ksTyxVLEksRSxLLEcsSyxHO1FBRTVCLE9BQU8sZUFBZSxTQUFTLFVBQVUsS0FBSyxTQUFTLFlBQVk7SUFDckU7QUFBQzs7Ozs7a0RFM0dZO3FEQWFBO0EsSSxZLGEsVSxhLFMsTyxFLFUsRSxDLEUsUztJLFMsTSxLO1EsTyxpQixJLFEsSSxFLFMsTztZLFE7UTtJO0ksTyxJLEMsSyxDLEksTyxDLEUsUyxPLEUsTTtRLFMsVSxLO1ksSTtnQixLLFUsSztZLEUsTyxHO2dCLE87WTtRO1EsUyxTLEs7WSxJO2dCLEssUyxDLFEsQztZLEUsTyxHO2dCLE87WTtRO1EsUyxLLE07WSxPLE8sUSxPLFMsTSxPLE8sSyxXO1E7USxLLEEsQyxZLFUsTSxTLGMsRSxDLEU7STtBO0FBYk4sTUFBTSxlQUFlLENBQUM7SUFDM0IsSUFBSTtJQUNKLElBQUksYUFDRixTQUFTO1NBQ0osSUFBSSxPQUFPLFVBQVUsYUFDMUIsU0FBUyxDQUFDLEdBQUcsT0FDWCxRQUFPLG9CQUErQixLQUFLLENBQUMsRUFBRSxTQUFTLE1BQUssRUFBRSxHQUFLLFVBQVM7U0FFOUUsU0FBUztJQUVYLE9BQU8sQ0FBQyxHQUFHLE9BQVMsVUFBVTtBQUNoQztBQUVPLE1BQU0sa0JBQWtCLElBQS9CLFVBQUEsS0FBQSxHQUFBLEtBQUEsR0FBQSxLQUFBLEdBQUE7UUFDRSxJQUFJLE9BQU8sYUFBYSxhQUN0QixhQUFhO1FBQ2IsT0FBTyxBQUFDLENBQUEsTUFBTSxRQUFPLG1CQUE2QixFQUFHO1FBR3ZELE9BQU87SUFDVDs7Ozs7QUV0QkE7QUFDQTtBQUNBO0FBQ0E7QSxJLFksYSxVLGEsUyxPLEUsVSxFLEMsRSxTO0ksUyxNLEs7USxPLGlCLEksUSxJLEUsUyxPO1ksUTtRO0k7SSxPLEksQyxLLEMsSSxPLEMsRSxTLE8sRSxNO1EsUyxVLEs7WSxJO2dCLEssVSxLO1ksRSxPLEc7Z0IsTztZO1E7USxTLFMsSztZLEk7Z0IsSyxTLEMsUSxDO1ksRSxPLEc7Z0IsTztZO1E7USxTLEssTTtZLE8sTyxRLE8sUyxNLE8sTyxLLFc7UTtRLEssQSxDLFksVSxNLFMsYyxFLEMsRTtJO0E7QUFHYyxNQUFPO0lBS25CLFlBQVksR0FBVyxFQUFFLFVBQXFDLENBQUEsQ0FBRSxFQUFFLEtBQWEsQ0FBL0U7UUFDRSxJQUFJLENBQUMsTUFBTTtRQUNYLElBQUksQ0FBQyxVQUFPLE9BQUEsT0FBQSxPQUFBLE9BQUEsQ0FBQSxHQUFRLENBQUEsR0FBQSwwQkFBQSxJQUFvQjtRQUN4QyxJQUFJLENBQUMsUUFBUSxDQUFBLEdBQUEscUJBQUEsRUFBYTtJQUM1QjtJQUVBOztLQUVHLEdBQ0csY0FBQTtRLE8sVSxJLEUsSyxHLEssRztZQVVKLElBQUk7Z0JBQ0YsTUFBTSxPQUFPLE1BQU0sQ0FBQSxHQUFBLFVBQUEsRUFBSSxJQUFJLENBQUMsT0FBTyxDQUFBLEVBQUcsSUFBSSxDQUFDLElBQUcsT0FBQSxDQUFTLEVBQUU7b0JBQUUsU0FBUyxJQUFJLENBQUM7Z0JBQU87Z0JBQ2hGLE9BQU87b0JBQUU7b0JBQU0sT0FBTztnQkFBSTtZQUMzQixFQUFDLE9BQU8sT0FBTztnQkFDZCxJQUFJLENBQUEsR0FBQSxzQkFBQSxFQUFlLFFBQ2pCLE9BQU87b0JBQUUsTUFBTTtvQkFBTTtnQkFBSztnQkFHNUIsTUFBTTtZQUNQO1FBQ0g7SUFBQztJQUVEOzs7O0tBSUcsR0FDRyxVQUNKLEVBQVUsRUFETjtRLE8sVSxJLEUsSyxHLEssRztZQVlKLElBQUk7Z0JBQ0YsTUFBTSxPQUFPLE1BQU0sQ0FBQSxHQUFBLFVBQUEsRUFBSSxJQUFJLENBQUMsT0FBTyxDQUFBLEVBQUcsSUFBSSxDQUFDLElBQUcsUUFBQSxFQUFXLEdBQUUsQ0FBRSxFQUFFO29CQUFFLFNBQVMsSUFBSSxDQUFDO2dCQUFPO2dCQUN0RixPQUFPO29CQUFFO29CQUFNLE9BQU87Z0JBQUk7WUFDM0IsRUFBQyxPQUFPLE9BQU87Z0JBQ2QsSUFBSSxDQUFBLEdBQUEsc0JBQUEsRUFBZSxRQUNqQixPQUFPO29CQUFFLE1BQU07b0JBQU07Z0JBQUs7Z0JBRzVCLE1BQU07WUFDUDtRQUNIO0lBQUM7SUFFRDs7Ozs7Ozs7Ozs7O0tBWUcsR0FDRyxhQUNKLEVBQVUsRUFDVixVQUlJO1FBQ0YsUUFBUTtJQUNULENBQUEsRUFBQTtRLE8sVSxJLEUsSyxHLEssRztZQVdELElBQUk7Z0JBQ0YsTUFBTSxPQUFPLE1BQU0sQ0FBQSxHQUFBLFdBQUEsRUFDakIsSUFBSSxDQUFDLE9BQ0wsQ0FBQSxFQUFHLElBQUksQ0FBQyxJQUFHLE9BQUEsQ0FBUyxFQUNwQjtvQkFDRTtvQkFDQSxNQUFNO29CQUNOLFFBQVEsUUFBUTtvQkFDaEIsaUJBQWlCLFFBQVE7b0JBQ3pCLG9CQUFvQixRQUFRO2dCQUM3QixHQUNEO29CQUFFLFNBQVMsSUFBSSxDQUFDO2dCQUFPO2dCQUV6QixPQUFPO29CQUFFO29CQUFNLE9BQU87Z0JBQUk7WUFDM0IsRUFBQyxPQUFPLE9BQU87Z0JBQ2QsSUFBSSxDQUFBLEdBQUEsc0JBQUEsRUFBZSxRQUNqQixPQUFPO29CQUFFLE1BQU07b0JBQU07Z0JBQUs7Z0JBRzVCLE1BQU07WUFDUDtRQUNIO0lBQUM7SUFFRDs7Ozs7Ozs7Ozs7S0FXRyxHQUNHLGFBQ0osRUFBVSxFQUNWLE9BSUMsRUFORztRLE8sVSxJLEUsSyxHLEssRztZQWlCSixJQUFJO2dCQUNGLE1BQU0sT0FBTyxNQUFNLENBQUEsR0FBQSxVQUFBLEVBQ2pCLElBQUksQ0FBQyxPQUNMLENBQUEsRUFBRyxJQUFJLENBQUMsSUFBRyxRQUFBLEVBQVcsR0FBRSxDQUFFLEVBQzFCO29CQUNFO29CQUNBLE1BQU07b0JBQ04sUUFBUSxRQUFRO29CQUNoQixpQkFBaUIsUUFBUTtvQkFDekIsb0JBQW9CLFFBQVE7Z0JBQzdCLEdBQ0Q7b0JBQUUsU0FBUyxJQUFJLENBQUM7Z0JBQU87Z0JBRXpCLE9BQU87b0JBQUU7b0JBQU0sT0FBTztnQkFBSTtZQUMzQixFQUFDLE9BQU8sT0FBTztnQkFDZCxJQUFJLENBQUEsR0FBQSxzQkFBQSxFQUFlLFFBQ2pCLE9BQU87b0JBQUUsTUFBTTtvQkFBTTtnQkFBSztnQkFHNUIsTUFBTTtZQUNQO1FBQ0g7SUFBQztJQUVEOzs7O0tBSUcsR0FDRyxZQUNKLEVBQVUsRUFETjtRLE8sVSxJLEUsSyxHLEssRztZQVlKLElBQUk7Z0JBQ0YsTUFBTSxPQUFPLE1BQU0sQ0FBQSxHQUFBLFdBQUEsRUFDakIsSUFBSSxDQUFDLE9BQ0wsQ0FBQSxFQUFHLElBQUksQ0FBQyxJQUFHLFFBQUEsRUFBVyxHQUFFLE1BQUEsQ0FBUSxFQUNoQyxDQUFBLEdBQ0E7b0JBQUUsU0FBUyxJQUFJLENBQUM7Z0JBQU87Z0JBRXpCLE9BQU87b0JBQUU7b0JBQU0sT0FBTztnQkFBSTtZQUMzQixFQUFDLE9BQU8sT0FBTztnQkFDZCxJQUFJLENBQUEsR0FBQSxzQkFBQSxFQUFlLFFBQ2pCLE9BQU87b0JBQUUsTUFBTTtvQkFBTTtnQkFBSztnQkFHNUIsTUFBTTtZQUNQO1FBQ0g7SUFBQztJQUVEOzs7OztLQUtHLEdBQ0csYUFDSixFQUFVLEVBRE47USxPLFUsSSxFLEssRyxLLEc7WUFZSixJQUFJO2dCQUNGLE1BQU0sT0FBTyxNQUFNLENBQUEsR0FBQSxhQUFBLEVBQ2pCLElBQUksQ0FBQyxPQUNMLENBQUEsRUFBRyxJQUFJLENBQUMsSUFBRyxRQUFBLEVBQVcsR0FBRSxDQUFFLEVBQzFCLENBQUEsR0FDQTtvQkFBRSxTQUFTLElBQUksQ0FBQztnQkFBTztnQkFFekIsT0FBTztvQkFBRTtvQkFBTSxPQUFPO2dCQUFJO1lBQzNCLEVBQUMsT0FBTyxPQUFPO2dCQUNkLElBQUksQ0FBQSxHQUFBLHNCQUFBLEVBQWUsUUFDakIsT0FBTztvQkFBRSxNQUFNO29CQUFNO2dCQUFLO2dCQUc1QixNQUFNO1lBQ1A7UUFDSDtJQUFDO0FBQ0Y7a0JBaFBvQjs7Ozs7cURFTFI7QUFEYjtBQUNPLE1BQU0sa0JBQWtCO0lBQUUsaUJBQWlCLENBQUEsV0FBQSxFQUFjLENBQUEsR0FBQSxnQkFBQSxFQUFPLENBQUU7QUFBQTs7O0FFRHpFLDBCQUEwQjs7OzZDQUNiO0FBQU4sTUFBTSxVQUFVOzs7Ozs7Ozs7cURHZ0JWOzREQUVBO3dEQUlBOzBEQUlBOzhEQU9BO0FBL0JiO0FBRUEsSUFBSSxTQUFTO0FBQ2IsYUFBYTtBQUNiLElBQUksT0FBTyxTQUFTLGFBQ2xCLFNBQVM7S0FDSixJQUFJLE9BQU8sYUFBYSxhQUM3QixTQUFTO0tBQ0osSUFBSSxPQUFPLGNBQWMsZUFBZSxVQUFVLFlBQVksZUFDbkUsU0FBUztLQUVULFNBQVM7QUFHSixNQUFNLGtCQUFrQjtJQUFFLGlCQUFpQixDQUFBLFlBQUEsRUFBZSxPQUFNLENBQUEsRUFBSSxDQUFBLEdBQUEsZ0JBQUEsRUFBTyxDQUFFO0FBQUE7QUFFN0UsTUFBTSx5QkFBeUI7SUFDcEMsU0FBUztBQUNWO0FBRU0sTUFBTSxxQkFBcUI7SUFDaEMsUUFBUTtBQUNUO0FBRU0sTUFBTSx1QkFBa0Q7SUFDN0Qsa0JBQWtCO0lBQ2xCLGdCQUFnQjtJQUNoQixvQkFBb0I7SUFDcEIsVUFBVTtBQUNYO0FBRU0sTUFBTSwyQkFBa0QsQ0FBQTs7Ozs7NkNFbENsRDtBQUFOLE1BQU0sVUFBVTs7Ozs7a0RFS1Y7K0RBWUE7bURBUUE7QUF6QmIsYUFBYTtBQUNiOztBLEksWSxhLFUsYSxTLE8sRSxVLEUsQyxFLFM7SSxTLE0sSztRLE8saUIsSSxRLEksRSxTLE87WSxRO1E7STtJLE8sSSxDLEssQyxJLE8sQyxFLFMsTyxFLE07USxTLFUsSztZLEk7Z0IsSyxVLEs7WSxFLE8sRztnQixPO1k7UTtRLFMsUyxLO1ksSTtnQixLLFMsQyxRLEM7WSxFLE8sRztnQixPO1k7UTtRLFMsSyxNO1ksTyxPLFEsTyxTLE0sTyxPLEssVztRO1EsSyxBLEMsWSxVLE0sUyxjLEUsQyxFO0k7QTtBQUlPLE1BQU0sZUFBZSxDQUFDO0lBQzNCLElBQUk7SUFDSixJQUFJLGFBQ0YsU0FBUztTQUNKLElBQUksT0FBTyxVQUFVLGFBQzFCLFNBQVMsQ0FBQSxHQUFBLHlCQUFBO1NBRVQsU0FBUztJQUVYLE9BQU8sQ0FBQyxHQUFHLE9BQTRCLFVBQVU7QUFDbkQ7QUFFTyxNQUFNLDRCQUE0QjtJQUN2QyxJQUFJLE9BQU8sWUFBWSxhQUNyQixPQUFPLEdBQUE7SUFHVCxPQUFPO0FBQ1Q7QUFFTyxNQUFNLGdCQUFnQixDQUMzQixhQUNBLGdCQUNBO0lBRUEsTUFBTSxTQUFRLGFBQWE7SUFDM0IsTUFBTSxxQkFBcUI7SUFFM0IsT0FBTyxDQUFPLE9BQU8sT0FBckIsVUFBQSxLQUFBLEdBQUEsS0FBQSxHQUFBLEtBQUEsR0FBQTtZLEk7WUFDRSxNQUFNLGNBQWMsQUFBQSxDQUFBLEtBQUMsTUFBTSxnQkFBZ0IsTUFBQyxRQUFBLE9BQUEsS0FBQSxJQUFBLEtBQUk7WUFDaEQsSUFBSSxVQUFVLElBQUksbUJBQW1CLFNBQUksUUFBSixTQUFJLEtBQUEsSUFBQSxLQUFBLElBQUosS0FBTTtZQUUzQyxJQUFJLENBQUMsUUFBUSxJQUFJLFdBQ2YsUUFBUSxJQUFJLFVBQVU7WUFHeEIsSUFBSSxDQUFDLFFBQVEsSUFBSSxrQkFDZixRQUFRLElBQUksaUJBQWlCLENBQUEsT0FBQSxFQUFVLFlBQVcsQ0FBRTtZQUd0RCxPQUFPLE9BQU0sT0FBSyxPQUFBLE9BQUEsT0FBQSxPQUFBLENBQUEsR0FBTyxPQUFJO2dCQUFFO1lBQU87UUFDeEM7QUFDRjs7Ozs7QUU1Q0EsMENBQWdCO0FBUWhCLHdEQUFnQjsrQ0FJSDtBQUViLDBEQUFnQjtBQWRWLFNBQVU7SUFDZCxPQUFPLHVDQUF1QyxRQUFRLFNBQVMsU0FBVSxDQUFDO1FBQ3hFLElBQUksSUFBSSxBQUFDLEtBQUssV0FBVyxLQUFNLEdBQzdCLElBQUksS0FBSyxNQUFNLElBQUksQUFBQyxJQUFJLE1BQU87UUFDakMsT0FBTyxFQUFFLFNBQVM7SUFDcEI7QUFDRjtBQUVNLFNBQVUsbUJBQW1CLEdBQVc7SUFDNUMsT0FBTyxJQUFJLFFBQVEsT0FBTztBQUM1QjtBQUVPLE1BQU0sWUFBWSxJQUFNLE9BQU8sV0FBVztBQUUzQyxTQUFVLHFCQU1kLE9BQTBDLEVBQzFDLFFBQW9DO0lBRXBDLE1BQU0sRUFDSixJQUFJLFNBQVMsRUFDYixNQUFNLFdBQVcsRUFDakIsVUFBVSxlQUFlLEVBQ3pCLFFBQVEsYUFBYSxFQUN0QixHQUFHO0lBQ0osTUFBTSxFQUNKLElBQUksa0JBQWtCLEVBQ3RCLE1BQU0sb0JBQW9CLEVBQzFCLFVBQVUsd0JBQXdCLEVBQ2xDLFFBQVEsc0JBQXNCLEVBQy9CLEdBQUc7SUFFSixPQUFPO1FBQ0wsSUFBRSxPQUFBLE9BQUEsT0FBQSxPQUFBLENBQUEsR0FDRyxxQkFDQTtRQUVMLE1BQUksT0FBQSxPQUFBLE9BQUEsT0FBQSxDQUFBLEdBQ0MsdUJBQ0E7UUFFTCxVQUFRLE9BQUEsT0FBQSxPQUFBLE9BQUEsQ0FBQSxHQUNILDJCQUNBO1FBRUwsUUFBTSxPQUFBLE9BQUEsT0FBQSxPQUFBLENBQUEsR0FDRCx5QkFDQTtJQUVOO0FBQ0g7Ozs7O0FFdERBLHdEQUFhO0FBSGI7QUFHTSxNQUFPLDJCQUEyQixDQUFBLEdBQUEsa0JBQUE7SUFDdEMsWUFBWSxPQUFrQyxDQUE5QztRQUNFLEtBQUssQ0FBQztJQUNSO0FBQ0Q7Ozs7O0FFQUQ7QUFBQTtBQUFBO0FBSEEsb0RBQVMsQ0FBQSxHQUFBLDhCQUFBO0FBQVQsa0RBQXlCLENBQUEsR0FBQSw0QkFBQTtBQUF6QixrREFBdUMsQ0FBQSxHQUFBLDRCQUFBO0FBQXZDLGdEQUFxRCxDQUFBLEdBQUEsMEJBQUE7QUFKckQ7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7QUFBQSx3QkFBQTtBQUNBO0FBQUEsd0JBQUE7QUFDQTs7Ozs7QUVQQTtBQU9BO0FBZUE7QSxJLFMsYSxVLFUsUyxDLEUsQztJLEksSSxDO0ksSSxJLEssRSxJLE8sVSxlLEssRyxNLEUsUSxLLEcsQyxDLEUsRyxDLEMsRTtJLEksSyxRLE8sTywwQixZO1EsSSxJLEksRyxJLE8sc0IsSSxJLEUsUSxJLEksRSxRLEMsQyxFLEksSyxPLFUscUIsSyxHLEMsQyxFLEcsQyxDLEMsQyxFLEMsRyxDLEMsQyxDLEUsQztJO0ksTztBO0FBRWMsTUFBTztJQVVuQixZQUFZLEVBQ1YsTUFBTSxFQUFFLEVBQ1IsVUFBVSxDQUFBLENBQUUsRUFDWixLQUFLLEVBT04sQ0FWRDtRQVdFLElBQUksQ0FBQyxNQUFNO1FBQ1gsSUFBSSxDQUFDLFVBQVU7UUFDZixJQUFJLENBQUMsUUFBUSxDQUFBLEdBQUEscUJBQUEsRUFBYTtRQUMxQixJQUFJLENBQUMsTUFBTTtZQUNULGFBQWEsSUFBSSxDQUFDLGFBQWEsS0FBSyxJQUFJO1lBQ3hDLGNBQWMsSUFBSSxDQUFDLGNBQWMsS0FBSyxJQUFJO1FBQzNDO0lBQ0g7SUFFQTs7OztLQUlHLEdBQ0gsTUFBTSxRQUNKLEdBQVcsRUFDWCxRQUF1QyxRQUFRLEVBRmpEO1FBSUUsSUFBSTtZQUNGLE1BQU0sQ0FBQSxHQUFBLGVBQUEsRUFBUyxJQUFJLENBQUMsT0FBTyxRQUFRLENBQUEsRUFBRyxJQUFJLENBQUMsSUFBRyxjQUFBLEVBQWlCLE1BQUssQ0FBRSxFQUFFO2dCQUN0RSxTQUFTLElBQUksQ0FBQztnQkFDZDtnQkFDQSxlQUFlO1lBQ2hCO1lBQ0QsT0FBTztnQkFBRSxNQUFNO2dCQUFNLE9BQU87WUFBSTtRQUNqQyxFQUFDLE9BQU8sT0FBTztZQUNkLElBQUksQ0FBQSxHQUFBLG1CQUFBLEVBQVksUUFDZCxPQUFPO2dCQUFFLE1BQU07Z0JBQU07WUFBSztZQUc1QixNQUFNO1FBQ1A7SUFDSDtJQUVBOzs7O0tBSUcsR0FDSCxNQUFNLGtCQUNKLEtBQWEsRUFDYixVQU1JLENBQUEsQ0FBRSxFQVJSO1FBVUUsSUFBSTtZQUNGLE9BQU8sTUFBTSxDQUFBLEdBQUEsZUFBQSxFQUFTLElBQUksQ0FBQyxPQUFPLFFBQVEsQ0FBQSxFQUFHLElBQUksQ0FBQyxJQUFHLE9BQUEsQ0FBUyxFQUFFO2dCQUM5RCxNQUFNO29CQUFFO29CQUFPLE1BQU0sUUFBUTtnQkFBSTtnQkFDakMsU0FBUyxJQUFJLENBQUM7Z0JBQ2QsWUFBWSxRQUFRO2dCQUNwQixPQUFPLENBQUEsR0FBQSxvQkFBQTtZQUNSO1FBQ0YsRUFBQyxPQUFPLE9BQU87WUFDZCxJQUFJLENBQUEsR0FBQSxtQkFBQSxFQUFZLFFBQ2QsT0FBTztnQkFBRSxNQUFNO29CQUFFLE1BQU07Z0JBQUk7Z0JBQUk7WUFBSztZQUd0QyxNQUFNO1FBQ1A7SUFDSDtJQUVBOzs7Ozs7S0FNRyxHQUNILE1BQU0sYUFBYSxNQUEwQixFQUE3QztRQUNFLElBQUk7WUFDRixNQUFNLEVBQUUsT0FBTyxFQUFBLEdBQWMsUUFBVCxPQUFJLE9BQUssUUFBdkI7Z0JBQUE7YUFBb0I7WUFDMUIsTUFBTSxPQUFJLE9BQUEsT0FBQSxPQUFBLE9BQUEsQ0FBQSxHQUFhLE9BQVM7WUFDaEMsSUFBSSxjQUFjLE1BQU07Z0JBQ3RCLGtEQUFrRDtnQkFDbEQsS0FBSyxZQUFZLFNBQUksUUFBSixTQUFJLEtBQUEsSUFBQSxLQUFBLElBQUosS0FBTTtnQkFDdkIsT0FBTyxJQUFJLENBQUMsV0FBVztZQUN4QjtZQUNELE9BQU8sTUFBTSxDQUFBLEdBQUEsZUFBQSxFQUFTLElBQUksQ0FBQyxPQUFPLFFBQVEsQ0FBQSxFQUFHLElBQUksQ0FBQyxJQUFHLG9CQUFBLENBQXNCLEVBQUU7Z0JBQzNFLE1BQU07Z0JBQ04sU0FBUyxJQUFJLENBQUM7Z0JBQ2QsT0FBTyxDQUFBLEdBQUEsNEJBQUE7Z0JBQ1AsWUFBWSxZQUFPLFFBQVAsWUFBTyxLQUFBLElBQUEsS0FBQSxJQUFQLFFBQVM7WUFDdEI7UUFDRixFQUFDLE9BQU8sT0FBTztZQUNkLElBQUksQ0FBQSxHQUFBLG1CQUFBLEVBQVksUUFDZCxPQUFPO2dCQUNMLE1BQU07b0JBQ0osWUFBWTtvQkFDWixNQUFNO2dCQUNQO2dCQUNEO1lBQ0Q7WUFFSCxNQUFNO1FBQ1A7SUFDSDtJQUVBLGlCQUFpQjtJQUNqQjs7O0tBR0csR0FDSCxNQUFNLFdBQVcsVUFBK0IsRUFBaEQ7UUFDRSxJQUFJO1lBQ0YsT0FBTyxNQUFNLENBQUEsR0FBQSxlQUFBLEVBQVMsSUFBSSxDQUFDLE9BQU8sUUFBUSxDQUFBLEVBQUcsSUFBSSxDQUFDLElBQUcsWUFBQSxDQUFjLEVBQUU7Z0JBQ25FLE1BQU07Z0JBQ04sU0FBUyxJQUFJLENBQUM7Z0JBQ2QsT0FBTyxDQUFBLEdBQUEsb0JBQUE7WUFDUjtRQUNGLEVBQUMsT0FBTyxPQUFPO1lBQ2QsSUFBSSxDQUFBLEdBQUEsbUJBQUEsRUFBWSxRQUNkLE9BQU87Z0JBQUUsTUFBTTtvQkFBRSxNQUFNO2dCQUFJO2dCQUFJO1lBQUs7WUFHdEMsTUFBTTtRQUNQO0lBQ0g7SUFFQTs7Ozs7S0FLRyxHQUNILE1BQU0sVUFDSixNQUFtQixFQURyQjtRLEksSSxJLEksSSxJLEk7UUFNRSxJQUFJO1lBQ0YsTUFBTSxhQUF5QjtnQkFBRSxVQUFVO2dCQUFNLFVBQVU7Z0JBQUcsT0FBTztZQUFDO1lBQ3RFLE1BQU0sV0FBVyxNQUFNLENBQUEsR0FBQSxlQUFBLEVBQVMsSUFBSSxDQUFDLE9BQU8sT0FBTyxDQUFBLEVBQUcsSUFBSSxDQUFDLElBQUcsWUFBQSxDQUFjLEVBQUU7Z0JBQzVFLFNBQVMsSUFBSSxDQUFDO2dCQUNkLGVBQWU7Z0JBQ2YsT0FBTztvQkFDTCxNQUFNLEFBQUEsQ0FBQSxLQUFBLEFBQUEsQ0FBQSxLQUFBLFdBQU0sUUFBTixXQUFNLEtBQUEsSUFBQSxLQUFBLElBQU4sT0FBUSxJQUFBLE1BQUksUUFBQSxPQUFBLEtBQUEsSUFBQSxLQUFBLElBQUEsR0FBRSxVQUFRLE1BQUUsUUFBQSxPQUFBLEtBQUEsSUFBQSxLQUFJO29CQUNsQyxVQUFVLEFBQUEsQ0FBQSxLQUFBLEFBQUEsQ0FBQSxLQUFBLFdBQU0sUUFBTixXQUFNLEtBQUEsSUFBQSxLQUFBLElBQU4sT0FBUSxPQUFBLE1BQU8sUUFBQSxPQUFBLEtBQUEsSUFBQSxLQUFBLElBQUEsR0FBRSxVQUFRLE1BQUUsUUFBQSxPQUFBLEtBQUEsSUFBQSxLQUFJO2dCQUMxQztnQkFDRCxPQUFPLENBQUEsR0FBQSw2QkFBQTtZQUNSO1lBQ0QsSUFBSSxTQUFTLE9BQU8sTUFBTSxTQUFTO1lBRW5DLE1BQU0sUUFBUSxNQUFNLFNBQVM7WUFDN0IsTUFBTSxRQUFRLEFBQUEsQ0FBQSxLQUFBLFNBQVMsUUFBUSxJQUFJLGdCQUFlLE1BQUMsUUFBQSxPQUFBLEtBQUEsSUFBQSxLQUFJO1lBQ3ZELE1BQU0sUUFBUSxBQUFBLENBQUEsS0FBQSxBQUFBLENBQUEsS0FBQSxTQUFTLFFBQVEsSUFBSSxPQUFNLE1BQUMsUUFBQSxPQUFBLEtBQUEsSUFBQSxLQUFBLElBQUEsR0FBRSxNQUFNLElBQUcsTUFBQyxRQUFBLE9BQUEsS0FBQSxJQUFBLEtBQUksRUFBRTtZQUM1RCxJQUFJLE1BQU0sU0FBUyxHQUFHO2dCQUNwQixNQUFNLFFBQVEsQ0FBQztvQkFDYixNQUFNLE9BQU8sU0FBUyxLQUFLLE1BQU0sSUFBSSxDQUFDLEVBQUUsQ0FBQyxNQUFNLElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxHQUFHO29CQUNwRSxNQUFNLE1BQU0sS0FBSyxNQUFNLEtBQUssTUFBTSxJQUFJLENBQUMsRUFBRSxDQUFDLE1BQU0sSUFBSSxDQUFDLEVBQUU7b0JBQ3ZELFVBQVUsQ0FBQyxDQUFBLEVBQUcsSUFBRyxJQUFBLENBQU0sQ0FBQyxHQUFHO2dCQUM3QjtnQkFFQSxXQUFXLFFBQVEsU0FBUztZQUM3QjtZQUNELE9BQU87Z0JBQUUsTUFBSSxPQUFBLE9BQUEsT0FBQSxPQUFBLENBQUEsR0FBTyxRQUFVO2dCQUFjLE9BQU87WUFBSTtRQUN4RCxFQUFDLE9BQU8sT0FBTztZQUNkLElBQUksQ0FBQSxHQUFBLG1CQUFBLEVBQVksUUFDZCxPQUFPO2dCQUFFLE1BQU07b0JBQUUsT0FBTyxFQUFFO2dCQUFBO2dCQUFJO1lBQUs7WUFFckMsTUFBTTtRQUNQO0lBQ0g7SUFFQTs7Ozs7O0tBTUcsR0FDSCxNQUFNLFlBQVksR0FBVyxFQUE3QjtRQUNFLElBQUk7WUFDRixPQUFPLE1BQU0sQ0FBQSxHQUFBLGVBQUEsRUFBUyxJQUFJLENBQUMsT0FBTyxPQUFPLENBQUEsRUFBRyxJQUFJLENBQUMsSUFBRyxhQUFBLEVBQWdCLElBQUcsQ0FBRSxFQUFFO2dCQUN6RSxTQUFTLElBQUksQ0FBQztnQkFDZCxPQUFPLENBQUEsR0FBQSxvQkFBQTtZQUNSO1FBQ0YsRUFBQyxPQUFPLE9BQU87WUFDZCxJQUFJLENBQUEsR0FBQSxtQkFBQSxFQUFZLFFBQ2QsT0FBTztnQkFBRSxNQUFNO29CQUFFLE1BQU07Z0JBQUk7Z0JBQUk7WUFBSztZQUd0QyxNQUFNO1FBQ1A7SUFDSDtJQUVBOzs7Ozs7S0FNRyxHQUNILE1BQU0sZUFBZSxHQUFXLEVBQUUsVUFBK0IsRUFBakU7UUFDRSxJQUFJO1lBQ0YsT0FBTyxNQUFNLENBQUEsR0FBQSxlQUFBLEVBQVMsSUFBSSxDQUFDLE9BQU8sT0FBTyxDQUFBLEVBQUcsSUFBSSxDQUFDLElBQUcsYUFBQSxFQUFnQixJQUFHLENBQUUsRUFBRTtnQkFDekUsTUFBTTtnQkFDTixTQUFTLElBQUksQ0FBQztnQkFDZCxPQUFPLENBQUEsR0FBQSxvQkFBQTtZQUNSO1FBQ0YsRUFBQyxPQUFPLE9BQU87WUFDZCxJQUFJLENBQUEsR0FBQSxtQkFBQSxFQUFZLFFBQ2QsT0FBTztnQkFBRSxNQUFNO29CQUFFLE1BQU07Z0JBQUk7Z0JBQUk7WUFBSztZQUd0QyxNQUFNO1FBQ1A7SUFDSDtJQUVBOzs7Ozs7OztLQVFHLEdBQ0gsTUFBTSxXQUFXLEVBQVUsRUFBRSxtQkFBbUIsS0FBSyxFQUFyRDtRQUNFLElBQUk7WUFDRixPQUFPLE1BQU0sQ0FBQSxHQUFBLGVBQUEsRUFBUyxJQUFJLENBQUMsT0FBTyxVQUFVLENBQUEsRUFBRyxJQUFJLENBQUMsSUFBRyxhQUFBLEVBQWdCLEdBQUUsQ0FBRSxFQUFFO2dCQUMzRSxTQUFTLElBQUksQ0FBQztnQkFDZCxNQUFNO29CQUNKLG9CQUFvQjtnQkFDckI7Z0JBQ0QsT0FBTyxDQUFBLEdBQUEsb0JBQUE7WUFDUjtRQUNGLEVBQUMsT0FBTyxPQUFPO1lBQ2QsSUFBSSxDQUFBLEdBQUEsbUJBQUEsRUFBWSxRQUNkLE9BQU87Z0JBQUUsTUFBTTtvQkFBRSxNQUFNO2dCQUFJO2dCQUFJO1lBQUs7WUFHdEMsTUFBTTtRQUNQO0lBQ0g7SUFFUSxNQUFNLGFBQ1osTUFBcUMsRUFEL0I7UUFHTixJQUFJO1lBQ0YsTUFBTSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsR0FBRyxNQUFNLENBQUEsR0FBQSxlQUFBLEVBQzVCLElBQUksQ0FBQyxPQUNMLE9BQ0EsQ0FBQSxFQUFHLElBQUksQ0FBQyxJQUFHLGFBQUEsRUFBZ0IsT0FBTyxPQUFNLFFBQUEsQ0FBVSxFQUNsRDtnQkFDRSxTQUFTLElBQUksQ0FBQztnQkFDZCxPQUFPLENBQUM7b0JBQ04sT0FBTzt3QkFBRSxNQUFNOzRCQUFFO3dCQUFPO3dCQUFJLE9BQU87b0JBQUk7Z0JBQ3pDO1lBQ0Q7WUFFSCxPQUFPO2dCQUFFO2dCQUFNO1lBQUs7UUFDckIsRUFBQyxPQUFPLE9BQU87WUFDZCxJQUFJLENBQUEsR0FBQSxtQkFBQSxFQUFZLFFBQ2QsT0FBTztnQkFBRSxNQUFNO2dCQUFNO1lBQUs7WUFHNUIsTUFBTTtRQUNQO0lBQ0g7SUFFUSxNQUFNLGNBQ1osTUFBc0MsRUFEaEM7UUFHTixJQUFJO1lBQ0YsTUFBTSxPQUFPLE1BQU0sQ0FBQSxHQUFBLGVBQUEsRUFDakIsSUFBSSxDQUFDLE9BQ0wsVUFDQSxDQUFBLEVBQUcsSUFBSSxDQUFDLElBQUcsYUFBQSxFQUFnQixPQUFPLE9BQU0sU0FBQSxFQUFZLE9BQU8sR0FBRSxDQUFFLEVBQy9EO2dCQUNFLFNBQVMsSUFBSSxDQUFDO1lBQ2Y7WUFHSCxPQUFPO2dCQUFFO2dCQUFNLE9BQU87WUFBSTtRQUMzQixFQUFDLE9BQU8sT0FBTztZQUNkLElBQUksQ0FBQSxHQUFBLG1CQUFBLEVBQVksUUFDZCxPQUFPO2dCQUFFLE1BQU07Z0JBQU07WUFBSztZQUc1QixNQUFNO1FBQ1A7SUFDSDtBQUNEO2tCQXBUb0I7Ozs7O0FFY3JCLGlEQUFzQjtBQXdGdEIsOENBQXNCO0FBNEV0QixzREFBZ0I7QUFjaEIsOERBQWdCO0FBbUJoQixtREFBZ0I7QUFLaEIsa0RBQWdCO0FBSWhCLDJEQUFnQjtBQXFCaEIsNERBQWdCO0FBelFoQjtBQUNBO0FBVUE7QSxJLFMsYSxVLFUsUyxDLEUsQztJLEksSSxDO0ksSSxJLEssRSxJLE8sVSxlLEssRyxNLEUsUSxLLEcsQyxDLEUsRyxDLEMsRTtJLEksSyxRLE8sTywwQixZO1EsSSxJLEksRyxJLE8sc0IsSSxJLEUsUSxJLEksRSxRLEMsQyxFLEksSyxPLFUscUIsSyxHLEMsQyxFLEcsQyxDLEMsQyxFLEMsRyxDLEMsQyxDLEUsQztJO0ksTztBO0FBc0JBLE1BQU0sbUJBQW1CLENBQUMsTUFDeEIsSUFBSSxPQUFPLElBQUksV0FBVyxJQUFJLHFCQUFxQixJQUFJLFNBQVMsS0FBSyxVQUFVO0FBRWpGLE1BQU0sc0JBQXNCO0lBQUM7SUFBSztJQUFLO0NBQUk7QUFFcEMsZUFBZSxZQUFZLEtBQWM7SSxJO0lBQzlDLElBQUksQ0FBQyxDQUFBLEdBQUEsK0JBQUEsRUFBdUIsUUFDMUIsTUFBTSxJQUFJLENBQUEsR0FBQSwrQkFBQSxFQUF3QixpQkFBaUIsUUFBUTtJQUc3RCxJQUFJLG9CQUFvQixTQUFTLE1BQU0sU0FDckMsNkVBQTZFO0lBQzdFLE1BQU0sSUFBSSxDQUFBLEdBQUEsK0JBQUEsRUFBd0IsaUJBQWlCLFFBQVEsTUFBTTtJQUduRSxJQUFJO0lBQ0osSUFBSTtRQUNGLE9BQU8sTUFBTSxNQUFNO0lBQ3BCLEVBQUMsT0FBTyxHQUFRO1FBQ2YsTUFBTSxJQUFJLENBQUEsR0FBQSx3QkFBQSxFQUFpQixpQkFBaUIsSUFBSTtJQUNqRDtJQUVELElBQUksWUFBZ0M7SUFFcEMsTUFBTSxxQkFBcUIsQ0FBQSxHQUFBLGdDQUFBLEVBQXdCO0lBQ25ELElBQ0Usc0JBQ0EsbUJBQW1CLGFBQWEsQ0FBQSxHQUFBLHVCQUFBLENBQVksQ0FBQyxhQUFhLENBQUMsYUFDM0QsT0FBTyxTQUFTLFlBQ2hCLFFBQ0EsT0FBTyxLQUFLLFNBQVMsVUFFckIsWUFBWSxLQUFLO1NBQ1osSUFBSSxPQUFPLFNBQVMsWUFBWSxRQUFRLE9BQU8sS0FBSyxlQUFlLFVBQ3hFLFlBQVksS0FBSztJQUduQixJQUFJLENBQUMsV0FBVztRQUNkLDBFQUEwRTtRQUMxRSxJQUNFLE9BQU8sU0FBUyxZQUNoQixRQUNBLE9BQU8sS0FBSyxrQkFBa0IsWUFDOUIsS0FBSyxpQkFDTCxNQUFNLFFBQVEsS0FBSyxjQUFjLFlBQ2pDLEtBQUssY0FBYyxRQUFRLFVBQzNCLEtBQUssY0FBYyxRQUFRLE9BQU8sQ0FBQyxHQUFZLElBQVcsS0FBSyxPQUFPLE1BQU0sVUFBVSxPQUV0RixNQUFNLElBQUksQ0FBQSxHQUFBLDZCQUFBLEVBQ1IsaUJBQWlCLE9BQ2pCLE1BQU0sUUFDTixLQUFLLGNBQWM7SUFHeEIsT0FBTSxJQUFJLGNBQWMsaUJBQ3ZCLE1BQU0sSUFBSSxDQUFBLEdBQUEsNkJBQUEsRUFDUixpQkFBaUIsT0FDakIsTUFBTSxRQUNOLEFBQUEsQ0FBQSxBQUFBLENBQUEsS0FBQSxLQUFLLGFBQUEsTUFBYSxRQUFBLE9BQUEsS0FBQSxJQUFBLEtBQUEsSUFBQSxHQUFFLE9BQUEsS0FBVyxFQUFFO0lBSXJDLE1BQU0sSUFBSSxDQUFBLEdBQUEsb0JBQUEsRUFBYSxpQkFBaUIsT0FBTyxNQUFNLFVBQVUsS0FBSztBQUN0RTtBQUVBLE1BQU0sb0JBQW9CLENBQ3hCLFFBQ0EsU0FDQSxZQUNBO0lBRUEsTUFBTSxTQUErQjtRQUFFO1FBQVEsU0FBUyxBQUFBLENBQUEsWUFBTyxRQUFQLFlBQU8sS0FBQSxJQUFBLEtBQUEsSUFBUCxRQUFTLE9BQUEsS0FBVyxDQUFBO0lBQUU7SUFFOUUsSUFBSSxXQUFXLE9BQ2IsT0FBTztJQUdULE9BQU8sVUFBTyxPQUFBLE9BQUE7UUFBSyxnQkFBZ0I7SUFBZ0MsR0FBSyxZQUFPLFFBQVAsWUFBTyxLQUFBLElBQUEsS0FBQSxJQUFQLFFBQVM7SUFDakYsT0FBTyxPQUFPLEtBQUssVUFBVTtJQUM3QixPQUFBLE9BQUEsT0FBQSxPQUFBLE9BQUEsQ0FBQSxHQUFZLFNBQVc7QUFDekI7QUFhTyxlQUFlLFNBQ3BCLE9BQWMsRUFDZCxNQUF5QixFQUN6QixHQUFXLEVBQ1gsT0FBOEI7SSxJO0lBRTlCLE1BQU0sVUFBTyxPQUFBLE9BQUEsQ0FBQSxHQUNSLFlBQU8sUUFBUCxZQUFPLEtBQUEsSUFBQSxLQUFBLElBQVAsUUFBUztJQUdkLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBQSxtQ0FBd0IsRUFDbkMsT0FBTyxDQUFDLEdBQUEsbUNBQXdCLEdBQUcsQ0FBQSxHQUFBLHVCQUFBLENBQVksQ0FBQyxhQUFhLENBQUM7SUFHaEUsSUFBSSxZQUFPLFFBQVAsWUFBTyxLQUFBLElBQUEsS0FBQSxJQUFQLFFBQVMsS0FDWCxPQUFPLENBQUMsZ0JBQWdCLEdBQUcsQ0FBQSxPQUFBLEVBQVUsUUFBUSxJQUFHLENBQUU7SUFHcEQsTUFBTSxLQUFLLEFBQUEsQ0FBQSxLQUFBLFlBQU8sUUFBUCxZQUFPLEtBQUEsSUFBQSxLQUFBLElBQVAsUUFBUyxLQUFBLE1BQUssUUFBQSxPQUFBLEtBQUEsSUFBQSxLQUFJLENBQUE7SUFDN0IsSUFBSSxZQUFPLFFBQVAsWUFBTyxLQUFBLElBQUEsS0FBQSxJQUFQLFFBQVMsWUFDWCxFQUFFLENBQUMsY0FBYyxHQUFHLFFBQVE7SUFHOUIsTUFBTSxjQUFjLE9BQU8sS0FBSyxJQUFJLFNBQVMsTUFBTSxJQUFJLGdCQUFnQixJQUFJLGFBQWE7SUFDeEYsTUFBTSxPQUFPLE1BQU0sZUFDakIsU0FDQSxRQUNBLE1BQU0sYUFDTjtRQUNFO1FBQ0EsZUFBZSxZQUFPLFFBQVAsWUFBTyxLQUFBLElBQUEsS0FBQSxJQUFQLFFBQVM7SUFDekIsR0FDRCxDQUFBLEdBQ0EsWUFBTyxRQUFQLFlBQU8sS0FBQSxJQUFBLEtBQUEsSUFBUCxRQUFTO0lBRVgsT0FBTyxBQUFBLENBQUEsWUFBTyxRQUFQLFlBQU8sS0FBQSxJQUFBLEtBQUEsSUFBUCxRQUFTLEtBQUEsSUFBUSxZQUFPLFFBQVAsWUFBTyxLQUFBLElBQUEsS0FBQSxJQUFQLFFBQVMsTUFBTSxRQUFRO1FBQUUsTUFBSSxPQUFBLE9BQUEsQ0FBQSxHQUFPO1FBQVEsT0FBTztJQUFJO0FBQ2pGO0FBRUEsZUFBZSxlQUNiLE9BQWMsRUFDZCxNQUF5QixFQUN6QixHQUFXLEVBQ1gsT0FBc0IsRUFDdEIsVUFBNEIsRUFDNUIsSUFBYTtJQUViLE1BQU0sZ0JBQWdCLGtCQUFrQixRQUFRLFNBQVMsWUFBWTtJQUVyRSxJQUFJO0lBRUosSUFBSTtRQUNGLFNBQVMsTUFBTSxRQUFRLEtBQUcsT0FBQSxPQUFBLENBQUEsR0FDckI7SUFFTixFQUFDLE9BQU8sR0FBRztRQUNWLFFBQVEsTUFBTTtRQUVkLHNEQUFzRDtRQUN0RCxNQUFNLElBQUksQ0FBQSxHQUFBLCtCQUFBLEVBQXdCLGlCQUFpQixJQUFJO0lBQ3hEO0lBRUQsSUFBSSxDQUFDLE9BQU8sSUFDVixNQUFNLFlBQVk7SUFHcEIsSUFBSSxZQUFPLFFBQVAsWUFBTyxLQUFBLElBQUEsS0FBQSxJQUFQLFFBQVMsZUFDWCxPQUFPO0lBR1QsSUFBSTtRQUNGLE9BQU8sTUFBTSxPQUFPO0lBQ3JCLEVBQUMsT0FBTyxHQUFRO1FBQ2YsTUFBTSxZQUFZO0lBQ25CO0FBQ0g7QUFFTSxTQUFVLGlCQUFpQixJQUFTO0ksSTtJQUN4QyxJQUFJLFVBQVU7SUFDZCxJQUFJLFdBQVcsT0FBTztRQUNwQixVQUFPLE9BQUEsT0FBQSxDQUFBLEdBQVE7UUFFZixJQUFJLENBQUMsS0FBSyxZQUNSLFFBQVEsYUFBYSxDQUFBLEdBQUEsa0JBQUEsRUFBVSxLQUFLO0lBRXZDO0lBRUQsTUFBTSxPQUFhLEFBQUEsQ0FBQSxLQUFBLEtBQUssSUFBQSxNQUFJLFFBQUEsT0FBQSxLQUFBLElBQUEsS0FBSztJQUNqQyxPQUFPO1FBQUUsTUFBTTtZQUFFO1lBQVM7UUFBSTtRQUFJLE9BQU87SUFBSTtBQUMvQztBQUVNLFNBQVUseUJBQXlCLElBQVM7SUFDaEQsTUFBTSxXQUFXLGlCQUFpQjtJQUVsQyxJQUNFLENBQUMsU0FBUyxTQUNWLEtBQUssaUJBQ0wsT0FBTyxLQUFLLGtCQUFrQixZQUM5QixNQUFNLFFBQVEsS0FBSyxjQUFjLFlBQ2pDLEtBQUssY0FBYyxRQUFRLFVBQzNCLEtBQUssY0FBYyxXQUNuQixPQUFPLEtBQUssY0FBYyxZQUFZLFlBQ3RDLEtBQUssY0FBYyxRQUFRLE9BQU8sQ0FBQyxHQUFZLElBQVcsS0FBSyxPQUFPLE1BQU0sVUFBVSxPQUV0RixTQUFTLEtBQUssZ0JBQWdCLEtBQUs7SUFHckMsT0FBTztBQUNUO0FBRU0sU0FBVSxjQUFjLElBQVM7SSxJO0lBQ3JDLE1BQU0sT0FBYSxBQUFBLENBQUEsS0FBQSxLQUFLLElBQUEsTUFBSSxRQUFBLE9BQUEsS0FBQSxJQUFBLEtBQUs7SUFDakMsT0FBTztRQUFFLE1BQU07WUFBRTtRQUFJO1FBQUksT0FBTztJQUFJO0FBQ3RDO0FBRU0sU0FBVSxhQUFhLElBQVM7SUFDcEMsT0FBTztRQUFFO1FBQU0sT0FBTztJQUFJO0FBQzVCO0FBRU0sU0FBVSxzQkFBc0IsSUFBUztJQUM3QyxNQUFNLEVBQUUsV0FBVyxFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQUUsV0FBVyxFQUFFLGlCQUFpQixFQUFBLEdBQWMsTUFBVCxPQUFJLE9BQUssTUFBcEY7UUFBQTtRQUFBO1FBQUE7UUFBQTtRQUFBO0tBQWlGO0lBRXZGLE1BQU0sYUFBcUM7UUFDekM7UUFDQTtRQUNBO1FBQ0E7UUFDQTtJQUNEO0lBRUQsTUFBTSxPQUFJLE9BQUEsT0FBQSxDQUFBLEdBQWM7SUFDeEIsT0FBTztRQUNMLE1BQU07WUFDSjtZQUNBO1FBQ0Q7UUFDRCxPQUFPO0lBQ1I7QUFDSDtBQUVNLFNBQVUsdUJBQXVCLElBQVM7SUFDOUMsT0FBTztBQUNUO0FBRUE7Ozs7Q0FJRyxHQUNILFNBQVMsV0FBVyxJQUFTO0lBQzNCLE9BQU8sS0FBSyxnQkFBZ0IsS0FBSyxpQkFBaUIsS0FBSztBQUN6RDs7Ozs7Z0RFblJhO2lEQUNBOzhDQUNBO3FEQUNBO21EQUNBO3FEQUNBOzZEQUtBO2tEQUNBO0FBWmI7QUFDTyxNQUFNLGFBQWE7QUFDbkIsTUFBTSxjQUFjO0FBQ3BCLE1BQU0sV0FBVztBQUNqQixNQUFNLGtCQUFrQjtJQUFFLGlCQUFpQixDQUFBLFVBQUEsRUFBYSxDQUFBLEdBQUEsZ0JBQUEsRUFBTyxDQUFFO0FBQUE7QUFDakUsTUFBTSxnQkFBZ0IsSUFBRyxhQUFhO0FBQ3RDLE1BQU0sa0JBQWtCO0lBQzdCLGFBQWE7SUFDYixnQkFBZ0I7QUFDakI7QUFFTSxNQUFNLDBCQUEwQjtBQUNoQyxNQUFNLGVBQWU7SUFDMUIsY0FBYztRQUNaLFdBQVcsS0FBSyxNQUFNO1FBQ3RCLE1BQU07SUFDUDtBQUNGOzs7Ozs2Q0VqQlk7QUFBTixNQUFNLFVBQVU7Ozs7O0FFR3ZCLCtDQUFnQjtBQUtoQiwwQ0FBZ0I7K0NBUUg7MERBVUE7QUFxQ2I7O0NBRUcsR0FDSCw0REFBZ0I7a0RBMEJIOzREQWFBO2tEQVlBO2tEQVFBO3FEQWNBO0FBSWIscURBQWdCO0FBNEJoQjs7OztDQUlHLEdBQ0gsOENBQWE7QUFvQmIseUhBQXlIO0FBQ3pILHNEQUFnQjtBQWtCaEI7O0NBRUcsR0FDSCwyQ0FBc0I7QUFNdEI7Ozs7Q0FJRyxHQUNILCtDQUFnQjtBQWdDaEIsMEpBQTBKO0FBQzFKLDBEQUFnQjtBQStCaEIsMkRBQXNCO0FBZ0J0QiwrREFBc0I7QUFtQnRCLDZEQUFnQjtBQXhVaEI7QUFHTSxTQUFVLFVBQVUsU0FBaUI7SUFDekMsTUFBTSxVQUFVLEtBQUssTUFBTSxLQUFLLFFBQVE7SUFDeEMsT0FBTyxVQUFVO0FBQ25CO0FBRU0sU0FBVTtJQUNkLE9BQU8sdUNBQXVDLFFBQVEsU0FBUyxTQUFVLENBQUM7UUFDeEUsTUFBTSxJQUFJLEFBQUMsS0FBSyxXQUFXLEtBQU0sR0FDL0IsSUFBSSxLQUFLLE1BQU0sSUFBSSxBQUFDLElBQUksTUFBTztRQUNqQyxPQUFPLEVBQUUsU0FBUztJQUNwQjtBQUNGO0FBRU8sTUFBTSxZQUFZLElBQU0sT0FBTyxhQUFhO0FBRW5ELE1BQU0seUJBQXlCO0lBQzdCLFFBQVE7SUFDUixVQUFVO0FBQ1g7QUFLTSxNQUFNLHVCQUF1QjtJQUNsQyxJQUFJLENBQUMsYUFDSCxPQUFPO0lBR1QsSUFBSTtRQUNGLElBQUksT0FBTyxXQUFXLGlCQUFpQixVQUNyQyxPQUFPO0lBRVYsRUFBQyxPQUFPLEdBQUc7UUFDViw4Q0FBOEM7UUFDOUMsT0FBTztJQUNSO0lBRUQsSUFBSSx1QkFBdUIsUUFDekIsT0FBTyx1QkFBdUI7SUFHaEMsTUFBTSxZQUFZLENBQUEsS0FBQSxFQUFRLEtBQUssU0FBUSxFQUFHLEtBQUssU0FBUSxDQUFFO0lBRXpELElBQUk7UUFDRixXQUFXLGFBQWEsUUFBUSxXQUFXO1FBQzNDLFdBQVcsYUFBYSxXQUFXO1FBRW5DLHVCQUF1QixTQUFTO1FBQ2hDLHVCQUF1QixXQUFXO0lBQ25DLEVBQUMsT0FBTyxHQUFHO1FBQ1YsbUNBQW1DO1FBQ25DLCtLQUErSztRQUUvSyx1QkFBdUIsU0FBUztRQUNoQyx1QkFBdUIsV0FBVztJQUNuQztJQUVELE9BQU8sdUJBQXVCO0FBQ2hDO0FBS00sU0FBVSx1QkFBdUIsSUFBWTtJQUNqRCxNQUFNLFNBQTBDLENBQUE7SUFFaEQsTUFBTSxNQUFNLElBQUksSUFBSTtJQUVwQixJQUFJLElBQUksUUFBUSxJQUFJLElBQUksQ0FBQyxFQUFFLEtBQUssS0FDOUIsSUFBSTtRQUNGLE1BQU0sbUJBQW1CLElBQUksZ0JBQWdCLElBQUksS0FBSyxVQUFVO1FBQ2hFLGlCQUFpQixRQUFRLENBQUMsT0FBTztZQUMvQixNQUFNLENBQUMsSUFBSSxHQUFHO1FBQ2hCO0lBQ0QsRUFBQyxPQUFPLEdBQVE7SUFDZiw2QkFBNkI7SUFDOUI7SUFHSCx5REFBeUQ7SUFDekQsSUFBSSxhQUFhLFFBQVEsQ0FBQyxPQUFPO1FBQy9CLE1BQU0sQ0FBQyxJQUFJLEdBQUc7SUFDaEI7SUFFQSxPQUFPO0FBQ1Q7QUFJTyxNQUFNLGVBQWUsQ0FBQztJQUMzQixJQUFJO0lBQ0osSUFBSSxhQUNGLFNBQVM7U0FDSixJQUFJLE9BQU8sVUFBVSxhQUMxQixTQUFTLENBQUMsR0FBRyxPQUNYLFFBQU8sb0JBQStCLEtBQUssQ0FBQyxFQUFFLFNBQVMsTUFBSyxFQUFFLEdBQUssVUFBUztTQUU5RSxTQUFTO0lBRVgsT0FBTyxDQUFDLEdBQUcsT0FBUyxVQUFVO0FBQ2hDO0FBRU8sTUFBTSx5QkFBeUIsQ0FBQztJQUNyQyxPQUNFLE9BQU8sa0JBQWtCLFlBQ3pCLGtCQUFrQixRQUNsQixZQUFZLGlCQUNaLFFBQVEsaUJBQ1IsVUFBVSxpQkFDVixPQUFRLGNBQXNCLFNBQVM7QUFFM0M7QUFHTyxNQUFNLGVBQWUsT0FDMUIsU0FDQSxLQUNBO0lBRUEsTUFBTSxRQUFRLFFBQVEsS0FBSyxLQUFLLFVBQVU7QUFDNUM7QUFFTyxNQUFNLGVBQWUsT0FBTyxTQUEyQjtJQUM1RCxNQUFNLFFBQVEsTUFBTSxRQUFRLFFBQVE7SUFFcEMsSUFBSSxDQUFDLE9BQ0gsT0FBTztJQUdULElBQUk7UUFDRixPQUFPLEtBQUssTUFBTTtJQUNuQixFQUFDLE9BQUEsSUFBTTtRQUNOLE9BQU87SUFDUjtBQUNIO0FBRU8sTUFBTSxrQkFBa0IsT0FBTyxTQUEyQjtJQUMvRCxNQUFNLFFBQVEsV0FBVztBQUMzQjtBQUVNLFNBQVUsZ0JBQWdCLEtBQWE7SUFDM0MsTUFBTSxNQUFNO0lBQ1osSUFBSSxTQUFTO0lBQ2IsSUFBSSxNQUFNLE1BQU07SUFDaEIsSUFBSSxNQUFNLE1BQU0sTUFBTTtJQUN0QixJQUFJLElBQUk7SUFDUixRQUFRLE1BQU0sUUFBUSxLQUFLLEtBQUssUUFBUSxLQUFLO0lBRTdDLE1BQU8sSUFBSSxNQUFNLE9BQVE7UUFDdkIsT0FBTyxJQUFJLFFBQVEsTUFBTSxPQUFPO1FBQ2hDLE9BQU8sSUFBSSxRQUFRLE1BQU0sT0FBTztRQUNoQyxPQUFPLElBQUksUUFBUSxNQUFNLE9BQU87UUFDaEMsT0FBTyxJQUFJLFFBQVEsTUFBTSxPQUFPO1FBQ2hDLE9BQU8sQUFBQyxRQUFRLElBQU0sUUFBUTtRQUM5QixPQUFPLEFBQUUsQ0FBQSxPQUFPLEVBQUEsS0FBTyxJQUFNLFFBQVE7UUFDckMsT0FBTyxBQUFFLENBQUEsT0FBTyxDQUFBLEtBQU0sSUFBSztRQUMzQixTQUFTLFNBQVMsT0FBTyxhQUFhO1FBRXRDLElBQUksUUFBUSxNQUFNLFFBQVEsR0FDeEIsU0FBUyxTQUFTLE9BQU8sYUFBYTtRQUV4QyxJQUFJLFFBQVEsTUFBTSxRQUFRLEdBQ3hCLFNBQVMsU0FBUyxPQUFPLGFBQWE7SUFFekM7SUFDRCxPQUFPO0FBQ1Q7QUFPTSxNQUFPO0lBU1gsYUFBQTtRQUVJLElBQVksQ0FBQyxVQUFVLElBQUksU0FBUyxtQkFBbUIsQ0FBQyxLQUFLO1lBRTNELElBQVksQ0FBQyxVQUFVO1lBRXZCLElBQVksQ0FBQyxTQUFTO1FBQzFCO0lBQ0Y7QTtBQWhCYyxTQUFBLHFCQUF5QztBQW9CbkQsU0FBVSxpQkFBaUIsS0FBYTtJQUM1QyxvQ0FBb0M7SUFDcEMsTUFBTSxpQkFBaUI7SUFFdkIsTUFBTSxRQUFRLE1BQU0sTUFBTTtJQUUxQixJQUFJLE1BQU0sV0FBVyxHQUNuQixNQUFNLElBQUksTUFBTTtJQUdsQixJQUFJLENBQUMsZUFBZSxLQUFLLEtBQUssQ0FBQyxFQUFFLEdBQy9CLE1BQU0sSUFBSSxNQUFNO0lBR2xCLE1BQU0sWUFBWSxLQUFLLENBQUMsRUFBRTtJQUMxQixPQUFPLEtBQUssTUFBTSxnQkFBZ0I7QUFDcEM7QUFLTyxlQUFlLE1BQU0sSUFBWTtJQUN0QyxPQUFPLE1BQU0sSUFBSSxRQUFRLENBQUM7UUFDeEIsV0FBVyxJQUFNLE9BQU8sT0FBTztJQUNqQztBQUNGO0FBT00sU0FBVSxVQUNkLEVBQW1DLEVBQ25DLFdBQXdFO0lBRXhFLE1BQU0sVUFBVSxJQUFJLFFBQVcsQ0FBQyxRQUFRO1FBRXBDLENBQUE7WUFDQSxJQUFLLElBQUksVUFBVSxHQUFHLFVBQVUsVUFBVSxVQUN4QyxJQUFJO2dCQUNGLE1BQU0sU0FBUyxNQUFNLEdBQUc7Z0JBRXhCLElBQUksQ0FBQyxZQUFZLFNBQVMsTUFBTSxTQUFTO29CQUN2QyxPQUFPO29CQUNQO2dCQUNEO1lBQ0YsRUFBQyxPQUFPLEdBQVE7Z0JBQ2YsSUFBSSxDQUFDLFlBQVksU0FBUyxJQUFJO29CQUM1QixPQUFPO29CQUNQO2dCQUNEO1lBQ0Y7UUFFTCxDQUFBO0lBQ0Y7SUFFQSxPQUFPO0FBQ1Q7QUFFQSxTQUFTLFFBQVEsR0FBVztJQUMxQixPQUFPLEFBQUMsQ0FBQSxNQUFNLElBQUksU0FBUyxHQUFFLEVBQUcsT0FBTztBQUN6QztBQUdNLFNBQVU7SUFDZCxNQUFNLGlCQUFpQjtJQUN2QixNQUFNLFFBQVEsSUFBSSxZQUFZO0lBQzlCLElBQUksT0FBTyxXQUFXLGFBQWE7UUFDakMsTUFBTSxVQUFVO1FBQ2hCLE1BQU0sYUFBYSxRQUFRO1FBQzNCLElBQUksV0FBVztRQUNmLElBQUssSUFBSSxJQUFJLEdBQUcsSUFBSSxnQkFBZ0IsSUFDbEMsWUFBWSxRQUFRLE9BQU8sS0FBSyxNQUFNLEtBQUssV0FBVztRQUV4RCxPQUFPO0lBQ1I7SUFDRCxPQUFPLGdCQUFnQjtJQUN2QixPQUFPLE1BQU0sS0FBSyxPQUFPLFNBQVMsS0FBSztBQUN6QztBQUVBLGVBQWUsT0FBTyxZQUFvQjtJQUN4QyxNQUFNLFVBQVUsSUFBSTtJQUNwQixNQUFNLGNBQWMsUUFBUSxPQUFPO0lBQ25DLE1BQU0sT0FBTyxNQUFNLE9BQU8sT0FBTyxPQUFPLFdBQVc7SUFDbkQsTUFBTSxRQUFRLElBQUksV0FBVztJQUU3QixPQUFPLE1BQU0sS0FBSyxPQUNmLElBQUksQ0FBQyxJQUFNLE9BQU8sYUFBYSxJQUMvQixLQUFLO0FBQ1Y7QUFFQSxTQUFTLGdCQUFnQixHQUFXO0lBQ2xDLE9BQU8sS0FBSyxLQUFLLFFBQVEsT0FBTyxLQUFLLFFBQVEsT0FBTyxLQUFLLFFBQVEsT0FBTztBQUMxRTtBQUVPLGVBQWUsc0JBQXNCLFFBQWdCO0lBQzFELE1BQU0sbUJBQ0osT0FBTyxXQUFXLGVBQ2xCLE9BQU8sT0FBTyxXQUFXLGVBQ3pCLE9BQU8sZ0JBQWdCO0lBRXpCLElBQUksQ0FBQyxrQkFBa0I7UUFDckIsUUFBUSxLQUNOO1FBRUYsT0FBTztJQUNSO0lBQ0QsTUFBTSxTQUFTLE1BQU0sT0FBTztJQUM1QixPQUFPLGdCQUFnQjtBQUN6QjtBQUVPLGVBQWUsMEJBQ3BCLE9BQXlCLEVBQ3pCLFVBQWtCLEVBQ2xCLHFCQUFxQixLQUFLO0lBRTFCLE1BQU0sZUFBZTtJQUNyQixJQUFJLHFCQUFxQjtJQUN6QixJQUFJLG9CQUNGLHNCQUFzQjtJQUV4QixNQUFNLGFBQWEsU0FBUyxDQUFBLEVBQUcsV0FBVSxjQUFBLENBQWdCLEVBQUU7SUFDM0QsTUFBTSxnQkFBZ0IsTUFBTSxzQkFBc0I7SUFDbEQsTUFBTSxzQkFBc0IsaUJBQWlCLGdCQUFnQixVQUFVO0lBQ3ZFLE9BQU87UUFBQztRQUFlO0tBQW9CO0FBQzdDO0FBRUEsZ0RBQUEsR0FDQSxNQUFNLG9CQUFvQjtBQUVwQixTQUFVLHdCQUF3QixRQUFrQjtJQUN4RCxNQUFNLGFBQWEsU0FBUyxRQUFRLElBQUksQ0FBQSxHQUFBLGtDQUFBO0lBRXhDLElBQUksQ0FBQyxZQUNILE9BQU87SUFHVCxJQUFJLENBQUMsV0FBVyxNQUFNLG9CQUNwQixPQUFPO0lBR1QsSUFBSTtRQUNGLE1BQU0sT0FBTyxJQUFJLEtBQUssQ0FBQSxFQUFHLFdBQVUsWUFBQSxDQUFjO1FBQ2pELE9BQU87SUFDUixFQUFDLE9BQU8sR0FBUTtRQUNmLE9BQU87SUFDUjtBQUNIOzs7OztBRXRWQSwrQ0FBYTtBQXNCYixpREFBZ0I7QUFJaEIsa0RBQWE7QUFXYixvREFBZ0I7QUFJaEIsc0RBQWE7QUFVYixxREFBYTtBQVdiLDZEQUFhO0FBTWIsbUVBQWE7QUFNYixpRUFBYTtBQU1iLG9FQUFhO0FBaUJiLG9FQUFhO0FBa0JiLDZEQUFhO0FBTWIsK0RBQWdCO0FBSWhCOzs7O0NBSUcsR0FDSCwyREFBYTtBQWFiLDZEQUFnQjtBQS9JVixNQUFPLGtCQUFrQjtJQWM3QixZQUFZLE9BQWUsRUFBRSxNQUFlLEVBQUUsSUFBYSxDQUEzRDtRQUNFLEtBQUssQ0FBQztRQUhFLElBQUEsQ0FBQSxnQkFBZ0I7UUFJeEIsSUFBSSxDQUFDLE9BQU87UUFDWixJQUFJLENBQUMsU0FBUztRQUNkLElBQUksQ0FBQyxPQUFPO0lBQ2Q7QUFDRDtBQUVLLFNBQVUsWUFBWSxLQUFjO0lBQ3hDLE9BQU8sT0FBTyxVQUFVLFlBQVksVUFBVSxRQUFRLG1CQUFtQjtBQUMzRTtBQUVNLE1BQU8scUJBQXFCO0lBR2hDLFlBQVksT0FBZSxFQUFFLE1BQWMsRUFBRSxJQUF3QixDQUFyRTtRQUNFLEtBQUssQ0FBQyxTQUFTLFFBQVE7UUFDdkIsSUFBSSxDQUFDLE9BQU87UUFDWixJQUFJLENBQUMsU0FBUztRQUNkLElBQUksQ0FBQyxPQUFPO0lBQ2Q7QUFDRDtBQUVLLFNBQVUsZUFBZSxLQUFjO0lBQzNDLE9BQU8sWUFBWSxVQUFVLE1BQU0sU0FBUztBQUM5QztBQUVNLE1BQU8seUJBQXlCO0lBR3BDLFlBQVksT0FBZSxFQUFFLGFBQXNCLENBQW5EO1FBQ0UsS0FBSyxDQUFDO1FBQ04sSUFBSSxDQUFDLE9BQU87UUFDWixJQUFJLENBQUMsZ0JBQWdCO0lBQ3ZCO0FBQ0Q7QUFFSyxNQUFPLHdCQUF3QjtJQUluQyxZQUFZLE9BQWUsRUFBRSxJQUFZLEVBQUUsTUFBYyxFQUFFLElBQXdCLENBQW5GO1FBQ0UsS0FBSyxDQUFDLFNBQVMsUUFBUTtRQUN2QixJQUFJLENBQUMsT0FBTztRQUNaLElBQUksQ0FBQyxTQUFTO0lBQ2hCO0FBQ0Q7QUFFSyxNQUFPLGdDQUFnQztJQUMzQyxhQUFBO1FBQ0UsS0FBSyxDQUFDLHlCQUF5QiwyQkFBMkIsS0FBSztJQUNqRTtBQUNEO0FBRUssTUFBTyxzQ0FBc0M7SUFDakQsYUFBQTtRQUNFLEtBQUssQ0FBQyxnQ0FBZ0MsaUNBQWlDLEtBQUs7SUFDOUU7QUFDRDtBQUVLLE1BQU8sb0NBQW9DO0lBQy9DLFlBQVksT0FBZSxDQUEzQjtRQUNFLEtBQUssQ0FBQyxTQUFTLCtCQUErQixLQUFLO0lBQ3JEO0FBQ0Q7QUFFSyxNQUFPLHVDQUF1QztJQUVsRCxZQUFZLE9BQWUsRUFBRSxVQUFrRCxJQUFJLENBQW5GO1FBQ0UsS0FBSyxDQUFDLFNBQVMsa0NBQWtDLEtBQUs7UUFGeEQsSUFBQSxDQUFBLFVBQWtEO1FBR2hELElBQUksQ0FBQyxVQUFVO0lBQ2pCO0lBRUEsU0FBQTtRQUNFLE9BQU87WUFDTCxNQUFNLElBQUksQ0FBQztZQUNYLFNBQVMsSUFBSSxDQUFDO1lBQ2QsUUFBUSxJQUFJLENBQUM7WUFDYixTQUFTLElBQUksQ0FBQztRQUNmO0lBQ0g7QUFDRDtBQUVLLE1BQU8sdUNBQXVDO0lBR2xELFlBQVksT0FBZSxFQUFFLFVBQWtELElBQUksQ0FBbkY7UUFDRSxLQUFLLENBQUMsU0FBUyxrQ0FBa0MsS0FBSztRQUh4RCxJQUFBLENBQUEsVUFBa0Q7UUFJaEQsSUFBSSxDQUFDLFVBQVU7SUFDakI7SUFFQSxTQUFBO1FBQ0UsT0FBTztZQUNMLE1BQU0sSUFBSSxDQUFDO1lBQ1gsU0FBUyxJQUFJLENBQUM7WUFDZCxRQUFRLElBQUksQ0FBQztZQUNiLFNBQVMsSUFBSSxDQUFDO1FBQ2Y7SUFDSDtBQUNEO0FBRUssTUFBTyxnQ0FBZ0M7SUFDM0MsWUFBWSxPQUFlLEVBQUUsTUFBYyxDQUEzQztRQUNFLEtBQUssQ0FBQyxTQUFTLDJCQUEyQixRQUFRO0lBQ3BEO0FBQ0Q7QUFFSyxTQUFVLDBCQUEwQixLQUFjO0lBQ3RELE9BQU8sWUFBWSxVQUFVLE1BQU0sU0FBUztBQUM5QztBQU9NLE1BQU8sOEJBQThCO0lBTXpDLFlBQVksT0FBZSxFQUFFLE1BQWMsRUFBRSxPQUFpQixDQUE5RDtRQUNFLEtBQUssQ0FBQyxTQUFTLHlCQUF5QixRQUFRO1FBRWhELElBQUksQ0FBQyxVQUFVO0lBQ2pCO0FBQ0Q7QUFFSyxTQUFVLHdCQUF3QixLQUFjO0lBQ3BELE9BQU8sWUFBWSxVQUFVLE1BQU0sU0FBUztBQUM5Qzs7Ozs7QUVwSkE7O0FBQ0E7QUFDQTtBQVlBO0FBUUE7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQW1EQSxDQUFBLEdBQUEsNkJBQUEsS0FBcUIsOEJBQThCO0FBRW5ELE1BQU0sa0JBQXFGO0lBQ3pGLEtBQUssQ0FBQSxHQUFBLHFCQUFBO0lBQ0wsWUFBWSxDQUFBLEdBQUEsc0JBQUE7SUFDWixrQkFBa0I7SUFDbEIsZ0JBQWdCO0lBQ2hCLG9CQUFvQjtJQUNwQixTQUFTLENBQUEsR0FBQSwwQkFBQTtJQUNULFVBQVU7SUFDVixPQUFPO0lBQ1AsOEJBQThCO0FBQy9CO0FBRUQsa0VBQUEsR0FDQSxNQUFNLDZCQUE2QjtBQUVuQzt5RkFDMkYsR0FDM0YsTUFBTSw4QkFBOEI7QUFFcEMsZUFBZSxTQUFZLElBQVksRUFBRSxjQUFzQixFQUFFLEVBQW9CO0lBQ25GLE9BQU8sTUFBTTtBQUNmO0FBRWMsTUFBTztJQXdEbkI7O0tBRUcsR0FDSCxZQUFZLE9BQTRCLENBQXhDO1EsSSxJO1FBbkNVLElBQUEsQ0FBQSxnQkFBa0Q7UUFDbEQsSUFBQSxDQUFBLHNCQUFpRCxJQUFJO1FBQ3JELElBQUEsQ0FBQSxvQkFBMkQ7UUFDM0QsSUFBQSxDQUFBLDRCQUF5RDtRQUN6RCxJQUFBLENBQUEscUJBQThEO1FBQ3hFOzs7OztTQUtHLEdBQ08sSUFBQSxDQUFBLG9CQUFzRDtRQUN0RCxJQUFBLENBQUEscUJBQXFCO1FBS3JCLElBQUEsQ0FBQSwrQkFBK0I7UUFDL0IsSUFBQSxDQUFBLDRCQUE0QjtRQUc1QixJQUFBLENBQUEsZUFBZTtRQUNmLElBQUEsQ0FBQSxnQkFBZ0MsRUFBRTtRQUU1Qzs7U0FFRyxHQUNPLElBQUEsQ0FBQSxtQkFBNEM7UUFHNUMsSUFBQSxDQUFBLFNBQW9ELFFBQVE7UUFNcEUsSUFBSSxDQUFDLGFBQWEsYUFBYTtRQUMvQixhQUFhLGtCQUFrQjtRQUUvQixJQUFJLElBQUksQ0FBQyxhQUFhLEtBQUssQ0FBQSxHQUFBLGtCQUFBLEtBQ3pCLFFBQVEsS0FDTjtRQUlKLE1BQU0sV0FBUSxPQUFBLE9BQUEsT0FBQSxPQUFBLENBQUEsR0FBUSxrQkFBb0I7UUFFMUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLENBQUMsU0FBUztRQUNuQyxJQUFJLE9BQU8sU0FBUyxVQUFVLFlBQzVCLElBQUksQ0FBQyxTQUFTLFNBQVM7UUFHekIsSUFBSSxDQUFDLGlCQUFpQixTQUFTO1FBQy9CLElBQUksQ0FBQyxhQUFhLFNBQVM7UUFDM0IsSUFBSSxDQUFDLG1CQUFtQixTQUFTO1FBQ2pDLElBQUksQ0FBQyxRQUFRLElBQUksQ0FBQSxHQUFBLDhCQUFBLEVBQWU7WUFDOUIsS0FBSyxTQUFTO1lBQ2QsU0FBUyxTQUFTO1lBQ2xCLE9BQU8sU0FBUztRQUNqQjtRQUVELElBQUksQ0FBQyxNQUFNLFNBQVM7UUFDcEIsSUFBSSxDQUFDLFVBQVUsU0FBUztRQUN4QixJQUFJLENBQUMsUUFBUSxDQUFBLEdBQUEscUJBQUEsRUFBYSxTQUFTO1FBQ25DLElBQUksQ0FBQyxPQUFPLFNBQVMsUUFBUTtRQUM3QixJQUFJLENBQUMscUJBQXFCLFNBQVM7UUFDbkMsSUFBSSxDQUFDLFdBQVcsU0FBUztRQUN6QixJQUFJLENBQUMsK0JBQStCLFNBQVM7UUFFN0MsSUFBSSxTQUFTLE1BQ1gsSUFBSSxDQUFDLE9BQU8sU0FBUzthQUNoQixJQUFJLENBQUEsR0FBQSxrQkFBQSxPQUFlLENBQUEsQUFBQSxDQUFBLEtBQUEsZUFBVSxRQUFWLGVBQVUsS0FBQSxJQUFBLEtBQUEsSUFBVixXQUFZLFNBQUEsTUFBUyxRQUFBLE9BQUEsS0FBQSxJQUFBLEtBQUEsSUFBQSxHQUFFLEtBQUEsR0FDL0MsSUFBSSxDQUFDLE9BQU8sQ0FBQSxHQUFBLG9CQUFBO2FBRVosSUFBSSxDQUFDLE9BQU87UUFHZCxJQUFJLENBQUMsTUFBTTtZQUNULFFBQVEsSUFBSSxDQUFDLFFBQVEsS0FBSyxJQUFJO1lBQzlCLFFBQVEsSUFBSSxDQUFDLFFBQVEsS0FBSyxJQUFJO1lBQzlCLFVBQVUsSUFBSSxDQUFDLFVBQVUsS0FBSyxJQUFJO1lBQ2xDLFdBQVcsSUFBSSxDQUFDLFdBQVcsS0FBSyxJQUFJO1lBQ3BDLGFBQWEsSUFBSSxDQUFDLGFBQWEsS0FBSyxJQUFJO1lBQ3hDLG9CQUFvQixJQUFJLENBQUMsb0JBQW9CLEtBQUssSUFBSTtZQUN0RCxnQ0FBZ0MsSUFBSSxDQUFDLGdDQUFnQyxLQUFLLElBQUk7UUFDL0U7UUFFRCxJQUFJLElBQUksQ0FBQyxnQkFBZ0I7WUFDdkIsSUFBSSxTQUFTLFNBQ1gsSUFBSSxDQUFDLFVBQVUsU0FBUztpQkFFeEIsSUFBSSxDQUFBLEdBQUEsNkJBQUEsS0FDRixJQUFJLENBQUMsVUFBVSxDQUFBLEdBQUEsaUNBQUE7aUJBQ1Y7Z0JBQ0wsSUFBSSxDQUFDLGdCQUFnQixDQUFBO2dCQUNyQixJQUFJLENBQUMsVUFBVSxDQUFBLEdBQUEsdUNBQUEsRUFBMEIsSUFBSSxDQUFDO1lBQy9DO1FBRUosT0FBTTtZQUNMLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQTtZQUNyQixJQUFJLENBQUMsVUFBVSxDQUFBLEdBQUEsdUNBQUEsRUFBMEIsSUFBSSxDQUFDO1FBQy9DO1FBRUQsSUFBSSxDQUFBLEdBQUEsa0JBQUEsT0FBZSxXQUFXLG9CQUFvQixJQUFJLENBQUMsa0JBQWtCLElBQUksQ0FBQyxZQUFZO1lBQ3hGLElBQUk7Z0JBQ0YsSUFBSSxDQUFDLG1CQUFtQixJQUFJLFdBQVcsaUJBQWlCLElBQUksQ0FBQztZQUM5RCxFQUFDLE9BQU8sR0FBUTtnQkFDZixRQUFRLE1BQ04sMEZBQ0E7WUFFSDtZQUVELENBQUEsS0FBQSxJQUFJLENBQUMsZ0JBQUEsTUFBZ0IsUUFBQSxPQUFBLEtBQUEsS0FBQSxHQUFFLGlCQUFpQixXQUFXLE9BQU87Z0JBQ3hELElBQUksQ0FBQyxPQUFPLDREQUE0RDtnQkFFeEUsTUFBTSxJQUFJLENBQUMsc0JBQXNCLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxTQUFTLFFBQU8sZ0VBQWdFO1lBQ2hKO1FBQ0Q7UUFFRCxJQUFJLENBQUM7SUFDUDtJQUVRLE9BQU8sR0FBRyxJQUFXLEVBQXJCO1FBQ04sSUFBSSxJQUFJLENBQUMsa0JBQ1AsSUFBSSxDQUFDLE9BQ0gsQ0FBQSxhQUFBLEVBQWdCLElBQUksQ0FBQyxXQUFVLEVBQUEsRUFBSyxDQUFBLEdBQUEsZ0JBQUEsRUFBTyxFQUFBLEVBQUssSUFBSSxPQUFPLGNBQWEsQ0FBRSxLQUN2RTtRQUlQLE9BQU8sSUFBSTtJQUNiO0lBRUE7Ozs7S0FJRyxHQUNILE1BQU0sYUFBTjtRQUNFLElBQUksSUFBSSxDQUFDLG1CQUNQLE9BQU8sTUFBTSxJQUFJLENBQUM7UUFHcEIsSUFBSSxDQUFDLG9CQUFvQixBQUFDLENBQUE7WUFDeEIsT0FBTyxNQUFNLElBQUksQ0FBQyxhQUFhLElBQUk7Z0JBQ2pDLE9BQU8sTUFBTSxJQUFJLENBQUM7WUFDcEI7UUFDRixDQUFBO1FBRUEsT0FBTyxNQUFNLElBQUksQ0FBQztJQUNwQjtJQUVBOzs7OztLQUtHLEdBQ0ssTUFBTSxjQUFOO1FBQ04sSUFBSTtZQUNGLE1BQU0sYUFBYSxDQUFBLEdBQUEsa0JBQUEsTUFBYyxNQUFNLElBQUksQ0FBQyxnQkFBZ0I7WUFDNUQsSUFBSSxDQUFDLE9BQU8sa0JBQWtCLFNBQVMsZ0JBQWdCO1lBRXZELElBQUksY0FBZSxJQUFJLENBQUMsc0JBQXNCLElBQUksQ0FBQyx3QkFBeUI7Z0JBQzFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLEdBQUcsTUFBTSxJQUFJLENBQUMsbUJBQW1CO2dCQUN0RCxJQUFJLE9BQU87b0JBQ1QsSUFBSSxDQUFDLE9BQU8sa0JBQWtCLG9DQUFvQztvQkFFbEUsbUdBQW1HO29CQUNuRyxzRkFBc0Y7b0JBQ3RGLElBQ0UsQUFBQSxDQUFBLFVBQUssUUFBTCxVQUFLLEtBQUEsSUFBQSxLQUFBLElBQUwsTUFBTyxPQUFBLE1BQVksZ0NBQ25CLEFBQUEsQ0FBQSxVQUFLLFFBQUwsVUFBSyxLQUFBLElBQUEsS0FBQSxJQUFMLE1BQU8sT0FBQSxNQUFZLDhDQUVuQixPQUFPO3dCQUFFO29CQUFLO29CQUdoQixnQ0FBZ0M7b0JBQ2hDLDZEQUE2RDtvQkFDN0QsTUFBTSxJQUFJLENBQUM7b0JBRVgsT0FBTzt3QkFBRTtvQkFBSztnQkFDZjtnQkFFRCxNQUFNLEVBQUUsT0FBTyxFQUFFLFlBQVksRUFBRSxHQUFHO2dCQUVsQyxJQUFJLENBQUMsT0FDSCxrQkFDQSwyQkFDQSxTQUNBLGlCQUNBO2dCQUdGLE1BQU0sSUFBSSxDQUFDLGFBQWE7Z0JBRXhCLFdBQVc7b0JBQ1QsSUFBSSxpQkFBaUIsWUFDbkIsTUFBTSxJQUFJLENBQUMsc0JBQXNCLHFCQUFxQjt5QkFFdEQsTUFBTSxJQUFJLENBQUMsc0JBQXNCLGFBQWE7Z0JBRWxELEdBQUc7Z0JBRUgsT0FBTztvQkFBRSxPQUFPO2dCQUFJO1lBQ3JCO1lBQ0Qsd0VBQXdFO1lBQ3hFLE1BQU0sSUFBSSxDQUFDO1lBQ1gsT0FBTztnQkFBRSxPQUFPO1lBQUk7UUFDckIsRUFBQyxPQUFPLE9BQU87WUFDZCxJQUFJLENBQUEsR0FBQSxtQkFBQSxFQUFZLFFBQ2QsT0FBTztnQkFBRTtZQUFLO1lBR2hCLE9BQU87Z0JBQ0wsT0FBTyxJQUFJLENBQUEsR0FBQSx3QkFBQSxFQUFpQiwwQ0FBMEM7WUFDdkU7UUFDRixTQUFTO1lBQ1IsTUFBTSxJQUFJLENBQUM7WUFDWCxJQUFJLENBQUMsT0FBTyxrQkFBa0I7UUFDL0I7SUFDSDtJQUVBOzs7O0tBSUcsR0FDSCxNQUFNLGtCQUFrQixXQUEwQyxFQUFsRTtRLEksSSxJO1FBQ0UsSUFBSTtZQUNGLE1BQU0sTUFBTSxNQUFNLENBQUEsR0FBQSxlQUFBLEVBQVMsSUFBSSxDQUFDLE9BQU8sUUFBUSxDQUFBLEVBQUcsSUFBSSxDQUFDLElBQUcsT0FBQSxDQUFTLEVBQUU7Z0JBQ25FLFNBQVMsSUFBSSxDQUFDO2dCQUNkLE1BQU07b0JBQ0osTUFBTSxBQUFBLENBQUEsS0FBQSxBQUFBLENBQUEsS0FBQSxnQkFBVyxRQUFYLGdCQUFXLEtBQUEsSUFBQSxLQUFBLElBQVgsWUFBYSxPQUFBLE1BQU8sUUFBQSxPQUFBLEtBQUEsSUFBQSxLQUFBLElBQUEsR0FBRSxJQUFBLE1BQUksUUFBQSxPQUFBLEtBQUEsSUFBQSxLQUFJLENBQUE7b0JBQ3BDLHNCQUFzQjt3QkFBRSxlQUFlLEFBQUEsQ0FBQSxLQUFBLGdCQUFXLFFBQVgsZ0JBQVcsS0FBQSxJQUFBLEtBQUEsSUFBWCxZQUFhLE9BQUEsTUFBTyxRQUFBLE9BQUEsS0FBQSxJQUFBLEtBQUEsSUFBQSxHQUFFO29CQUFZO2dCQUMxRTtnQkFDRCxPQUFPLENBQUEsR0FBQSx1QkFBQTtZQUNSO1lBQ0QsTUFBTSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsR0FBRztZQUV4QixJQUFJLFNBQVMsQ0FBQyxNQUNaLE9BQU87Z0JBQUUsTUFBTTtvQkFBRSxNQUFNO29CQUFNLFNBQVM7Z0JBQUk7Z0JBQUksT0FBTztZQUFLO1lBRTVELE1BQU0sVUFBMEIsS0FBSztZQUNyQyxNQUFNLE9BQW9CLEtBQUs7WUFFL0IsSUFBSSxLQUFLLFNBQVM7Z0JBQ2hCLE1BQU0sSUFBSSxDQUFDLGFBQWEsS0FBSztnQkFDN0IsTUFBTSxJQUFJLENBQUMsc0JBQXNCLGFBQWE7WUFDL0M7WUFFRCxPQUFPO2dCQUFFLE1BQU07b0JBQUU7b0JBQU07Z0JBQU87Z0JBQUksT0FBTztZQUFJO1FBQzlDLEVBQUMsT0FBTyxPQUFPO1lBQ2QsSUFBSSxDQUFBLEdBQUEsbUJBQUEsRUFBWSxRQUNkLE9BQU87Z0JBQUUsTUFBTTtvQkFBRSxNQUFNO29CQUFNLFNBQVM7Z0JBQUk7Z0JBQUk7WUFBSztZQUdyRCxNQUFNO1FBQ1A7SUFDSDtJQUVBOzs7Ozs7Ozs7S0FTRyxHQUNILE1BQU0sT0FBTyxXQUEwQyxFQUF2RDtRLEksSSxJO1FBQ0UsSUFBSTtZQUNGLElBQUk7WUFDSixJQUFJLFdBQVcsYUFBYTtnQkFDMUIsTUFBTSxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLEdBQUc7Z0JBQ3JDLElBQUksZ0JBQStCO2dCQUNuQyxJQUFJLHNCQUFxQztnQkFDekMsSUFBSSxJQUFJLENBQUMsYUFBYSxRQUNuQixDQUFDLGVBQWUsb0JBQW9CLEdBQUcsTUFBTSxDQUFBLEdBQUEsa0NBQUEsRUFDNUMsSUFBSSxDQUFDLFNBQ0wsSUFBSSxDQUFDO2dCQUdULE1BQU0sTUFBTSxDQUFBLEdBQUEsZUFBQSxFQUFTLElBQUksQ0FBQyxPQUFPLFFBQVEsQ0FBQSxFQUFHLElBQUksQ0FBQyxJQUFHLE9BQUEsQ0FBUyxFQUFFO29CQUM3RCxTQUFTLElBQUksQ0FBQztvQkFDZCxZQUFZLFlBQU8sUUFBUCxZQUFPLEtBQUEsSUFBQSxLQUFBLElBQVAsUUFBUztvQkFDckIsTUFBTTt3QkFDSjt3QkFDQTt3QkFDQSxNQUFNLEFBQUEsQ0FBQSxLQUFBLFlBQU8sUUFBUCxZQUFPLEtBQUEsSUFBQSxLQUFBLElBQVAsUUFBUyxJQUFBLE1BQUksUUFBQSxPQUFBLEtBQUEsSUFBQSxLQUFJLENBQUE7d0JBQ3ZCLHNCQUFzQjs0QkFBRSxlQUFlLFlBQU8sUUFBUCxZQUFPLEtBQUEsSUFBQSxLQUFBLElBQVAsUUFBUzt3QkFBWTt3QkFDNUQsZ0JBQWdCO3dCQUNoQix1QkFBdUI7b0JBQ3hCO29CQUNELE9BQU8sQ0FBQSxHQUFBLHVCQUFBO2dCQUNSO1lBQ0YsT0FBTSxJQUFJLFdBQVcsYUFBYTtnQkFDakMsTUFBTSxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLEdBQUc7Z0JBQ3JDLE1BQU0sTUFBTSxDQUFBLEdBQUEsZUFBQSxFQUFTLElBQUksQ0FBQyxPQUFPLFFBQVEsQ0FBQSxFQUFHLElBQUksQ0FBQyxJQUFHLE9BQUEsQ0FBUyxFQUFFO29CQUM3RCxTQUFTLElBQUksQ0FBQztvQkFDZCxNQUFNO3dCQUNKO3dCQUNBO3dCQUNBLE1BQU0sQUFBQSxDQUFBLEtBQUEsWUFBTyxRQUFQLFlBQU8sS0FBQSxJQUFBLEtBQUEsSUFBUCxRQUFTLElBQUEsTUFBSSxRQUFBLE9BQUEsS0FBQSxJQUFBLEtBQUksQ0FBQTt3QkFDdkIsU0FBUyxBQUFBLENBQUEsS0FBQSxZQUFPLFFBQVAsWUFBTyxLQUFBLElBQUEsS0FBQSxJQUFQLFFBQVMsT0FBQSxNQUFPLFFBQUEsT0FBQSxLQUFBLElBQUEsS0FBSTt3QkFDN0Isc0JBQXNCOzRCQUFFLGVBQWUsWUFBTyxRQUFQLFlBQU8sS0FBQSxJQUFBLEtBQUEsSUFBUCxRQUFTO3dCQUFZO29CQUM3RDtvQkFDRCxPQUFPLENBQUEsR0FBQSx1QkFBQTtnQkFDUjtZQUNGLE9BQ0MsTUFBTSxJQUFJLENBQUEsR0FBQSxtQ0FBQSxFQUNSO1lBSUosTUFBTSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsR0FBRztZQUV4QixJQUFJLFNBQVMsQ0FBQyxNQUNaLE9BQU87Z0JBQUUsTUFBTTtvQkFBRSxNQUFNO29CQUFNLFNBQVM7Z0JBQUk7Z0JBQUksT0FBTztZQUFLO1lBRzVELE1BQU0sVUFBMEIsS0FBSztZQUNyQyxNQUFNLE9BQW9CLEtBQUs7WUFFL0IsSUFBSSxLQUFLLFNBQVM7Z0JBQ2hCLE1BQU0sSUFBSSxDQUFDLGFBQWEsS0FBSztnQkFDN0IsTUFBTSxJQUFJLENBQUMsc0JBQXNCLGFBQWE7WUFDL0M7WUFFRCxPQUFPO2dCQUFFLE1BQU07b0JBQUU7b0JBQU07Z0JBQU87Z0JBQUksT0FBTztZQUFJO1FBQzlDLEVBQUMsT0FBTyxPQUFPO1lBQ2QsSUFBSSxDQUFBLEdBQUEsbUJBQUEsRUFBWSxRQUNkLE9BQU87Z0JBQUUsTUFBTTtvQkFBRSxNQUFNO29CQUFNLFNBQVM7Z0JBQUk7Z0JBQUk7WUFBSztZQUdyRCxNQUFNO1FBQ1A7SUFDSDtJQUVBOzs7Ozs7O0tBT0csR0FDSCxNQUFNLG1CQUNKLFdBQTBDLEVBRDVDO1FBR0UsSUFBSTtZQUNGLElBQUk7WUFDSixJQUFJLFdBQVcsYUFBYTtnQkFDMUIsTUFBTSxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLEdBQUc7Z0JBQ3JDLE1BQU0sTUFBTSxDQUFBLEdBQUEsZUFBQSxFQUFTLElBQUksQ0FBQyxPQUFPLFFBQVEsQ0FBQSxFQUFHLElBQUksQ0FBQyxJQUFHLDBCQUFBLENBQTRCLEVBQUU7b0JBQ2hGLFNBQVMsSUFBSSxDQUFDO29CQUNkLE1BQU07d0JBQ0o7d0JBQ0E7d0JBQ0Esc0JBQXNCOzRCQUFFLGVBQWUsWUFBTyxRQUFQLFlBQU8sS0FBQSxJQUFBLEtBQUEsSUFBUCxRQUFTO3dCQUFZO29CQUM3RDtvQkFDRCxPQUFPLENBQUEsR0FBQSwrQkFBQTtnQkFDUjtZQUNGLE9BQU0sSUFBSSxXQUFXLGFBQWE7Z0JBQ2pDLE1BQU0sRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSxHQUFHO2dCQUNyQyxNQUFNLE1BQU0sQ0FBQSxHQUFBLGVBQUEsRUFBUyxJQUFJLENBQUMsT0FBTyxRQUFRLENBQUEsRUFBRyxJQUFJLENBQUMsSUFBRywwQkFBQSxDQUE0QixFQUFFO29CQUNoRixTQUFTLElBQUksQ0FBQztvQkFDZCxNQUFNO3dCQUNKO3dCQUNBO3dCQUNBLHNCQUFzQjs0QkFBRSxlQUFlLFlBQU8sUUFBUCxZQUFPLEtBQUEsSUFBQSxLQUFBLElBQVAsUUFBUzt3QkFBWTtvQkFDN0Q7b0JBQ0QsT0FBTyxDQUFBLEdBQUEsK0JBQUE7Z0JBQ1I7WUFDRixPQUNDLE1BQU0sSUFBSSxDQUFBLEdBQUEsbUNBQUEsRUFDUjtZQUdKLE1BQU0sRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLEdBQUc7WUFFeEIsSUFBSSxPQUNGLE9BQU87Z0JBQUUsTUFBTTtvQkFBRSxNQUFNO29CQUFNLFNBQVM7Z0JBQUk7Z0JBQUk7WUFBSztpQkFDOUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLFdBQVcsQ0FBQyxLQUFLLE1BQ3pDLE9BQU87Z0JBQUUsTUFBTTtvQkFBRSxNQUFNO29CQUFNLFNBQVM7Z0JBQUk7Z0JBQUksT0FBTyxJQUFJLENBQUEsR0FBQSxxQ0FBQTtZQUErQjtZQUUxRixJQUFJLEtBQUssU0FBUztnQkFDaEIsTUFBTSxJQUFJLENBQUMsYUFBYSxLQUFLO2dCQUM3QixNQUFNLElBQUksQ0FBQyxzQkFBc0IsYUFBYSxLQUFLO1lBQ3BEO1lBQ0QsT0FBTztnQkFDTCxNQUFJLE9BQUEsT0FBQTtvQkFDRixNQUFNLEtBQUs7b0JBQ1gsU0FBUyxLQUFLO2dCQUFPLEdBQ2pCLEtBQUssZ0JBQWdCO29CQUFFLGNBQWMsS0FBSztnQkFBYSxJQUFLO2dCQUVsRTtZQUNEO1FBQ0YsRUFBQyxPQUFPLE9BQU87WUFDZCxJQUFJLENBQUEsR0FBQSxtQkFBQSxFQUFZLFFBQ2QsT0FBTztnQkFBRSxNQUFNO29CQUFFLE1BQU07b0JBQU0sU0FBUztnQkFBSTtnQkFBSTtZQUFLO1lBRXJELE1BQU07UUFDUDtJQUNIO0lBRUE7OztLQUdHLEdBQ0gsTUFBTSxnQkFBZ0IsV0FBdUMsRUFBN0Q7USxJLEksSSxJO1FBQ0UsT0FBTyxNQUFNLElBQUksQ0FBQyxzQkFBc0IsWUFBWSxVQUFVO1lBQzVELFlBQVksQUFBQSxDQUFBLEtBQUEsWUFBWSxPQUFBLE1BQU8sUUFBQSxPQUFBLEtBQUEsSUFBQSxLQUFBLElBQUEsR0FBRTtZQUNqQyxRQUFRLEFBQUEsQ0FBQSxLQUFBLFlBQVksT0FBQSxNQUFPLFFBQUEsT0FBQSxLQUFBLElBQUEsS0FBQSxJQUFBLEdBQUU7WUFDN0IsYUFBYSxBQUFBLENBQUEsS0FBQSxZQUFZLE9BQUEsTUFBTyxRQUFBLE9BQUEsS0FBQSxJQUFBLEtBQUEsSUFBQSxHQUFFO1lBQ2xDLHFCQUFxQixBQUFBLENBQUEsS0FBQSxZQUFZLE9BQUEsTUFBTyxRQUFBLE9BQUEsS0FBQSxJQUFBLEtBQUEsSUFBQSxHQUFFO1FBQzNDO0lBQ0g7SUFFQTs7S0FFRyxHQUNILE1BQU0sdUJBQXVCLFFBQWdCLEVBQTdDO1FBQ0UsTUFBTSxJQUFJLENBQUM7UUFFWCxPQUFPLElBQUksQ0FBQyxhQUFhLElBQUk7WUFDM0IsT0FBTyxJQUFJLENBQUMsd0JBQXdCO1FBQ3RDO0lBQ0Y7SUFFUSxNQUFNLHdCQUF3QixRQUFnQixFQUE5QztRQU9OLE1BQU0sY0FBYyxNQUFNLENBQUEsR0FBQSxxQkFBQSxFQUFhLElBQUksQ0FBQyxTQUFTLENBQUEsRUFBRyxJQUFJLENBQUMsV0FBVSxjQUFBLENBQWdCO1FBQ3ZGLE1BQU0sQ0FBQyxjQUFjLGFBQWEsR0FBSSxBQUFDLENBQUEsZ0JBQVcsUUFBWCxnQkFBVyxLQUFBLElBQVgsY0FBZSxFQUFBLEVBQWUsTUFBTTtRQUMzRSxNQUFNLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxHQUFHLE1BQU0sQ0FBQSxHQUFBLGVBQUEsRUFDNUIsSUFBSSxDQUFDLE9BQ0wsUUFDQSxDQUFBLEVBQUcsSUFBSSxDQUFDLElBQUcsc0JBQUEsQ0FBd0IsRUFDbkM7WUFDRSxTQUFTLElBQUksQ0FBQztZQUNkLE1BQU07Z0JBQ0osV0FBVztnQkFDWCxlQUFlO1lBQ2hCO1lBQ0QsT0FBTyxDQUFBLEdBQUEsdUJBQUE7UUFDUjtRQUVILE1BQU0sQ0FBQSxHQUFBLHdCQUFBLEVBQWdCLElBQUksQ0FBQyxTQUFTLENBQUEsRUFBRyxJQUFJLENBQUMsV0FBVSxjQUFBLENBQWdCO1FBQ3RFLElBQUksT0FDRixPQUFPO1lBQUUsTUFBTTtnQkFBRSxNQUFNO2dCQUFNLFNBQVM7Z0JBQU0sY0FBYztZQUFJO1lBQUk7UUFBSzthQUNsRSxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssV0FBVyxDQUFDLEtBQUssTUFDekMsT0FBTztZQUNMLE1BQU07Z0JBQUUsTUFBTTtnQkFBTSxTQUFTO2dCQUFNLGNBQWM7WUFBSTtZQUNyRCxPQUFPLElBQUksQ0FBQSxHQUFBLHFDQUFBO1FBQ1o7UUFFSCxJQUFJLEtBQUssU0FBUztZQUNoQixNQUFNLElBQUksQ0FBQyxhQUFhLEtBQUs7WUFDN0IsTUFBTSxJQUFJLENBQUMsc0JBQXNCLGFBQWEsS0FBSztRQUNwRDtRQUNELE9BQU87WUFBRSxNQUFJLE9BQUEsT0FBQSxPQUFBLE9BQUEsQ0FBQSxHQUFPLE9BQUk7Z0JBQUUsY0FBYyxpQkFBWSxRQUFaLGlCQUFZLEtBQUEsSUFBWixlQUFnQjtZQUFJO1lBQUk7UUFBSztJQUN2RTtJQUVBOzs7S0FHRyxHQUNILE1BQU0sa0JBQWtCLFdBQXlDLEVBQWpFO1FBQ0UsSUFBSTtZQUNGLE1BQU0sRUFBRSxPQUFPLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFFLEdBQUc7WUFFMUQsTUFBTSxNQUFNLE1BQU0sQ0FBQSxHQUFBLGVBQUEsRUFBUyxJQUFJLENBQUMsT0FBTyxRQUFRLENBQUEsRUFBRyxJQUFJLENBQUMsSUFBRywwQkFBQSxDQUE0QixFQUFFO2dCQUN0RixTQUFTLElBQUksQ0FBQztnQkFDZCxNQUFNO29CQUNKO29CQUNBLFVBQVU7b0JBQ1Y7b0JBQ0E7b0JBQ0Esc0JBQXNCO3dCQUFFLGVBQWUsWUFBTyxRQUFQLFlBQU8sS0FBQSxJQUFBLEtBQUEsSUFBUCxRQUFTO29CQUFZO2dCQUM3RDtnQkFDRCxPQUFPLENBQUEsR0FBQSx1QkFBQTtZQUNSO1lBRUQsTUFBTSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsR0FBRztZQUN4QixJQUFJLE9BQ0YsT0FBTztnQkFBRSxNQUFNO29CQUFFLE1BQU07b0JBQU0sU0FBUztnQkFBSTtnQkFBSTtZQUFLO2lCQUM5QyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssV0FBVyxDQUFDLEtBQUssTUFDekMsT0FBTztnQkFDTCxNQUFNO29CQUFFLE1BQU07b0JBQU0sU0FBUztnQkFBSTtnQkFDakMsT0FBTyxJQUFJLENBQUEsR0FBQSxxQ0FBQTtZQUNaO1lBRUgsSUFBSSxLQUFLLFNBQVM7Z0JBQ2hCLE1BQU0sSUFBSSxDQUFDLGFBQWEsS0FBSztnQkFDN0IsTUFBTSxJQUFJLENBQUMsc0JBQXNCLGFBQWEsS0FBSztZQUNwRDtZQUNELE9BQU87Z0JBQUU7Z0JBQU07WUFBSztRQUNyQixFQUFDLE9BQU8sT0FBTztZQUNkLElBQUksQ0FBQSxHQUFBLG1CQUFBLEVBQVksUUFDZCxPQUFPO2dCQUFFLE1BQU07b0JBQUUsTUFBTTtvQkFBTSxTQUFTO2dCQUFJO2dCQUFJO1lBQUs7WUFFckQsTUFBTTtRQUNQO0lBQ0g7SUFFQTs7Ozs7Ozs7Ozs7Ozs7OztLQWdCRyxHQUNILE1BQU0sY0FBYyxXQUE4QyxFQUFsRTtRLEksSSxJLEksSTtRQUNFLElBQUk7WUFDRixJQUFJLFdBQVcsYUFBYTtnQkFDMUIsTUFBTSxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsR0FBRztnQkFDM0IsSUFBSSxnQkFBK0I7Z0JBQ25DLElBQUksc0JBQXFDO2dCQUN6QyxJQUFJLElBQUksQ0FBQyxhQUFhLFFBQ25CLENBQUMsZUFBZSxvQkFBb0IsR0FBRyxNQUFNLENBQUEsR0FBQSxrQ0FBQSxFQUM1QyxJQUFJLENBQUMsU0FDTCxJQUFJLENBQUM7Z0JBR1QsTUFBTSxFQUFFLEtBQUssRUFBRSxHQUFHLE1BQU0sQ0FBQSxHQUFBLGVBQUEsRUFBUyxJQUFJLENBQUMsT0FBTyxRQUFRLENBQUEsRUFBRyxJQUFJLENBQUMsSUFBRyxJQUFBLENBQU0sRUFBRTtvQkFDdEUsU0FBUyxJQUFJLENBQUM7b0JBQ2QsTUFBTTt3QkFDSjt3QkFDQSxNQUFNLEFBQUEsQ0FBQSxLQUFBLFlBQU8sUUFBUCxZQUFPLEtBQUEsSUFBQSxLQUFBLElBQVAsUUFBUyxJQUFBLE1BQUksUUFBQSxPQUFBLEtBQUEsSUFBQSxLQUFJLENBQUE7d0JBQ3ZCLGFBQWEsQUFBQSxDQUFBLEtBQUEsWUFBTyxRQUFQLFlBQU8sS0FBQSxJQUFBLEtBQUEsSUFBUCxRQUFTLGdCQUFBLE1BQWdCLFFBQUEsT0FBQSxLQUFBLElBQUEsS0FBSTt3QkFDMUMsc0JBQXNCOzRCQUFFLGVBQWUsWUFBTyxRQUFQLFlBQU8sS0FBQSxJQUFBLEtBQUEsSUFBUCxRQUFTO3dCQUFZO3dCQUM1RCxnQkFBZ0I7d0JBQ2hCLHVCQUF1QjtvQkFDeEI7b0JBQ0QsWUFBWSxZQUFPLFFBQVAsWUFBTyxLQUFBLElBQUEsS0FBQSxJQUFQLFFBQVM7Z0JBQ3RCO2dCQUNELE9BQU87b0JBQUUsTUFBTTt3QkFBRSxNQUFNO3dCQUFNLFNBQVM7b0JBQUk7b0JBQUk7Z0JBQUs7WUFDcEQ7WUFDRCxJQUFJLFdBQVcsYUFBYTtnQkFDMUIsTUFBTSxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsR0FBRztnQkFDM0IsTUFBTSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsR0FBRyxNQUFNLENBQUEsR0FBQSxlQUFBLEVBQVMsSUFBSSxDQUFDLE9BQU8sUUFBUSxDQUFBLEVBQUcsSUFBSSxDQUFDLElBQUcsSUFBQSxDQUFNLEVBQUU7b0JBQzVFLFNBQVMsSUFBSSxDQUFDO29CQUNkLE1BQU07d0JBQ0o7d0JBQ0EsTUFBTSxBQUFBLENBQUEsS0FBQSxZQUFPLFFBQVAsWUFBTyxLQUFBLElBQUEsS0FBQSxJQUFQLFFBQVMsSUFBQSxNQUFJLFFBQUEsT0FBQSxLQUFBLElBQUEsS0FBSSxDQUFBO3dCQUN2QixhQUFhLEFBQUEsQ0FBQSxLQUFBLFlBQU8sUUFBUCxZQUFPLEtBQUEsSUFBQSxLQUFBLElBQVAsUUFBUyxnQkFBQSxNQUFnQixRQUFBLE9BQUEsS0FBQSxJQUFBLEtBQUk7d0JBQzFDLHNCQUFzQjs0QkFBRSxlQUFlLFlBQU8sUUFBUCxZQUFPLEtBQUEsSUFBQSxLQUFBLElBQVAsUUFBUzt3QkFBWTt3QkFDNUQsU0FBUyxBQUFBLENBQUEsS0FBQSxZQUFPLFFBQVAsWUFBTyxLQUFBLElBQUEsS0FBQSxJQUFQLFFBQVMsT0FBQSxNQUFPLFFBQUEsT0FBQSxLQUFBLElBQUEsS0FBSTtvQkFDOUI7Z0JBQ0Y7Z0JBQ0QsT0FBTztvQkFBRSxNQUFNO3dCQUFFLE1BQU07d0JBQU0sU0FBUzt3QkFBTSxXQUFXLFNBQUksUUFBSixTQUFJLEtBQUEsSUFBQSxLQUFBLElBQUosS0FBTTtvQkFBVTtvQkFBSTtnQkFBSztZQUNqRjtZQUNELE1BQU0sSUFBSSxDQUFBLEdBQUEsbUNBQUEsRUFBNEI7UUFDdkMsRUFBQyxPQUFPLE9BQU87WUFDZCxJQUFJLENBQUEsR0FBQSxtQkFBQSxFQUFZLFFBQ2QsT0FBTztnQkFBRSxNQUFNO29CQUFFLE1BQU07b0JBQU0sU0FBUztnQkFBSTtnQkFBSTtZQUFLO1lBR3JELE1BQU07UUFDUDtJQUNIO0lBRUE7O0tBRUcsR0FDSCxNQUFNLFVBQVUsTUFBdUIsRUFBdkM7USxJLEk7UUFDRSxJQUFJO1lBQ0YsSUFBSSxhQUFpQztZQUNyQyxJQUFJLGVBQW1DO1lBQ3ZDLElBQUksYUFBYSxRQUFRO2dCQUN2QixhQUFhLEFBQUEsQ0FBQSxLQUFBLE9BQU8sT0FBQSxNQUFPLFFBQUEsT0FBQSxLQUFBLElBQUEsS0FBQSxJQUFBLEdBQUU7Z0JBQzdCLGVBQWUsQUFBQSxDQUFBLEtBQUEsT0FBTyxPQUFBLE1BQU8sUUFBQSxPQUFBLEtBQUEsSUFBQSxLQUFBLElBQUEsR0FBRTtZQUNoQztZQUNELE1BQU0sRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLEdBQUcsTUFBTSxDQUFBLEdBQUEsZUFBQSxFQUFTLElBQUksQ0FBQyxPQUFPLFFBQVEsQ0FBQSxFQUFHLElBQUksQ0FBQyxJQUFHLE9BQUEsQ0FBUyxFQUFFO2dCQUMvRSxTQUFTLElBQUksQ0FBQztnQkFDZCxNQUFJLE9BQUEsT0FBQSxPQUFBLE9BQUEsQ0FBQSxHQUNDLFNBQU07b0JBQ1Qsc0JBQXNCO3dCQUFFLGVBQWU7b0JBQVk7Z0JBQUU7Z0JBRXZEO2dCQUNBLE9BQU8sQ0FBQSxHQUFBLHVCQUFBO1lBQ1I7WUFFRCxJQUFJLE9BQ0YsTUFBTTtZQUdSLElBQUksQ0FBQyxNQUNILE1BQU0sSUFBSSxNQUFNO1lBR2xCLE1BQU0sVUFBMEIsS0FBSztZQUNyQyxNQUFNLE9BQWEsS0FBSztZQUV4QixJQUFJLFlBQU8sUUFBUCxZQUFPLEtBQUEsSUFBQSxLQUFBLElBQVAsUUFBUyxjQUFjO2dCQUN6QixNQUFNLElBQUksQ0FBQyxhQUFhO2dCQUN4QixNQUFNLElBQUksQ0FBQyxzQkFDVCxPQUFPLFFBQVEsYUFBYSxzQkFBc0IsYUFDbEQ7WUFFSDtZQUVELE9BQU87Z0JBQUUsTUFBTTtvQkFBRTtvQkFBTTtnQkFBTztnQkFBSSxPQUFPO1lBQUk7UUFDOUMsRUFBQyxPQUFPLE9BQU87WUFDZCxJQUFJLENBQUEsR0FBQSxtQkFBQSxFQUFZLFFBQ2QsT0FBTztnQkFBRSxNQUFNO29CQUFFLE1BQU07b0JBQU0sU0FBUztnQkFBSTtnQkFBSTtZQUFLO1lBR3JELE1BQU07UUFDUDtJQUNIO0lBRUE7Ozs7Ozs7Ozs7Ozs7S0FhRyxHQUNILE1BQU0sY0FBYyxNQUFxQixFQUF6QztRLEksSSxJO1FBQ0UsSUFBSTtZQUNGLElBQUksZ0JBQStCO1lBQ25DLElBQUksc0JBQXFDO1lBQ3pDLElBQUksSUFBSSxDQUFDLGFBQWEsUUFDbkIsQ0FBQyxlQUFlLG9CQUFvQixHQUFHLE1BQU0sQ0FBQSxHQUFBLGtDQUFBLEVBQzVDLElBQUksQ0FBQyxTQUNMLElBQUksQ0FBQztZQUlULE9BQU8sTUFBTSxDQUFBLEdBQUEsZUFBQSxFQUFTLElBQUksQ0FBQyxPQUFPLFFBQVEsQ0FBQSxFQUFHLElBQUksQ0FBQyxJQUFHLElBQUEsQ0FBTSxFQUFFO2dCQUMzRCxNQUFJLE9BQUEsT0FBQSxPQUFBLE9BQUEsT0FBQSxPQUFBLE9BQUEsT0FBQSxPQUFBLE9BQUEsQ0FBQSxHQUNFLGdCQUFnQixTQUFTO29CQUFFLGFBQWEsT0FBTztnQkFBVSxJQUFLLE9BQzlELFlBQVksU0FBUztvQkFBRSxRQUFRLE9BQU87Z0JBQU0sSUFBSyxPQUFLO29CQUMxRCxhQUFhLEFBQUEsQ0FBQSxLQUFBLEFBQUEsQ0FBQSxLQUFBLE9BQU8sT0FBQSxNQUFPLFFBQUEsT0FBQSxLQUFBLElBQUEsS0FBQSxJQUFBLEdBQUUsVUFBQSxNQUFVLFFBQUEsT0FBQSxLQUFBLElBQUEsS0FBSTtnQkFBUyxJQUNoRCxBQUFBLENBQUEsQUFBQSxDQUFBLEtBQUEsV0FBTSxRQUFOLFdBQU0sS0FBQSxJQUFBLEtBQUEsSUFBTixPQUFRLE9BQUEsTUFBTyxRQUFBLE9BQUEsS0FBQSxJQUFBLEtBQUEsSUFBQSxHQUFFLFlBQUEsSUFDakI7b0JBQUUsc0JBQXNCO3dCQUFFLGVBQWUsT0FBTyxRQUFRO29CQUFZO2dCQUFFLElBQ3RFLE9BQUs7b0JBQ1Qsb0JBQW9CO29CQUNwQixnQkFBZ0I7b0JBQ2hCLHVCQUF1QjtnQkFBbUI7Z0JBRTVDLFNBQVMsSUFBSSxDQUFDO2dCQUNkLE9BQU8sQ0FBQSxHQUFBLG1CQUFBO1lBQ1I7UUFDRixFQUFDLE9BQU8sT0FBTztZQUNkLElBQUksQ0FBQSxHQUFBLG1CQUFBLEVBQVksUUFDZCxPQUFPO2dCQUFFLE1BQU07Z0JBQU07WUFBSztZQUU1QixNQUFNO1FBQ1A7SUFDSDtJQUVBOzs7S0FHRyxHQUNILE1BQU0saUJBQU47UUFDRSxNQUFNLElBQUksQ0FBQztRQUVYLE9BQU8sTUFBTSxJQUFJLENBQUMsYUFBYSxJQUFJO1lBQ2pDLE9BQU8sTUFBTSxJQUFJLENBQUM7UUFDcEI7SUFDRjtJQUVRLE1BQU0sa0JBQU47UUFDTixJQUFJO1lBQ0YsT0FBTyxNQUFNLElBQUksQ0FBQyxZQUFZLE9BQU87Z0JBQ25DLE1BQU0sRUFDSixNQUFNLEVBQUUsT0FBTyxFQUFFLEVBQ2pCLE9BQU8sWUFBWSxFQUNwQixHQUFHO2dCQUNKLElBQUksY0FBYyxNQUFNO2dCQUN4QixJQUFJLENBQUMsU0FBUyxNQUFNLElBQUksQ0FBQSxHQUFBLCtCQUFBO2dCQUV4QixNQUFNLEVBQUUsS0FBSyxFQUFFLEdBQUcsTUFBTSxDQUFBLEdBQUEsZUFBQSxFQUFTLElBQUksQ0FBQyxPQUFPLE9BQU8sQ0FBQSxFQUFHLElBQUksQ0FBQyxJQUFHLGVBQUEsQ0FBaUIsRUFBRTtvQkFDaEYsU0FBUyxJQUFJLENBQUM7b0JBQ2QsS0FBSyxRQUFRO2dCQUNkO2dCQUNELE9BQU87b0JBQUUsTUFBTTt3QkFBRSxNQUFNO3dCQUFNLFNBQVM7b0JBQUk7b0JBQUk7Z0JBQUs7WUFDckQ7UUFDRCxFQUFDLE9BQU8sT0FBTztZQUNkLElBQUksQ0FBQSxHQUFBLG1CQUFBLEVBQVksUUFDZCxPQUFPO2dCQUFFLE1BQU07b0JBQUUsTUFBTTtvQkFBTSxTQUFTO2dCQUFJO2dCQUFJO1lBQUs7WUFFckQsTUFBTTtRQUNQO0lBQ0g7SUFFQTs7S0FFRyxHQUNILE1BQU0sT0FBTyxXQUF5QixFQUF0QztRQUNFLElBQUk7WUFDRixNQUFNLFdBQVcsQ0FBQSxFQUFHLElBQUksQ0FBQyxJQUFHLE9BQUEsQ0FBUztZQUNyQyxJQUFJLFdBQVcsYUFBYTtnQkFDMUIsTUFBTSxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLEdBQUc7Z0JBQ2pDLE1BQU0sRUFBRSxLQUFLLEVBQUUsR0FBRyxNQUFNLENBQUEsR0FBQSxlQUFBLEVBQVMsSUFBSSxDQUFDLE9BQU8sUUFBUSxVQUFVO29CQUM3RCxTQUFTLElBQUksQ0FBQztvQkFDZCxNQUFNO3dCQUNKO3dCQUNBO3dCQUNBLHNCQUFzQjs0QkFBRSxlQUFlLFlBQU8sUUFBUCxZQUFPLEtBQUEsSUFBQSxLQUFBLElBQVAsUUFBUzt3QkFBWTtvQkFDN0Q7b0JBQ0QsWUFBWSxZQUFPLFFBQVAsWUFBTyxLQUFBLElBQUEsS0FBQSxJQUFQLFFBQVM7Z0JBQ3RCO2dCQUNELE9BQU87b0JBQUUsTUFBTTt3QkFBRSxNQUFNO3dCQUFNLFNBQVM7b0JBQUk7b0JBQUk7Z0JBQUs7WUFDcEQsT0FBTSxJQUFJLFdBQVcsYUFBYTtnQkFDakMsTUFBTSxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLEdBQUc7Z0JBQ2pDLE1BQU0sRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLEdBQUcsTUFBTSxDQUFBLEdBQUEsZUFBQSxFQUFTLElBQUksQ0FBQyxPQUFPLFFBQVEsVUFBVTtvQkFDbkUsU0FBUyxJQUFJLENBQUM7b0JBQ2QsTUFBTTt3QkFDSjt3QkFDQTt3QkFDQSxzQkFBc0I7NEJBQUUsZUFBZSxZQUFPLFFBQVAsWUFBTyxLQUFBLElBQUEsS0FBQSxJQUFQLFFBQVM7d0JBQVk7b0JBQzdEO2dCQUNGO2dCQUNELE9BQU87b0JBQUUsTUFBTTt3QkFBRSxNQUFNO3dCQUFNLFNBQVM7d0JBQU0sV0FBVyxTQUFJLFFBQUosU0FBSSxLQUFBLElBQUEsS0FBQSxJQUFKLEtBQU07b0JBQVU7b0JBQUk7Z0JBQUs7WUFDakY7WUFDRCxNQUFNLElBQUksQ0FBQSxHQUFBLG1DQUFBLEVBQ1I7UUFFSCxFQUFDLE9BQU8sT0FBTztZQUNkLElBQUksQ0FBQSxHQUFBLG1CQUFBLEVBQVksUUFDZCxPQUFPO2dCQUFFLE1BQU07b0JBQUUsTUFBTTtvQkFBTSxTQUFTO2dCQUFJO2dCQUFJO1lBQUs7WUFFckQsTUFBTTtRQUNQO0lBQ0g7SUFFQTs7Ozs7Ozs7OztLQVVHLEdBQ0gsTUFBTSxhQUFOO1FBQ0UsTUFBTSxJQUFJLENBQUM7UUFFWCxNQUFNLFNBQVMsTUFBTSxJQUFJLENBQUMsYUFBYSxJQUFJO1lBQ3pDLE9BQU8sSUFBSSxDQUFDLFlBQVksT0FBTztnQkFDN0IsT0FBTztZQUNUO1FBQ0Y7UUFFQSxPQUFPO0lBQ1Q7SUFFQTs7S0FFRyxHQUNLLE1BQU0sYUFBZ0IsY0FBc0IsRUFBRSxFQUFvQixFQUFsRTtRQUNOLElBQUksQ0FBQyxPQUFPLGlCQUFpQixTQUFTO1FBRXRDLElBQUk7WUFDRixJQUFJLElBQUksQ0FBQyxjQUFjO2dCQUNyQixNQUFNLE9BQU8sSUFBSSxDQUFDLGNBQWMsU0FDNUIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsY0FBYyxTQUFTLEVBQUUsR0FDakQsUUFBUTtnQkFFWixNQUFNLFNBQVMsQUFBQyxDQUFBO29CQUNkLE1BQU07b0JBQ04sT0FBTyxNQUFNO2dCQUNmLENBQUE7Z0JBRUEsSUFBSSxDQUFDLGNBQWMsS0FDakIsQUFBQyxDQUFBO29CQUNDLElBQUk7d0JBQ0YsTUFBTTtvQkFDUCxFQUFDLE9BQU8sR0FBUTtvQkFDZiw4QkFBOEI7b0JBQy9CO2dCQUNILENBQUE7Z0JBR0YsT0FBTztZQUNSO1lBRUQsT0FBTyxNQUFNLElBQUksQ0FBQyxLQUFLLENBQUEsS0FBQSxFQUFRLElBQUksQ0FBQyxXQUFVLENBQUUsRUFBRSxnQkFBZ0I7Z0JBQ2hFLElBQUksQ0FBQyxPQUFPLGlCQUFpQixpQ0FBaUMsSUFBSSxDQUFDO2dCQUVuRSxJQUFJO29CQUNGLElBQUksQ0FBQyxlQUFlO29CQUVwQixNQUFNLFNBQVM7b0JBRWYsSUFBSSxDQUFDLGNBQWMsS0FDakIsQUFBQyxDQUFBO3dCQUNDLElBQUk7NEJBQ0YsTUFBTTt3QkFDUCxFQUFDLE9BQU8sR0FBUTt3QkFDZiw4QkFBOEI7d0JBQy9CO29CQUNILENBQUE7b0JBR0YsTUFBTTtvQkFFTiwyREFBMkQ7b0JBQzNELE1BQU8sSUFBSSxDQUFDLGNBQWMsT0FBUTt3QkFDaEMsTUFBTSxTQUFTOytCQUFJLElBQUksQ0FBQzt5QkFBYzt3QkFFdEMsTUFBTSxRQUFRLElBQUk7d0JBRWxCLElBQUksQ0FBQyxjQUFjLE9BQU8sR0FBRyxPQUFPO29CQUNyQztvQkFFRCxPQUFPLE1BQU07Z0JBQ2QsU0FBUztvQkFDUixJQUFJLENBQUMsT0FBTyxpQkFBaUIsaUNBQWlDLElBQUksQ0FBQztvQkFFbkUsSUFBSSxDQUFDLGVBQWU7Z0JBQ3JCO1lBQ0g7UUFDRCxTQUFTO1lBQ1IsSUFBSSxDQUFDLE9BQU8saUJBQWlCO1FBQzlCO0lBQ0g7SUFFQTs7Ozs7S0FLRyxHQUNLLE1BQU0sWUFDWixFQW9CZSxFQXJCVDtRQXVCTixJQUFJLENBQUMsT0FBTyxnQkFBZ0I7UUFFNUIsSUFBSTtZQUNGLHlFQUF5RTtZQUN6RSxNQUFNLFNBQVMsTUFBTSxJQUFJLENBQUM7WUFFMUIsT0FBTyxNQUFNLEdBQUc7UUFDakIsU0FBUztZQUNSLElBQUksQ0FBQyxPQUFPLGdCQUFnQjtRQUM3QjtJQUNIO0lBRUE7Ozs7S0FJRyxHQUNLLE1BQU0sZ0JBQU47UUFvQk4sSUFBSSxDQUFDLE9BQU8sb0JBQW9CO1FBRWhDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FDUixJQUFJLENBQUMsT0FBTyxvQkFBb0IscUNBQXFDLElBQUksUUFBUTtRQUduRixJQUFJO1lBQ0YsSUFBSSxpQkFBaUM7WUFFckMsTUFBTSxlQUFlLE1BQU0sQ0FBQSxHQUFBLHFCQUFBLEVBQWEsSUFBSSxDQUFDLFNBQVMsSUFBSSxDQUFDO1lBRTNELElBQUksQ0FBQyxPQUFPLGlCQUFpQix3QkFBd0I7WUFFckQsSUFBSSxpQkFBaUI7Z0JBQ25CLElBQUksSUFBSSxDQUFDLGdCQUFnQixlQUN2QixpQkFBaUI7cUJBQ1o7b0JBQ0wsSUFBSSxDQUFDLE9BQU8saUJBQWlCO29CQUM3QixNQUFNLElBQUksQ0FBQztnQkFDWjs7WUFHSCxJQUFJLENBQUMsZ0JBQ0gsT0FBTztnQkFBRSxNQUFNO29CQUFFLFNBQVM7Z0JBQUk7Z0JBQUksT0FBTztZQUFJO1lBRy9DLE1BQU0sYUFBYSxlQUFlLGFBQzlCLGVBQWUsY0FBYyxLQUFLLFFBQVEsT0FDMUM7WUFFSixJQUFJLENBQUMsT0FDSCxvQkFDQSxDQUFBLFdBQUEsRUFBYyxhQUFhLEtBQUssT0FBTSxRQUFBLENBQVUsRUFDaEQsY0FDQSxlQUFlO1lBR2pCLElBQUksQ0FBQyxZQUFZO2dCQUNmLElBQUksSUFBSSxDQUFDLFFBQVEsVUFBVTtvQkFDekIsSUFBSSxrQkFBa0IsSUFBSSxDQUFDO29CQUMzQixNQUFNLGVBQXdCLElBQUksTUFBTSxnQkFBZ0I7d0JBQ3RELEtBQUssQ0FBQyxRQUFhLE1BQWM7NEJBQy9CLElBQUksQ0FBQyxtQkFBbUIsU0FBUyxRQUFRO2dDQUN2QywyRUFBMkU7Z0NBQzNFLFFBQVEsS0FDTjtnQ0FFRixrQkFBa0IsTUFBSyw2REFBNkQ7Z0NBQ3BGLElBQUksQ0FBQyw0QkFBNEIsTUFBSywwREFBMEQ7NEJBQ2pHOzRCQUNELE9BQU8sUUFBUSxJQUFJLFFBQVEsTUFBTTt3QkFDbkM7b0JBQ0Q7b0JBQ0QsaUJBQWlCO2dCQUNsQjtnQkFFRCxPQUFPO29CQUFFLE1BQU07d0JBQUUsU0FBUztvQkFBYztvQkFBSSxPQUFPO2dCQUFJO1lBQ3hEO1lBRUQsTUFBTSxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsR0FBRyxNQUFNLElBQUksQ0FBQyxrQkFBa0IsZUFBZTtZQUN2RSxJQUFJLE9BQ0YsT0FBTztnQkFBRSxNQUFNO29CQUFFLFNBQVM7Z0JBQUk7Z0JBQUk7WUFBSztZQUd6QyxPQUFPO2dCQUFFLE1BQU07b0JBQUU7Z0JBQU87Z0JBQUksT0FBTztZQUFJO1FBQ3hDLFNBQVM7WUFDUixJQUFJLENBQUMsT0FBTyxvQkFBb0I7UUFDakM7SUFDSDtJQUVBOzs7Ozs7S0FNRyxHQUNILE1BQU0sUUFBUSxHQUFZLEVBQTFCO1FBQ0UsSUFBSSxLQUNGLE9BQU8sTUFBTSxJQUFJLENBQUMsU0FBUztRQUc3QixNQUFNLElBQUksQ0FBQztRQUVYLE1BQU0sU0FBUyxNQUFNLElBQUksQ0FBQyxhQUFhLElBQUk7WUFDekMsT0FBTyxNQUFNLElBQUksQ0FBQztRQUNwQjtRQUVBLE9BQU87SUFDVDtJQUVRLE1BQU0sU0FBUyxHQUFZLEVBQTNCO1FBQ04sSUFBSTtZQUNGLElBQUksS0FDRixPQUFPLE1BQU0sQ0FBQSxHQUFBLGVBQUEsRUFBUyxJQUFJLENBQUMsT0FBTyxPQUFPLENBQUEsRUFBRyxJQUFJLENBQUMsSUFBRyxLQUFBLENBQU8sRUFBRTtnQkFDM0QsU0FBUyxJQUFJLENBQUM7Z0JBQ2QsS0FBSztnQkFDTCxPQUFPLENBQUEsR0FBQSxvQkFBQTtZQUNSO1lBR0gsT0FBTyxNQUFNLElBQUksQ0FBQyxZQUFZLE9BQU87Z0IsSSxJLEk7Z0JBQ25DLE1BQU0sRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLEdBQUc7Z0JBQ3hCLElBQUksT0FDRixNQUFNO2dCQUdSLDhFQUE4RTtnQkFDOUUsSUFBSSxDQUFDLENBQUEsQUFBQSxDQUFBLEtBQUEsS0FBSyxPQUFBLE1BQU8sUUFBQSxPQUFBLEtBQUEsSUFBQSxLQUFBLElBQUEsR0FBRSxZQUFBLEtBQWdCLENBQUMsSUFBSSxDQUFDLDhCQUN2QyxPQUFPO29CQUFFLE1BQU07d0JBQUUsTUFBTTtvQkFBSTtvQkFBSSxPQUFPLElBQUksQ0FBQSxHQUFBLCtCQUFBO2dCQUF5QjtnQkFHckUsT0FBTyxNQUFNLENBQUEsR0FBQSxlQUFBLEVBQVMsSUFBSSxDQUFDLE9BQU8sT0FBTyxDQUFBLEVBQUcsSUFBSSxDQUFDLElBQUcsS0FBQSxDQUFPLEVBQUU7b0JBQzNELFNBQVMsSUFBSSxDQUFDO29CQUNkLEtBQUssQUFBQSxDQUFBLEtBQUEsQUFBQSxDQUFBLEtBQUEsS0FBSyxPQUFBLE1BQU8sUUFBQSxPQUFBLEtBQUEsSUFBQSxLQUFBLElBQUEsR0FBRSxZQUFBLE1BQVksUUFBQSxPQUFBLEtBQUEsSUFBQSxLQUFJO29CQUNuQyxPQUFPLENBQUEsR0FBQSxvQkFBQTtnQkFDUjtZQUNIO1FBQ0QsRUFBQyxPQUFPLE9BQU87WUFDZCxJQUFJLENBQUEsR0FBQSxtQkFBQSxFQUFZLFFBQ2QsT0FBTztnQkFBRSxNQUFNO29CQUFFLE1BQU07Z0JBQUk7Z0JBQUk7WUFBSztZQUd0QyxNQUFNO1FBQ1A7SUFDSDtJQUVBOztLQUVHLEdBQ0gsTUFBTSxXQUNKLFVBQTBCLEVBQzFCLFVBRUksQ0FBQSxDQUFFLEVBSlI7UUFNRSxNQUFNLElBQUksQ0FBQztRQUVYLE9BQU8sTUFBTSxJQUFJLENBQUMsYUFBYSxJQUFJO1lBQ2pDLE9BQU8sTUFBTSxJQUFJLENBQUMsWUFBWSxZQUFZO1FBQzVDO0lBQ0Y7SUFFVSxNQUFNLFlBQ2QsVUFBMEIsRUFDMUIsVUFFSSxDQUFBLENBQUUsRUFKRTtRQU1SLElBQUk7WUFDRixPQUFPLE1BQU0sSUFBSSxDQUFDLFlBQVksT0FBTztnQkFDbkMsTUFBTSxFQUFFLE1BQU0sV0FBVyxFQUFFLE9BQU8sWUFBWSxFQUFFLEdBQUc7Z0JBQ25ELElBQUksY0FDRixNQUFNO2dCQUVSLElBQUksQ0FBQyxZQUFZLFNBQ2YsTUFBTSxJQUFJLENBQUEsR0FBQSwrQkFBQTtnQkFFWixNQUFNLFVBQW1CLFlBQVk7Z0JBQ3JDLElBQUksZ0JBQStCO2dCQUNuQyxJQUFJLHNCQUFxQztnQkFDekMsSUFBSSxJQUFJLENBQUMsYUFBYSxVQUFVLFdBQVcsU0FBUyxNQUNqRCxDQUFDLGVBQWUsb0JBQW9CLEdBQUcsTUFBTSxDQUFBLEdBQUEsa0NBQUEsRUFDNUMsSUFBSSxDQUFDLFNBQ0wsSUFBSSxDQUFDO2dCQUlULE1BQU0sRUFBRSxJQUFJLEVBQUUsT0FBTyxTQUFTLEVBQUUsR0FBRyxNQUFNLENBQUEsR0FBQSxlQUFBLEVBQVMsSUFBSSxDQUFDLE9BQU8sT0FBTyxDQUFBLEVBQUcsSUFBSSxDQUFDLElBQUcsS0FBQSxDQUFPLEVBQUU7b0JBQ3ZGLFNBQVMsSUFBSSxDQUFDO29CQUNkLFlBQVksWUFBTyxRQUFQLFlBQU8sS0FBQSxJQUFBLEtBQUEsSUFBUCxRQUFTO29CQUNyQixNQUFJLE9BQUEsT0FBQSxPQUFBLE9BQUEsQ0FBQSxHQUNDLGFBQVU7d0JBQ2IsZ0JBQWdCO3dCQUNoQix1QkFBdUI7b0JBQW1CO29CQUU1QyxLQUFLLFFBQVE7b0JBQ2IsT0FBTyxDQUFBLEdBQUEsb0JBQUE7Z0JBQ1I7Z0JBQ0QsSUFBSSxXQUFXLE1BQU07Z0JBQ3JCLFFBQVEsT0FBTyxLQUFLO2dCQUNwQixNQUFNLElBQUksQ0FBQyxhQUFhO2dCQUN4QixNQUFNLElBQUksQ0FBQyxzQkFBc0IsZ0JBQWdCO2dCQUNqRCxPQUFPO29CQUFFLE1BQU07d0JBQUUsTUFBTSxRQUFRO29CQUFJO29CQUFJLE9BQU87Z0JBQUk7WUFDcEQ7UUFDRCxFQUFDLE9BQU8sT0FBTztZQUNkLElBQUksQ0FBQSxHQUFBLG1CQUFBLEVBQVksUUFDZCxPQUFPO2dCQUFFLE1BQU07b0JBQUUsTUFBTTtnQkFBSTtnQkFBSTtZQUFLO1lBR3RDLE1BQU07UUFDUDtJQUNIO0lBRUE7O0tBRUcsR0FDSyxXQUFXLEdBQVcsRUFBdEI7UUFLTixPQUFPLENBQUEsR0FBQSx5QkFBQSxFQUFpQjtJQUMxQjtJQUVBOzs7O0tBSUcsR0FDSCxNQUFNLFdBQVcsY0FHaEIsRUFIRDtRQUlFLE1BQU0sSUFBSSxDQUFDO1FBRVgsT0FBTyxNQUFNLElBQUksQ0FBQyxhQUFhLElBQUk7WUFDakMsT0FBTyxNQUFNLElBQUksQ0FBQyxZQUFZO1FBQ2hDO0lBQ0Y7SUFFVSxNQUFNLFlBQVksY0FHM0IsRUFIUztRQUlSLElBQUk7WUFDRixJQUFJLENBQUMsZUFBZSxnQkFBZ0IsQ0FBQyxlQUFlLGVBQ2xELE1BQU0sSUFBSSxDQUFBLEdBQUEsK0JBQUE7WUFHWixNQUFNLFVBQVUsS0FBSyxRQUFRO1lBQzdCLElBQUksWUFBWTtZQUNoQixJQUFJLGFBQWE7WUFDakIsSUFBSSxVQUEwQjtZQUM5QixNQUFNLFVBQVUsQ0FBQSxHQUFBLHlCQUFBLEVBQWlCLGVBQWU7WUFDaEQsSUFBSSxRQUFRLEtBQUs7Z0JBQ2YsWUFBWSxRQUFRO2dCQUNwQixhQUFhLGFBQWE7WUFDM0I7WUFFRCxJQUFJLFlBQVk7Z0JBQ2QsTUFBTSxFQUFFLFNBQVMsZ0JBQWdCLEVBQUUsS0FBSyxFQUFFLEdBQUcsTUFBTSxJQUFJLENBQUMsa0JBQ3RELGVBQWU7Z0JBRWpCLElBQUksT0FDRixPQUFPO29CQUFFLE1BQU07d0JBQUUsTUFBTTt3QkFBTSxTQUFTO29CQUFJO29CQUFJLE9BQU87Z0JBQUs7Z0JBRzVELElBQUksQ0FBQyxrQkFDSCxPQUFPO29CQUFFLE1BQU07d0JBQUUsTUFBTTt3QkFBTSxTQUFTO29CQUFJO29CQUFJLE9BQU87Z0JBQUk7Z0JBRTNELFVBQVU7WUFDWCxPQUFNO2dCQUNMLE1BQU0sRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLEdBQUcsTUFBTSxJQUFJLENBQUMsU0FBUyxlQUFlO2dCQUMzRCxJQUFJLE9BQ0YsTUFBTTtnQkFFUixVQUFVO29CQUNSLGNBQWMsZUFBZTtvQkFDN0IsZUFBZSxlQUFlO29CQUM5QixNQUFNLEtBQUs7b0JBQ1gsWUFBWTtvQkFDWixZQUFZLFlBQVk7b0JBQ3hCLFlBQVk7Z0JBQ2I7Z0JBQ0QsTUFBTSxJQUFJLENBQUMsYUFBYTtnQkFDeEIsTUFBTSxJQUFJLENBQUMsc0JBQXNCLGFBQWE7WUFDL0M7WUFFRCxPQUFPO2dCQUFFLE1BQU07b0JBQUUsTUFBTSxRQUFRO29CQUFNO2dCQUFPO2dCQUFJLE9BQU87WUFBSTtRQUM1RCxFQUFDLE9BQU8sT0FBTztZQUNkLElBQUksQ0FBQSxHQUFBLG1CQUFBLEVBQVksUUFDZCxPQUFPO2dCQUFFLE1BQU07b0JBQUUsU0FBUztvQkFBTSxNQUFNO2dCQUFJO2dCQUFJO1lBQUs7WUFHckQsTUFBTTtRQUNQO0lBQ0g7SUFFQTs7Ozs7S0FLRyxHQUNILE1BQU0sZUFBZSxjQUEwQyxFQUEvRDtRQUNFLE1BQU0sSUFBSSxDQUFDO1FBRVgsT0FBTyxNQUFNLElBQUksQ0FBQyxhQUFhLElBQUk7WUFDakMsT0FBTyxNQUFNLElBQUksQ0FBQyxnQkFBZ0I7UUFDcEM7SUFDRjtJQUVVLE1BQU0sZ0JBQWdCLGNBRS9CLEVBRlM7UUFHUixJQUFJO1lBQ0YsT0FBTyxNQUFNLElBQUksQ0FBQyxZQUFZLE9BQU87Z0IsSTtnQkFDbkMsSUFBSSxDQUFDLGdCQUFnQjtvQkFDbkIsTUFBTSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsR0FBRztvQkFDeEIsSUFBSSxPQUNGLE1BQU07b0JBR1IsaUJBQWlCLEFBQUEsQ0FBQSxLQUFBLEtBQUssT0FBQSxNQUFPLFFBQUEsT0FBQSxLQUFBLElBQUEsS0FBSTtnQkFDbEM7Z0JBRUQsSUFBSSxDQUFDLENBQUEsbUJBQWMsUUFBZCxtQkFBYyxLQUFBLElBQUEsS0FBQSxJQUFkLGVBQWdCLGFBQUEsR0FDbkIsTUFBTSxJQUFJLENBQUEsR0FBQSwrQkFBQTtnQkFHWixNQUFNLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxHQUFHLE1BQU0sSUFBSSxDQUFDLGtCQUFrQixlQUFlO2dCQUN2RSxJQUFJLE9BQ0YsT0FBTztvQkFBRSxNQUFNO3dCQUFFLE1BQU07d0JBQU0sU0FBUztvQkFBSTtvQkFBSSxPQUFPO2dCQUFLO2dCQUc1RCxJQUFJLENBQUMsU0FDSCxPQUFPO29CQUFFLE1BQU07d0JBQUUsTUFBTTt3QkFBTSxTQUFTO29CQUFJO29CQUFJLE9BQU87Z0JBQUk7Z0JBRzNELE9BQU87b0JBQUUsTUFBTTt3QkFBRSxNQUFNLFFBQVE7d0JBQU07b0JBQU87b0JBQUksT0FBTztnQkFBSTtZQUM3RDtRQUNELEVBQUMsT0FBTyxPQUFPO1lBQ2QsSUFBSSxDQUFBLEdBQUEsbUJBQUEsRUFBWSxRQUNkLE9BQU87Z0JBQUUsTUFBTTtvQkFBRSxNQUFNO29CQUFNLFNBQVM7Z0JBQUk7Z0JBQUk7WUFBSztZQUdyRCxNQUFNO1FBQ1A7SUFDSDtJQUVBOztLQUVHLEdBQ0ssTUFBTSxtQkFBbUIsVUFBbUIsRUFBNUM7UUFPTixJQUFJO1lBQ0YsSUFBSSxDQUFDLENBQUEsR0FBQSxrQkFBQSxLQUFhLE1BQU0sSUFBSSxDQUFBLEdBQUEsc0NBQUEsRUFBK0I7WUFDM0QsSUFBSSxJQUFJLENBQUMsYUFBYSxjQUFjLENBQUMsSUFBSSxDQUFDLHdCQUN4QyxNQUFNLElBQUksQ0FBQSxHQUFBLHNDQUFBLEVBQStCO2lCQUNwQyxJQUFJLElBQUksQ0FBQyxZQUFZLFVBQVUsQ0FBQyxZQUNyQyxNQUFNLElBQUksQ0FBQSxHQUFBLHNDQUFBLEVBQStCO1lBRzNDLE1BQU0sU0FBUyxDQUFBLEdBQUEsK0JBQUEsRUFBdUIsT0FBTyxTQUFTO1lBRXRELElBQUksWUFBWTtnQkFDZCxJQUFJLENBQUMsT0FBTyxNQUFNLE1BQU0sSUFBSSxDQUFBLEdBQUEsc0NBQUEsRUFBK0I7Z0JBQzNELE1BQU0sRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLEdBQUcsTUFBTSxJQUFJLENBQUMsd0JBQXdCLE9BQU87Z0JBQ2xFLElBQUksT0FBTyxNQUFNO2dCQUVqQixNQUFNLE1BQU0sSUFBSSxJQUFJLE9BQU8sU0FBUztnQkFDcEMsSUFBSSxhQUFhLE9BQU87Z0JBRXhCLE9BQU8sUUFBUSxhQUFhLE9BQU8sUUFBUSxPQUFPLElBQUksSUFBSTtnQkFFMUQsT0FBTztvQkFBRSxNQUFNO3dCQUFFLFNBQVMsS0FBSzt3QkFBUyxjQUFjO29CQUFJO29CQUFJLE9BQU87Z0JBQUk7WUFDMUU7WUFFRCxJQUFJLE9BQU8sU0FBUyxPQUFPLHFCQUFxQixPQUFPLFlBQ3JELE1BQU0sSUFBSSxDQUFBLEdBQUEsc0NBQUEsRUFDUixPQUFPLHFCQUFxQixtREFDNUI7Z0JBQ0UsT0FBTyxPQUFPLFNBQVM7Z0JBQ3ZCLE1BQU0sT0FBTyxjQUFjO1lBQzVCO1lBSUwsTUFBTSxFQUNKLGNBQWMsRUFDZCxzQkFBc0IsRUFDdEIsWUFBWSxFQUNaLGFBQWEsRUFDYixVQUFVLEVBQ1YsVUFBVSxFQUNWLFVBQVUsRUFDWCxHQUFHO1lBRUosSUFBSSxDQUFDLGdCQUFnQixDQUFDLGNBQWMsQ0FBQyxpQkFBaUIsQ0FBQyxZQUNyRCxNQUFNLElBQUksQ0FBQSxHQUFBLHNDQUFBLEVBQStCO1lBRzNDLE1BQU0sVUFBVSxLQUFLLE1BQU0sS0FBSyxRQUFRO1lBQ3hDLE1BQU0sWUFBWSxTQUFTO1lBQzNCLElBQUksWUFBWSxVQUFVO1lBRTFCLElBQUksWUFDRixZQUFZLFNBQVM7WUFHdkIsTUFBTSxvQkFBb0IsWUFBWTtZQUN0QyxJQUFJLG9CQUFvQixRQUFRLDRCQUM5QixRQUFRLEtBQ04sQ0FBQSw4REFBQSxFQUFpRSxrQkFBaUIsOEJBQUEsRUFBaUMsVUFBUyxDQUFBLENBQUc7WUFJbkksTUFBTSxXQUFXLFlBQVk7WUFDN0IsSUFBSSxVQUFVLFlBQVksS0FDeEIsUUFBUSxLQUNOLG1HQUNBLFVBQ0EsV0FDQTtpQkFFRyxJQUFJLFVBQVUsV0FBVyxHQUM5QixRQUFRLEtBQ04sK0dBQ0EsVUFDQSxXQUNBO1lBSUosTUFBTSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsR0FBRyxNQUFNLElBQUksQ0FBQyxTQUFTO1lBQzVDLElBQUksT0FBTyxNQUFNO1lBRWpCLE1BQU0sVUFBbUI7Z0JBQ3ZCO2dCQUNBO2dCQUNBO2dCQUNBLFlBQVk7Z0JBQ1osWUFBWTtnQkFDWjtnQkFDQTtnQkFDQSxNQUFNLEtBQUs7WUFDWjtZQUVELHlCQUF5QjtZQUN6QixPQUFPLFNBQVMsT0FBTztZQUN2QixJQUFJLENBQUMsT0FBTyx5QkFBeUI7WUFFckMsT0FBTztnQkFBRSxNQUFNO29CQUFFO29CQUFTLGNBQWMsT0FBTztnQkFBSTtnQkFBSSxPQUFPO1lBQUk7UUFDbkUsRUFBQyxPQUFPLE9BQU87WUFDZCxJQUFJLENBQUEsR0FBQSxtQkFBQSxFQUFZLFFBQ2QsT0FBTztnQkFBRSxNQUFNO29CQUFFLFNBQVM7b0JBQU0sY0FBYztnQkFBSTtnQkFBSTtZQUFLO1lBRzdELE1BQU07UUFDUDtJQUNIO0lBRUE7O0tBRUcsR0FDSyx1QkFBQTtRQUNOLE1BQU0sU0FBUyxDQUFBLEdBQUEsK0JBQUEsRUFBdUIsT0FBTyxTQUFTO1FBRXRELE9BQU8sQ0FBQyxDQUFFLENBQUEsQ0FBQSxHQUFBLGtCQUFBLE9BQWdCLENBQUEsT0FBTyxnQkFBZ0IsT0FBTyxpQkFBQSxDQUFpQjtJQUMzRTtJQUVBOztLQUVHLEdBQ0ssTUFBTSxjQUFOO1FBQ04sTUFBTSxTQUFTLENBQUEsR0FBQSwrQkFBQSxFQUF1QixPQUFPLFNBQVM7UUFFdEQsTUFBTSx3QkFBd0IsTUFBTSxDQUFBLEdBQUEscUJBQUEsRUFDbEMsSUFBSSxDQUFDLFNBQ0wsQ0FBQSxFQUFHLElBQUksQ0FBQyxXQUFVLGNBQUEsQ0FBZ0I7UUFHcEMsT0FBTyxDQUFDLENBQUUsQ0FBQSxPQUFPLFFBQVEscUJBQUE7SUFDM0I7SUFFQTs7Ozs7OztLQU9HLEdBQ0gsTUFBTSxRQUFRLFVBQW1CO1FBQUUsT0FBTztJQUFRLENBQUUsRUFBcEQ7UUFDRSxNQUFNLElBQUksQ0FBQztRQUVYLE9BQU8sTUFBTSxJQUFJLENBQUMsYUFBYSxJQUFJO1lBQ2pDLE9BQU8sTUFBTSxJQUFJLENBQUMsU0FBUztRQUM3QjtJQUNGO0lBRVUsTUFBTSxTQUNkLEVBQUUsS0FBSyxFQUFBLEdBQWM7UUFBRSxPQUFPO0lBQVEsQ0FBRSxFQURoQztRQUdSLE9BQU8sTUFBTSxJQUFJLENBQUMsWUFBWSxPQUFPO1ksSTtZQUNuQyxNQUFNLEVBQUUsSUFBSSxFQUFFLE9BQU8sWUFBWSxFQUFFLEdBQUc7WUFDdEMsSUFBSSxjQUNGLE9BQU87Z0JBQUUsT0FBTztZQUFZO1lBRTlCLE1BQU0sY0FBYyxBQUFBLENBQUEsS0FBQSxLQUFLLE9BQUEsTUFBTyxRQUFBLE9BQUEsS0FBQSxJQUFBLEtBQUEsSUFBQSxHQUFFO1lBQ2xDLElBQUksYUFBYTtnQkFDZixNQUFNLEVBQUUsS0FBSyxFQUFFLEdBQUcsTUFBTSxJQUFJLENBQUMsTUFBTSxRQUFRLGFBQWE7Z0JBQ3hELElBQUksT0FBTztvQkFDVCxpREFBaUQ7b0JBQ2pELGtGQUFrRjtvQkFDbEYsSUFDRSxDQUNFLENBQUEsQ0FBQSxHQUFBLHNCQUFBLEVBQWUsVUFDZCxDQUFBLE1BQU0sV0FBVyxPQUFPLE1BQU0sV0FBVyxPQUFPLE1BQU0sV0FBVyxHQUFBLENBQUcsR0FHdkUsT0FBTzt3QkFBRTtvQkFBSztnQkFFakI7WUFDRjtZQUNELElBQUksVUFBVSxVQUFVO2dCQUN0QixNQUFNLElBQUksQ0FBQztnQkFDWCxNQUFNLENBQUEsR0FBQSx3QkFBQSxFQUFnQixJQUFJLENBQUMsU0FBUyxDQUFBLEVBQUcsSUFBSSxDQUFDLFdBQVUsY0FBQSxDQUFnQjtnQkFDdEUsTUFBTSxJQUFJLENBQUMsc0JBQXNCLGNBQWM7WUFDaEQ7WUFDRCxPQUFPO2dCQUFFLE9BQU87WUFBSTtRQUN0QjtJQUNGO0lBRUE7OztLQUdHLEdBQ0gsa0JBQ0UsUUFBbUYsRUFEckY7UUFLRSxNQUFNLEtBQWEsQ0FBQSxHQUFBLGFBQUE7UUFDbkIsTUFBTSxlQUE2QjtZQUNqQztZQUNBO1lBQ0EsYUFBYTtnQkFDWCxJQUFJLENBQUMsT0FBTyxrQkFBa0IseUNBQXlDO2dCQUV2RSxJQUFJLENBQUMsb0JBQW9CLE9BQU87WUFDbEM7UUFDRDtRQUVELElBQUksQ0FBQyxPQUFPLHdCQUF3QiwrQkFBK0I7UUFFbkUsSUFBSSxDQUFDLG9CQUFvQixJQUFJLElBQUk7UUFDL0IsQ0FBQTtZQUNBLE1BQU0sSUFBSSxDQUFDO1lBRVgsTUFBTSxJQUFJLENBQUMsYUFBYSxJQUFJO2dCQUMxQixJQUFJLENBQUMsb0JBQW9CO1lBQzNCO1FBQ0YsQ0FBQTtRQUVBLE9BQU87WUFBRSxNQUFNO2dCQUFFO1lBQVk7UUFBRTtJQUNqQztJQUVRLE1BQU0sb0JBQW9CLEVBQVUsRUFBcEM7UUFDTixPQUFPLE1BQU0sSUFBSSxDQUFDLFlBQVksT0FBTztZLEksSTtZQUNuQyxJQUFJO2dCQUNGLE1BQU0sRUFDSixNQUFNLEVBQUUsT0FBTyxFQUFFLEVBQ2pCLEtBQUssRUFDTixHQUFHO2dCQUNKLElBQUksT0FBTyxNQUFNO2dCQUVqQixNQUFNLENBQUEsQUFBQSxDQUFBLEtBQUEsSUFBSSxDQUFDLG9CQUFvQixJQUFJLEdBQUUsTUFBQyxRQUFBLE9BQUEsS0FBQSxJQUFBLEtBQUEsSUFBQSxHQUFFLFNBQVMsbUJBQW1CLFFBQU87Z0JBQzNFLElBQUksQ0FBQyxPQUFPLG1CQUFtQixlQUFlLElBQUksV0FBVztZQUM5RCxFQUFDLE9BQU8sS0FBSztnQkFDWixNQUFNLENBQUEsQUFBQSxDQUFBLEtBQUEsSUFBSSxDQUFDLG9CQUFvQixJQUFJLEdBQUUsTUFBQyxRQUFBLE9BQUEsS0FBQSxJQUFBLEtBQUEsSUFBQSxHQUFFLFNBQVMsbUJBQW1CLEtBQUk7Z0JBQ3hFLElBQUksQ0FBQyxPQUFPLG1CQUFtQixlQUFlLElBQUksU0FBUztnQkFDM0QsUUFBUSxNQUFNO1lBQ2Y7UUFDSDtJQUNGO0lBRUE7Ozs7OztLQU1HLEdBQ0gsTUFBTSxzQkFDSixLQUFhLEVBQ2IsVUFHSSxDQUFBLENBQUUsRUFMUjtRQWFFLElBQUksZ0JBQStCO1FBQ25DLElBQUksc0JBQXFDO1FBRXpDLElBQUksSUFBSSxDQUFDLGFBQWEsUUFDbkIsQ0FBQyxlQUFlLG9CQUFvQixHQUFHLE1BQU0sQ0FBQSxHQUFBLGtDQUFBLEVBQzVDLElBQUksQ0FBQyxTQUNMLElBQUksQ0FBQyxZQUNMLEtBQUsscUJBQXFCOztRQUc5QixJQUFJO1lBQ0YsT0FBTyxNQUFNLENBQUEsR0FBQSxlQUFBLEVBQVMsSUFBSSxDQUFDLE9BQU8sUUFBUSxDQUFBLEVBQUcsSUFBSSxDQUFDLElBQUcsUUFBQSxDQUFVLEVBQUU7Z0JBQy9ELE1BQU07b0JBQ0o7b0JBQ0EsZ0JBQWdCO29CQUNoQix1QkFBdUI7b0JBQ3ZCLHNCQUFzQjt3QkFBRSxlQUFlLFFBQVE7b0JBQVk7Z0JBQzVEO2dCQUNELFNBQVMsSUFBSSxDQUFDO2dCQUNkLFlBQVksUUFBUTtZQUNyQjtRQUNGLEVBQUMsT0FBTyxPQUFPO1lBQ2QsSUFBSSxDQUFBLEdBQUEsbUJBQUEsRUFBWSxRQUNkLE9BQU87Z0JBQUUsTUFBTTtnQkFBTTtZQUFLO1lBRzVCLE1BQU07UUFDUDtJQUNIO0lBRUE7O0tBRUcsR0FDSCxNQUFNLG9CQUFOO1EsSTtRQVNFLElBQUk7WUFDRixNQUFNLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxHQUFHLE1BQU0sSUFBSSxDQUFDO1lBQ25DLElBQUksT0FBTyxNQUFNO1lBQ2pCLE9BQU87Z0JBQUUsTUFBTTtvQkFBRSxZQUFZLEFBQUEsQ0FBQSxLQUFBLEtBQUssS0FBSyxVQUFBLE1BQVUsUUFBQSxPQUFBLEtBQUEsSUFBQSxLQUFJLEVBQUU7Z0JBQUE7Z0JBQUksT0FBTztZQUFJO1FBQ3ZFLEVBQUMsT0FBTyxPQUFPO1lBQ2QsSUFBSSxDQUFBLEdBQUEsbUJBQUEsRUFBWSxRQUNkLE9BQU87Z0JBQUUsTUFBTTtnQkFBTTtZQUFLO1lBRTVCLE1BQU07UUFDUDtJQUNIO0lBQ0E7OztLQUdHLEdBQ0gsTUFBTSxhQUFhLFdBQXVDLEVBQTFEO1EsSTtRQUNFLElBQUk7WUFDRixNQUFNLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxHQUFHLE1BQU0sSUFBSSxDQUFDLFlBQVksT0FBTztnQixJLEksSSxJLEk7Z0JBQ3BELE1BQU0sRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLEdBQUc7Z0JBQ3hCLElBQUksT0FBTyxNQUFNO2dCQUNqQixNQUFNLE1BQWMsTUFBTSxJQUFJLENBQUMsbUJBQzdCLENBQUEsRUFBRyxJQUFJLENBQUMsSUFBRywwQkFBQSxDQUE0QixFQUN2QyxZQUFZLFVBQ1o7b0JBQ0UsWUFBWSxBQUFBLENBQUEsS0FBQSxZQUFZLE9BQUEsTUFBTyxRQUFBLE9BQUEsS0FBQSxJQUFBLEtBQUEsSUFBQSxHQUFFO29CQUNqQyxRQUFRLEFBQUEsQ0FBQSxLQUFBLFlBQVksT0FBQSxNQUFPLFFBQUEsT0FBQSxLQUFBLElBQUEsS0FBQSxJQUFBLEdBQUU7b0JBQzdCLGFBQWEsQUFBQSxDQUFBLEtBQUEsWUFBWSxPQUFBLE1BQU8sUUFBQSxPQUFBLEtBQUEsSUFBQSxLQUFBLElBQUEsR0FBRTtvQkFDbEMscUJBQXFCO2dCQUN0QjtnQkFFSCxPQUFPLE1BQU0sQ0FBQSxHQUFBLGVBQUEsRUFBUyxJQUFJLENBQUMsT0FBTyxPQUFPLEtBQUs7b0JBQzVDLFNBQVMsSUFBSSxDQUFDO29CQUNkLEtBQUssQUFBQSxDQUFBLEtBQUEsQUFBQSxDQUFBLEtBQUEsS0FBSyxPQUFBLE1BQU8sUUFBQSxPQUFBLEtBQUEsSUFBQSxLQUFBLElBQUEsR0FBRSxZQUFBLE1BQVksUUFBQSxPQUFBLEtBQUEsSUFBQSxLQUFJO2dCQUNwQztZQUNIO1lBQ0EsSUFBSSxPQUFPLE1BQU07WUFDakIsSUFBSSxDQUFBLEdBQUEsa0JBQUEsT0FBZSxDQUFDLENBQUEsQUFBQSxDQUFBLEtBQUEsWUFBWSxPQUFBLE1BQU8sUUFBQSxPQUFBLEtBQUEsSUFBQSxLQUFBLElBQUEsR0FBRSxtQkFBQSxHQUN2QyxPQUFPLFNBQVMsT0FBTyxTQUFJLFFBQUosU0FBSSxLQUFBLElBQUEsS0FBQSxJQUFKLEtBQU07WUFFL0IsT0FBTztnQkFBRSxNQUFNO29CQUFFLFVBQVUsWUFBWTtvQkFBVSxLQUFLLFNBQUksUUFBSixTQUFJLEtBQUEsSUFBQSxLQUFBLElBQUosS0FBTTtnQkFBRztnQkFBSSxPQUFPO1lBQUk7UUFDL0UsRUFBQyxPQUFPLE9BQU87WUFDZCxJQUFJLENBQUEsR0FBQSxtQkFBQSxFQUFZLFFBQ2QsT0FBTztnQkFBRSxNQUFNO29CQUFFLFVBQVUsWUFBWTtvQkFBVSxLQUFLO2dCQUFJO2dCQUFJO1lBQUs7WUFFckUsTUFBTTtRQUNQO0lBQ0g7SUFFQTs7S0FFRyxHQUNILE1BQU0sZUFBZSxRQUFzQixFQUEzQztRQU9FLElBQUk7WUFDRixPQUFPLE1BQU0sSUFBSSxDQUFDLFlBQVksT0FBTztnQixJLEk7Z0JBQ25DLE1BQU0sRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLEdBQUc7Z0JBQ3hCLElBQUksT0FDRixNQUFNO2dCQUVSLE9BQU8sTUFBTSxDQUFBLEdBQUEsZUFBQSxFQUNYLElBQUksQ0FBQyxPQUNMLFVBQ0EsQ0FBQSxFQUFHLElBQUksQ0FBQyxJQUFHLGlCQUFBLEVBQW9CLFNBQVMsWUFBVyxDQUFFLEVBQ3JEO29CQUNFLFNBQVMsSUFBSSxDQUFDO29CQUNkLEtBQUssQUFBQSxDQUFBLEtBQUEsQUFBQSxDQUFBLEtBQUEsS0FBSyxPQUFBLE1BQU8sUUFBQSxPQUFBLEtBQUEsSUFBQSxLQUFBLElBQUEsR0FBRSxZQUFBLE1BQVksUUFBQSxPQUFBLEtBQUEsSUFBQSxLQUFJO2dCQUNwQztZQUVMO1FBQ0QsRUFBQyxPQUFPLE9BQU87WUFDZCxJQUFJLENBQUEsR0FBQSxtQkFBQSxFQUFZLFFBQ2QsT0FBTztnQkFBRSxNQUFNO2dCQUFNO1lBQUs7WUFFNUIsTUFBTTtRQUNQO0lBQ0g7SUFFQTs7O0tBR0csR0FDSyxNQUFNLG9CQUFvQixZQUFvQixFQUE5QztRQUNOLE1BQU0sWUFBWSxDQUFBLHFCQUFBLEVBQXdCLGFBQWEsVUFBVSxHQUFHLEdBQUUsSUFBQSxDQUFNO1FBQzVFLElBQUksQ0FBQyxPQUFPLFdBQVc7UUFFdkIsSUFBSTtZQUNGLE1BQU0sWUFBWSxLQUFLO1lBRXZCLDZEQUE2RDtZQUM3RCxPQUFPLE1BQU0sQ0FBQSxHQUFBLGtCQUFBLEVBQ1gsT0FBTztnQkFDTCxJQUFJLFVBQVUsR0FDWixNQUFNLENBQUEsR0FBQSxjQUFBLEVBQU0sTUFBTSxLQUFLLElBQUksR0FBRyxVQUFVLEtBQUkscUJBQXFCO2dCQUduRSxJQUFJLENBQUMsT0FBTyxXQUFXLHNCQUFzQjtnQkFFN0MsT0FBTyxNQUFNLENBQUEsR0FBQSxlQUFBLEVBQVMsSUFBSSxDQUFDLE9BQU8sUUFBUSxDQUFBLEVBQUcsSUFBSSxDQUFDLElBQUcsK0JBQUEsQ0FBaUMsRUFBRTtvQkFDdEYsTUFBTTt3QkFBRSxlQUFlO29CQUFZO29CQUNuQyxTQUFTLElBQUksQ0FBQztvQkFDZCxPQUFPLENBQUEsR0FBQSx1QkFBQTtnQkFDUjtZQUNILEdBQ0EsQ0FBQyxTQUFTO2dCQUNSLE1BQU0sc0JBQXNCLE1BQU0sS0FBSyxJQUFJLEdBQUc7Z0JBQzlDLE9BQ0UsU0FDQSxDQUFBLEdBQUEsaUNBQUEsRUFBMEIsVUFDMUIsMkZBQTJGO2dCQUMzRixLQUFLLFFBQVEsc0JBQXNCLFlBQVk7WUFFbkQ7UUFFSCxFQUFDLE9BQU8sT0FBTztZQUNkLElBQUksQ0FBQyxPQUFPLFdBQVcsU0FBUztZQUVoQyxJQUFJLENBQUEsR0FBQSxtQkFBQSxFQUFZLFFBQ2QsT0FBTztnQkFBRSxNQUFNO29CQUFFLFNBQVM7b0JBQU0sTUFBTTtnQkFBSTtnQkFBSTtZQUFLO1lBRXJELE1BQU07UUFDUCxTQUFTO1lBQ1IsSUFBSSxDQUFDLE9BQU8sV0FBVztRQUN4QjtJQUNIO0lBRVEsZ0JBQWdCLFlBQXFCLEVBQXJDO1FBQ04sTUFBTSxpQkFDSixPQUFPLGlCQUFpQixZQUN4QixpQkFBaUIsUUFDakIsa0JBQWtCLGdCQUNsQixtQkFBbUIsZ0JBQ25CLGdCQUFnQjtRQUVsQixPQUFPO0lBQ1Q7SUFFUSxNQUFNLHNCQUNaLFFBQWtCLEVBQ2xCLE9BS0MsRUFQSztRQVNOLE1BQU0sTUFBYyxNQUFNLElBQUksQ0FBQyxtQkFBbUIsQ0FBQSxFQUFHLElBQUksQ0FBQyxJQUFHLFVBQUEsQ0FBWSxFQUFFLFVBQVU7WUFDbkYsWUFBWSxRQUFRO1lBQ3BCLFFBQVEsUUFBUTtZQUNoQixhQUFhLFFBQVE7UUFDdEI7UUFFRCxJQUFJLENBQUMsT0FBTyw0QkFBNEIsWUFBWSxVQUFVLFdBQVcsU0FBUyxPQUFPO1FBRXpGLDZCQUE2QjtRQUM3QixJQUFJLENBQUEsR0FBQSxrQkFBQSxPQUFlLENBQUMsUUFBUSxxQkFDMUIsT0FBTyxTQUFTLE9BQU87UUFHekIsT0FBTztZQUFFLE1BQU07Z0JBQUU7Z0JBQVU7WUFBRztZQUFJLE9BQU87UUFBSTtJQUMvQztJQUVBOzs7S0FHRyxHQUNLLE1BQU0scUJBQU47USxJO1FBQ04sTUFBTSxZQUFZO1FBQ2xCLElBQUksQ0FBQyxPQUFPLFdBQVc7UUFFdkIsSUFBSTtZQUNGLE1BQU0saUJBQWlCLE1BQU0sQ0FBQSxHQUFBLHFCQUFBLEVBQWEsSUFBSSxDQUFDLFNBQVMsSUFBSSxDQUFDO1lBQzdELElBQUksQ0FBQyxPQUFPLFdBQVcsd0JBQXdCO1lBRS9DLElBQUksQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLGlCQUFpQjtnQkFDekMsSUFBSSxDQUFDLE9BQU8sV0FBVztnQkFDdkIsSUFBSSxtQkFBbUIsTUFDckIsTUFBTSxJQUFJLENBQUM7Z0JBR2I7WUFDRDtZQUVELE1BQU0sVUFBVSxLQUFLLE1BQU0sS0FBSyxRQUFRO1lBQ3hDLE1BQU0sb0JBQW9CLEFBQUMsQ0FBQSxBQUFBLENBQUEsS0FBQSxlQUFlLFVBQUEsTUFBVSxRQUFBLE9BQUEsS0FBQSxJQUFBLEtBQUksUUFBQSxJQUFZLFVBQVUsQ0FBQSxHQUFBLHdCQUFBO1lBRTlFLElBQUksQ0FBQyxPQUNILFdBQ0EsQ0FBQSxXQUFBLEVBQWMsb0JBQW9CLEtBQUssT0FBTSx3QkFBQSxFQUEyQixDQUFBLEdBQUEsd0JBQUEsRUFBYSxDQUFBLENBQUc7WUFHMUYsSUFBSSxtQkFDRjtnQkFBQSxJQUFJLElBQUksQ0FBQyxvQkFBb0IsZUFBZSxlQUFlO29CQUN6RCxNQUFNLEVBQUUsS0FBSyxFQUFFLEdBQUcsTUFBTSxJQUFJLENBQUMsa0JBQWtCLGVBQWU7b0JBRTlELElBQUksT0FBTzt3QkFDVCxRQUFRLE1BQU07d0JBRWQsSUFBSSxDQUFDLENBQUEsR0FBQSxpQ0FBQSxFQUEwQixRQUFROzRCQUNyQyxJQUFJLENBQUMsT0FDSCxXQUNBLG1FQUNBOzRCQUVGLE1BQU0sSUFBSSxDQUFDO3dCQUNaO29CQUNGO2dCQUNGO1lBQUEsT0FFRCxxRUFBcUU7WUFDckUsb0VBQW9FO1lBQ3BFLHVEQUF1RDtZQUN2RCxNQUFNLElBQUksQ0FBQyxzQkFBc0IsYUFBYTtRQUVqRCxFQUFDLE9BQU8sS0FBSztZQUNaLElBQUksQ0FBQyxPQUFPLFdBQVcsU0FBUztZQUVoQyxRQUFRLE1BQU07WUFDZDtRQUNELFNBQVM7WUFDUixJQUFJLENBQUMsT0FBTyxXQUFXO1FBQ3hCO0lBQ0g7SUFFUSxNQUFNLGtCQUFrQixZQUFvQixFQUE1QztRLEksSTtRQUNOLElBQUksQ0FBQyxjQUNILE1BQU0sSUFBSSxDQUFBLEdBQUEsK0JBQUE7UUFHWixvQ0FBb0M7UUFDcEMsSUFBSSxJQUFJLENBQUMsb0JBQ1AsT0FBTyxJQUFJLENBQUMsbUJBQW1CO1FBR2pDLE1BQU0sWUFBWSxDQUFBLG1CQUFBLEVBQXNCLGFBQWEsVUFBVSxHQUFHLEdBQUUsSUFBQSxDQUFNO1FBRTFFLElBQUksQ0FBQyxPQUFPLFdBQVc7UUFFdkIsSUFBSTtZQUNGLElBQUksQ0FBQyxxQkFBcUIsSUFBSSxDQUFBLEdBQUEsaUJBQUE7WUFFOUIsTUFBTSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsR0FBRyxNQUFNLElBQUksQ0FBQyxvQkFBb0I7WUFDdkQsSUFBSSxPQUFPLE1BQU07WUFDakIsSUFBSSxDQUFDLEtBQUssU0FBUyxNQUFNLElBQUksQ0FBQSxHQUFBLCtCQUFBO1lBRTdCLE1BQU0sSUFBSSxDQUFDLGFBQWEsS0FBSztZQUM3QixNQUFNLElBQUksQ0FBQyxzQkFBc0IsbUJBQW1CLEtBQUs7WUFFekQsTUFBTSxTQUFTO2dCQUFFLFNBQVMsS0FBSztnQkFBUyxPQUFPO1lBQUk7WUFFbkQsSUFBSSxDQUFDLG1CQUFtQixRQUFRO1lBRWhDLE9BQU87UUFDUixFQUFDLE9BQU8sT0FBTztZQUNkLElBQUksQ0FBQyxPQUFPLFdBQVcsU0FBUztZQUVoQyxJQUFJLENBQUEsR0FBQSxtQkFBQSxFQUFZLFFBQVE7Z0JBQ3RCLE1BQU0sU0FBUztvQkFBRSxTQUFTO29CQUFNO2dCQUFLO2dCQUVyQyxJQUFJLENBQUMsQ0FBQSxHQUFBLGlDQUFBLEVBQTBCLFFBQVE7b0JBQ3JDLE1BQU0sSUFBSSxDQUFDO29CQUNYLE1BQU0sSUFBSSxDQUFDLHNCQUFzQixjQUFjO2dCQUNoRDtnQkFFRCxDQUFBLEtBQUEsSUFBSSxDQUFDLGtCQUFBLE1BQWtCLFFBQUEsT0FBQSxLQUFBLEtBQUEsR0FBRSxRQUFRO2dCQUVqQyxPQUFPO1lBQ1I7WUFFRCxDQUFBLEtBQUEsSUFBSSxDQUFDLGtCQUFBLE1BQWtCLFFBQUEsT0FBQSxLQUFBLEtBQUEsR0FBRSxPQUFPO1lBQ2hDLE1BQU07UUFDUCxTQUFTO1lBQ1IsSUFBSSxDQUFDLHFCQUFxQjtZQUMxQixJQUFJLENBQUMsT0FBTyxXQUFXO1FBQ3hCO0lBQ0g7SUFFUSxNQUFNLHNCQUNaLEtBQXNCLEVBQ3RCLE9BQXVCLEVBQ3ZCLFlBQVksSUFBSSxFQUhWO1FBS04sTUFBTSxZQUFZLENBQUEsdUJBQUEsRUFBMEIsTUFBSyxDQUFBLENBQUc7UUFDcEQsSUFBSSxDQUFDLE9BQU8sV0FBVyxTQUFTLFNBQVMsQ0FBQSxZQUFBLEVBQWUsVUFBUyxDQUFFO1FBRW5FLElBQUk7WUFDRixJQUFJLElBQUksQ0FBQyxvQkFBb0IsV0FDM0IsSUFBSSxDQUFDLGlCQUFpQixZQUFZO2dCQUFFO2dCQUFPO1lBQU87WUFHcEQsTUFBTSxTQUFnQixFQUFFO1lBQ3hCLE1BQU0sV0FBVyxNQUFNLEtBQUssSUFBSSxDQUFDLG9CQUFvQixVQUFVLElBQUksT0FBTztnQkFDeEUsSUFBSTtvQkFDRixNQUFNLEVBQUUsU0FBUyxPQUFPO2dCQUN6QixFQUFDLE9BQU8sR0FBUTtvQkFDZixPQUFPLEtBQUs7Z0JBQ2I7WUFDSDtZQUVBLE1BQU0sUUFBUSxJQUFJO1lBRWxCLElBQUksT0FBTyxTQUFTLEdBQUc7Z0JBQ3JCLElBQUssSUFBSSxJQUFJLEdBQUcsSUFBSSxPQUFPLFFBQVEsS0FBSyxFQUN0QyxRQUFRLE1BQU0sTUFBTSxDQUFDLEVBQUU7Z0JBR3pCLE1BQU0sTUFBTSxDQUFDLEVBQUU7WUFDaEI7UUFDRixTQUFTO1lBQ1IsSUFBSSxDQUFDLE9BQU8sV0FBVztRQUN4QjtJQUNIO0lBRUE7OztLQUdHLEdBQ0ssTUFBTSxhQUFhLE9BQWdCLEVBQW5DO1FBQ04sSUFBSSxDQUFDLE9BQU8sbUJBQW1CO1FBQy9CLHlFQUF5RTtRQUN6RSw0RUFBNEU7UUFDNUUsSUFBSSxDQUFDLDRCQUE0QjtRQUNqQyxNQUFNLENBQUEsR0FBQSxxQkFBQSxFQUFhLElBQUksQ0FBQyxTQUFTLElBQUksQ0FBQyxZQUFZO0lBQ3BEO0lBRVEsTUFBTSxpQkFBTjtRQUNOLElBQUksQ0FBQyxPQUFPO1FBRVosTUFBTSxDQUFBLEdBQUEsd0JBQUEsRUFBZ0IsSUFBSSxDQUFDLFNBQVMsSUFBSSxDQUFDO0lBQzNDO0lBRUE7Ozs7O0tBS0csR0FDSyxtQ0FBQTtRQUNOLElBQUksQ0FBQyxPQUFPO1FBRVosTUFBTSxXQUFXLElBQUksQ0FBQztRQUN0QixJQUFJLENBQUMsNEJBQTRCO1FBRWpDLElBQUk7WUFDRixJQUFJLFlBQVksQ0FBQSxHQUFBLGtCQUFBLE9BQWUsQ0FBQSxXQUFNLFFBQU4sV0FBTSxLQUFBLElBQUEsS0FBQSxJQUFOLE9BQVEsbUJBQUEsR0FDckMsT0FBTyxvQkFBb0Isb0JBQW9CO1FBRWxELEVBQUMsT0FBTyxHQUFHO1lBQ1YsUUFBUSxNQUFNLDZDQUE2QztRQUM1RDtJQUNIO0lBRUE7OztLQUdHLEdBQ0ssTUFBTSxvQkFBTjtRQUNOLE1BQU0sSUFBSSxDQUFDO1FBRVgsSUFBSSxDQUFDLE9BQU87UUFFWixNQUFNLFNBQVMsWUFBWSxJQUFNLElBQUksQ0FBQyx5QkFBeUI7UUFDL0QsSUFBSSxDQUFDLG9CQUFvQjtRQUV6QixJQUFJLFVBQVUsT0FBTyxXQUFXLFlBQVksT0FBTyxPQUFPLFVBQVUsWUFDbEUsK0RBQStEO1FBQy9ELGtEQUFrRDtRQUNsRCw2REFBNkQ7UUFDN0QsK0RBQStEO1FBQy9ELHFFQUFxRTtRQUNyRSxvQ0FBb0M7UUFDcEMsT0FBTzthQUVGLElBQUksT0FBTyxTQUFTLGVBQWUsT0FBTyxLQUFLLGVBQWUsWUFDbkUsaURBQWlEO1FBQ2pELDBEQUEwRDtRQUMxRCxhQUFhO1FBQ2IsS0FBSyxXQUFXO1FBR2xCLDJFQUEyRTtRQUMzRSx5RUFBeUU7UUFDekUsU0FBUztRQUNULFdBQVc7WUFDVCxNQUFNLElBQUksQ0FBQztZQUNYLE1BQU0sSUFBSSxDQUFDO1FBQ2IsR0FBRztJQUNMO0lBRUE7OztLQUdHLEdBQ0ssTUFBTSxtQkFBTjtRQUNOLElBQUksQ0FBQyxPQUFPO1FBRVosTUFBTSxTQUFTLElBQUksQ0FBQztRQUNwQixJQUFJLENBQUMsb0JBQW9CO1FBRXpCLElBQUksUUFDRixjQUFjO0lBRWxCO0lBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQXFCRyxHQUNILE1BQU0sbUJBQU47UUFDRSxJQUFJLENBQUM7UUFDTCxNQUFNLElBQUksQ0FBQztJQUNiO0lBRUE7Ozs7Ozs7S0FPRyxHQUNILE1BQU0sa0JBQU47UUFDRSxJQUFJLENBQUM7UUFDTCxNQUFNLElBQUksQ0FBQztJQUNiO0lBRUE7O0tBRUcsR0FDSyxNQUFNLHdCQUFOO1FBQ04sSUFBSSxDQUFDLE9BQU8sNEJBQTRCO1FBRXhDLElBQUk7WUFDRixNQUFNLElBQUksQ0FBQyxhQUFhLEdBQUc7Z0JBQ3pCLElBQUk7b0JBQ0YsTUFBTSxNQUFNLEtBQUs7b0JBRWpCLElBQUk7d0JBQ0YsT0FBTyxNQUFNLElBQUksQ0FBQyxZQUFZLE9BQU87NEJBQ25DLE1BQU0sRUFDSixNQUFNLEVBQUUsT0FBTyxFQUFFLEVBQ2xCLEdBQUc7NEJBRUosSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLGlCQUFpQixDQUFDLFFBQVEsWUFBWTtnQ0FDN0QsSUFBSSxDQUFDLE9BQU8sNEJBQTRCO2dDQUN4Qzs0QkFDRDs0QkFFRCwwRUFBMEU7NEJBQzFFLE1BQU0saUJBQWlCLEtBQUssTUFDMUIsQUFBQyxDQUFBLFFBQVEsYUFBYSxPQUFPLEdBQUEsSUFBTzs0QkFHdEMsSUFBSSxDQUFDLE9BQ0gsNEJBQ0EsQ0FBQSx3QkFBQSxFQUEyQixlQUFjLHFCQUFBLEVBQXdCLDJCQUEwQix5QkFBQSxFQUE0Qiw0QkFBMkIsTUFBQSxDQUFROzRCQUc1SixJQUFJLGtCQUFrQiw2QkFDcEIsTUFBTSxJQUFJLENBQUMsa0JBQWtCLFFBQVE7d0JBRXpDO29CQUNELEVBQUMsT0FBTyxHQUFRO3dCQUNmLFFBQVEsTUFDTiwwRUFDQTtvQkFFSDtnQkFDRixTQUFTO29CQUNSLElBQUksQ0FBQyxPQUFPLDRCQUE0QjtnQkFDekM7WUFDSDtRQUNELEVBQUMsT0FBTyxHQUFRO1lBQ2YsSUFBSSxFQUFFLG9CQUFvQixhQUFhLENBQUEsR0FBQSw4QkFBQSxHQUNyQyxJQUFJLENBQUMsT0FBTztpQkFFWixNQUFNO1FBRVQ7SUFDSDtJQUVBOzs7O0tBSUcsR0FDSyxNQUFNLDBCQUFOO1FBQ04sSUFBSSxDQUFDLE9BQU87UUFFWixJQUFJLENBQUMsQ0FBQSxHQUFBLGtCQUFBLE9BQWUsQ0FBQyxDQUFBLFdBQU0sUUFBTixXQUFNLEtBQUEsSUFBQSxLQUFBLElBQU4sT0FBUSxnQkFBQSxHQUFrQjtZQUM3QyxJQUFJLElBQUksQ0FBQyxrQkFDUCxtRUFBbUU7WUFDbkUsSUFBSSxDQUFDO1lBR1AsT0FBTztRQUNSO1FBRUQsSUFBSTtZQUNGLElBQUksQ0FBQyw0QkFBNEIsVUFBWSxNQUFNLElBQUksQ0FBQyxxQkFBcUI7WUFFN0UsV0FBTSxRQUFOLFdBQU0sS0FBQSxLQUFOLE9BQVEsaUJBQWlCLG9CQUFvQixJQUFJLENBQUM7WUFFbEQsd0VBQXdFO1lBQ3hFLDBCQUEwQjtZQUMxQixNQUFNLElBQUksQ0FBQyxxQkFBcUIsT0FBTSxlQUFlO1FBQ3RELEVBQUMsT0FBTyxPQUFPO1lBQ2QsUUFBUSxNQUFNLDJCQUEyQjtRQUMxQztJQUNIO0lBRUE7O0tBRUcsR0FDSyxNQUFNLHFCQUFxQixvQkFBNkIsRUFBeEQ7UUFDTixNQUFNLGFBQWEsQ0FBQSxzQkFBQSxFQUF5QixxQkFBb0IsQ0FBQSxDQUFHO1FBQ25FLElBQUksQ0FBQyxPQUFPLFlBQVksbUJBQW1CLFNBQVM7UUFFcEQsSUFBSSxTQUFTLG9CQUFvQixXQUFXO1lBQzFDLElBQUksSUFBSSxDQUFDLGtCQUNQLDZFQUE2RTtZQUM3RSxpQ0FBaUM7WUFDakMsSUFBSSxDQUFDO1lBR1AsSUFBSSxDQUFDLHNCQUFzQjtnQkFDekIsMkRBQTJEO2dCQUMzRCx1RUFBdUU7Z0JBQ3ZFLHVFQUF1RTtnQkFDdkUsZ0NBQWdDO2dCQUNoQyxNQUFNLElBQUksQ0FBQztnQkFFWCxNQUFNLElBQUksQ0FBQyxhQUFhLElBQUk7b0JBQzFCLElBQUksU0FBUyxvQkFBb0IsV0FBVzt3QkFDMUMsSUFBSSxDQUFDLE9BQ0gsWUFDQTt3QkFHRiwyREFBMkQ7d0JBQzNEO29CQUNEO29CQUVELHNCQUFzQjtvQkFDdEIsTUFBTSxJQUFJLENBQUM7Z0JBQ2I7WUFDRDtRQUNGLE9BQU0sSUFBSSxTQUFTLG9CQUFvQixVQUN0QztZQUFBLElBQUksSUFBSSxDQUFDLGtCQUNQLElBQUksQ0FBQztRQUNOO0lBRUw7SUFFQTs7Ozs7S0FLRyxHQUNLLE1BQU0sbUJBQ1osR0FBVyxFQUNYLFFBQWtCLEVBQ2xCLE9BS0MsRUFSSztRQVVOLE1BQU0sWUFBc0I7WUFBQyxDQUFBLFNBQUEsRUFBWSxtQkFBbUIsVUFBUyxDQUFFO1NBQUM7UUFDeEUsSUFBSSxZQUFPLFFBQVAsWUFBTyxLQUFBLElBQUEsS0FBQSxJQUFQLFFBQVMsWUFDWCxVQUFVLEtBQUssQ0FBQSxZQUFBLEVBQWUsbUJBQW1CLFFBQVEsWUFBVyxDQUFFO1FBRXhFLElBQUksWUFBTyxRQUFQLFlBQU8sS0FBQSxJQUFBLEtBQUEsSUFBUCxRQUFTLFFBQ1gsVUFBVSxLQUFLLENBQUEsT0FBQSxFQUFVLG1CQUFtQixRQUFRLFFBQU8sQ0FBRTtRQUUvRCxJQUFJLElBQUksQ0FBQyxhQUFhLFFBQVE7WUFDNUIsTUFBTSxDQUFDLGVBQWUsb0JBQW9CLEdBQUcsTUFBTSxDQUFBLEdBQUEsa0NBQUEsRUFDakQsSUFBSSxDQUFDLFNBQ0wsSUFBSSxDQUFDO1lBR1AsTUFBTSxhQUFhLElBQUksZ0JBQWdCO2dCQUNyQyxnQkFBZ0IsQ0FBQSxFQUFHLG1CQUFtQixlQUFjLENBQUU7Z0JBQ3RELHVCQUF1QixDQUFBLEVBQUcsbUJBQW1CLHFCQUFvQixDQUFFO1lBQ3BFO1lBQ0QsVUFBVSxLQUFLLFdBQVc7UUFDM0I7UUFDRCxJQUFJLFlBQU8sUUFBUCxZQUFPLEtBQUEsSUFBQSxLQUFBLElBQVAsUUFBUyxhQUFhO1lBQ3hCLE1BQU0sUUFBUSxJQUFJLGdCQUFnQixRQUFRO1lBQzFDLFVBQVUsS0FBSyxNQUFNO1FBQ3RCO1FBQ0QsSUFBSSxZQUFPLFFBQVAsWUFBTyxLQUFBLElBQUEsS0FBQSxJQUFQLFFBQVMscUJBQ1gsVUFBVSxLQUFLLENBQUEsbUJBQUEsRUFBc0IsUUFBUSxvQkFBbUIsQ0FBRTtRQUdwRSxPQUFPLENBQUEsRUFBRyxJQUFHLENBQUEsRUFBSSxVQUFVLEtBQUssS0FBSSxDQUFFO0lBQ3hDO0lBRVEsTUFBTSxVQUFVLE1BQXlCLEVBQXpDO1FBQ04sSUFBSTtZQUNGLE9BQU8sTUFBTSxJQUFJLENBQUMsWUFBWSxPQUFPO2dCLEk7Z0JBQ25DLE1BQU0sRUFBRSxNQUFNLFdBQVcsRUFBRSxPQUFPLFlBQVksRUFBRSxHQUFHO2dCQUNuRCxJQUFJLGNBQ0YsT0FBTztvQkFBRSxNQUFNO29CQUFNLE9BQU87Z0JBQVk7Z0JBRzFDLE9BQU8sTUFBTSxDQUFBLEdBQUEsZUFBQSxFQUFTLElBQUksQ0FBQyxPQUFPLFVBQVUsQ0FBQSxFQUFHLElBQUksQ0FBQyxJQUFHLFNBQUEsRUFBWSxPQUFPLFNBQVEsQ0FBRSxFQUFFO29CQUNwRixTQUFTLElBQUksQ0FBQztvQkFDZCxLQUFLLEFBQUEsQ0FBQSxLQUFBLGdCQUFXLFFBQVgsZ0JBQVcsS0FBQSxJQUFBLEtBQUEsSUFBWCxZQUFhLE9BQUEsTUFBTyxRQUFBLE9BQUEsS0FBQSxJQUFBLEtBQUEsSUFBQSxHQUFFO2dCQUM1QjtZQUNIO1FBQ0QsRUFBQyxPQUFPLE9BQU87WUFDZCxJQUFJLENBQUEsR0FBQSxtQkFBQSxFQUFZLFFBQ2QsT0FBTztnQkFBRSxNQUFNO2dCQUFNO1lBQUs7WUFFNUIsTUFBTTtRQUNQO0lBQ0g7SUFFQTs7S0FFRyxHQUNLLE1BQU0sUUFBUSxNQUF1QixFQUFyQztRQUNOLElBQUk7WUFDRixPQUFPLE1BQU0sSUFBSSxDQUFDLFlBQVksT0FBTztnQixJLEk7Z0JBQ25DLE1BQU0sRUFBRSxNQUFNLFdBQVcsRUFBRSxPQUFPLFlBQVksRUFBRSxHQUFHO2dCQUNuRCxJQUFJLGNBQ0YsT0FBTztvQkFBRSxNQUFNO29CQUFNLE9BQU87Z0JBQVk7Z0JBRzFDLE1BQU0sRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLEdBQUcsTUFBTSxDQUFBLEdBQUEsZUFBQSxFQUFTLElBQUksQ0FBQyxPQUFPLFFBQVEsQ0FBQSxFQUFHLElBQUksQ0FBQyxJQUFHLFFBQUEsQ0FBVSxFQUFFO29CQUNoRixNQUFNO3dCQUNKLGVBQWUsT0FBTzt3QkFDdEIsYUFBYSxPQUFPO3dCQUNwQixRQUFRLE9BQU87b0JBQ2hCO29CQUNELFNBQVMsSUFBSSxDQUFDO29CQUNkLEtBQUssQUFBQSxDQUFBLEtBQUEsZ0JBQVcsUUFBWCxnQkFBVyxLQUFBLElBQUEsS0FBQSxJQUFYLFlBQWEsT0FBQSxNQUFPLFFBQUEsT0FBQSxLQUFBLElBQUEsS0FBQSxJQUFBLEdBQUU7Z0JBQzVCO2dCQUVELElBQUksT0FDRixPQUFPO29CQUFFLE1BQU07b0JBQU07Z0JBQUs7Z0JBRzVCLElBQUksQUFBQSxDQUFBLEtBQUEsU0FBSSxRQUFKLFNBQUksS0FBQSxJQUFBLEtBQUEsSUFBSixLQUFNLElBQUEsTUFBSSxRQUFBLE9BQUEsS0FBQSxJQUFBLEtBQUEsSUFBQSxHQUFFLFNBQ2QsS0FBSyxLQUFLLFVBQVUsQ0FBQSx5QkFBQSxFQUE0QixLQUFLLEtBQUssUUFBTyxDQUFFO2dCQUdyRSxPQUFPO29CQUFFO29CQUFNLE9BQU87Z0JBQUk7WUFDNUI7UUFDRCxFQUFDLE9BQU8sT0FBTztZQUNkLElBQUksQ0FBQSxHQUFBLG1CQUFBLEVBQVksUUFDZCxPQUFPO2dCQUFFLE1BQU07Z0JBQU07WUFBSztZQUU1QixNQUFNO1FBQ1A7SUFDSDtJQUVBOztLQUVHLEdBQ0ssTUFBTSxRQUFRLE1BQXVCLEVBQXJDO1FBQ04sT0FBTyxJQUFJLENBQUMsYUFBYSxJQUFJO1lBQzNCLElBQUk7Z0JBQ0YsT0FBTyxNQUFNLElBQUksQ0FBQyxZQUFZLE9BQU87b0IsSTtvQkFDbkMsTUFBTSxFQUFFLE1BQU0sV0FBVyxFQUFFLE9BQU8sWUFBWSxFQUFFLEdBQUc7b0JBQ25ELElBQUksY0FDRixPQUFPO3dCQUFFLE1BQU07d0JBQU0sT0FBTztvQkFBWTtvQkFHMUMsTUFBTSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsR0FBRyxNQUFNLENBQUEsR0FBQSxlQUFBLEVBQzVCLElBQUksQ0FBQyxPQUNMLFFBQ0EsQ0FBQSxFQUFHLElBQUksQ0FBQyxJQUFHLFNBQUEsRUFBWSxPQUFPLFNBQVEsT0FBQSxDQUFTLEVBQy9DO3dCQUNFLE1BQU07NEJBQUUsTUFBTSxPQUFPOzRCQUFNLGNBQWMsT0FBTzt3QkFBVzt3QkFDM0QsU0FBUyxJQUFJLENBQUM7d0JBQ2QsS0FBSyxBQUFBLENBQUEsS0FBQSxnQkFBVyxRQUFYLGdCQUFXLEtBQUEsSUFBQSxLQUFBLElBQVgsWUFBYSxPQUFBLE1BQU8sUUFBQSxPQUFBLEtBQUEsSUFBQSxLQUFBLElBQUEsR0FBRTtvQkFDNUI7b0JBRUgsSUFBSSxPQUNGLE9BQU87d0JBQUUsTUFBTTt3QkFBTTtvQkFBSztvQkFHNUIsTUFBTSxJQUFJLENBQUMsYUFBWSxPQUFBLE9BQUE7d0JBQ3JCLFlBQVksS0FBSyxNQUFNLEtBQUssUUFBUSxRQUFRLEtBQUs7b0JBQVUsR0FDeEQ7b0JBRUwsTUFBTSxJQUFJLENBQUMsc0JBQXNCLDBCQUEwQjtvQkFFM0QsT0FBTzt3QkFBRTt3QkFBTTtvQkFBSztnQkFDdEI7WUFDRCxFQUFDLE9BQU8sT0FBTztnQkFDZCxJQUFJLENBQUEsR0FBQSxtQkFBQSxFQUFZLFFBQ2QsT0FBTztvQkFBRSxNQUFNO29CQUFNO2dCQUFLO2dCQUU1QixNQUFNO1lBQ1A7UUFDSDtJQUNGO0lBRUE7O0tBRUcsR0FDSyxNQUFNLFdBQVcsTUFBMEIsRUFBM0M7UUFDTixPQUFPLElBQUksQ0FBQyxhQUFhLElBQUk7WUFDM0IsSUFBSTtnQkFDRixPQUFPLE1BQU0sSUFBSSxDQUFDLFlBQVksT0FBTztvQixJO29CQUNuQyxNQUFNLEVBQUUsTUFBTSxXQUFXLEVBQUUsT0FBTyxZQUFZLEVBQUUsR0FBRztvQkFDbkQsSUFBSSxjQUNGLE9BQU87d0JBQUUsTUFBTTt3QkFBTSxPQUFPO29CQUFZO29CQUcxQyxPQUFPLE1BQU0sQ0FBQSxHQUFBLGVBQUEsRUFDWCxJQUFJLENBQUMsT0FDTCxRQUNBLENBQUEsRUFBRyxJQUFJLENBQUMsSUFBRyxTQUFBLEVBQVksT0FBTyxTQUFRLFVBQUEsQ0FBWSxFQUNsRDt3QkFDRSxTQUFTLElBQUksQ0FBQzt3QkFDZCxLQUFLLEFBQUEsQ0FBQSxLQUFBLGdCQUFXLFFBQVgsZ0JBQVcsS0FBQSxJQUFBLEtBQUEsSUFBWCxZQUFhLE9BQUEsTUFBTyxRQUFBLE9BQUEsS0FBQSxJQUFBLEtBQUEsSUFBQSxHQUFFO29CQUM1QjtnQkFFTDtZQUNELEVBQUMsT0FBTyxPQUFPO2dCQUNkLElBQUksQ0FBQSxHQUFBLG1CQUFBLEVBQVksUUFDZCxPQUFPO29CQUFFLE1BQU07b0JBQU07Z0JBQUs7Z0JBRTVCLE1BQU07WUFDUDtRQUNIO0lBQ0Y7SUFFQTs7S0FFRyxHQUNLLE1BQU0sb0JBQ1osTUFBbUMsRUFEN0I7UUFHTix5RUFBeUU7UUFDekUscUJBQXFCO1FBRXJCLE1BQU0sRUFBRSxNQUFNLGFBQWEsRUFBRSxPQUFPLGNBQWMsRUFBRSxHQUFHLE1BQU0sSUFBSSxDQUFDLFdBQVc7WUFDM0UsVUFBVSxPQUFPO1FBQ2xCO1FBQ0QsSUFBSSxnQkFDRixPQUFPO1lBQUUsTUFBTTtZQUFNLE9BQU87UUFBYztRQUc1QyxPQUFPLE1BQU0sSUFBSSxDQUFDLFFBQVE7WUFDeEIsVUFBVSxPQUFPO1lBQ2pCLGFBQWEsY0FBYztZQUMzQixNQUFNLE9BQU87UUFDZDtJQUNIO0lBRUE7O0tBRUcsR0FDSyxNQUFNLGVBQU47UUFDTixrRUFBa0U7UUFDbEUsTUFBTSxFQUNKLE1BQU0sRUFBRSxJQUFJLEVBQUUsRUFDZCxPQUFPLFNBQVMsRUFDakIsR0FBRyxNQUFNLElBQUksQ0FBQztRQUNmLElBQUksV0FDRixPQUFPO1lBQUUsTUFBTTtZQUFNLE9BQU87UUFBUztRQUd2QyxNQUFNLFVBQVUsQUFBQSxDQUFBLFNBQUksUUFBSixTQUFJLEtBQUEsSUFBQSxLQUFBLElBQUosS0FBTSxPQUFBLEtBQVcsRUFBRTtRQUNuQyxNQUFNLE9BQU8sUUFBUSxPQUNuQixDQUFDLFNBQVcsT0FBTyxnQkFBZ0IsVUFBVSxPQUFPLFdBQVc7UUFHakUsT0FBTztZQUNMLE1BQU07Z0JBQ0osS0FBSztnQkFDTDtZQUNEO1lBQ0QsT0FBTztRQUNSO0lBQ0g7SUFFQTs7S0FFRyxHQUNLLE1BQU0sa0NBQU47UUFDTixPQUFPLElBQUksQ0FBQyxhQUFhLElBQUk7WUFDM0IsT0FBTyxNQUFNLElBQUksQ0FBQyxZQUFZLE9BQU87Z0IsSSxJO2dCQUNuQyxNQUFNLEVBQ0osTUFBTSxFQUFFLE9BQU8sRUFBRSxFQUNqQixPQUFPLFlBQVksRUFDcEIsR0FBRztnQkFDSixJQUFJLGNBQ0YsT0FBTztvQkFBRSxNQUFNO29CQUFNLE9BQU87Z0JBQVk7Z0JBRTFDLElBQUksQ0FBQyxTQUNILE9BQU87b0JBQ0wsTUFBTTt3QkFBRSxjQUFjO3dCQUFNLFdBQVc7d0JBQU0sOEJBQThCLEVBQUU7b0JBQUE7b0JBQzdFLE9BQU87Z0JBQ1I7Z0JBR0gsTUFBTSxVQUFVLElBQUksQ0FBQyxXQUFXLFFBQVE7Z0JBRXhDLElBQUksZUFBb0Q7Z0JBRXhELElBQUksUUFBUSxLQUNWLGVBQWUsUUFBUTtnQkFHekIsSUFBSSxZQUFpRDtnQkFFckQsTUFBTSxrQkFDSixBQUFBLENBQUEsS0FBQSxBQUFBLENBQUEsS0FBQSxRQUFRLEtBQUssT0FBQSxNQUFPLFFBQUEsT0FBQSxLQUFBLElBQUEsS0FBQSxJQUFBLEdBQUUsT0FBTyxDQUFDLFNBQW1CLE9BQU8sV0FBVyxXQUFVLE1BQUMsUUFBQSxPQUFBLEtBQUEsSUFBQSxLQUFJLEVBQUU7Z0JBRXRGLElBQUksZ0JBQWdCLFNBQVMsR0FDM0IsWUFBWTtnQkFHZCxNQUFNLCtCQUErQixRQUFRLE9BQU8sRUFBRTtnQkFFdEQsT0FBTztvQkFBRSxNQUFNO3dCQUFFO3dCQUFjO3dCQUFXO29CQUE0QjtvQkFBSSxPQUFPO2dCQUFJO1lBQ3ZGO1FBQ0Y7SUFDRjtBO2tCQXIzRW1CO0FBQ0osYUFBQSxpQkFBaUI7Ozs7O3lERS9HckI7QUF3QmI7OztDQUdHLEdBQ0gsK0RBQWdCO0FBbENoQjtBQU1PLE1BQU0sc0JBQXdDO0lBQ25ELFNBQVMsQ0FBQztRQUNSLElBQUksQ0FBQyxDQUFBLEdBQUEsNkJBQUEsS0FDSCxPQUFPO1FBR1QsT0FBTyxXQUFXLGFBQWEsUUFBUTtJQUN6QztJQUNBLFNBQVMsQ0FBQyxLQUFLO1FBQ2IsSUFBSSxDQUFDLENBQUEsR0FBQSw2QkFBQSxLQUNIO1FBR0YsV0FBVyxhQUFhLFFBQVEsS0FBSztJQUN2QztJQUNBLFlBQVksQ0FBQztRQUNYLElBQUksQ0FBQyxDQUFBLEdBQUEsNkJBQUEsS0FDSDtRQUdGLFdBQVcsYUFBYSxXQUFXO0lBQ3JDO0FBQ0Q7QUFNSyxTQUFVLDBCQUEwQixRQUFtQyxDQUFBLENBQUU7SUFDN0UsT0FBTztRQUNMLFNBQVMsQ0FBQztZQUNSLE9BQU8sS0FBSyxDQUFDLElBQUksSUFBSTtRQUN2QjtRQUVBLFNBQVMsQ0FBQyxLQUFLO1lBQ2IsS0FBSyxDQUFDLElBQUksR0FBRztRQUNmO1FBRUEsWUFBWSxDQUFDO1lBQ1gsT0FBTyxLQUFLLENBQUMsSUFBSTtRQUNuQjtJQUNEO0FBQ0g7OztBRWhEQTs7Q0FFRzs7QUFDSCx3REFBZ0I7QUFBVixTQUFVO0lBQ2QsSUFBSSxPQUFPLGVBQWUsVUFBVTtJQUNwQyxJQUFJO1FBQ0YsT0FBTyxlQUFlLE9BQU8sV0FBVyxhQUFhO1lBQ25ELEtBQUs7Z0JBQ0gsT0FBTyxJQUFJO1lBQ2I7WUFDQSxjQUFjO1FBQ2Y7UUFDRCwyQ0FBMkM7UUFDM0MsVUFBVSxhQUFhO1FBQ3ZCLDJDQUEyQztRQUMzQyxPQUFPLE9BQU8sVUFBVTtJQUN6QixFQUFDLE9BQU8sR0FBRztRQUNWLElBQUksT0FBTyxTQUFTLGFBQ2xCLDZDQUE2QztRQUM3QyxLQUFLLGFBQWE7SUFFckI7QUFDSDs7Ozs7K0NFakJhO0FBWWI7Ozs7Q0FJRyxHQUNILDZEQUFzQjtBQVF0QixzRUFBYTtBQUViOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F3QkcsR0FDSCxtREFBc0I7QUF6RHRCO0FBS08sTUFBTSxZQUFZO0lBQ3ZCOztLQUVHLEdBQ0gsT0FBTyxDQUFDLENBQ04sQ0FBQSxjQUNBLENBQUEsR0FBQSw2QkFBQSxPQUNBLFdBQVcsZ0JBQ1gsV0FBVyxhQUFhLFFBQVEsc0NBQXNDLE1BQUE7QUFFekU7QUFPSyxNQUFnQixnQ0FBZ0M7SUFHcEQsWUFBWSxPQUFlLENBQTNCO1FBQ0UsS0FBSyxDQUFDO1FBSFEsSUFBQSxDQUFBLG1CQUFtQjtJQUluQztBQUNEO0FBRUssTUFBTyx5Q0FBeUM7QUFBMEI7QUEyQnpFLGVBQWUsY0FDcEIsSUFBWSxFQUNaLGNBQXNCLEVBQ3RCLEVBQW9CO0lBRXBCLElBQUksVUFBVSxPQUNaLFFBQVEsSUFBSSxvREFBb0QsTUFBTTtJQUd4RSxNQUFNLGtCQUFrQixJQUFJLFdBQVc7SUFFdkMsSUFBSSxpQkFBaUIsR0FDbkIsV0FBVztRQUNULGdCQUFnQjtRQUNoQixJQUFJLFVBQVUsT0FDWixRQUFRLElBQUksd0RBQXdEO0lBRXhFLEdBQUc7SUFHTCxvRkFBb0Y7SUFFcEYsT0FBTyxNQUFNLFdBQVcsVUFBVSxNQUFNLFFBQ3RDLE1BQ0EsbUJBQW1CLElBQ2Y7UUFDRSxNQUFNO1FBQ04sYUFBYTtJQUNkLElBQ0Q7UUFDRSxNQUFNO1FBQ04sUUFBUSxnQkFBZ0I7SUFDekIsR0FDTCxPQUFPO1FBQ0wsSUFBSSxNQUFNO1lBQ1IsSUFBSSxVQUFVLE9BQ1osUUFBUSxJQUFJLGdEQUFnRCxNQUFNLEtBQUs7WUFHekUsSUFBSTtnQkFDRixPQUFPLE1BQU07WUFDZCxTQUFTO2dCQUNSLElBQUksVUFBVSxPQUNaLFFBQVEsSUFBSSxnREFBZ0QsTUFBTSxLQUFLO1lBRTFFO1FBQ0YsT0FDQyxJQUFJLG1CQUFtQixHQUFHO1lBQ3hCLElBQUksVUFBVSxPQUNaLFFBQVEsSUFBSSxpRUFBaUU7WUFHL0UsTUFBTSxJQUFJLGlDQUNSLENBQUEsbURBQUEsRUFBc0QsS0FBSSxvQkFBQSxDQUFzQjtRQUVuRixPQUFNO1lBQ0wsSUFBSSxVQUFVLE9BQ1osSUFBSTtnQkFDRixNQUFNLFNBQVMsTUFBTSxXQUFXLFVBQVUsTUFBTTtnQkFFaEQsUUFBUSxJQUNOLG9EQUNBLEtBQUssVUFBVSxRQUFRLE1BQU07WUFFaEMsRUFBQyxPQUFPLEdBQVE7Z0JBQ2YsUUFBUSxLQUNOLHdFQUNBO1lBRUg7WUFHSCw4REFBOEQ7WUFDOUQsaUVBQWlFO1lBQ2pFLHFFQUFxRTtZQUNyRSxpREFBaUQ7WUFDakQsUUFBUSxLQUNOO1lBR0YsT0FBTyxNQUFNO1FBQ2Q7SUFFTDtBQUVKOzs7OztBRTlJQTs7QUFFQSxNQUFNLGVBQWUsQ0FBQSxHQUFBLDhCQUFBO2tCQUVOOzs7OztBRUpmOztBQUVBLE1BQU0sYUFBYSxDQUFBLEdBQUEsNEJBQUE7a0JBRUo7Ozs7Ozs7OztrREVGRjtzREFLQTtrREFVQTtpRUFHQTtBQXBCYjtBQUVPLE1BQU0sZUFBZSxJQUMxQixJQUFJLENBQUEsR0FBQSxnQkFBTSxFQUFFO1FBQ1YsTUFBTTtJQUNSO0FBRUssTUFBTSxtQkFBbUIsQ0FBQyxTQUFpQixFQUFFO0lBQ2xELE1BQU0sYUFDSjtJQUNGLElBQUksU0FBUztJQUNiLElBQUssSUFBSSxJQUFJLEdBQUcsSUFBSSxRQUFRLElBQzFCLFVBQVUsV0FBVyxPQUFPLEtBQUssTUFBTSxLQUFLLFdBQVcsV0FBVztJQUVwRSxPQUFPO0FBQ1Q7QUFFTyxNQUFNLGVBQWUsQ0FBQyxLQUFVLFdBQ3JDLE9BQU8sUUFBUSxXQUFXLE1BQU0sWUFBWTtBQUV2QyxNQUFNLDhCQUE4QixDQUFDO0lBQzFDLE1BQU0sZ0JBQWdCO1FBQ3BCO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO0tBQ0Q7SUFDRCxNQUFNLFdBQVcsSUFBSSxJQUFJLEtBQUs7SUFDOUIsTUFBTSxRQUFRLFNBQVMsTUFBTTtJQUU3QixNQUFNLFdBQVcsY0FBYyxLQUFLLENBQUMsTUFBUSxTQUFTLFNBQVM7SUFDL0QsSUFBSSxVQUNGLE9BQU8sTUFBTSxNQUFNLENBQUMsU0FBUyxNQUFNLEtBQUssU0FBUyxHQUFHLEtBQUs7SUFHM0QsT0FBTyxNQUFNLFVBQVUsSUFBSSxXQUFXLE1BQU0sTUFBTSxJQUFJLEtBQUs7QUFDN0Q7Ozs7O0FDMUNvOUgsaURBQU87QUFBUCw2Q0FBd0I7QUFBNStIOztBQUFvQixJQUFJLElBQUU7SUFBSyxJQUFHO1FBQUMsSUFBSSxJQUFFLEFBQUMsV0FBVyxXQUFXLFVBQVcsTUFBTSxtRUFBaUUsRUFBRTtRQUFDLElBQUcsQ0FBQyxDQUFDLEVBQUUsS0FBRyxVQUFTLE9BQU8sU0FBUyxDQUFDLENBQUMsRUFBRSxJQUFFLE9BQUssV0FBVyxPQUFPLFNBQVMsZUFBZSxxQkFBbUI7SUFBQyxFQUFDLE9BQUs7UUFBQyxPQUFNLENBQUM7SUFBQztJQUFDLE9BQU0sQ0FBQztBQUFDO0FBQUUsSUFBSSxJQUFFO0lBQU0sQ0FBQyxDQUFDLENBQUM7SUFBQSxDQUFDLENBQUMsQ0FBQztJQUFBLElBQUksZ0JBQWU7UUFBQyxPQUFPLElBQUksQ0FBQyxDQUFDLENBQUM7SUFBQTtJQUFDLENBQUMsQ0FBQyxDQUFDO0lBQUEsSUFBSSxrQkFBaUI7UUFBQyxPQUFPLElBQUksQ0FBQyxDQUFDLENBQUM7SUFBQTtJQUFDLENBQUMsQ0FBQyxDQUFDO0lBQUEsSUFBSSxPQUFNO1FBQUMsT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQUE7SUFBQyxJQUFJLFlBQVc7UUFBQyxJQUFHO1lBQUMsT0FBTyxPQUFPLFNBQU8sT0FBSyxDQUFDLENBQUMsT0FBTztRQUFZLEVBQUMsT0FBTSxHQUFFO1lBQUMsT0FBTyxRQUFRLE1BQU0sSUFBRyxDQUFDO1FBQUM7SUFBQztJQUFDLENBQUMsQ0FBQyxHQUFDLElBQUksSUFBSTtJQUFBLENBQUMsQ0FBQyxDQUFDO0lBQUEsSUFBSSxlQUFjO1FBQUMsT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQUE7SUFBQyxXQUFTLENBQUEsSUFBRyxJQUFJLENBQUMsYUFBWSxDQUFBLElBQUksQ0FBQyxhQUFXLElBQUksQ0FBQyxhQUFhLElBQUksRUFBQyxFQUFHO0lBQUEsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxFQUFFO0lBQUEsSUFBSSxZQUFXO1FBQUMsT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQUE7SUFBQyxtQkFBaUIsSUFBSSxXQUFXLFNBQVMsV0FBUyxXQUFXLFFBQVEsUUFBUTtJQUFBLElBQUksa0JBQWlCO1FBQUMsSUFBRztZQUFDLE9BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQztRQUFrQixFQUFDLE9BQU0sR0FBRTtZQUFDLE9BQU8sUUFBUSxNQUFNLElBQUcsQ0FBQztRQUFDO0lBQUM7SUFBQyxtQkFBaUIsSUFBSSxJQUFJLENBQUMsZ0JBQWdCO0lBQUEsZUFBYSxHQUFHO0lBQUEsYUFBVyxDQUFBLElBQUcsRUFBRSxXQUFXLElBQUksQ0FBQyxjQUFjO0lBQUEsbUJBQWlCLENBQUEsSUFBRyxDQUFDLEVBQUUsSUFBSSxDQUFDLGFBQWEsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUFBLHFCQUFtQixDQUFBLElBQUcsRUFBRSxNQUFNLElBQUksQ0FBQyxhQUFhLFFBQVE7SUFBQSxRQUFNO1FBQUMsWUFBVyxLQUFLO1FBQVUsY0FBYSxLQUFLO0lBQUssRUFBRTtJQUFBLFlBQVksRUFBQyxNQUFLLElBQUUsTUFBTSxFQUFDLFdBQVUsSUFBRSxDQUFDLENBQUMsRUFBQyxlQUFjLElBQUUsRUFBRSxFQUFDLE9BQU0sSUFBRSxDQUFDLENBQUMsRUFBQyxHQUFDLENBQUMsQ0FBQyxDQUFDO1FBQUMsSUFBSSxDQUFDLGdCQUFnQixJQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBQyxHQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBQyxHQUFFLElBQUksQ0FBQyxRQUFNO1lBQUMsR0FBRyxJQUFJLENBQUMsS0FBSztZQUFDLEdBQUcsQ0FBQztRQUFBO1FBQUUsSUFBRztZQUFDLElBQUksQ0FBQyxhQUFZLENBQUEsS0FBRyxFQUFFLFNBQU8sQ0FBQSxLQUFLLENBQUEsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFDLE9BQU8sWUFBVztRQUFFLEVBQUMsT0FBSyxDQUFDO1FBQUMsSUFBRztZQUFDLElBQUksQ0FBQyxtQkFBa0IsQ0FBQSxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUMsSUFBSSxDQUFDLG9CQUFtQixNQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBQyxDQUFBLEdBQUEsb0JBQUEsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBQztnQkFBQyxTQUFRO29CQUFDO2lCQUFnQjtnQkFBQyxZQUFXLENBQUM7WUFBQyxLQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQUFBRDtRQUFFLEVBQUMsT0FBSyxDQUFDO0lBQUM7SUFBQyxnQkFBZ0IsQ0FBQyxFQUFDO1FBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFDLElBQUksSUFBSTtJQUFFO0lBQUMsWUFBVSxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxNQUFNO0lBQUEsU0FBTztRQUFVLElBQUksSUFBRSxNQUFNLElBQUksQ0FBQztRQUFZLE9BQU8sT0FBTyxRQUFRLEdBQUcsT0FBTyxDQUFDLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQyxXQUFXLElBQUksT0FBTyxDQUFDLEdBQUUsQ0FBQyxHQUFFLEVBQUUsR0FBSSxDQUFBLENBQUMsQ0FBQyxJQUFJLENBQUMsbUJBQW1CLEdBQUcsR0FBQyxHQUFFLENBQUEsR0FBRyxDQUFDO0lBQUUsRUFBRTtJQUFBLE9BQUssT0FBTTtRQUFJLElBQUksSUFBRSxNQUFJLEtBQUs7UUFBRSxJQUFHLENBQUMsS0FBRyxDQUFDLElBQUksQ0FBQyxhQUFhLElBQUksTUFBSSxDQUFDLElBQUksQ0FBQyxhQUFXLENBQUMsSUFBSSxDQUFDLGlCQUFnQixPQUFNLENBQUM7UUFBRSxJQUFJLElBQUUsSUFBSSxDQUFDLFlBQVUsTUFBTSxJQUFJLENBQUMsY0FBWSxNQUFNLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEFBQUMsQ0FBQSxJQUFFO2VBQUksSUFBSSxDQUFDO1NBQWEsR0FBQztZQUFDO1NBQUUsQUFBRCxFQUFHLElBQUksSUFBSSxDQUFDO1FBQW1CLElBQUcsQ0FBQyxHQUFFLE9BQU0sQ0FBQztRQUFFLElBQUksSUFBRSxDQUFDO1FBQUUsSUFBSSxJQUFJLEtBQUssRUFBRTtZQUFDLElBQUksSUFBRSxDQUFDLENBQUMsRUFBRSxFQUFDLElBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLFFBQVE7WUFBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsUUFBUSxHQUFFLElBQUcsTUFBSSxNQUFJO1FBQUM7UUFBQyxPQUFPO0lBQUMsRUFBRTtJQUFBLFNBQU8sT0FBTSxJQUFHLElBQUksQ0FBQyxrQkFBZ0IsQUFBQyxDQUFBLE1BQU0sSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBQyxDQUFFLENBQUMsRUFBRSxHQUFDLElBQUksQ0FBQyxTQUFTLEtBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLFFBQVEsS0FBRyxLQUFLO0lBQUEsU0FBTyxPQUFNLEdBQUUsSUFBSyxDQUFBLElBQUksQ0FBQyxTQUFTLE1BQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLFFBQVEsR0FBRSxJQUFHLElBQUksQ0FBQyxtQkFBaUIsTUFBTSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSTtZQUFDLENBQUMsRUFBRSxFQUFDO1FBQUMsSUFBRyxJQUFHLEVBQUc7SUFBQSxRQUFNLE9BQU0sSUFBRSxDQUFDLENBQUM7UUFBSSxLQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxTQUFRLE1BQU0sSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQU8sRUFBRTtJQUFBLFlBQVUsT0FBTTtRQUFJLElBQUksQ0FBQyxTQUFTLE1BQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLFdBQVcsSUFBRyxJQUFJLENBQUMsbUJBQWlCLE1BQU0sSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU87SUFBRSxFQUFFO0lBQUEsWUFBVTtRQUFVLElBQUksSUFBRSxNQUFNLElBQUksQ0FBQyxVQUFTLElBQUUsT0FBTyxLQUFLO1FBQUcsTUFBTSxRQUFRLElBQUksRUFBRSxJQUFJLElBQUksQ0FBQztJQUFRLEVBQUU7SUFBQSxRQUFNLENBQUE7UUFBSSxJQUFJLElBQUUsSUFBSSxDQUFDO1FBQW1CLE9BQU8sS0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBRztJQUFDLEVBQUU7SUFBQSxDQUFDLENBQUMsR0FBQyxDQUFBO1FBQUksSUFBSSxJQUFJLEtBQUssRUFBRTtZQUFDLElBQUksSUFBRSxJQUFJLENBQUMsaUJBQWlCLElBQUcs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QU87Z0JBQ3pELE1BQU0sSUFBSSxVQUFVO2dCQUNwQixPQUFPO1lBQ1I7WUFFQSxPQUFPO1FBQ1I7SUFDRDtJQUVBLE9BQU87QUFDUjs7O0FDOUdBO0FBRUEsT0FBTyxRQUFRLFlBQVksWUFBWSxPQUFPO0lBQzVDLE1BQU0sRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLEdBQUcsTUFBTSxDQUFBLEdBQUEsa0JBQU8sRUFBRSxLQUFLO0lBQzVDLFFBQVEsSUFBSSxpQkFBaUI7SUFDN0IsSUFBSSxDQUFDLEtBQUssU0FBUyxPQUFPLFFBQVE7SUFDbEMsSUFBSSxPQUFPLFFBQVEsTUFBTTtBQUMzQiIsInNvdXJjZXMiOlsibm9kZV9tb2R1bGVzL0BwbGFzbW9ocS9wYXJjZWwtcnVudGltZS9kaXN0L3J1bnRpbWUtMWFiODQxNDc5YjA4NGU1OC5qcyIsIi5wbGFzbW8vc3RhdGljL2JhY2tncm91bmQvaW5kZXgudHMiLCIucGxhc21vL3N0YXRpYy9iYWNrZ3JvdW5kL21lc3NhZ2luZy50cyIsImJhY2tncm91bmQvbWVzc2FnZXMvc2F2ZS1zZXNzaW9uLnRzIiwibm9kZV9tb2R1bGVzL0BwbGFzbW9ocS9tZXNzYWdpbmcvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9uYW5vaWQvaW5kZXguYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9AcGFyY2VsL3RyYW5zZm9ybWVyLWpzL3NyYy9lc21vZHVsZS1oZWxwZXJzLmpzIiwibGliL2JhY2tncm91bmQvY29va2llcy50cyIsImxpYi9jb25zdGFudHMudHMiLCJsaWIvc2VydmVyLWFjdGlvbnMudHMiLCJub2RlX21vZHVsZXMvYXhpb3MvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2F4aW9zLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9iaW5kLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0F4aW9zLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2J1aWxkVVJMLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL0F4aW9zVVJMU2VhcmNoUGFyYW1zLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3RvRm9ybURhdGEuanMiLCJub2RlX21vZHVsZXMvQHBsYXNtb2hxL3BhcmNlbC1yZXNvbHZlci9kaXN0L3BvbHlmaWxscy9idWZmZXIuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvQXhpb3NFcnJvci5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9udWxsLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0ludGVyY2VwdG9yTWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9kaXNwYXRjaFJlcXVlc3QuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvdHJhbnNmb3JtRGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvZGVmYXVsdHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzL3RyYW5zaXRpb25hbC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy90b1VSTEVuY29kZWRGb3JtLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9wbGF0Zm9ybS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvcGxhdGZvcm0vYnJvd3Nlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvcGxhdGZvcm0vYnJvd3Nlci9jbGFzc2VzL1VSTFNlYXJjaFBhcmFtcy5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvcGxhdGZvcm0vYnJvd3Nlci9jbGFzc2VzL0Zvcm1EYXRhLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9wbGF0Zm9ybS9icm93c2VyL2NsYXNzZXMvQmxvYi5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvcGxhdGZvcm0vY29tbW9uL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2Zvcm1EYXRhVG9KU09OLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0F4aW9zSGVhZGVycy5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9wYXJzZUhlYWRlcnMuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9pc0NhbmNlbC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbGVkRXJyb3IuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL2FkYXB0ZXJzLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9hZGFwdGVycy94aHIuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvc2V0dGxlLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3BhcnNlUHJvdG9jb2wuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcHJvZ3Jlc3NFdmVudFJlZHVjZXIuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvc3BlZWRvbWV0ZXIuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvdGhyb3R0bGUuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcmVzb2x2ZUNvbmZpZy5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc1VSTFNhbWVPcmlnaW4uanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29va2llcy5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9idWlsZEZ1bGxQYXRoLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvbWVyZ2VDb25maWcuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL2ZldGNoLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2NvbXBvc2VTaWduYWxzLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3RyYWNrU3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3ZhbGlkYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvZW52L2RhdGEuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxUb2tlbi5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9zcHJlYWQuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBeGlvc0Vycm9yLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL0h0dHBTdGF0dXNDb2RlLmpzIiwibGliL2JhY2tncm91bmQvYXV0aC50cyIsImxpYi9zdXBhYmFzZS50cyIsIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3VwYWJhc2UtanMvZGlzdC9tb2R1bGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL3NyYy9pbmRleC50cyIsIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3VwYWJhc2UtanMvZGlzdC9tb2R1bGUvU3VwYWJhc2VDbGllbnQuanMiLCJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL3NyYy9TdXBhYmFzZUNsaWVudC50cyIsIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvZnVuY3Rpb25zLWpzL2Rpc3QvbW9kdWxlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9mdW5jdGlvbnMtanMvc3JjL2luZGV4LnRzIiwibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9mdW5jdGlvbnMtanMvZGlzdC9tb2R1bGUvRnVuY3Rpb25zQ2xpZW50LmpzIiwibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9mdW5jdGlvbnMtanMvc3JjL0Z1bmN0aW9uc0NsaWVudC50cyIsIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvZnVuY3Rpb25zLWpzL2Rpc3QvbW9kdWxlL2hlbHBlci5qcyIsIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvZnVuY3Rpb25zLWpzL3NyYy9oZWxwZXIudHMiLCJub2RlX21vZHVsZXMvQHBhcmNlbC9ydW50aW1lLWpzL2xpYi9ydW50aW1lLWM0YjY5M2RhY2ExYTFlZTIuanMiLCJub2RlX21vZHVsZXMvQHBhcmNlbC9ydW50aW1lLWpzL2xpYi9oZWxwZXJzL3dvcmtlci9qcy1sb2FkZXIuanMiLCJub2RlX21vZHVsZXMvQHBhcmNlbC9ydW50aW1lLWpzL2xpYi9oZWxwZXJzL2NhY2hlTG9hZGVyLmpzIiwibm9kZV9tb2R1bGVzL0BwYXJjZWwvcnVudGltZS1qcy9saWIvaGVscGVycy9idW5kbGUtdXJsLmpzIiwibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9mdW5jdGlvbnMtanMvZGlzdC9tb2R1bGUvdHlwZXMuanMiLCJub2RlX21vZHVsZXMvQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcy9zcmMvdHlwZXMudHMiLCJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9kaXN0L2VzbS93cmFwcGVyLm1qcyIsIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL2Rpc3QvY2pzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMvc3JjL2luZGV4LnRzIiwibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMvZGlzdC9janMvUG9zdGdyZXN0Q2xpZW50LmpzIiwibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMvc3JjL1Bvc3RncmVzdENsaWVudC50cyIsIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL2Rpc3QvY2pzL1Bvc3RncmVzdFF1ZXJ5QnVpbGRlci5qcyIsIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL3NyYy9Qb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIudHMiLCJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9kaXN0L2Nqcy9Qb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyLmpzIiwibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMvc3JjL1Bvc3RncmVzdEZpbHRlckJ1aWxkZXIudHMiLCJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9kaXN0L2Nqcy9Qb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyLmpzIiwibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMvc3JjL1Bvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXIudHMiLCJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9kaXN0L2Nqcy9Qb3N0Z3Jlc3RCdWlsZGVyLmpzIiwibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMvc3JjL1Bvc3RncmVzdEJ1aWxkZXIudHMiLCJub2RlX21vZHVsZXMvQHN1cGFiYXNlL25vZGUtZmV0Y2gvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL2Rpc3QvY2pzL1Bvc3RncmVzdEVycm9yLmpzIiwibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMvc3JjL1Bvc3RncmVzdEVycm9yLnRzIiwibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMvZGlzdC9janMvY29uc3RhbnRzLmpzIiwibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMvc3JjL2NvbnN0YW50cy50cyIsIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL2Rpc3QvY2pzL3ZlcnNpb24uanMiLCJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9zcmMvdmVyc2lvbi50cyIsIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL3NyYy9pbmRleC50cyIsIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvUmVhbHRpbWVDbGllbnQuanMiLCJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL3NyYy9SZWFsdGltZUNsaWVudC50cyIsIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvbGliL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvc3JjL2xpYi9jb25zdGFudHMudHMiLCJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2xpYi92ZXJzaW9uLmpzIiwibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9zcmMvbGliL3ZlcnNpb24udHMiLCJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2xpYi9zZXJpYWxpemVyLmpzIiwibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9zcmMvbGliL3NlcmlhbGl6ZXIudHMiLCJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2xpYi90aW1lci5qcyIsIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvc3JjL2xpYi90aW1lci50cyIsIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvbGliL3RyYW5zZm9ybWVycy5qcyIsIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvc3JjL2xpYi90cmFuc2Zvcm1lcnMudHMiLCJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL1JlYWx0aW1lQ2hhbm5lbC5qcyIsIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvc3JjL1JlYWx0aW1lQ2hhbm5lbC50cyIsIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvbGliL3B1c2guanMiLCJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL3NyYy9saWIvcHVzaC50cyIsIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvUmVhbHRpbWVQcmVzZW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvc3JjL1JlYWx0aW1lUHJlc2VuY2UudHMiLCJub2RlX21vZHVsZXMvQHBhcmNlbC9ydW50aW1lLWpzL2xpYi9ydW50aW1lLTFiODUyYjRhZjlkYjFmZTEuanMiLCJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvc3JjL2luZGV4LnRzIiwibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdG9yYWdlLWpzL2Rpc3QvbW9kdWxlL1N0b3JhZ2VDbGllbnQuanMiLCJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvc3JjL1N0b3JhZ2VDbGllbnQudHMiLCJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvcGFja2FnZXMvU3RvcmFnZUZpbGVBcGkuanMiLCJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvc3JjL3BhY2thZ2VzL1N0b3JhZ2VGaWxlQXBpLnRzIiwibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdG9yYWdlLWpzL2Rpc3QvbW9kdWxlL2xpYi9lcnJvcnMuanMiLCJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvc3JjL2xpYi9lcnJvcnMudHMiLCJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvbGliL2ZldGNoLmpzIiwibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdG9yYWdlLWpzL3NyYy9saWIvZmV0Y2gudHMiLCJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvbGliL2hlbHBlcnMuanMiLCJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvc3JjL2xpYi9oZWxwZXJzLnRzIiwibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdG9yYWdlLWpzL2Rpc3QvbW9kdWxlL3BhY2thZ2VzL1N0b3JhZ2VCdWNrZXRBcGkuanMiLCJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvc3JjL3BhY2thZ2VzL1N0b3JhZ2VCdWNrZXRBcGkudHMiLCJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvbGliL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9zcmMvbGliL2NvbnN0YW50cy50cyIsIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9kaXN0L21vZHVsZS9saWIvdmVyc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9zcmMvbGliL3ZlcnNpb24udHMiLCJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvc3JjL2xpYi90eXBlcy50cyIsIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3VwYWJhc2UtanMvZGlzdC9tb2R1bGUvbGliL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3VwYWJhc2UtanMvc3JjL2xpYi9jb25zdGFudHMudHMiLCJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL2Rpc3QvbW9kdWxlL2xpYi92ZXJzaW9uLmpzIiwibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdXBhYmFzZS1qcy9zcmMvbGliL3ZlcnNpb24udHMiLCJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL2Rpc3QvbW9kdWxlL2xpYi9mZXRjaC5qcyIsIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3VwYWJhc2UtanMvc3JjL2xpYi9mZXRjaC50cyIsIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3VwYWJhc2UtanMvZGlzdC9tb2R1bGUvbGliL2hlbHBlcnMuanMiLCJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL3NyYy9saWIvaGVscGVycy50cyIsIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3VwYWJhc2UtanMvZGlzdC9tb2R1bGUvbGliL1N1cGFiYXNlQXV0aENsaWVudC5qcyIsIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3VwYWJhc2UtanMvc3JjL2xpYi9TdXBhYmFzZUF1dGhDbGllbnQudHMiLCJub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvc3JjL2luZGV4LnRzIiwibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbW9kdWxlL0dvVHJ1ZUFkbWluQXBpLmpzIiwibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL3NyYy9Hb1RydWVBZG1pbkFwaS50cyIsIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvZmV0Y2guanMiLCJub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvc3JjL2xpYi9mZXRjaC50cyIsIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvY29uc3RhbnRzLmpzIiwibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL3NyYy9saWIvY29uc3RhbnRzLnRzIiwibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbW9kdWxlL2xpYi92ZXJzaW9uLmpzIiwibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL3NyYy9saWIvdmVyc2lvbi50cyIsIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvaGVscGVycy5qcyIsIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9zcmMvbGliL2hlbHBlcnMudHMiLCJub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2Vycm9ycy5qcyIsIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9zcmMvbGliL2Vycm9ycy50cyIsIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9Hb1RydWVDbGllbnQuanMiLCJub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvc3JjL0dvVHJ1ZUNsaWVudC50cyIsIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvbG9jYWwtc3RvcmFnZS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9zcmMvbGliL2xvY2FsLXN0b3JhZ2UudHMiLCJub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL3BvbHlmaWxscy5qcyIsIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9zcmMvbGliL3BvbHlmaWxscy50cyIsIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvbG9ja3MuanMiLCJub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvc3JjL2xpYi9sb2Nrcy50cyIsIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9BdXRoQWRtaW5BcGkuanMiLCJub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvc3JjL0F1dGhBZG1pbkFwaS50cyIsIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9BdXRoQ2xpZW50LmpzIiwibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL3NyYy9BdXRoQ2xpZW50LnRzIiwibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL3NyYy9saWIvdHlwZXMudHMiLCJsaWIvdXRpbHMudHMiLCJub2RlX21vZHVsZXMvQHBsYXNtb2hxL3N0b3JhZ2UvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9waWZ5L2luZGV4LmpzIiwiYmFja2dyb3VuZC9pbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdT10eXBlb2YgZ2xvYmFsVGhpcy5wcm9jZXNzPFwidVwiP2dsb2JhbFRoaXMucHJvY2Vzcy5hcmd2OltdO3ZhciBoPSgpPT50eXBlb2YgZ2xvYmFsVGhpcy5wcm9jZXNzPFwidVwiP2dsb2JhbFRoaXMucHJvY2Vzcy5lbnY6e307dmFyIEI9bmV3IFNldCh1KSxfPWU9PkIuaGFzKGUpLEc9dS5maWx0ZXIoZT0+ZS5zdGFydHNXaXRoKFwiLS1cIikmJmUuaW5jbHVkZXMoXCI9XCIpKS5tYXAoZT0+ZS5zcGxpdChcIj1cIikpLnJlZHVjZSgoZSxbdCxvXSk9PihlW3RdPW8sZSkse30pO3ZhciBVPV8oXCItLWRyeS1ydW5cIiksZz0oKT0+XyhcIi0tdmVyYm9zZVwiKXx8aCgpLlZFUkJPU0U9PT1cInRydWVcIixOPWcoKTt2YXIgbT0oZT1cIlwiLC4uLnQpPT5jb25zb2xlLmxvZyhlLnBhZEVuZCg5KSxcInxcIiwuLi50KTt2YXIgeT0oLi4uZSk9PmNvbnNvbGUuZXJyb3IoXCJcXHV7MUY1MzR9IEVSUk9SXCIucGFkRW5kKDkpLFwifFwiLC4uLmUpLGI9KC4uLmUpPT5tKFwiXFx1ezFGNTM1fSBJTkZPXCIsLi4uZSksZj0oLi4uZSk9Pm0oXCJcXHV7MUY3RTB9IFdBUk5cIiwuLi5lKSxNPTAsaT0oLi4uZSk9PmcoKSYmbShgXFx1ezFGN0UxfSAke00rK31gLC4uLmUpO3ZhciB2PSgpPT57bGV0IGU9Z2xvYmFsVGhpcy5icm93c2VyPy5ydW50aW1lfHxnbG9iYWxUaGlzLmNocm9tZT8ucnVudGltZSx0PSgpPT5zZXRJbnRlcnZhbChlLmdldFBsYXRmb3JtSW5mbywyNGUzKTtlLm9uU3RhcnR1cC5hZGRMaXN0ZW5lcih0KSx0KCl9O3ZhciBuPXtcImlzQ29udGVudFNjcmlwdFwiOmZhbHNlLFwiaXNCYWNrZ3JvdW5kXCI6dHJ1ZSxcImlzUmVhY3RcIjpmYWxzZSxcInJ1bnRpbWVzXCI6W1wiYmFja2dyb3VuZC1zZXJ2aWNlLXJ1bnRpbWVcIl0sXCJob3N0XCI6XCJsb2NhbGhvc3RcIixcInBvcnRcIjoxODE1LFwiZW50cnlGaWxlUGF0aFwiOlwiL1VzZXJzL2NoYXJsZXNtYWRkb2NrL1Byb2plY3RzL2RlbmRyaXRlL2RlbmRyaXRlLWF1dGgtZXh0ZW5zaW9uLy5wbGFzbW8vc3RhdGljL2JhY2tncm91bmQvaW5kZXgudHNcIixcImJ1bmRsZUlkXCI6XCJjMzM4OTA4ZTcwNGM5MWYxXCIsXCJlbnZIYXNoXCI6XCJkOTlhNWZmYTU3YWNkNjM4XCIsXCJ2ZXJib3NlXCI6XCJmYWxzZVwiLFwic2VjdXJlXCI6ZmFsc2UsXCJzZXJ2ZXJQb3J0XCI6NjM1OTJ9O21vZHVsZS5idW5kbGUuSE1SX0JVTkRMRV9JRD1uLmJ1bmRsZUlkO2dsb2JhbFRoaXMucHJvY2Vzcz17YXJndjpbXSxlbnY6e1ZFUkJPU0U6bi52ZXJib3NlfX07dmFyIEQ9bW9kdWxlLmJ1bmRsZS5Nb2R1bGU7ZnVuY3Rpb24gSChlKXtELmNhbGwodGhpcyxlKSx0aGlzLmhvdD17ZGF0YTptb2R1bGUuYnVuZGxlLmhvdERhdGFbZV0sX2FjY2VwdENhbGxiYWNrczpbXSxfZGlzcG9zZUNhbGxiYWNrczpbXSxhY2NlcHQ6ZnVuY3Rpb24odCl7dGhpcy5fYWNjZXB0Q2FsbGJhY2tzLnB1c2godHx8ZnVuY3Rpb24oKXt9KX0sZGlzcG9zZTpmdW5jdGlvbih0KXt0aGlzLl9kaXNwb3NlQ2FsbGJhY2tzLnB1c2godCl9fSxtb2R1bGUuYnVuZGxlLmhvdERhdGFbZV09dm9pZCAwfW1vZHVsZS5idW5kbGUuTW9kdWxlPUg7bW9kdWxlLmJ1bmRsZS5ob3REYXRhPXt9O3ZhciBjPWdsb2JhbFRoaXMuYnJvd3Nlcnx8Z2xvYmFsVGhpcy5jaHJvbWV8fG51bGw7ZnVuY3Rpb24gUigpe3JldHVybiFuLmhvc3R8fG4uaG9zdD09PVwiMC4wLjAuMFwiP2xvY2F0aW9uLnByb3RvY29sLmluZGV4T2YoXCJodHRwXCIpPT09MD9sb2NhdGlvbi5ob3N0bmFtZTpcImxvY2FsaG9zdFwiOm4uaG9zdH1mdW5jdGlvbiB4KCl7cmV0dXJuIW4uaG9zdHx8bi5ob3N0PT09XCIwLjAuMC4wXCI/XCJsb2NhbGhvc3RcIjpuLmhvc3R9ZnVuY3Rpb24gZCgpe3JldHVybiBuLnBvcnR8fGxvY2F0aW9uLnBvcnR9dmFyIFA9XCJfX3BsYXNtb19ydW50aW1lX3BhZ2VfXCIsUz1cIl9fcGxhc21vX3J1bnRpbWVfc2NyaXB0X1wiO3ZhciBPPWAke24uc2VjdXJlP1wiaHR0cHNcIjpcImh0dHBcIn06Ly8ke1IoKX06JHtkKCl9L2A7YXN5bmMgZnVuY3Rpb24gayhlPTE0NzApe2Zvcig7Oyl0cnl7YXdhaXQgZmV0Y2goTyk7YnJlYWt9Y2F0Y2h7YXdhaXQgbmV3IFByb21pc2Uobz0+c2V0VGltZW91dChvLGUpKX19aWYoYy5ydW50aW1lLmdldE1hbmlmZXN0KCkubWFuaWZlc3RfdmVyc2lvbj09PTMpe2xldCBlPWMucnVudGltZS5nZXRVUkwoXCIvX19wbGFzbW9faG1yX3Byb3h5X18/dXJsPVwiKTtnbG9iYWxUaGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJmZXRjaFwiLGZ1bmN0aW9uKHQpe2xldCBvPXQucmVxdWVzdC51cmw7aWYoby5zdGFydHNXaXRoKGUpKXtsZXQgcz1uZXcgVVJMKGRlY29kZVVSSUNvbXBvbmVudChvLnNsaWNlKGUubGVuZ3RoKSkpO3MuaG9zdG5hbWU9PT1uLmhvc3QmJnMucG9ydD09PWAke24ucG9ydH1gPyhzLnNlYXJjaFBhcmFtcy5zZXQoXCJ0XCIsRGF0ZS5ub3coKS50b1N0cmluZygpKSx0LnJlc3BvbmRXaXRoKGZldGNoKHMpLnRoZW4ocj0+bmV3IFJlc3BvbnNlKHIuYm9keSx7aGVhZGVyczp7XCJDb250ZW50LVR5cGVcIjpyLmhlYWRlcnMuZ2V0KFwiQ29udGVudC1UeXBlXCIpPz9cInRleHQvamF2YXNjcmlwdFwifX0pKSkpOnQucmVzcG9uZFdpdGgobmV3IFJlc3BvbnNlKFwiUGxhc21vIEhNUlwiLHtzdGF0dXM6MjAwLHN0YXR1c1RleHQ6XCJUZXN0aW5nXCJ9KSl9fSl9ZnVuY3Rpb24gRShlLHQpe2xldHttb2R1bGVzOm99PWU7cmV0dXJuIG8/ISFvW3RdOiExfWZ1bmN0aW9uIEMoZT1kKCkpe2xldCB0PXgoKTtyZXR1cm5gJHtuLnNlY3VyZXx8bG9jYXRpb24ucHJvdG9jb2w9PT1cImh0dHBzOlwiJiYhL2xvY2FsaG9zdHwxMjcuMC4wLjF8MC4wLjAuMC8udGVzdCh0KT9cIndzc1wiOlwid3NcIn06Ly8ke3R9OiR7ZX0vYH1mdW5jdGlvbiBUKGUpe3R5cGVvZiBlLm1lc3NhZ2U9PVwic3RyaW5nXCImJnkoXCJbcGxhc21vL3BhcmNlbC1ydW50aW1lXTogXCIrZS5tZXNzYWdlKX1mdW5jdGlvbiBMKGUpe2lmKHR5cGVvZiBnbG9iYWxUaGlzLldlYlNvY2tldD5cInVcIilyZXR1cm47bGV0IHQ9bmV3IFdlYlNvY2tldChDKE51bWJlcihkKCkpKzEpKTtyZXR1cm4gdC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLGFzeW5jIGZ1bmN0aW9uKG8pe2xldCBzPUpTT04ucGFyc2Uoby5kYXRhKTthd2FpdCBlKHMpfSksdC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIixUKSx0fWZ1bmN0aW9uIEEoZSl7aWYodHlwZW9mIGdsb2JhbFRoaXMuV2ViU29ja2V0PlwidVwiKXJldHVybjtsZXQgdD1uZXcgV2ViU29ja2V0KEMoKSk7cmV0dXJuIHQuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIixhc3luYyBmdW5jdGlvbihvKXtsZXQgcz1KU09OLnBhcnNlKG8uZGF0YSk7aWYocy50eXBlPT09XCJ1cGRhdGVcIiYmYXdhaXQgZShzLmFzc2V0cykscy50eXBlPT09XCJlcnJvclwiKWZvcihsZXQgciBvZiBzLmRpYWdub3N0aWNzLmFuc2kpe2xldCBsPXIuY29kZWZyYW1lfHxyLnN0YWNrO2YoXCJbcGxhc21vL3BhcmNlbC1ydW50aW1lXTogXCIrci5tZXNzYWdlK2BcbmArbCtgXG5cbmArci5oaW50cy5qb2luKGBcbmApKX19KSx0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLFQpLHQuYWRkRXZlbnRMaXN0ZW5lcihcIm9wZW5cIiwoKT0+e2IoYFtwbGFzbW8vcGFyY2VsLXJ1bnRpbWVdOiBDb25uZWN0ZWQgdG8gSE1SIHNlcnZlciBmb3IgJHtuLmVudHJ5RmlsZVBhdGh9YCl9KSx0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCgpPT57ZihgW3BsYXNtby9wYXJjZWwtcnVudGltZV06IENvbm5lY3Rpb24gdG8gdGhlIEhNUiBzZXJ2ZXIgaXMgY2xvc2VkIGZvciAke24uZW50cnlGaWxlUGF0aH1gKX0pLHR9dmFyIHc9bW9kdWxlLmJ1bmRsZS5wYXJlbnQsYT17YnVpbGRSZWFkeTohMSxiZ0NoYW5nZWQ6ITEsY3NDaGFuZ2VkOiExLHBhZ2VDaGFuZ2VkOiExLHNjcmlwdFBvcnRzOm5ldyBTZXQscGFnZVBvcnRzOm5ldyBTZXR9O2FzeW5jIGZ1bmN0aW9uIHAoZT0hMSl7aWYoZXx8YS5idWlsZFJlYWR5JiZhLnBhZ2VDaGFuZ2VkKXtpKFwiQkdTVyBSdW50aW1lIC0gcmVsb2FkaW5nIFBhZ2VcIik7Zm9yKGxldCB0IG9mIGEucGFnZVBvcnRzKXQucG9zdE1lc3NhZ2UobnVsbCl9aWYoZXx8YS5idWlsZFJlYWR5JiYoYS5iZ0NoYW5nZWR8fGEuY3NDaGFuZ2VkKSl7aShcIkJHU1cgUnVudGltZSAtIHJlbG9hZGluZyBDU1wiKTtsZXQgdD1hd2FpdCBjPy50YWJzLnF1ZXJ5KHthY3RpdmU6ITB9KTtmb3IobGV0IG8gb2YgYS5zY3JpcHRQb3J0cyl7bGV0IHM9dC5zb21lKHI9PnIuaWQ9PT1vLnNlbmRlci50YWI/LmlkKTtvLnBvc3RNZXNzYWdlKHtfX3BsYXNtb19jc19hY3RpdmVfdGFiX186c30pfWMucnVudGltZS5yZWxvYWQoKX19aWYoIXd8fCF3LmlzUGFyY2VsUmVxdWlyZSl7digpO2xldCBlPUEoYXN5bmMgdD0+e2koXCJCR1NXIFJ1bnRpbWUgLSBPbiBITVIgVXBkYXRlXCIpLGEuYmdDaGFuZ2VkfHw9dC5maWx0ZXIocz0+cy5lbnZIYXNoPT09bi5lbnZIYXNoKS5zb21lKHM9PkUobW9kdWxlLmJ1bmRsZSxzLmlkKSk7bGV0IG89dC5maW5kKHM9PnMudHlwZT09PVwianNvblwiKTtpZihvKXtsZXQgcz1uZXcgU2V0KHQubWFwKGw9PmwuaWQpKSxyPU9iamVjdC52YWx1ZXMoby5kZXBzQnlCdW5kbGUpLm1hcChsPT5PYmplY3QudmFsdWVzKGwpKS5mbGF0KCk7YS5iZ0NoYW5nZWR8fD1yLmV2ZXJ5KGw9PnMuaGFzKGwpKX1wKCl9KTtlLmFkZEV2ZW50TGlzdGVuZXIoXCJvcGVuXCIsKCk9PntsZXQgdD1zZXRJbnRlcnZhbCgoKT0+ZS5zZW5kKFwicGluZ1wiKSwyNGUzKTtlLmFkZEV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCgpPT5jbGVhckludGVydmFsKHQpKX0pLGUuYWRkRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsYXN5bmMoKT0+e2F3YWl0IGsoKSxwKCEwKX0pfUwoYXN5bmMgZT0+e3N3aXRjaChpKFwiQkdTVyBSdW50aW1lIC0gT24gQnVpbGQgUmVwYWNrYWdlZFwiKSxlLnR5cGUpe2Nhc2VcImJ1aWxkX3JlYWR5XCI6e2EuYnVpbGRSZWFkeXx8PSEwLHAoKTticmVha31jYXNlXCJjc19jaGFuZ2VkXCI6e2EuY3NDaGFuZ2VkfHw9ITAscCgpO2JyZWFrfX19KTtjLnJ1bnRpbWUub25Db25uZWN0LmFkZExpc3RlbmVyKGZ1bmN0aW9uKGUpe2xldCB0PWUubmFtZS5zdGFydHNXaXRoKFApLG89ZS5uYW1lLnN0YXJ0c1dpdGgoUyk7aWYodHx8byl7bGV0IHM9dD9hLnBhZ2VQb3J0czphLnNjcmlwdFBvcnRzO3MuYWRkKGUpLGUub25EaXNjb25uZWN0LmFkZExpc3RlbmVyKCgpPT57cy5kZWxldGUoZSl9KSxlLm9uTWVzc2FnZS5hZGRMaXN0ZW5lcihmdW5jdGlvbihyKXtpKFwiQkdTVyBSdW50aW1lIC0gT24gc291cmNlIGNoYW5nZWRcIixyKSxyLl9fcGxhc21vX2NzX2NoYW5nZWRfXyYmKGEuY3NDaGFuZ2VkfHw9ITApLHIuX19wbGFzbW9fcGFnZV9jaGFuZ2VkX18mJihhLnBhZ2VDaGFuZ2VkfHw9ITApLHAoKX0pfX0pO2MucnVudGltZS5vbk1lc3NhZ2UuYWRkTGlzdGVuZXIoZnVuY3Rpb24odCl7cmV0dXJuIHQuX19wbGFzbW9fZnVsbF9yZWxvYWRfXyYmKGkoXCJCR1NXIFJ1bnRpbWUgLSBPbiB0b3AtbGV2ZWwgY29kZSBjaGFuZ2VkXCIpLHAoKSksITB9KTtcbiIsImltcG9ydCBcIi4vbWVzc2FnaW5nXCJcbmltcG9ydCBcIi4uLy4uLy4uL2JhY2tncm91bmQvaW5kZXhcIiIsIi8vIEB0cy1ub2NoZWNrXG5nbG9iYWxUaGlzLl9fcGxhc21vSW50ZXJuYWxQb3J0TWFwID0gbmV3IE1hcCgpXG5cbmltcG9ydCB7IGRlZmF1bHQgYXMgbWVzc2FnZXNTYXZlU2Vzc2lvbiB9IGZyb20gXCJ+YmFja2dyb3VuZC9tZXNzYWdlcy9zYXZlLXNlc3Npb25cIlxuXG5jaHJvbWUucnVudGltZS5vbk1lc3NhZ2VFeHRlcm5hbC5hZGRMaXN0ZW5lcigocmVxdWVzdCwgc2VuZGVyLCBzZW5kUmVzcG9uc2UpID0+IHtcbiAgc3dpdGNoIChyZXF1ZXN0Py5uYW1lKSB7XG4gICAgXG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufSlcblxuY2hyb21lLnJ1bnRpbWUub25NZXNzYWdlLmFkZExpc3RlbmVyKChyZXF1ZXN0LCBzZW5kZXIsIHNlbmRSZXNwb25zZSkgPT4ge1xuICBzd2l0Y2ggKHJlcXVlc3QubmFtZSkge1xuICAgIGNhc2UgXCJzYXZlLXNlc3Npb25cIjpcbiAgbWVzc2FnZXNTYXZlU2Vzc2lvbih7XG4gICAgLi4ucmVxdWVzdCxcbiAgICBzZW5kZXJcbiAgfSwge1xuICAgIHNlbmQ6IChwKSA9PiBzZW5kUmVzcG9uc2UocClcbiAgfSlcbiAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWtcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59KVxuXG5jaHJvbWUucnVudGltZS5vbkNvbm5lY3QuYWRkTGlzdGVuZXIoZnVuY3Rpb24ocG9ydCkge1xuICBnbG9iYWxUaGlzLl9fcGxhc21vSW50ZXJuYWxQb3J0TWFwLnNldChwb3J0Lm5hbWUsIHBvcnQpXG4gIHBvcnQub25NZXNzYWdlLmFkZExpc3RlbmVyKGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgICBzd2l0Y2ggKHBvcnQubmFtZSkge1xuICAgICAgXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVha1xuICAgIH1cbiAgfSlcbn0pXG5cbiIsImltcG9ydCB7IHNlbmRUb0NvbnRlbnRTY3JpcHQsIHR5cGUgUGxhc21vTWVzc2FnaW5nIH0gZnJvbSBcIkBwbGFzbW9ocS9tZXNzYWdpbmdcIlxuXG5pbXBvcnQgeyBnZXRDb29raWVzIH0gZnJvbSBcIn5saWIvYmFja2dyb3VuZC9jb29raWVzXCJcbmltcG9ydCB7IE1FU1NBR0VfTkFNRVMgfSBmcm9tIFwifmxpYi9jb25zdGFudHNcIlxuaW1wb3J0IHsgc3VibWl0U2Vzc2lvbiB9IGZyb20gXCJ+bGliL3NlcnZlci1hY3Rpb25zXCJcbmltcG9ydCB7IGVycm9yTWVzc2FnZSwgZ2V0SG9zdG5hbWVXaXRob3V0U3ViZG9tYWluIH0gZnJvbSBcIn5saWIvdXRpbHNcIlxuaW1wb3J0IHR5cGUgeyBTZXNzaW9uRFRPIH0gZnJvbSBcIn50eXBlcy9kdG9cIlxuaW1wb3J0IHR5cGUge1xuICBGZXRjaFNlc3Npb25SZXNwb25zZUJvZHksXG4gIE1lc3NhZ2VSZXNwb25zZUJvZHlcbn0gZnJvbSBcIn50eXBlcy9tZXNzYWdpbmdcIlxuXG5jb25zdCBoYW5kbGVyOiBQbGFzbW9NZXNzYWdpbmcuTWVzc2FnZUhhbmRsZXI8XG4gIHVuZGVmaW5lZCxcbiAgTWVzc2FnZVJlc3BvbnNlQm9keVxuPiA9IGFzeW5jIChyZXEsIHJlcykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgdXJsLCB1c2VyQWdlbnQsIGxvY2FsU3RvcmFnZSB9ID0gYXdhaXQgc2VuZFRvQ29udGVudFNjcmlwdDxcbiAgICAgIHN0cmluZyxcbiAgICAgIEZldGNoU2Vzc2lvblJlc3BvbnNlQm9keVxuICAgID4oe1xuICAgICAgbmFtZTogTUVTU0FHRV9OQU1FUy5GRVRDSF9TRVNTSU9OXG4gICAgfSlcbiAgICBjb25zdCBkb21haW4gPSBnZXRIb3N0bmFtZVdpdGhvdXRTdWJkb21haW4odXJsKVxuICAgIGNvbnNvbGUubG9nKHsgZG9tYWluIH0pXG4gICAgY29uc3QgY29va2llcyA9IGF3YWl0IGdldENvb2tpZXMoZG9tYWluKVxuICAgIGNvbnN0IHNlc3Npb25EVE86IFNlc3Npb25EVE8gPSB7XG4gICAgICBkb21haW4sXG4gICAgICB1c2VyX2FnZW50OiB1c2VyQWdlbnQsXG4gICAgICBjb29raWVzLFxuICAgICAgb3JpZ2luc19zdG9yYWdlOiBsb2NhbFN0b3JhZ2VcbiAgICB9XG4gICAgY29uc29sZS5sb2coXCJTYXZpbmcgc2Vzc2lvbiBkYXRhOlwiLCBzZXNzaW9uRFRPKVxuXG4gICAgYXdhaXQgc3VibWl0U2Vzc2lvbihzZXNzaW9uRFRPKVxuXG4gICAgcmVzLnNlbmQoe1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIG1lc3NhZ2U6IFwiR3JlYXQgc3VjY2Vzc1wiXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnIpXG4gICAgcmVzLnNlbmQoeyBzdWNjZXNzOiBmYWxzZSwgbWVzc2FnZTogZXJyb3JNZXNzYWdlKGVycikgfSlcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBoYW5kbGVyXG4iLCJpbXBvcnR7bmFub2lkIGFzIGJ9ZnJvbVwibmFub2lkXCI7dmFyIGw9Z2xvYmFsVGhpcy5icm93c2VyPy50YWJzfHxnbG9iYWxUaGlzLmNocm9tZT8udGFicyxkPSgpPT57bGV0IGU9Z2xvYmFsVGhpcy5icm93c2VyPy5ydW50aW1lfHxnbG9iYWxUaGlzLmNocm9tZT8ucnVudGltZTtpZighZSl0aHJvdyBuZXcgRXJyb3IoXCJFeHRlbnNpb24gcnVudGltZSBpcyBub3QgYXZhaWxhYmxlXCIpO3JldHVybiBlfSxpPSgpPT57aWYoIWwpdGhyb3cgbmV3IEVycm9yKFwiRXh0ZW5zaW9uIHRhYnMgQVBJIGlzIG5vdCBhdmFpbGFibGVcIik7cmV0dXJuIGx9LG09YXN5bmMoKT0+e2xldCBlPWkoKSxbYV09YXdhaXQgZS5xdWVyeSh7YWN0aXZlOiEwLGN1cnJlbnRXaW5kb3c6ITB9KTtyZXR1cm4gYX0sZz0oZSxhKT0+IWEuX19pbnRlcm5hbCYmZS5zb3VyY2U9PT1nbG9iYWxUaGlzLndpbmRvdyYmZS5kYXRhLm5hbWU9PT1hLm5hbWUmJihhLnJlbGF5SWQ9PT12b2lkIDB8fGUuZGF0YS5yZWxheUlkPT09YS5yZWxheUlkKTt2YXIgYz0oZSxhLG49Z2xvYmFsVGhpcy53aW5kb3cpPT57bGV0IHI9YXN5bmMgcz0+e2lmKGcocyxlKSYmIXMuZGF0YS5yZWxheWVkKXtsZXQgbz17bmFtZTplLm5hbWUscmVsYXlJZDplLnJlbGF5SWQsYm9keTpzLmRhdGEuYm9keX0sdD1hd2FpdCBhPy4obyk7bi5wb3N0TWVzc2FnZSh7bmFtZTplLm5hbWUscmVsYXlJZDplLnJlbGF5SWQsaW5zdGFuY2VJZDpzLmRhdGEuaW5zdGFuY2VJZCxib2R5OnQscmVsYXllZDohMH0se3RhcmdldE9yaWdpbjplLnRhcmdldE9yaWdpbnx8XCIvXCJ9KX19O3JldHVybiBuLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsciksKCk9Pm4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIixyKX0seT0oZSxhPWdsb2JhbFRoaXMud2luZG93KT0+bmV3IFByb21pc2UoKG4scik9PntsZXQgcz1iKCksbz1uZXcgQWJvcnRDb250cm9sbGVyO2EuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIix0PT57Zyh0LGUpJiZ0LmRhdGEucmVsYXllZCYmdC5kYXRhLmluc3RhbmNlSWQ9PT1zJiYobih0LmRhdGEuYm9keSksby5hYm9ydCgpKX0se3NpZ25hbDpvLnNpZ25hbH0pLGEucG9zdE1lc3NhZ2Uoey4uLmUsaW5zdGFuY2VJZDpzfSx7dGFyZ2V0T3JpZ2luOmUudGFyZ2V0T3JpZ2lufHxcIi9cIn0pfSk7dmFyIHA9YXN5bmMgZT0+ZCgpLnNlbmRNZXNzYWdlKGUuZXh0ZW5zaW9uSWQ/P251bGwsZSkseD1hc3luYyBlPT57bGV0IGE9dHlwZW9mIGUudGFiSWQ9PVwibnVtYmVyXCI/ZS50YWJJZDooYXdhaXQgbSgpKT8uaWQ7aWYoIWEpdGhyb3cgbmV3IEVycm9yKFwiTm8gYWN0aXZlIHRhYiBmb3VuZCB0byBzZW5kIG1lc3NhZ2UgdG8uXCIpO3JldHVybiBpKCkuc2VuZE1lc3NhZ2UoYSxlKX0saD14LE09ZT0+YyhlLHApLEU9TSx1PXksUz11O2V4cG9ydHtFIGFzIHJlbGF5LE0gYXMgcmVsYXlNZXNzYWdlLGggYXMgc2VuZFRvQWN0aXZlQ29udGVudFNjcmlwdCxwIGFzIHNlbmRUb0JhY2tncm91bmQsdSBhcyBzZW5kVG9CYWNrZ3JvdW5kVmlhUmVsYXkseCBhcyBzZW5kVG9Db250ZW50U2NyaXB0LFMgYXMgc2VuZFZpYVJlbGF5fTtcbiIsImV4cG9ydCB7IHVybEFscGhhYmV0IH0gZnJvbSAnLi91cmwtYWxwaGFiZXQvaW5kZXguanMnXG5leHBvcnQgbGV0IHJhbmRvbSA9IGJ5dGVzID0+IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXMpKVxuZXhwb3J0IGxldCBjdXN0b21SYW5kb20gPSAoYWxwaGFiZXQsIGRlZmF1bHRTaXplLCBnZXRSYW5kb20pID0+IHtcbiAgbGV0IG1hc2sgPSAoMiA8PCAoTWF0aC5sb2coYWxwaGFiZXQubGVuZ3RoIC0gMSkgLyBNYXRoLkxOMikpIC0gMVxuICBsZXQgc3RlcCA9IC1+KCgxLjYgKiBtYXNrICogZGVmYXVsdFNpemUpIC8gYWxwaGFiZXQubGVuZ3RoKVxuICByZXR1cm4gKHNpemUgPSBkZWZhdWx0U2l6ZSkgPT4ge1xuICAgIGxldCBpZCA9ICcnXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGxldCBieXRlcyA9IGdldFJhbmRvbShzdGVwKVxuICAgICAgbGV0IGogPSBzdGVwXG4gICAgICB3aGlsZSAoai0tKSB7XG4gICAgICAgIGlkICs9IGFscGhhYmV0W2J5dGVzW2pdICYgbWFza10gfHwgJydcbiAgICAgICAgaWYgKGlkLmxlbmd0aCA9PT0gc2l6ZSkgcmV0dXJuIGlkXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5leHBvcnQgbGV0IGN1c3RvbUFscGhhYmV0ID0gKGFscGhhYmV0LCBzaXplID0gMjEpID0+XG4gIGN1c3RvbVJhbmRvbShhbHBoYWJldCwgc2l6ZSwgcmFuZG9tKVxuZXhwb3J0IGxldCBuYW5vaWQgPSAoc2l6ZSA9IDIxKSA9PlxuICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KHNpemUpKS5yZWR1Y2UoKGlkLCBieXRlKSA9PiB7XG4gICAgYnl0ZSAmPSA2M1xuICAgIGlmIChieXRlIDwgMzYpIHtcbiAgICAgIGlkICs9IGJ5dGUudG9TdHJpbmcoMzYpXG4gICAgfSBlbHNlIGlmIChieXRlIDwgNjIpIHtcbiAgICAgIGlkICs9IChieXRlIC0gMjYpLnRvU3RyaW5nKDM2KS50b1VwcGVyQ2FzZSgpXG4gICAgfSBlbHNlIGlmIChieXRlID4gNjIpIHtcbiAgICAgIGlkICs9ICctJ1xuICAgIH0gZWxzZSB7XG4gICAgICBpZCArPSAnXydcbiAgICB9XG4gICAgcmV0dXJuIGlkXG4gIH0sICcnKVxuIiwiZXhwb3J0cy5pbnRlcm9wRGVmYXVsdCA9IGZ1bmN0aW9uIChhKSB7XG4gIHJldHVybiBhICYmIGEuX19lc01vZHVsZSA/IGEgOiB7ZGVmYXVsdDogYX07XG59O1xuXG5leHBvcnRzLmRlZmluZUludGVyb3BGbGFnID0gZnVuY3Rpb24gKGEpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGEsICdfX2VzTW9kdWxlJywge3ZhbHVlOiB0cnVlfSk7XG59O1xuXG5leHBvcnRzLmV4cG9ydEFsbCA9IGZ1bmN0aW9uIChzb3VyY2UsIGRlc3QpIHtcbiAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoa2V5ID09PSAnZGVmYXVsdCcgfHwga2V5ID09PSAnX19lc01vZHVsZScgfHwgZGVzdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlc3QsIGtleSwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc291cmNlW2tleV07XG4gICAgICB9LFxuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmV4cG9ydHMuZXhwb3J0ID0gZnVuY3Rpb24gKGRlc3QsIGRlc3ROYW1lLCBnZXQpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlc3QsIGRlc3ROYW1lLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGdldCxcbiAgfSk7XG59O1xuIiwiaW1wb3J0IHsgVGFyZ2V0ZWRDb29raWUsIHRhcmdldGVkQ29va2llcyB9IGZyb20gXCJ+Y29uZmlnL3RhcmdldGVkQ29va2llc1wiXG5pbXBvcnQgdHlwZSB7IENocm9tZUNvb2tpZSwgQ29va2llU2FtZVNpdGVTdGF0dXMgfSBmcm9tIFwifnR5cGVzXCJcbmltcG9ydCB0eXBlIHsgQ29va2llRFRPIH0gZnJvbSBcIn50eXBlcy9kdG9cIlxuXG5jb25zdCBzYW1lU2l0ZU1hcDogUmVjb3JkPENvb2tpZVNhbWVTaXRlU3RhdHVzLCBDb29raWVEVE9bXCJzYW1lU2l0ZVwiXT4gPSB7XG4gIHVuc3BlY2lmaWVkOiBcIkxheFwiLFxuICBub19yZXN0cmljdGlvbjogXCJOb25lXCIsXG4gIGxheDogXCJMYXhcIixcbiAgc3RyaWN0OiBcIlN0cmljdFwiXG59XG5cbmNvbnN0IG1hcENocm9tZUNvb2tpZSA9IChcbiAgY29va2llOiBDaHJvbWVDb29raWUsXG4gIGN1c3RvbVByb3BzPzogUGFydGlhbDxDb29raWVEVE8+XG4pOiBDb29raWVEVE8gPT4gKHtcbiAgLi4uY29va2llLFxuICBleHBpcmVzOiBjb29raWUuZXhwaXJhdGlvbkRhdGUsXG4gIHNhbWVTaXRlOiBzYW1lU2l0ZU1hcFtjb29raWUuc2FtZVNpdGVdLFxuICAuLi4oY3VzdG9tUHJvcHMgPz8ge30pXG59KVxuXG5leHBvcnQgY29uc3QgZ2V0Q29va2llcyA9IGFzeW5jIChkb21haW46IHN0cmluZyk6IFByb21pc2U8Q29va2llRFRPW10+ID0+IHtcbiAgY29uc3QgY29va2llczogQ29va2llRFRPW10gPSBbXVxuICBjb25zdCBnZW5lcmFsQ29va2llcyA9IGF3YWl0IGNocm9tZS5jb29raWVzLmdldEFsbCh7ZG9tYWlufSlcbiAgY29va2llcy5wdXNoKC4uLmdlbmVyYWxDb29raWVzLm1hcCgoYykgPT4gbWFwQ2hyb21lQ29va2llKGMpKSlcblxuICByZXR1cm4gY29va2llc1xufVxuIiwiZXhwb3J0IGNvbnN0IExTX0tFWVMgPSB7XG4gIFVTRVJfREFUQTogXCJ1c2VyX2RhdGFcIlxufVxuXG5leHBvcnQgY29uc3QgTUVTU0FHRV9OQU1FUyA9IHtcbiAgRkVUQ0hfU0VTU0lPTjogXCJmZXRjaF9zZXNzaW9uXCJcbn1cbiIsImltcG9ydCBheGlvcyBmcm9tIFwiYXhpb3NcIlxuXG5pbXBvcnQgdHlwZSB7IFNlc3Npb25EVE8gfSBmcm9tIFwifnR5cGVzL2R0b1wiXG5cbmltcG9ydCB7IGdldEF1dGhIZWFkZXJzIH0gZnJvbSBcIi4vYmFja2dyb3VuZC9hdXRoXCJcbmltcG9ydCB7IGVycm9yTWVzc2FnZSB9IGZyb20gXCIuL3V0aWxzXCJcblxuY29uc3Qge1xuICBOT0RFX0VOVixcbiAgUExBU01PX1BVQkxJQ19MT0NBTF9BUElfVVJMOiBMT0NBTF9VUkwsXG4gIFBMQVNNT19QVUJMSUNfUFJPRFVDVElPTl9BUElfVVJMOiBMSVZFX1VSTFxufSA9IHByb2Nlc3MuZW52XG5cbmNvbnN0IEFQSV9VUkwgPSBOT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiID8gTE9DQUxfVVJMIDogTElWRV9VUkxcblxuY29uc3QgY2xpZW50ID0gYXhpb3MuY3JlYXRlKHtcbiAgYmFzZVVSTDogQVBJX1VSTCxcbiAgd2l0aENyZWRlbnRpYWxzOiBmYWxzZVxufSlcblxuZXhwb3J0IGNvbnN0IHN1Ym1pdFNlc3Npb24gPSBhc3luYyAoc2Vzc2lvbjogU2Vzc2lvbkRUTykgPT4ge1xuICB0cnkge1xuICAgIC8vIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDMwMDApKVxuICAgIC8vIHJldHVyblxuICAgIGNvbnN0IGNvbmZpZyA9IGF3YWl0IGdldEF1dGhIZWFkZXJzKClcbiAgICByZXR1cm4gY2xpZW50LnBvc3QoXCIvdXNlci9zZXNzaW9uXCIsIHNlc3Npb24sIGNvbmZpZylcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgZXJyb3JNZXNzYWdlKGVycilcbiAgfVxufVxuIiwiaW1wb3J0IGF4aW9zIGZyb20gJy4vbGliL2F4aW9zLmpzJztcblxuLy8gVGhpcyBtb2R1bGUgaXMgaW50ZW5kZWQgdG8gdW53cmFwIEF4aW9zIGRlZmF1bHQgZXhwb3J0IGFzIG5hbWVkLlxuLy8gS2VlcCB0b3AtbGV2ZWwgZXhwb3J0IHNhbWUgd2l0aCBzdGF0aWMgcHJvcGVydGllc1xuLy8gc28gdGhhdCBpdCBjYW4ga2VlcCBzYW1lIHdpdGggZXMgbW9kdWxlIG9yIGNqc1xuY29uc3Qge1xuICBBeGlvcyxcbiAgQXhpb3NFcnJvcixcbiAgQ2FuY2VsZWRFcnJvcixcbiAgaXNDYW5jZWwsXG4gIENhbmNlbFRva2VuLFxuICBWRVJTSU9OLFxuICBhbGwsXG4gIENhbmNlbCxcbiAgaXNBeGlvc0Vycm9yLFxuICBzcHJlYWQsXG4gIHRvRm9ybURhdGEsXG4gIEF4aW9zSGVhZGVycyxcbiAgSHR0cFN0YXR1c0NvZGUsXG4gIGZvcm1Ub0pTT04sXG4gIGdldEFkYXB0ZXIsXG4gIG1lcmdlQ29uZmlnXG59ID0gYXhpb3M7XG5cbmV4cG9ydCB7XG4gIGF4aW9zIGFzIGRlZmF1bHQsXG4gIEF4aW9zLFxuICBBeGlvc0Vycm9yLFxuICBDYW5jZWxlZEVycm9yLFxuICBpc0NhbmNlbCxcbiAgQ2FuY2VsVG9rZW4sXG4gIFZFUlNJT04sXG4gIGFsbCxcbiAgQ2FuY2VsLFxuICBpc0F4aW9zRXJyb3IsXG4gIHNwcmVhZCxcbiAgdG9Gb3JtRGF0YSxcbiAgQXhpb3NIZWFkZXJzLFxuICBIdHRwU3RhdHVzQ29kZSxcbiAgZm9ybVRvSlNPTixcbiAgZ2V0QWRhcHRlcixcbiAgbWVyZ2VDb25maWdcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IGJpbmQgZnJvbSAnLi9oZWxwZXJzL2JpbmQuanMnO1xuaW1wb3J0IEF4aW9zIGZyb20gJy4vY29yZS9BeGlvcy5qcyc7XG5pbXBvcnQgbWVyZ2VDb25maWcgZnJvbSAnLi9jb3JlL21lcmdlQ29uZmlnLmpzJztcbmltcG9ydCBkZWZhdWx0cyBmcm9tICcuL2RlZmF1bHRzL2luZGV4LmpzJztcbmltcG9ydCBmb3JtRGF0YVRvSlNPTiBmcm9tICcuL2hlbHBlcnMvZm9ybURhdGFUb0pTT04uanMnO1xuaW1wb3J0IENhbmNlbGVkRXJyb3IgZnJvbSAnLi9jYW5jZWwvQ2FuY2VsZWRFcnJvci5qcyc7XG5pbXBvcnQgQ2FuY2VsVG9rZW4gZnJvbSAnLi9jYW5jZWwvQ2FuY2VsVG9rZW4uanMnO1xuaW1wb3J0IGlzQ2FuY2VsIGZyb20gJy4vY2FuY2VsL2lzQ2FuY2VsLmpzJztcbmltcG9ydCB7VkVSU0lPTn0gZnJvbSAnLi9lbnYvZGF0YS5qcyc7XG5pbXBvcnQgdG9Gb3JtRGF0YSBmcm9tICcuL2hlbHBlcnMvdG9Gb3JtRGF0YS5qcyc7XG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tICcuL2NvcmUvQXhpb3NFcnJvci5qcyc7XG5pbXBvcnQgc3ByZWFkIGZyb20gJy4vaGVscGVycy9zcHJlYWQuanMnO1xuaW1wb3J0IGlzQXhpb3NFcnJvciBmcm9tICcuL2hlbHBlcnMvaXNBeGlvc0Vycm9yLmpzJztcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSBcIi4vY29yZS9BeGlvc0hlYWRlcnMuanNcIjtcbmltcG9ydCBhZGFwdGVycyBmcm9tICcuL2FkYXB0ZXJzL2FkYXB0ZXJzLmpzJztcbmltcG9ydCBIdHRwU3RhdHVzQ29kZSBmcm9tICcuL2hlbHBlcnMvSHR0cFN0YXR1c0NvZGUuanMnO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0Q29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKlxuICogQHJldHVybnMge0F4aW9zfSBBIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICovXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZShkZWZhdWx0Q29uZmlnKSB7XG4gIGNvbnN0IGNvbnRleHQgPSBuZXcgQXhpb3MoZGVmYXVsdENvbmZpZyk7XG4gIGNvbnN0IGluc3RhbmNlID0gYmluZChBeGlvcy5wcm90b3R5cGUucmVxdWVzdCwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBheGlvcy5wcm90b3R5cGUgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBBeGlvcy5wcm90b3R5cGUsIGNvbnRleHQsIHthbGxPd25LZXlzOiB0cnVlfSk7XG5cbiAgLy8gQ29weSBjb250ZXh0IHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgY29udGV4dCwgbnVsbCwge2FsbE93bktleXM6IHRydWV9KTtcblxuICAvLyBGYWN0b3J5IGZvciBjcmVhdGluZyBuZXcgaW5zdGFuY2VzXG4gIGluc3RhbmNlLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpbnN0YW5jZUNvbmZpZykge1xuICAgIHJldHVybiBjcmVhdGVJbnN0YW5jZShtZXJnZUNvbmZpZyhkZWZhdWx0Q29uZmlnLCBpbnN0YW5jZUNvbmZpZykpO1xuICB9O1xuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuLy8gQ3JlYXRlIHRoZSBkZWZhdWx0IGluc3RhbmNlIHRvIGJlIGV4cG9ydGVkXG5jb25zdCBheGlvcyA9IGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRzKTtcblxuLy8gRXhwb3NlIEF4aW9zIGNsYXNzIHRvIGFsbG93IGNsYXNzIGluaGVyaXRhbmNlXG5heGlvcy5BeGlvcyA9IEF4aW9zO1xuXG4vLyBFeHBvc2UgQ2FuY2VsICYgQ2FuY2VsVG9rZW5cbmF4aW9zLkNhbmNlbGVkRXJyb3IgPSBDYW5jZWxlZEVycm9yO1xuYXhpb3MuQ2FuY2VsVG9rZW4gPSBDYW5jZWxUb2tlbjtcbmF4aW9zLmlzQ2FuY2VsID0gaXNDYW5jZWw7XG5heGlvcy5WRVJTSU9OID0gVkVSU0lPTjtcbmF4aW9zLnRvRm9ybURhdGEgPSB0b0Zvcm1EYXRhO1xuXG4vLyBFeHBvc2UgQXhpb3NFcnJvciBjbGFzc1xuYXhpb3MuQXhpb3NFcnJvciA9IEF4aW9zRXJyb3I7XG5cbi8vIGFsaWFzIGZvciBDYW5jZWxlZEVycm9yIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5heGlvcy5DYW5jZWwgPSBheGlvcy5DYW5jZWxlZEVycm9yO1xuXG4vLyBFeHBvc2UgYWxsL3NwcmVhZFxuYXhpb3MuYWxsID0gZnVuY3Rpb24gYWxsKHByb21pc2VzKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG59O1xuXG5heGlvcy5zcHJlYWQgPSBzcHJlYWQ7XG5cbi8vIEV4cG9zZSBpc0F4aW9zRXJyb3JcbmF4aW9zLmlzQXhpb3NFcnJvciA9IGlzQXhpb3NFcnJvcjtcblxuLy8gRXhwb3NlIG1lcmdlQ29uZmlnXG5heGlvcy5tZXJnZUNvbmZpZyA9IG1lcmdlQ29uZmlnO1xuXG5heGlvcy5BeGlvc0hlYWRlcnMgPSBBeGlvc0hlYWRlcnM7XG5cbmF4aW9zLmZvcm1Ub0pTT04gPSB0aGluZyA9PiBmb3JtRGF0YVRvSlNPTih1dGlscy5pc0hUTUxGb3JtKHRoaW5nKSA/IG5ldyBGb3JtRGF0YSh0aGluZykgOiB0aGluZyk7XG5cbmF4aW9zLmdldEFkYXB0ZXIgPSBhZGFwdGVycy5nZXRBZGFwdGVyO1xuXG5heGlvcy5IdHRwU3RhdHVzQ29kZSA9IEh0dHBTdGF0dXNDb2RlO1xuXG5heGlvcy5kZWZhdWx0ID0gYXhpb3M7XG5cbi8vIHRoaXMgbW9kdWxlIHNob3VsZCBvbmx5IGhhdmUgYSBkZWZhdWx0IGV4cG9ydFxuZXhwb3J0IGRlZmF1bHQgYXhpb3NcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IGJpbmQgZnJvbSAnLi9oZWxwZXJzL2JpbmQuanMnO1xuXG4vLyB1dGlscyBpcyBhIGxpYnJhcnkgb2YgZ2VuZXJpYyBoZWxwZXIgZnVuY3Rpb25zIG5vbi1zcGVjaWZpYyB0byBheGlvc1xuXG5jb25zdCB7dG9TdHJpbmd9ID0gT2JqZWN0LnByb3RvdHlwZTtcbmNvbnN0IHtnZXRQcm90b3R5cGVPZn0gPSBPYmplY3Q7XG5cbmNvbnN0IGtpbmRPZiA9IChjYWNoZSA9PiB0aGluZyA9PiB7XG4gICAgY29uc3Qgc3RyID0gdG9TdHJpbmcuY2FsbCh0aGluZyk7XG4gICAgcmV0dXJuIGNhY2hlW3N0cl0gfHwgKGNhY2hlW3N0cl0gPSBzdHIuc2xpY2UoOCwgLTEpLnRvTG93ZXJDYXNlKCkpO1xufSkoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG5cbmNvbnN0IGtpbmRPZlRlc3QgPSAodHlwZSkgPT4ge1xuICB0eXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gKHRoaW5nKSA9PiBraW5kT2YodGhpbmcpID09PSB0eXBlXG59XG5cbmNvbnN0IHR5cGVPZlRlc3QgPSB0eXBlID0+IHRoaW5nID0+IHR5cGVvZiB0aGluZyA9PT0gdHlwZTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IHtpc0FycmF5fSA9IEFycmF5O1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIHVuZGVmaW5lZFxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGlzIHVuZGVmaW5lZCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzVW5kZWZpbmVkID0gdHlwZU9mVGVzdCgndW5kZWZpbmVkJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCdWZmZXJcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNCdWZmZXIodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgIWlzVW5kZWZpbmVkKHZhbCkgJiYgdmFsLmNvbnN0cnVjdG9yICE9PSBudWxsICYmICFpc1VuZGVmaW5lZCh2YWwuY29uc3RydWN0b3IpXG4gICAgJiYgaXNGdW5jdGlvbih2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIpICYmIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlcih2YWwpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzQXJyYXlCdWZmZXIgPSBraW5kT2ZUZXN0KCdBcnJheUJ1ZmZlcicpO1xuXG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyh2YWwpIHtcbiAgbGV0IHJlc3VsdDtcbiAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnKSAmJiAoQXJyYXlCdWZmZXIuaXNWaWV3KSkge1xuICAgIHJlc3VsdCA9IEFycmF5QnVmZmVyLmlzVmlldyh2YWwpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9ICh2YWwpICYmICh2YWwuYnVmZmVyKSAmJiAoaXNBcnJheUJ1ZmZlcih2YWwuYnVmZmVyKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmluZ1xuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJpbmcsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc1N0cmluZyA9IHR5cGVPZlRlc3QoJ3N0cmluZycpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGdW5jdGlvbiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzRnVuY3Rpb24gPSB0eXBlT2ZUZXN0KCdmdW5jdGlvbicpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgTnVtYmVyXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIE51bWJlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzTnVtYmVyID0gdHlwZU9mVGVzdCgnbnVtYmVyJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gT2JqZWN0XG4gKlxuICogQHBhcmFtIHsqfSB0aGluZyBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIE9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzT2JqZWN0ID0gKHRoaW5nKSA9PiB0aGluZyAhPT0gbnVsbCAmJiB0eXBlb2YgdGhpbmcgPT09ICdvYmplY3QnO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQm9vbGVhblxuICpcbiAqIEBwYXJhbSB7Kn0gdGhpbmcgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQm9vbGVhbiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzQm9vbGVhbiA9IHRoaW5nID0+IHRoaW5nID09PSB0cnVlIHx8IHRoaW5nID09PSBmYWxzZTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIHBsYWluIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc1BsYWluT2JqZWN0ID0gKHZhbCkgPT4ge1xuICBpZiAoa2luZE9mKHZhbCkgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgcHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YodmFsKTtcbiAgcmV0dXJuIChwcm90b3R5cGUgPT09IG51bGwgfHwgcHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90b3R5cGUpID09PSBudWxsKSAmJiAhKFN5bWJvbC50b1N0cmluZ1RhZyBpbiB2YWwpICYmICEoU3ltYm9sLml0ZXJhdG9yIGluIHZhbCk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBEYXRlXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIERhdGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0RhdGUgPSBraW5kT2ZUZXN0KCdEYXRlJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGaWxlXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZpbGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0ZpbGUgPSBraW5kT2ZUZXN0KCdGaWxlJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCbG9iXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJsb2IsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0Jsb2IgPSBraW5kT2ZUZXN0KCdCbG9iJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGaWxlTGlzdFxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGaWxlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNGaWxlTGlzdCA9IGtpbmRPZlRlc3QoJ0ZpbGVMaXN0Jyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJlYW1cbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyZWFtLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNTdHJlYW0gPSAodmFsKSA9PiBpc09iamVjdCh2YWwpICYmIGlzRnVuY3Rpb24odmFsLnBpcGUpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRm9ybURhdGFcbiAqXG4gKiBAcGFyYW0geyp9IHRoaW5nIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gRm9ybURhdGEsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0Zvcm1EYXRhID0gKHRoaW5nKSA9PiB7XG4gIGxldCBraW5kO1xuICByZXR1cm4gdGhpbmcgJiYgKFxuICAgICh0eXBlb2YgRm9ybURhdGEgPT09ICdmdW5jdGlvbicgJiYgdGhpbmcgaW5zdGFuY2VvZiBGb3JtRGF0YSkgfHwgKFxuICAgICAgaXNGdW5jdGlvbih0aGluZy5hcHBlbmQpICYmIChcbiAgICAgICAgKGtpbmQgPSBraW5kT2YodGhpbmcpKSA9PT0gJ2Zvcm1kYXRhJyB8fFxuICAgICAgICAvLyBkZXRlY3QgZm9ybS1kYXRhIGluc3RhbmNlXG4gICAgICAgIChraW5kID09PSAnb2JqZWN0JyAmJiBpc0Z1bmN0aW9uKHRoaW5nLnRvU3RyaW5nKSAmJiB0aGluZy50b1N0cmluZygpID09PSAnW29iamVjdCBGb3JtRGF0YV0nKVxuICAgICAgKVxuICAgIClcbiAgKVxufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNVUkxTZWFyY2hQYXJhbXMgPSBraW5kT2ZUZXN0KCdVUkxTZWFyY2hQYXJhbXMnKTtcblxuY29uc3QgW2lzUmVhZGFibGVTdHJlYW0sIGlzUmVxdWVzdCwgaXNSZXNwb25zZSwgaXNIZWFkZXJzXSA9IFsnUmVhZGFibGVTdHJlYW0nLCAnUmVxdWVzdCcsICdSZXNwb25zZScsICdIZWFkZXJzJ10ubWFwKGtpbmRPZlRlc3QpO1xuXG4vKipcbiAqIFRyaW0gZXhjZXNzIHdoaXRlc3BhY2Ugb2ZmIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIFN0cmluZyB0byB0cmltXG4gKlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFN0cmluZyBmcmVlZCBvZiBleGNlc3Mgd2hpdGVzcGFjZVxuICovXG5jb25zdCB0cmltID0gKHN0cikgPT4gc3RyLnRyaW0gP1xuICBzdHIudHJpbSgpIDogc3RyLnJlcGxhY2UoL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nLCAnJyk7XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFuIEFycmF5IG9yIGFuIE9iamVjdCBpbnZva2luZyBhIGZ1bmN0aW9uIGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgYG9iamAgaXMgYW4gQXJyYXkgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBpbmRleCwgYW5kIGNvbXBsZXRlIGFycmF5IGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgJ29iaicgaXMgYW4gT2JqZWN0IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwga2V5LCBhbmQgY29tcGxldGUgb2JqZWN0IGZvciBlYWNoIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmogVGhlIG9iamVjdCB0byBpdGVyYXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIGZvciBlYWNoIGl0ZW1cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFthbGxPd25LZXlzID0gZmFsc2VdXG4gKiBAcmV0dXJucyB7YW55fVxuICovXG5mdW5jdGlvbiBmb3JFYWNoKG9iaiwgZm4sIHthbGxPd25LZXlzID0gZmFsc2V9ID0ge30pIHtcbiAgLy8gRG9uJ3QgYm90aGVyIGlmIG5vIHZhbHVlIHByb3ZpZGVkXG4gIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgaTtcbiAgbGV0IGw7XG5cbiAgLy8gRm9yY2UgYW4gYXJyYXkgaWYgbm90IGFscmVhZHkgc29tZXRoaW5nIGl0ZXJhYmxlXG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIG9iaiA9IFtvYmpdO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBhcnJheSB2YWx1ZXNcbiAgICBmb3IgKGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZm4uY2FsbChudWxsLCBvYmpbaV0sIGksIG9iaik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBvYmplY3Qga2V5c1xuICAgIGNvbnN0IGtleXMgPSBhbGxPd25LZXlzID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKSA6IE9iamVjdC5rZXlzKG9iaik7XG4gICAgY29uc3QgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgbGV0IGtleTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZEtleShvYmosIGtleSkge1xuICBrZXkgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGxldCBpID0ga2V5cy5sZW5ndGg7XG4gIGxldCBfa2V5O1xuICB3aGlsZSAoaS0tID4gMCkge1xuICAgIF9rZXkgPSBrZXlzW2ldO1xuICAgIGlmIChrZXkgPT09IF9rZXkudG9Mb3dlckNhc2UoKSkge1xuICAgICAgcmV0dXJuIF9rZXk7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5jb25zdCBfZ2xvYmFsID0gKCgpID0+IHtcbiAgLyplc2xpbnQgbm8tdW5kZWY6MCovXG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGdsb2JhbFRoaXM7XG4gIHJldHVybiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBnbG9iYWwpXG59KSgpO1xuXG5jb25zdCBpc0NvbnRleHREZWZpbmVkID0gKGNvbnRleHQpID0+ICFpc1VuZGVmaW5lZChjb250ZXh0KSAmJiBjb250ZXh0ICE9PSBfZ2xvYmFsO1xuXG4vKipcbiAqIEFjY2VwdHMgdmFyYXJncyBleHBlY3RpbmcgZWFjaCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3QsIHRoZW5cbiAqIGltbXV0YWJseSBtZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgZWFjaCBvYmplY3QgYW5kIHJldHVybnMgcmVzdWx0LlxuICpcbiAqIFdoZW4gbXVsdGlwbGUgb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIGtleSB0aGUgbGF0ZXIgb2JqZWN0IGluXG4gKiB0aGUgYXJndW1lbnRzIGxpc3Qgd2lsbCB0YWtlIHByZWNlZGVuY2UuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogdmFyIHJlc3VsdCA9IG1lcmdlKHtmb286IDEyM30sIHtmb286IDQ1Nn0pO1xuICogY29uc29sZS5sb2cocmVzdWx0LmZvbyk7IC8vIG91dHB1dHMgNDU2XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqMSBPYmplY3QgdG8gbWVyZ2VcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXN1bHQgb2YgYWxsIG1lcmdlIHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gbWVyZ2UoLyogb2JqMSwgb2JqMiwgb2JqMywgLi4uICovKSB7XG4gIGNvbnN0IHtjYXNlbGVzc30gPSBpc0NvbnRleHREZWZpbmVkKHRoaXMpICYmIHRoaXMgfHwge307XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBjb25zdCBhc3NpZ25WYWx1ZSA9ICh2YWwsIGtleSkgPT4ge1xuICAgIGNvbnN0IHRhcmdldEtleSA9IGNhc2VsZXNzICYmIGZpbmRLZXkocmVzdWx0LCBrZXkpIHx8IGtleTtcbiAgICBpZiAoaXNQbGFpbk9iamVjdChyZXN1bHRbdGFyZ2V0S2V5XSkgJiYgaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgICByZXN1bHRbdGFyZ2V0S2V5XSA9IG1lcmdlKHJlc3VsdFt0YXJnZXRLZXldLCB2YWwpO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgICByZXN1bHRbdGFyZ2V0S2V5XSA9IG1lcmdlKHt9LCB2YWwpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWwpKSB7XG4gICAgICByZXN1bHRbdGFyZ2V0S2V5XSA9IHZhbC5zbGljZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRbdGFyZ2V0S2V5XSA9IHZhbDtcbiAgICB9XG4gIH1cblxuICBmb3IgKGxldCBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBhcmd1bWVudHNbaV0gJiYgZm9yRWFjaChhcmd1bWVudHNbaV0sIGFzc2lnblZhbHVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEV4dGVuZHMgb2JqZWN0IGEgYnkgbXV0YWJseSBhZGRpbmcgdG8gaXQgdGhlIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGEgVGhlIG9iamVjdCB0byBiZSBleHRlbmRlZFxuICogQHBhcmFtIHtPYmplY3R9IGIgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogQHBhcmFtIHtPYmplY3R9IHRoaXNBcmcgVGhlIG9iamVjdCB0byBiaW5kIGZ1bmN0aW9uIHRvXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBbYWxsT3duS2V5c11cbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSByZXN1bHRpbmcgdmFsdWUgb2Ygb2JqZWN0IGFcbiAqL1xuY29uc3QgZXh0ZW5kID0gKGEsIGIsIHRoaXNBcmcsIHthbGxPd25LZXlzfT0ge30pID0+IHtcbiAgZm9yRWFjaChiLCAodmFsLCBrZXkpID0+IHtcbiAgICBpZiAodGhpc0FyZyAmJiBpc0Z1bmN0aW9uKHZhbCkpIHtcbiAgICAgIGFba2V5XSA9IGJpbmQodmFsLCB0aGlzQXJnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYVtrZXldID0gdmFsO1xuICAgIH1cbiAgfSwge2FsbE93bktleXN9KTtcbiAgcmV0dXJuIGE7XG59XG5cbi8qKlxuICogUmVtb3ZlIGJ5dGUgb3JkZXIgbWFya2VyLiBUaGlzIGNhdGNoZXMgRUYgQkIgQkYgKHRoZSBVVEYtOCBCT00pXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnQgd2l0aCBCT01cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBjb250ZW50IHZhbHVlIHdpdGhvdXQgQk9NXG4gKi9cbmNvbnN0IHN0cmlwQk9NID0gKGNvbnRlbnQpID0+IHtcbiAgaWYgKGNvbnRlbnQuY2hhckNvZGVBdCgwKSA9PT0gMHhGRUZGKSB7XG4gICAgY29udGVudCA9IGNvbnRlbnQuc2xpY2UoMSk7XG4gIH1cbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IFtwcm9wc11cbiAqIEBwYXJhbSB7b2JqZWN0fSBbZGVzY3JpcHRvcnNdXG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmNvbnN0IGluaGVyaXRzID0gKGNvbnN0cnVjdG9yLCBzdXBlckNvbnN0cnVjdG9yLCBwcm9wcywgZGVzY3JpcHRvcnMpID0+IHtcbiAgY29uc3RydWN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNvbnN0cnVjdG9yLnByb3RvdHlwZSwgZGVzY3JpcHRvcnMpO1xuICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjb25zdHJ1Y3RvcjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnN0cnVjdG9yLCAnc3VwZXInLCB7XG4gICAgdmFsdWU6IHN1cGVyQ29uc3RydWN0b3IucHJvdG90eXBlXG4gIH0pO1xuICBwcm9wcyAmJiBPYmplY3QuYXNzaWduKGNvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvcHMpO1xufVxuXG4vKipcbiAqIFJlc29sdmUgb2JqZWN0IHdpdGggZGVlcCBwcm90b3R5cGUgY2hhaW4gdG8gYSBmbGF0IG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZU9iaiBzb3VyY2Ugb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gW2Rlc3RPYmpdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufEJvb2xlYW59IFtmaWx0ZXJdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJvcEZpbHRlcl1cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5jb25zdCB0b0ZsYXRPYmplY3QgPSAoc291cmNlT2JqLCBkZXN0T2JqLCBmaWx0ZXIsIHByb3BGaWx0ZXIpID0+IHtcbiAgbGV0IHByb3BzO1xuICBsZXQgaTtcbiAgbGV0IHByb3A7XG4gIGNvbnN0IG1lcmdlZCA9IHt9O1xuXG4gIGRlc3RPYmogPSBkZXN0T2JqIHx8IHt9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXEtbnVsbCxlcWVxZXFcbiAgaWYgKHNvdXJjZU9iaiA9PSBudWxsKSByZXR1cm4gZGVzdE9iajtcblxuICBkbyB7XG4gICAgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2VPYmopO1xuICAgIGkgPSBwcm9wcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgIHByb3AgPSBwcm9wc1tpXTtcbiAgICAgIGlmICgoIXByb3BGaWx0ZXIgfHwgcHJvcEZpbHRlcihwcm9wLCBzb3VyY2VPYmosIGRlc3RPYmopKSAmJiAhbWVyZ2VkW3Byb3BdKSB7XG4gICAgICAgIGRlc3RPYmpbcHJvcF0gPSBzb3VyY2VPYmpbcHJvcF07XG4gICAgICAgIG1lcmdlZFtwcm9wXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHNvdXJjZU9iaiA9IGZpbHRlciAhPT0gZmFsc2UgJiYgZ2V0UHJvdG90eXBlT2Yoc291cmNlT2JqKTtcbiAgfSB3aGlsZSAoc291cmNlT2JqICYmICghZmlsdGVyIHx8IGZpbHRlcihzb3VyY2VPYmosIGRlc3RPYmopKSAmJiBzb3VyY2VPYmogIT09IE9iamVjdC5wcm90b3R5cGUpO1xuXG4gIHJldHVybiBkZXN0T2JqO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBhIHN0cmluZyBlbmRzIHdpdGggdGhlIGNoYXJhY3RlcnMgb2YgYSBzcGVjaWZpZWQgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtTdHJpbmd9IHNlYXJjaFN0cmluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IFtwb3NpdGlvbj0gMF1cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgZW5kc1dpdGggPSAoc3RyLCBzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKSA9PiB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCB8fCBwb3NpdGlvbiA+IHN0ci5sZW5ndGgpIHtcbiAgICBwb3NpdGlvbiA9IHN0ci5sZW5ndGg7XG4gIH1cbiAgcG9zaXRpb24gLT0gc2VhcmNoU3RyaW5nLmxlbmd0aDtcbiAgY29uc3QgbGFzdEluZGV4ID0gc3RyLmluZGV4T2Yoc2VhcmNoU3RyaW5nLCBwb3NpdGlvbik7XG4gIHJldHVybiBsYXN0SW5kZXggIT09IC0xICYmIGxhc3RJbmRleCA9PT0gcG9zaXRpb247XG59XG5cblxuLyoqXG4gKiBSZXR1cm5zIG5ldyBhcnJheSBmcm9tIGFycmF5IGxpa2Ugb2JqZWN0IG9yIG51bGwgaWYgZmFpbGVkXG4gKlxuICogQHBhcmFtIHsqfSBbdGhpbmddXG4gKlxuICogQHJldHVybnMgez9BcnJheX1cbiAqL1xuY29uc3QgdG9BcnJheSA9ICh0aGluZykgPT4ge1xuICBpZiAoIXRoaW5nKSByZXR1cm4gbnVsbDtcbiAgaWYgKGlzQXJyYXkodGhpbmcpKSByZXR1cm4gdGhpbmc7XG4gIGxldCBpID0gdGhpbmcubGVuZ3RoO1xuICBpZiAoIWlzTnVtYmVyKGkpKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgYXJyID0gbmV3IEFycmF5KGkpO1xuICB3aGlsZSAoaS0tID4gMCkge1xuICAgIGFycltpXSA9IHRoaW5nW2ldO1xuICB9XG4gIHJldHVybiBhcnI7XG59XG5cbi8qKlxuICogQ2hlY2tpbmcgaWYgdGhlIFVpbnQ4QXJyYXkgZXhpc3RzIGFuZCBpZiBpdCBkb2VzLCBpdCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgdGhlXG4gKiB0aGluZyBwYXNzZWQgaW4gaXMgYW4gaW5zdGFuY2Ugb2YgVWludDhBcnJheVxuICpcbiAqIEBwYXJhbSB7VHlwZWRBcnJheX1cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5jb25zdCBpc1R5cGVkQXJyYXkgPSAoVHlwZWRBcnJheSA9PiB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gIHJldHVybiB0aGluZyA9PiB7XG4gICAgcmV0dXJuIFR5cGVkQXJyYXkgJiYgdGhpbmcgaW5zdGFuY2VvZiBUeXBlZEFycmF5O1xuICB9O1xufSkodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnICYmIGdldFByb3RvdHlwZU9mKFVpbnQ4QXJyYXkpKTtcblxuLyoqXG4gKiBGb3IgZWFjaCBlbnRyeSBpbiB0aGUgb2JqZWN0LCBjYWxsIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBrZXkgYW5kIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0PGFueSwgYW55Pn0gb2JqIC0gVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGVudHJ5LlxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5jb25zdCBmb3JFYWNoRW50cnkgPSAob2JqLCBmbikgPT4ge1xuICBjb25zdCBnZW5lcmF0b3IgPSBvYmogJiYgb2JqW1N5bWJvbC5pdGVyYXRvcl07XG5cbiAgY29uc3QgaXRlcmF0b3IgPSBnZW5lcmF0b3IuY2FsbChvYmopO1xuXG4gIGxldCByZXN1bHQ7XG5cbiAgd2hpbGUgKChyZXN1bHQgPSBpdGVyYXRvci5uZXh0KCkpICYmICFyZXN1bHQuZG9uZSkge1xuICAgIGNvbnN0IHBhaXIgPSByZXN1bHQudmFsdWU7XG4gICAgZm4uY2FsbChvYmosIHBhaXJbMF0sIHBhaXJbMV0pO1xuICB9XG59XG5cbi8qKlxuICogSXQgdGFrZXMgYSByZWd1bGFyIGV4cHJlc3Npb24gYW5kIGEgc3RyaW5nLCBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiBhbGwgdGhlIG1hdGNoZXNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnRXhwIC0gVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBtYXRjaCBhZ2FpbnN0LlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIFRoZSBzdHJpbmcgdG8gc2VhcmNoLlxuICpcbiAqIEByZXR1cm5zIHtBcnJheTxib29sZWFuPn1cbiAqL1xuY29uc3QgbWF0Y2hBbGwgPSAocmVnRXhwLCBzdHIpID0+IHtcbiAgbGV0IG1hdGNoZXM7XG4gIGNvbnN0IGFyciA9IFtdO1xuXG4gIHdoaWxlICgobWF0Y2hlcyA9IHJlZ0V4cC5leGVjKHN0cikpICE9PSBudWxsKSB7XG4gICAgYXJyLnB1c2gobWF0Y2hlcyk7XG4gIH1cblxuICByZXR1cm4gYXJyO1xufVxuXG4vKiBDaGVja2luZyBpZiB0aGUga2luZE9mVGVzdCBmdW5jdGlvbiByZXR1cm5zIHRydWUgd2hlbiBwYXNzZWQgYW4gSFRNTEZvcm1FbGVtZW50LiAqL1xuY29uc3QgaXNIVE1MRm9ybSA9IGtpbmRPZlRlc3QoJ0hUTUxGb3JtRWxlbWVudCcpO1xuXG5jb25zdCB0b0NhbWVsQ2FzZSA9IHN0ciA9PiB7XG4gIHJldHVybiBzdHIudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bLV9cXHNdKFthLXpcXGRdKShcXHcqKS9nLFxuICAgIGZ1bmN0aW9uIHJlcGxhY2VyKG0sIHAxLCBwMikge1xuICAgICAgcmV0dXJuIHAxLnRvVXBwZXJDYXNlKCkgKyBwMjtcbiAgICB9XG4gICk7XG59O1xuXG4vKiBDcmVhdGluZyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBjaGVjayBpZiBhbiBvYmplY3QgaGFzIGEgcHJvcGVydHkuICovXG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9ICgoe2hhc093blByb3BlcnR5fSkgPT4gKG9iaiwgcHJvcCkgPT4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKShPYmplY3QucHJvdG90eXBlKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFJlZ0V4cCBvYmplY3RcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgUmVnRXhwIG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzUmVnRXhwID0ga2luZE9mVGVzdCgnUmVnRXhwJyk7XG5cbmNvbnN0IHJlZHVjZURlc2NyaXB0b3JzID0gKG9iaiwgcmVkdWNlcikgPT4ge1xuICBjb25zdCBkZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iaik7XG4gIGNvbnN0IHJlZHVjZWREZXNjcmlwdG9ycyA9IHt9O1xuXG4gIGZvckVhY2goZGVzY3JpcHRvcnMsIChkZXNjcmlwdG9yLCBuYW1lKSA9PiB7XG4gICAgbGV0IHJldDtcbiAgICBpZiAoKHJldCA9IHJlZHVjZXIoZGVzY3JpcHRvciwgbmFtZSwgb2JqKSkgIT09IGZhbHNlKSB7XG4gICAgICByZWR1Y2VkRGVzY3JpcHRvcnNbbmFtZV0gPSByZXQgfHwgZGVzY3JpcHRvcjtcbiAgICB9XG4gIH0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG9iaiwgcmVkdWNlZERlc2NyaXB0b3JzKTtcbn1cblxuLyoqXG4gKiBNYWtlcyBhbGwgbWV0aG9kcyByZWFkLW9ubHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqL1xuXG5jb25zdCBmcmVlemVNZXRob2RzID0gKG9iaikgPT4ge1xuICByZWR1Y2VEZXNjcmlwdG9ycyhvYmosIChkZXNjcmlwdG9yLCBuYW1lKSA9PiB7XG4gICAgLy8gc2tpcCByZXN0cmljdGVkIHByb3BzIGluIHN0cmljdCBtb2RlXG4gICAgaWYgKGlzRnVuY3Rpb24ob2JqKSAmJiBbJ2FyZ3VtZW50cycsICdjYWxsZXInLCAnY2FsbGVlJ10uaW5kZXhPZihuYW1lKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWx1ZSA9IG9ialtuYW1lXTtcblxuICAgIGlmICghaXNGdW5jdGlvbih2YWx1ZSkpIHJldHVybjtcblxuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGZhbHNlO1xuXG4gICAgaWYgKCd3cml0YWJsZScgaW4gZGVzY3JpcHRvcikge1xuICAgICAgZGVzY3JpcHRvci53cml0YWJsZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghZGVzY3JpcHRvci5zZXQpIHtcbiAgICAgIGRlc2NyaXB0b3Iuc2V0ID0gKCkgPT4ge1xuICAgICAgICB0aHJvdyBFcnJvcignQ2FuIG5vdCByZXdyaXRlIHJlYWQtb25seSBtZXRob2QgXFwnJyArIG5hbWUgKyAnXFwnJyk7XG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG59XG5cbmNvbnN0IHRvT2JqZWN0U2V0ID0gKGFycmF5T3JTdHJpbmcsIGRlbGltaXRlcikgPT4ge1xuICBjb25zdCBvYmogPSB7fTtcblxuICBjb25zdCBkZWZpbmUgPSAoYXJyKSA9PiB7XG4gICAgYXJyLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgb2JqW3ZhbHVlXSA9IHRydWU7XG4gICAgfSk7XG4gIH1cblxuICBpc0FycmF5KGFycmF5T3JTdHJpbmcpID8gZGVmaW5lKGFycmF5T3JTdHJpbmcpIDogZGVmaW5lKFN0cmluZyhhcnJheU9yU3RyaW5nKS5zcGxpdChkZWxpbWl0ZXIpKTtcblxuICByZXR1cm4gb2JqO1xufVxuXG5jb25zdCBub29wID0gKCkgPT4ge31cblxuY29uc3QgdG9GaW5pdGVOdW1iZXIgPSAodmFsdWUsIGRlZmF1bHRWYWx1ZSkgPT4ge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBOdW1iZXIuaXNGaW5pdGUodmFsdWUgPSArdmFsdWUpID8gdmFsdWUgOiBkZWZhdWx0VmFsdWU7XG59XG5cbmNvbnN0IEFMUEhBID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6J1xuXG5jb25zdCBESUdJVCA9ICcwMTIzNDU2Nzg5JztcblxuY29uc3QgQUxQSEFCRVQgPSB7XG4gIERJR0lULFxuICBBTFBIQSxcbiAgQUxQSEFfRElHSVQ6IEFMUEhBICsgQUxQSEEudG9VcHBlckNhc2UoKSArIERJR0lUXG59XG5cbmNvbnN0IGdlbmVyYXRlU3RyaW5nID0gKHNpemUgPSAxNiwgYWxwaGFiZXQgPSBBTFBIQUJFVC5BTFBIQV9ESUdJVCkgPT4ge1xuICBsZXQgc3RyID0gJyc7XG4gIGNvbnN0IHtsZW5ndGh9ID0gYWxwaGFiZXQ7XG4gIHdoaWxlIChzaXplLS0pIHtcbiAgICBzdHIgKz0gYWxwaGFiZXRbTWF0aC5yYW5kb20oKSAqIGxlbmd0aHwwXVxuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cblxuLyoqXG4gKiBJZiB0aGUgdGhpbmcgaXMgYSBGb3JtRGF0YSBvYmplY3QsIHJldHVybiB0cnVlLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxuICpcbiAqIEBwYXJhbSB7dW5rbm93bn0gdGhpbmcgLSBUaGUgdGhpbmcgdG8gY2hlY2suXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzU3BlY0NvbXBsaWFudEZvcm0odGhpbmcpIHtcbiAgcmV0dXJuICEhKHRoaW5nICYmIGlzRnVuY3Rpb24odGhpbmcuYXBwZW5kKSAmJiB0aGluZ1tTeW1ib2wudG9TdHJpbmdUYWddID09PSAnRm9ybURhdGEnICYmIHRoaW5nW1N5bWJvbC5pdGVyYXRvcl0pO1xufVxuXG5jb25zdCB0b0pTT05PYmplY3QgPSAob2JqKSA9PiB7XG4gIGNvbnN0IHN0YWNrID0gbmV3IEFycmF5KDEwKTtcblxuICBjb25zdCB2aXNpdCA9IChzb3VyY2UsIGkpID0+IHtcblxuICAgIGlmIChpc09iamVjdChzb3VyY2UpKSB7XG4gICAgICBpZiAoc3RhY2suaW5kZXhPZihzb3VyY2UpID49IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZighKCd0b0pTT04nIGluIHNvdXJjZSkpIHtcbiAgICAgICAgc3RhY2tbaV0gPSBzb3VyY2U7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGlzQXJyYXkoc291cmNlKSA/IFtdIDoge307XG5cbiAgICAgICAgZm9yRWFjaChzb3VyY2UsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVkdWNlZFZhbHVlID0gdmlzaXQodmFsdWUsIGkgKyAxKTtcbiAgICAgICAgICAhaXNVbmRlZmluZWQocmVkdWNlZFZhbHVlKSAmJiAodGFyZ2V0W2tleV0gPSByZWR1Y2VkVmFsdWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBzdGFja1tpXSA9IHVuZGVmaW5lZDtcblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cblxuICByZXR1cm4gdmlzaXQob2JqLCAwKTtcbn1cblxuY29uc3QgaXNBc3luY0ZuID0ga2luZE9mVGVzdCgnQXN5bmNGdW5jdGlvbicpO1xuXG5jb25zdCBpc1RoZW5hYmxlID0gKHRoaW5nKSA9PlxuICB0aGluZyAmJiAoaXNPYmplY3QodGhpbmcpIHx8IGlzRnVuY3Rpb24odGhpbmcpKSAmJiBpc0Z1bmN0aW9uKHRoaW5nLnRoZW4pICYmIGlzRnVuY3Rpb24odGhpbmcuY2F0Y2gpO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlzQXJyYXksXG4gIGlzQXJyYXlCdWZmZXIsXG4gIGlzQnVmZmVyLFxuICBpc0Zvcm1EYXRhLFxuICBpc0FycmF5QnVmZmVyVmlldyxcbiAgaXNTdHJpbmcsXG4gIGlzTnVtYmVyLFxuICBpc0Jvb2xlYW4sXG4gIGlzT2JqZWN0LFxuICBpc1BsYWluT2JqZWN0LFxuICBpc1JlYWRhYmxlU3RyZWFtLFxuICBpc1JlcXVlc3QsXG4gIGlzUmVzcG9uc2UsXG4gIGlzSGVhZGVycyxcbiAgaXNVbmRlZmluZWQsXG4gIGlzRGF0ZSxcbiAgaXNGaWxlLFxuICBpc0Jsb2IsXG4gIGlzUmVnRXhwLFxuICBpc0Z1bmN0aW9uLFxuICBpc1N0cmVhbSxcbiAgaXNVUkxTZWFyY2hQYXJhbXMsXG4gIGlzVHlwZWRBcnJheSxcbiAgaXNGaWxlTGlzdCxcbiAgZm9yRWFjaCxcbiAgbWVyZ2UsXG4gIGV4dGVuZCxcbiAgdHJpbSxcbiAgc3RyaXBCT00sXG4gIGluaGVyaXRzLFxuICB0b0ZsYXRPYmplY3QsXG4gIGtpbmRPZixcbiAga2luZE9mVGVzdCxcbiAgZW5kc1dpdGgsXG4gIHRvQXJyYXksXG4gIGZvckVhY2hFbnRyeSxcbiAgbWF0Y2hBbGwsXG4gIGlzSFRNTEZvcm0sXG4gIGhhc093blByb3BlcnR5LFxuICBoYXNPd25Qcm9wOiBoYXNPd25Qcm9wZXJ0eSwgLy8gYW4gYWxpYXMgdG8gYXZvaWQgRVNMaW50IG5vLXByb3RvdHlwZS1idWlsdGlucyBkZXRlY3Rpb25cbiAgcmVkdWNlRGVzY3JpcHRvcnMsXG4gIGZyZWV6ZU1ldGhvZHMsXG4gIHRvT2JqZWN0U2V0LFxuICB0b0NhbWVsQ2FzZSxcbiAgbm9vcCxcbiAgdG9GaW5pdGVOdW1iZXIsXG4gIGZpbmRLZXksXG4gIGdsb2JhbDogX2dsb2JhbCxcbiAgaXNDb250ZXh0RGVmaW5lZCxcbiAgQUxQSEFCRVQsXG4gIGdlbmVyYXRlU3RyaW5nLFxuICBpc1NwZWNDb21wbGlhbnRGb3JtLFxuICB0b0pTT05PYmplY3QsXG4gIGlzQXN5bmNGbixcbiAgaXNUaGVuYWJsZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcCgpIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJndW1lbnRzKTtcbiAgfTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4vLi4vdXRpbHMuanMnO1xuaW1wb3J0IGJ1aWxkVVJMIGZyb20gJy4uL2hlbHBlcnMvYnVpbGRVUkwuanMnO1xuaW1wb3J0IEludGVyY2VwdG9yTWFuYWdlciBmcm9tICcuL0ludGVyY2VwdG9yTWFuYWdlci5qcyc7XG5pbXBvcnQgZGlzcGF0Y2hSZXF1ZXN0IGZyb20gJy4vZGlzcGF0Y2hSZXF1ZXN0LmpzJztcbmltcG9ydCBtZXJnZUNvbmZpZyBmcm9tICcuL21lcmdlQ29uZmlnLmpzJztcbmltcG9ydCBidWlsZEZ1bGxQYXRoIGZyb20gJy4vYnVpbGRGdWxsUGF0aC5qcyc7XG5pbXBvcnQgdmFsaWRhdG9yIGZyb20gJy4uL2hlbHBlcnMvdmFsaWRhdG9yLmpzJztcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSAnLi9BeGlvc0hlYWRlcnMuanMnO1xuXG5jb25zdCB2YWxpZGF0b3JzID0gdmFsaWRhdG9yLnZhbGlkYXRvcnM7XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGluc3RhbmNlQ29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKlxuICogQHJldHVybiB7QXhpb3N9IEEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKi9cbmNsYXNzIEF4aW9zIHtcbiAgY29uc3RydWN0b3IoaW5zdGFuY2VDb25maWcpIHtcbiAgICB0aGlzLmRlZmF1bHRzID0gaW5zdGFuY2VDb25maWc7XG4gICAgdGhpcy5pbnRlcmNlcHRvcnMgPSB7XG4gICAgICByZXF1ZXN0OiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKCksXG4gICAgICByZXNwb25zZTogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaCBhIHJlcXVlc3RcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBjb25maWdPclVybCBUaGUgY29uZmlnIHNwZWNpZmljIGZvciB0aGlzIHJlcXVlc3QgKG1lcmdlZCB3aXRoIHRoaXMuZGVmYXVsdHMpXG4gICAqIEBwYXJhbSB7P09iamVjdH0gY29uZmlnXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAgICovXG4gIGFzeW5jIHJlcXVlc3QoY29uZmlnT3JVcmwsIGNvbmZpZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fcmVxdWVzdChjb25maWdPclVybCwgY29uZmlnKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBsZXQgZHVtbXk7XG5cbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgPyBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShkdW1teSA9IHt9KSA6IChkdW1teSA9IG5ldyBFcnJvcigpKTtcblxuICAgICAgICAvLyBzbGljZSBvZmYgdGhlIEVycm9yOiAuLi4gbGluZVxuICAgICAgICBjb25zdCBzdGFjayA9IGR1bW15LnN0YWNrID8gZHVtbXkuc3RhY2sucmVwbGFjZSgvXi4rXFxuLywgJycpIDogJyc7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFlcnIuc3RhY2spIHtcbiAgICAgICAgICAgIGVyci5zdGFjayA9IHN0YWNrO1xuICAgICAgICAgICAgLy8gbWF0Y2ggd2l0aG91dCB0aGUgMiB0b3Agc3RhY2sgbGluZXNcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YWNrICYmICFTdHJpbmcoZXJyLnN0YWNrKS5lbmRzV2l0aChzdGFjay5yZXBsYWNlKC9eLitcXG4uK1xcbi8sICcnKSkpIHtcbiAgICAgICAgICAgIGVyci5zdGFjayArPSAnXFxuJyArIHN0YWNrXG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gaWdub3JlIHRoZSBjYXNlIHdoZXJlIFwic3RhY2tcIiBpcyBhbiB1bi13cml0YWJsZSBwcm9wZXJ0eVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cblxuICBfcmVxdWVzdChjb25maWdPclVybCwgY29uZmlnKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgLy8gQWxsb3cgZm9yIGF4aW9zKCdleGFtcGxlL3VybCdbLCBjb25maWddKSBhIGxhIGZldGNoIEFQSVxuICAgIGlmICh0eXBlb2YgY29uZmlnT3JVcmwgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gICAgICBjb25maWcudXJsID0gY29uZmlnT3JVcmw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbmZpZyA9IGNvbmZpZ09yVXJsIHx8IHt9O1xuICAgIH1cblxuICAgIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG5cbiAgICBjb25zdCB7dHJhbnNpdGlvbmFsLCBwYXJhbXNTZXJpYWxpemVyLCBoZWFkZXJzfSA9IGNvbmZpZztcblxuICAgIGlmICh0cmFuc2l0aW9uYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFsaWRhdG9yLmFzc2VydE9wdGlvbnModHJhbnNpdGlvbmFsLCB7XG4gICAgICAgIHNpbGVudEpTT05QYXJzaW5nOiB2YWxpZGF0b3JzLnRyYW5zaXRpb25hbCh2YWxpZGF0b3JzLmJvb2xlYW4pLFxuICAgICAgICBmb3JjZWRKU09OUGFyc2luZzogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuKSxcbiAgICAgICAgY2xhcmlmeVRpbWVvdXRFcnJvcjogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuKVxuICAgICAgfSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXNTZXJpYWxpemVyICE9IG51bGwpIHtcbiAgICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKHBhcmFtc1NlcmlhbGl6ZXIpKSB7XG4gICAgICAgIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyID0ge1xuICAgICAgICAgIHNlcmlhbGl6ZTogcGFyYW1zU2VyaWFsaXplclxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWxpZGF0b3IuYXNzZXJ0T3B0aW9ucyhwYXJhbXNTZXJpYWxpemVyLCB7XG4gICAgICAgICAgZW5jb2RlOiB2YWxpZGF0b3JzLmZ1bmN0aW9uLFxuICAgICAgICAgIHNlcmlhbGl6ZTogdmFsaWRhdG9ycy5mdW5jdGlvblxuICAgICAgICB9LCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZXQgY29uZmlnLm1ldGhvZFxuICAgIGNvbmZpZy5tZXRob2QgPSAoY29uZmlnLm1ldGhvZCB8fCB0aGlzLmRlZmF1bHRzLm1ldGhvZCB8fCAnZ2V0JykudG9Mb3dlckNhc2UoKTtcblxuICAgIC8vIEZsYXR0ZW4gaGVhZGVyc1xuICAgIGxldCBjb250ZXh0SGVhZGVycyA9IGhlYWRlcnMgJiYgdXRpbHMubWVyZ2UoXG4gICAgICBoZWFkZXJzLmNvbW1vbixcbiAgICAgIGhlYWRlcnNbY29uZmlnLm1ldGhvZF1cbiAgICApO1xuXG4gICAgaGVhZGVycyAmJiB1dGlscy5mb3JFYWNoKFxuICAgICAgWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnLCAnY29tbW9uJ10sXG4gICAgICAobWV0aG9kKSA9PiB7XG4gICAgICAgIGRlbGV0ZSBoZWFkZXJzW21ldGhvZF07XG4gICAgICB9XG4gICAgKTtcblxuICAgIGNvbmZpZy5oZWFkZXJzID0gQXhpb3NIZWFkZXJzLmNvbmNhdChjb250ZXh0SGVhZGVycywgaGVhZGVycyk7XG5cbiAgICAvLyBmaWx0ZXIgb3V0IHNraXBwZWQgaW50ZXJjZXB0b3JzXG4gICAgY29uc3QgcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4gPSBbXTtcbiAgICBsZXQgc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzID0gdHJ1ZTtcbiAgICB0aGlzLmludGVyY2VwdG9ycy5yZXF1ZXN0LmZvckVhY2goZnVuY3Rpb24gdW5zaGlmdFJlcXVlc3RJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICAgIGlmICh0eXBlb2YgaW50ZXJjZXB0b3IucnVuV2hlbiA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnRlcmNlcHRvci5ydW5XaGVuKGNvbmZpZykgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzID0gc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzICYmIGludGVyY2VwdG9yLnN5bmNocm9ub3VzO1xuXG4gICAgICByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbi51bnNoaWZ0KGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluID0gW107XG4gICAgdGhpcy5pbnRlcmNlcHRvcnMucmVzcG9uc2UuZm9yRWFjaChmdW5jdGlvbiBwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICAgIHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbi5wdXNoKGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICAgIH0pO1xuXG4gICAgbGV0IHByb21pc2U7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBsZW47XG5cbiAgICBpZiAoIXN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycykge1xuICAgICAgY29uc3QgY2hhaW4gPSBbZGlzcGF0Y2hSZXF1ZXN0LmJpbmQodGhpcyksIHVuZGVmaW5lZF07XG4gICAgICBjaGFpbi51bnNoaWZ0LmFwcGx5KGNoYWluLCByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbik7XG4gICAgICBjaGFpbi5wdXNoLmFwcGx5KGNoYWluLCByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4pO1xuICAgICAgbGVuID0gY2hhaW4ubGVuZ3RoO1xuXG4gICAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGNvbmZpZyk7XG5cbiAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oY2hhaW5baSsrXSwgY2hhaW5baSsrXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cblxuICAgIGxlbiA9IHJlcXVlc3RJbnRlcmNlcHRvckNoYWluLmxlbmd0aDtcblxuICAgIGxldCBuZXdDb25maWcgPSBjb25maWc7XG5cbiAgICBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBjb25zdCBvbkZ1bGZpbGxlZCA9IHJlcXVlc3RJbnRlcmNlcHRvckNoYWluW2krK107XG4gICAgICBjb25zdCBvblJlamVjdGVkID0gcmVxdWVzdEludGVyY2VwdG9yQ2hhaW5baSsrXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5ld0NvbmZpZyA9IG9uRnVsZmlsbGVkKG5ld0NvbmZpZyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBvblJlamVjdGVkLmNhbGwodGhpcywgZXJyb3IpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcHJvbWlzZSA9IGRpc3BhdGNoUmVxdWVzdC5jYWxsKHRoaXMsIG5ld0NvbmZpZyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuXG4gICAgaSA9IDA7XG4gICAgbGVuID0gcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluLmxlbmd0aDtcblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbltpKytdLCByZXNwb25zZUludGVyY2VwdG9yQ2hhaW5baSsrXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBnZXRVcmkoY29uZmlnKSB7XG4gICAgY29uZmlnID0gbWVyZ2VDb25maWcodGhpcy5kZWZhdWx0cywgY29uZmlnKTtcbiAgICBjb25zdCBmdWxsUGF0aCA9IGJ1aWxkRnVsbFBhdGgoY29uZmlnLmJhc2VVUkwsIGNvbmZpZy51cmwpO1xuICAgIHJldHVybiBidWlsZFVSTChmdWxsUGF0aCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpO1xuICB9XG59XG5cbi8vIFByb3ZpZGUgYWxpYXNlcyBmb3Igc3VwcG9ydGVkIHJlcXVlc3QgbWV0aG9kc1xudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdvcHRpb25zJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG1lcmdlQ29uZmlnKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kLFxuICAgICAgdXJsLFxuICAgICAgZGF0YTogKGNvbmZpZyB8fCB7fSkuZGF0YVxuICAgIH0pKTtcbiAgfTtcbn0pO1xuXG51dGlscy5mb3JFYWNoKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZFdpdGhEYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlSFRUUE1ldGhvZChpc0Zvcm0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gaHR0cE1ldGhvZCh1cmwsIGRhdGEsIGNvbmZpZykge1xuICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChtZXJnZUNvbmZpZyhjb25maWcgfHwge30sIHtcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBoZWFkZXJzOiBpc0Zvcm0gPyB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdtdWx0aXBhcnQvZm9ybS1kYXRhJ1xuICAgICAgICB9IDoge30sXG4gICAgICAgIHVybCxcbiAgICAgICAgZGF0YVxuICAgICAgfSkpO1xuICAgIH07XG4gIH1cblxuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGdlbmVyYXRlSFRUUE1ldGhvZCgpO1xuXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2QgKyAnRm9ybSddID0gZ2VuZXJhdGVIVFRQTWV0aG9kKHRydWUpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IEF4aW9zO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IEF4aW9zVVJMU2VhcmNoUGFyYW1zIGZyb20gJy4uL2hlbHBlcnMvQXhpb3NVUkxTZWFyY2hQYXJhbXMuanMnO1xuXG4vKipcbiAqIEl0IHJlcGxhY2VzIGFsbCBpbnN0YW5jZXMgb2YgdGhlIGNoYXJhY3RlcnMgYDpgLCBgJGAsIGAsYCwgYCtgLCBgW2AsIGFuZCBgXWAgd2l0aCB0aGVpclxuICogVVJJIGVuY29kZWQgY291bnRlcnBhcnRzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbCBUaGUgdmFsdWUgdG8gYmUgZW5jb2RlZC5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZW5jb2RlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlKHZhbCkge1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHZhbCkuXG4gICAgcmVwbGFjZSgvJTNBL2dpLCAnOicpLlxuICAgIHJlcGxhY2UoLyUyNC9nLCAnJCcpLlxuICAgIHJlcGxhY2UoLyUyQy9naSwgJywnKS5cbiAgICByZXBsYWNlKC8lMjAvZywgJysnKS5cbiAgICByZXBsYWNlKC8lNUIvZ2ksICdbJykuXG4gICAgcmVwbGFjZSgvJTVEL2dpLCAnXScpO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgVVJMIGJ5IGFwcGVuZGluZyBwYXJhbXMgdG8gdGhlIGVuZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIGJhc2Ugb2YgdGhlIHVybCAoZS5nLiwgaHR0cDovL3d3dy5nb29nbGUuY29tKVxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIFRoZSBwYXJhbXMgdG8gYmUgYXBwZW5kZWRcbiAqIEBwYXJhbSB7P29iamVjdH0gb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgdXJsXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJ1aWxkVVJMKHVybCwgcGFyYW1zLCBvcHRpb25zKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICBpZiAoIXBhcmFtcykge1xuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgXG4gIGNvbnN0IF9lbmNvZGUgPSBvcHRpb25zICYmIG9wdGlvbnMuZW5jb2RlIHx8IGVuY29kZTtcblxuICBjb25zdCBzZXJpYWxpemVGbiA9IG9wdGlvbnMgJiYgb3B0aW9ucy5zZXJpYWxpemU7XG5cbiAgbGV0IHNlcmlhbGl6ZWRQYXJhbXM7XG5cbiAgaWYgKHNlcmlhbGl6ZUZuKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHNlcmlhbGl6ZUZuKHBhcmFtcywgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykgP1xuICAgICAgcGFyYW1zLnRvU3RyaW5nKCkgOlxuICAgICAgbmV3IEF4aW9zVVJMU2VhcmNoUGFyYW1zKHBhcmFtcywgb3B0aW9ucykudG9TdHJpbmcoX2VuY29kZSk7XG4gIH1cblxuICBpZiAoc2VyaWFsaXplZFBhcmFtcykge1xuICAgIGNvbnN0IGhhc2htYXJrSW5kZXggPSB1cmwuaW5kZXhPZihcIiNcIik7XG5cbiAgICBpZiAoaGFzaG1hcmtJbmRleCAhPT0gLTEpIHtcbiAgICAgIHVybCA9IHVybC5zbGljZSgwLCBoYXNobWFya0luZGV4KTtcbiAgICB9XG4gICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyBzZXJpYWxpemVkUGFyYW1zO1xuICB9XG5cbiAgcmV0dXJuIHVybDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHRvRm9ybURhdGEgZnJvbSAnLi90b0Zvcm1EYXRhLmpzJztcblxuLyoqXG4gKiBJdCBlbmNvZGVzIGEgc3RyaW5nIGJ5IHJlcGxhY2luZyBhbGwgY2hhcmFjdGVycyB0aGF0IGFyZSBub3QgaW4gdGhlIHVucmVzZXJ2ZWQgc2V0IHdpdGhcbiAqIHRoZWlyIHBlcmNlbnQtZW5jb2RlZCBlcXVpdmFsZW50c1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBUaGUgc3RyaW5nIHRvIGVuY29kZS5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZW5jb2RlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZShzdHIpIHtcbiAgY29uc3QgY2hhck1hcCA9IHtcbiAgICAnISc6ICclMjEnLFxuICAgIFwiJ1wiOiAnJTI3JyxcbiAgICAnKCc6ICclMjgnLFxuICAgICcpJzogJyUyOScsXG4gICAgJ34nOiAnJTdFJyxcbiAgICAnJTIwJzogJysnLFxuICAgICclMDAnOiAnXFx4MDAnXG4gIH07XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyKS5yZXBsYWNlKC9bIScoKX5dfCUyMHwlMDAvZywgZnVuY3Rpb24gcmVwbGFjZXIobWF0Y2gpIHtcbiAgICByZXR1cm4gY2hhck1hcFttYXRjaF07XG4gIH0pO1xufVxuXG4vKipcbiAqIEl0IHRha2VzIGEgcGFyYW1zIG9iamVjdCBhbmQgY29udmVydHMgaXQgdG8gYSBGb3JtRGF0YSBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIHRvIGJlIGNvbnZlcnRlZCB0byBhIEZvcm1EYXRhIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgYW55Pn0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIG9iamVjdCBwYXNzZWQgdG8gdGhlIEF4aW9zIGNvbnN0cnVjdG9yLlxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBBeGlvc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgdGhpcy5fcGFpcnMgPSBbXTtcblxuICBwYXJhbXMgJiYgdG9Gb3JtRGF0YShwYXJhbXMsIHRoaXMsIG9wdGlvbnMpO1xufVxuXG5jb25zdCBwcm90b3R5cGUgPSBBeGlvc1VSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGU7XG5cbnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQobmFtZSwgdmFsdWUpIHtcbiAgdGhpcy5fcGFpcnMucHVzaChbbmFtZSwgdmFsdWVdKTtcbn07XG5cbnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKGVuY29kZXIpIHtcbiAgY29uc3QgX2VuY29kZSA9IGVuY29kZXIgPyBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBlbmNvZGVyLmNhbGwodGhpcywgdmFsdWUsIGVuY29kZSk7XG4gIH0gOiBlbmNvZGU7XG5cbiAgcmV0dXJuIHRoaXMuX3BhaXJzLm1hcChmdW5jdGlvbiBlYWNoKHBhaXIpIHtcbiAgICByZXR1cm4gX2VuY29kZShwYWlyWzBdKSArICc9JyArIF9lbmNvZGUocGFpclsxXSk7XG4gIH0sICcnKS5qb2luKCcmJyk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBBeGlvc1VSTFNlYXJjaFBhcmFtcztcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gJy4uL2NvcmUvQXhpb3NFcnJvci5qcyc7XG4vLyB0ZW1wb3JhcnkgaG90Zml4IHRvIGF2b2lkIGNpcmN1bGFyIHJlZmVyZW5jZXMgdW50aWwgQXhpb3NVUkxTZWFyY2hQYXJhbXMgaXMgcmVmYWN0b3JlZFxuaW1wb3J0IFBsYXRmb3JtRm9ybURhdGEgZnJvbSAnLi4vcGxhdGZvcm0vbm9kZS9jbGFzc2VzL0Zvcm1EYXRhLmpzJztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBnaXZlbiB0aGluZyBpcyBhIGFycmF5IG9yIGpzIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGhpbmcgLSBUaGUgb2JqZWN0IG9yIGFycmF5IHRvIGJlIHZpc2l0ZWQuXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVmlzaXRhYmxlKHRoaW5nKSB7XG4gIHJldHVybiB1dGlscy5pc1BsYWluT2JqZWN0KHRoaW5nKSB8fCB1dGlscy5pc0FycmF5KHRoaW5nKTtcbn1cblxuLyoqXG4gKiBJdCByZW1vdmVzIHRoZSBicmFja2V0cyBmcm9tIHRoZSBlbmQgb2YgYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSBvZiB0aGUgcGFyYW1ldGVyLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBrZXkgd2l0aG91dCB0aGUgYnJhY2tldHMuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUJyYWNrZXRzKGtleSkge1xuICByZXR1cm4gdXRpbHMuZW5kc1dpdGgoa2V5LCAnW10nKSA/IGtleS5zbGljZSgwLCAtMikgOiBrZXk7XG59XG5cbi8qKlxuICogSXQgdGFrZXMgYSBwYXRoLCBhIGtleSwgYW5kIGEgYm9vbGVhbiwgYW5kIHJldHVybnMgYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIFRoZSBwYXRoIHRvIHRoZSBjdXJyZW50IGtleS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IG9mIHRoZSBjdXJyZW50IG9iamVjdCBiZWluZyBpdGVyYXRlZCBvdmVyLlxuICogQHBhcmFtIHtzdHJpbmd9IGRvdHMgLSBJZiB0cnVlLCB0aGUga2V5IHdpbGwgYmUgcmVuZGVyZWQgd2l0aCBkb3RzIGluc3RlYWQgb2YgYnJhY2tldHMuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIHBhdGggdG8gdGhlIGN1cnJlbnQga2V5LlxuICovXG5mdW5jdGlvbiByZW5kZXJLZXkocGF0aCwga2V5LCBkb3RzKSB7XG4gIGlmICghcGF0aCkgcmV0dXJuIGtleTtcbiAgcmV0dXJuIHBhdGguY29uY2F0KGtleSkubWFwKGZ1bmN0aW9uIGVhY2godG9rZW4sIGkpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICB0b2tlbiA9IHJlbW92ZUJyYWNrZXRzKHRva2VuKTtcbiAgICByZXR1cm4gIWRvdHMgJiYgaSA/ICdbJyArIHRva2VuICsgJ10nIDogdG9rZW47XG4gIH0pLmpvaW4oZG90cyA/ICcuJyA6ICcnKTtcbn1cblxuLyoqXG4gKiBJZiB0aGUgYXJyYXkgaXMgYW4gYXJyYXkgYW5kIG5vbmUgb2YgaXRzIGVsZW1lbnRzIGFyZSB2aXNpdGFibGUsIHRoZW4gaXQncyBhIGZsYXQgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtBcnJheTxhbnk+fSBhcnIgLSBUaGUgYXJyYXkgdG8gY2hlY2tcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGbGF0QXJyYXkoYXJyKSB7XG4gIHJldHVybiB1dGlscy5pc0FycmF5KGFycikgJiYgIWFyci5zb21lKGlzVmlzaXRhYmxlKTtcbn1cblxuY29uc3QgcHJlZGljYXRlcyA9IHV0aWxzLnRvRmxhdE9iamVjdCh1dGlscywge30sIG51bGwsIGZ1bmN0aW9uIGZpbHRlcihwcm9wKSB7XG4gIHJldHVybiAvXmlzW0EtWl0vLnRlc3QocHJvcCk7XG59KTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgZGF0YSBvYmplY3QgdG8gRm9ybURhdGFcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0gez9PYmplY3R9IFtmb3JtRGF0YV1cbiAqIEBwYXJhbSB7P09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy52aXNpdG9yXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tZXRhVG9rZW5zID0gdHJ1ZV1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZG90cyA9IGZhbHNlXVxuICogQHBhcmFtIHs/Qm9vbGVhbn0gW29wdGlvbnMuaW5kZXhlcyA9IGZhbHNlXVxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiovXG5cbi8qKlxuICogSXQgY29udmVydHMgYW4gb2JqZWN0IGludG8gYSBGb3JtRGF0YSBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdDxhbnksIGFueT59IG9iaiAtIFRoZSBvYmplY3QgdG8gY29udmVydCB0byBmb3JtIGRhdGEuXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9ybURhdGEgLSBUaGUgRm9ybURhdGEgb2JqZWN0IHRvIGFwcGVuZCB0by5cbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgYW55Pn0gb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIHRvRm9ybURhdGEob2JqLCBmb3JtRGF0YSwgb3B0aW9ucykge1xuICBpZiAoIXV0aWxzLmlzT2JqZWN0KG9iaikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0YXJnZXQgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICBmb3JtRGF0YSA9IGZvcm1EYXRhIHx8IG5ldyAoUGxhdGZvcm1Gb3JtRGF0YSB8fCBGb3JtRGF0YSkoKTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgb3B0aW9ucyA9IHV0aWxzLnRvRmxhdE9iamVjdChvcHRpb25zLCB7XG4gICAgbWV0YVRva2VuczogdHJ1ZSxcbiAgICBkb3RzOiBmYWxzZSxcbiAgICBpbmRleGVzOiBmYWxzZVxuICB9LCBmYWxzZSwgZnVuY3Rpb24gZGVmaW5lZChvcHRpb24sIHNvdXJjZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lcS1udWxsLGVxZXFlcVxuICAgIHJldHVybiAhdXRpbHMuaXNVbmRlZmluZWQoc291cmNlW29wdGlvbl0pO1xuICB9KTtcblxuICBjb25zdCBtZXRhVG9rZW5zID0gb3B0aW9ucy5tZXRhVG9rZW5zO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgY29uc3QgdmlzaXRvciA9IG9wdGlvbnMudmlzaXRvciB8fCBkZWZhdWx0VmlzaXRvcjtcbiAgY29uc3QgZG90cyA9IG9wdGlvbnMuZG90cztcbiAgY29uc3QgaW5kZXhlcyA9IG9wdGlvbnMuaW5kZXhlcztcbiAgY29uc3QgX0Jsb2IgPSBvcHRpb25zLkJsb2IgfHwgdHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIEJsb2I7XG4gIGNvbnN0IHVzZUJsb2IgPSBfQmxvYiAmJiB1dGlscy5pc1NwZWNDb21wbGlhbnRGb3JtKGZvcm1EYXRhKTtcblxuICBpZiAoIXV0aWxzLmlzRnVuY3Rpb24odmlzaXRvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2aXNpdG9yIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29udmVydFZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSByZXR1cm4gJyc7XG5cbiAgICBpZiAodXRpbHMuaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlLnRvSVNPU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgaWYgKCF1c2VCbG9iICYmIHV0aWxzLmlzQmxvYih2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKCdCbG9iIGlzIG5vdCBzdXBwb3J0ZWQuIFVzZSBhIEJ1ZmZlciBpbnN0ZWFkLicpO1xuICAgIH1cblxuICAgIGlmICh1dGlscy5pc0FycmF5QnVmZmVyKHZhbHVlKSB8fCB1dGlscy5pc1R5cGVkQXJyYXkodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdXNlQmxvYiAmJiB0eXBlb2YgQmxvYiA9PT0gJ2Z1bmN0aW9uJyA/IG5ldyBCbG9iKFt2YWx1ZV0pIDogQnVmZmVyLmZyb20odmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IHZpc2l0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBrZXlcbiAgICogQHBhcmFtIHtBcnJheTxTdHJpbmd8TnVtYmVyPn0gcGF0aFxuICAgKiBAdGhpcyB7Rm9ybURhdGF9XG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufSByZXR1cm4gdHJ1ZSB0byB2aXNpdCB0aGUgZWFjaCBwcm9wIG9mIHRoZSB2YWx1ZSByZWN1cnNpdmVseVxuICAgKi9cbiAgZnVuY3Rpb24gZGVmYXVsdFZpc2l0b3IodmFsdWUsIGtleSwgcGF0aCkge1xuICAgIGxldCBhcnIgPSB2YWx1ZTtcblxuICAgIGlmICh2YWx1ZSAmJiAhcGF0aCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAodXRpbHMuZW5kc1dpdGgoa2V5LCAne30nKSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAga2V5ID0gbWV0YVRva2VucyA/IGtleSA6IGtleS5zbGljZSgwLCAtMik7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICB2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICh1dGlscy5pc0FycmF5KHZhbHVlKSAmJiBpc0ZsYXRBcnJheSh2YWx1ZSkpIHx8XG4gICAgICAgICgodXRpbHMuaXNGaWxlTGlzdCh2YWx1ZSkgfHwgdXRpbHMuZW5kc1dpdGgoa2V5LCAnW10nKSkgJiYgKGFyciA9IHV0aWxzLnRvQXJyYXkodmFsdWUpKVxuICAgICAgICApKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBrZXkgPSByZW1vdmVCcmFja2V0cyhrZXkpO1xuXG4gICAgICAgIGFyci5mb3JFYWNoKGZ1bmN0aW9uIGVhY2goZWwsIGluZGV4KSB7XG4gICAgICAgICAgISh1dGlscy5pc1VuZGVmaW5lZChlbCkgfHwgZWwgPT09IG51bGwpICYmIGZvcm1EYXRhLmFwcGVuZChcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgICAgICAgICAgaW5kZXhlcyA9PT0gdHJ1ZSA/IHJlbmRlcktleShba2V5XSwgaW5kZXgsIGRvdHMpIDogKGluZGV4ZXMgPT09IG51bGwgPyBrZXkgOiBrZXkgKyAnW10nKSxcbiAgICAgICAgICAgIGNvbnZlcnRWYWx1ZShlbClcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc1Zpc2l0YWJsZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZvcm1EYXRhLmFwcGVuZChyZW5kZXJLZXkocGF0aCwga2V5LCBkb3RzKSwgY29udmVydFZhbHVlKHZhbHVlKSk7XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBzdGFjayA9IFtdO1xuXG4gIGNvbnN0IGV4cG9zZWRIZWxwZXJzID0gT2JqZWN0LmFzc2lnbihwcmVkaWNhdGVzLCB7XG4gICAgZGVmYXVsdFZpc2l0b3IsXG4gICAgY29udmVydFZhbHVlLFxuICAgIGlzVmlzaXRhYmxlXG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGJ1aWxkKHZhbHVlLCBwYXRoKSB7XG4gICAgaWYgKHV0aWxzLmlzVW5kZWZpbmVkKHZhbHVlKSkgcmV0dXJuO1xuXG4gICAgaWYgKHN0YWNrLmluZGV4T2YodmFsdWUpICE9PSAtMSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0NpcmN1bGFyIHJlZmVyZW5jZSBkZXRlY3RlZCBpbiAnICsgcGF0aC5qb2luKCcuJykpO1xuICAgIH1cblxuICAgIHN0YWNrLnB1c2godmFsdWUpO1xuXG4gICAgdXRpbHMuZm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24gZWFjaChlbCwga2V5KSB7XG4gICAgICBjb25zdCByZXN1bHQgPSAhKHV0aWxzLmlzVW5kZWZpbmVkKGVsKSB8fCBlbCA9PT0gbnVsbCkgJiYgdmlzaXRvci5jYWxsKFxuICAgICAgICBmb3JtRGF0YSwgZWwsIHV0aWxzLmlzU3RyaW5nKGtleSkgPyBrZXkudHJpbSgpIDoga2V5LCBwYXRoLCBleHBvc2VkSGVscGVyc1xuICAgICAgKTtcblxuICAgICAgaWYgKHJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgICBidWlsZChlbCwgcGF0aCA/IHBhdGguY29uY2F0KGtleSkgOiBba2V5XSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBzdGFjay5wb3AoKTtcbiAgfVxuXG4gIGlmICghdXRpbHMuaXNPYmplY3Qob2JqKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2RhdGEgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgfVxuXG4gIGJ1aWxkKG9iaik7XG5cbiAgcmV0dXJuIGZvcm1EYXRhO1xufVxuXG5leHBvcnQgZGVmYXVsdCB0b0Zvcm1EYXRhO1xuIiwidmFyIEVyPU9iamVjdC5jcmVhdGU7dmFyIE49T2JqZWN0LmRlZmluZVByb3BlcnR5O3ZhciBkcj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO3ZhciBncj1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lczt2YXIgbXI9T2JqZWN0LmdldFByb3RvdHlwZU9mLElyPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7dmFyICQ9KGkscik9PigpPT4ocnx8aSgocj17ZXhwb3J0czp7fX0pLmV4cG9ydHMsciksci5leHBvcnRzKSxGcj0oaSxyKT0+e2Zvcih2YXIgdCBpbiByKU4oaSx0LHtnZXQ6clt0XSxlbnVtZXJhYmxlOiEwfSl9LEw9KGkscix0LG4pPT57aWYociYmdHlwZW9mIHI9PVwib2JqZWN0XCJ8fHR5cGVvZiByPT1cImZ1bmN0aW9uXCIpZm9yKGxldCBlIG9mIGdyKHIpKSFJci5jYWxsKGksZSkmJmUhPT10JiZOKGksZSx7Z2V0OigpPT5yW2VdLGVudW1lcmFibGU6IShuPWRyKHIsZSkpfHxuLmVudW1lcmFibGV9KTtyZXR1cm4gaX0sUz0oaSxyLHQpPT4oTChpLHIsXCJkZWZhdWx0XCIpLHQmJkwodCxyLFwiZGVmYXVsdFwiKSksSj0oaSxyLHQpPT4odD1pIT1udWxsP0VyKG1yKGkpKTp7fSxMKHJ8fCFpfHwhaS5fX2VzTW9kdWxlP04odCxcImRlZmF1bHRcIix7dmFsdWU6aSxlbnVtZXJhYmxlOiEwfSk6dCxpKSksQXI9aT0+TChOKHt9LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGkpO3ZhciBRPSQoTT0+e1widXNlIHN0cmljdFwiO00uYnl0ZUxlbmd0aD1ScjtNLnRvQnl0ZUFycmF5PUNyO00uZnJvbUJ5dGVBcnJheT1Mcjt2YXIgQj1bXSx3PVtdLFVyPXR5cGVvZiBVaW50OEFycmF5PFwidVwiP1VpbnQ4QXJyYXk6QXJyYXksUD1cIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIjtmb3IobT0wLEs9UC5sZW5ndGg7bTxLOysrbSlCW21dPVBbbV0sd1tQLmNoYXJDb2RlQXQobSldPW07dmFyIG0sSzt3W1wiLVwiLmNoYXJDb2RlQXQoMCldPTYyO3dbXCJfXCIuY2hhckNvZGVBdCgwKV09NjM7ZnVuY3Rpb24gWihpKXt2YXIgcj1pLmxlbmd0aDtpZihyJTQ+MCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0XCIpO3ZhciB0PWkuaW5kZXhPZihcIj1cIik7dD09PS0xJiYodD1yKTt2YXIgbj10PT09cj8wOjQtdCU0O3JldHVyblt0LG5dfWZ1bmN0aW9uIFJyKGkpe3ZhciByPVooaSksdD1yWzBdLG49clsxXTtyZXR1cm4odCtuKSozLzQtbn1mdW5jdGlvbiBUcihpLHIsdCl7cmV0dXJuKHIrdCkqMy80LXR9ZnVuY3Rpb24gQ3IoaSl7dmFyIHIsdD1aKGkpLG49dFswXSxlPXRbMV0sbz1uZXcgVXIoVHIoaSxuLGUpKSx1PTAsZj1lPjA/bi00Om4sYztmb3IoYz0wO2M8ZjtjKz00KXI9d1tpLmNoYXJDb2RlQXQoYyldPDwxOHx3W2kuY2hhckNvZGVBdChjKzEpXTw8MTJ8d1tpLmNoYXJDb2RlQXQoYysyKV08PDZ8d1tpLmNoYXJDb2RlQXQoYyszKV0sb1t1KytdPXI+PjE2JjI1NSxvW3UrK109cj4+OCYyNTUsb1t1KytdPXImMjU1O3JldHVybiBlPT09MiYmKHI9d1tpLmNoYXJDb2RlQXQoYyldPDwyfHdbaS5jaGFyQ29kZUF0KGMrMSldPj40LG9bdSsrXT1yJjI1NSksZT09PTEmJihyPXdbaS5jaGFyQ29kZUF0KGMpXTw8MTB8d1tpLmNoYXJDb2RlQXQoYysxKV08PDR8d1tpLmNoYXJDb2RlQXQoYysyKV0+PjIsb1t1KytdPXI+PjgmMjU1LG9bdSsrXT1yJjI1NSksb31mdW5jdGlvbiBTcihpKXtyZXR1cm4gQltpPj4xOCY2M10rQltpPj4xMiY2M10rQltpPj42JjYzXStCW2kmNjNdfWZ1bmN0aW9uIF9yKGkscix0KXtmb3IodmFyIG4sZT1bXSxvPXI7bzx0O28rPTMpbj0oaVtvXTw8MTYmMTY3MTE2ODApKyhpW28rMV08PDgmNjUyODApKyhpW28rMl0mMjU1KSxlLnB1c2goU3IobikpO3JldHVybiBlLmpvaW4oXCJcIil9ZnVuY3Rpb24gTHIoaSl7Zm9yKHZhciByLHQ9aS5sZW5ndGgsbj10JTMsZT1bXSxvPTE2MzgzLHU9MCxmPXQtbjt1PGY7dSs9byllLnB1c2goX3IoaSx1LHUrbz5mP2Y6dStvKSk7cmV0dXJuIG49PT0xPyhyPWlbdC0xXSxlLnB1c2goQltyPj4yXStCW3I8PDQmNjNdK1wiPT1cIikpOm49PT0yJiYocj0oaVt0LTJdPDw4KStpW3QtMV0sZS5wdXNoKEJbcj4+MTBdK0Jbcj4+NCY2M10rQltyPDwyJjYzXStcIj1cIikpLGUuam9pbihcIlwiKX19KTt2YXIgdj0kKE89PntPLnJlYWQ9ZnVuY3Rpb24oaSxyLHQsbixlKXt2YXIgbyx1LGY9ZSo4LW4tMSxjPSgxPDxmKS0xLGw9Yz4+MSxzPS03LHA9dD9lLTE6MCxGPXQ/LTE6MSx4PWlbcitwXTtmb3IocCs9RixvPXgmKDE8PC1zKS0xLHg+Pj0tcyxzKz1mO3M+MDtvPW8qMjU2K2lbcitwXSxwKz1GLHMtPTgpO2Zvcih1PW8mKDE8PC1zKS0xLG8+Pj0tcyxzKz1uO3M+MDt1PXUqMjU2K2lbcitwXSxwKz1GLHMtPTgpO2lmKG89PT0wKW89MS1sO2Vsc2V7aWYobz09PWMpcmV0dXJuIHU/TmFOOih4Py0xOjEpKigxLzApO3U9dStNYXRoLnBvdygyLG4pLG89by1sfXJldHVybih4Py0xOjEpKnUqTWF0aC5wb3coMixvLW4pfTtPLndyaXRlPWZ1bmN0aW9uKGkscix0LG4sZSxvKXt2YXIgdSxmLGMsbD1vKjgtZS0xLHM9KDE8PGwpLTEscD1zPj4xLEY9ZT09PTIzP01hdGgucG93KDIsLTI0KS1NYXRoLnBvdygyLC03Nyk6MCx4PW4/MDpvLTEsYj1uPzE6LTEsQnI9cjwwfHxyPT09MCYmMS9yPDA/MTowO2ZvcihyPU1hdGguYWJzKHIpLGlzTmFOKHIpfHxyPT09MS8wPyhmPWlzTmFOKHIpPzE6MCx1PXMpOih1PU1hdGguZmxvb3IoTWF0aC5sb2cocikvTWF0aC5MTjIpLHIqKGM9TWF0aC5wb3coMiwtdSkpPDEmJih1LS0sYyo9MiksdStwPj0xP3IrPUYvYzpyKz1GKk1hdGgucG93KDIsMS1wKSxyKmM+PTImJih1KyssYy89MiksdStwPj1zPyhmPTAsdT1zKTp1K3A+PTE/KGY9KHIqYy0xKSpNYXRoLnBvdygyLGUpLHU9dStwKTooZj1yKk1hdGgucG93KDIscC0xKSpNYXRoLnBvdygyLGUpLHU9MCkpO2U+PTg7aVt0K3hdPWYmMjU1LHgrPWIsZi89MjU2LGUtPTgpO2Zvcih1PXU8PGV8ZixsKz1lO2w+MDtpW3QreF09dSYyNTUseCs9Yix1Lz0yNTYsbC09OCk7aVt0K3gtYl18PUJyKjEyOH19KTt2YXIgej0kKFQ9PntcInVzZSBzdHJpY3RcIjt2YXIgRz1RKCksVT12KCkscnI9dHlwZW9mIFN5bWJvbD09XCJmdW5jdGlvblwiJiZ0eXBlb2YgU3ltYm9sLmZvcj09XCJmdW5jdGlvblwiP1N5bWJvbC5mb3IoXCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbVwiKTpudWxsO1QuQnVmZmVyPWg7VC5TbG93QnVmZmVyPSRyO1QuSU5TUEVDVF9NQVhfQllURVM9NTA7dmFyIGs9MjE0NzQ4MzY0NztULmtNYXhMZW5ndGg9aztoLlRZUEVEX0FSUkFZX1NVUFBPUlQ9TnIoKTshaC5UWVBFRF9BUlJBWV9TVVBQT1JUJiZ0eXBlb2YgY29uc29sZTxcInVcIiYmdHlwZW9mIGNvbnNvbGUuZXJyb3I9PVwiZnVuY3Rpb25cIiYmY29uc29sZS5lcnJvcihcIlRoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSBgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LlwiKTtmdW5jdGlvbiBOcigpe3RyeXtsZXQgaT1uZXcgVWludDhBcnJheSgxKSxyPXtmb286ZnVuY3Rpb24oKXtyZXR1cm4gNDJ9fTtyZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mKHIsVWludDhBcnJheS5wcm90b3R5cGUpLE9iamVjdC5zZXRQcm90b3R5cGVPZihpLHIpLGkuZm9vKCk9PT00Mn1jYXRjaChpKXtyZXR1cm4hMX19T2JqZWN0LmRlZmluZVByb3BlcnR5KGgucHJvdG90eXBlLFwicGFyZW50XCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7aWYoaC5pc0J1ZmZlcih0aGlzKSlyZXR1cm4gdGhpcy5idWZmZXJ9fSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGgucHJvdG90eXBlLFwib2Zmc2V0XCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7aWYoaC5pc0J1ZmZlcih0aGlzKSlyZXR1cm4gdGhpcy5ieXRlT2Zmc2V0fX0pO2Z1bmN0aW9uIGQoaSl7aWYoaT5rKXRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInK2krJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpO2xldCByPW5ldyBVaW50OEFycmF5KGkpO3JldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2YocixoLnByb3RvdHlwZSkscn1mdW5jdGlvbiBoKGkscix0KXtpZih0eXBlb2YgaT09XCJudW1iZXJcIil7aWYodHlwZW9mIHI9PVwic3RyaW5nXCIpdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInKTtyZXR1cm4gaihpKX1yZXR1cm4gZXIoaSxyLHQpfWgucG9vbFNpemU9ODE5MjtmdW5jdGlvbiBlcihpLHIsdCl7aWYodHlwZW9mIGk9PVwic3RyaW5nXCIpcmV0dXJuIGtyKGkscik7aWYoQXJyYXlCdWZmZXIuaXNWaWV3KGkpKXJldHVybiBEcihpKTtpZihpPT1udWxsKXRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSBcIit0eXBlb2YgaSk7aWYoRShpLEFycmF5QnVmZmVyKXx8aSYmRShpLmJ1ZmZlcixBcnJheUJ1ZmZlcil8fHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlcjxcInVcIiYmKEUoaSxTaGFyZWRBcnJheUJ1ZmZlcil8fGkmJkUoaS5idWZmZXIsU2hhcmVkQXJyYXlCdWZmZXIpKSlyZXR1cm4gcShpLHIsdCk7aWYodHlwZW9mIGk9PVwibnVtYmVyXCIpdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInKTtsZXQgbj1pLnZhbHVlT2YmJmkudmFsdWVPZigpO2lmKG4hPW51bGwmJm4hPT1pKXJldHVybiBoLmZyb20obixyLHQpO2xldCBlPWJyKGkpO2lmKGUpcmV0dXJuIGU7aWYodHlwZW9mIFN5bWJvbDxcInVcIiYmU3ltYm9sLnRvUHJpbWl0aXZlIT1udWxsJiZ0eXBlb2YgaVtTeW1ib2wudG9QcmltaXRpdmVdPT1cImZ1bmN0aW9uXCIpcmV0dXJuIGguZnJvbShpW1N5bWJvbC50b1ByaW1pdGl2ZV0oXCJzdHJpbmdcIikscix0KTt0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgXCIrdHlwZW9mIGkpfWguZnJvbT1mdW5jdGlvbihpLHIsdCl7cmV0dXJuIGVyKGkscix0KX07T2JqZWN0LnNldFByb3RvdHlwZU9mKGgucHJvdG90eXBlLFVpbnQ4QXJyYXkucHJvdG90eXBlKTtPYmplY3Quc2V0UHJvdG90eXBlT2YoaCxVaW50OEFycmF5KTtmdW5jdGlvbiBvcihpKXtpZih0eXBlb2YgaSE9XCJudW1iZXJcIil0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJyk7aWYoaTwwKXRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInK2krJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpfWZ1bmN0aW9uIE1yKGkscix0KXtyZXR1cm4gb3IoaSksaTw9MD9kKGkpOnIhPT12b2lkIDA/dHlwZW9mIHQ9PVwic3RyaW5nXCI/ZChpKS5maWxsKHIsdCk6ZChpKS5maWxsKHIpOmQoaSl9aC5hbGxvYz1mdW5jdGlvbihpLHIsdCl7cmV0dXJuIE1yKGkscix0KX07ZnVuY3Rpb24gaihpKXtyZXR1cm4gb3IoaSksZChpPDA/MDpIKGkpfDApfWguYWxsb2NVbnNhZmU9ZnVuY3Rpb24oaSl7cmV0dXJuIGooaSl9O2guYWxsb2NVbnNhZmVTbG93PWZ1bmN0aW9uKGkpe3JldHVybiBqKGkpfTtmdW5jdGlvbiBrcihpLHIpe2lmKCh0eXBlb2YgciE9XCJzdHJpbmdcInx8cj09PVwiXCIpJiYocj1cInV0ZjhcIiksIWguaXNFbmNvZGluZyhyKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrcik7bGV0IHQ9dXIoaSxyKXwwLG49ZCh0KSxlPW4ud3JpdGUoaSxyKTtyZXR1cm4gZSE9PXQmJihuPW4uc2xpY2UoMCxlKSksbn1mdW5jdGlvbiBZKGkpe2xldCByPWkubGVuZ3RoPDA/MDpIKGkubGVuZ3RoKXwwLHQ9ZChyKTtmb3IobGV0IG49MDtuPHI7bis9MSl0W25dPWlbbl0mMjU1O3JldHVybiB0fWZ1bmN0aW9uIERyKGkpe2lmKEUoaSxVaW50OEFycmF5KSl7bGV0IHI9bmV3IFVpbnQ4QXJyYXkoaSk7cmV0dXJuIHEoci5idWZmZXIsci5ieXRlT2Zmc2V0LHIuYnl0ZUxlbmd0aCl9cmV0dXJuIFkoaSl9ZnVuY3Rpb24gcShpLHIsdCl7aWYocjwwfHxpLmJ5dGVMZW5ndGg8cil0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKTtpZihpLmJ5dGVMZW5ndGg8cisodHx8MCkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJyk7bGV0IG47cmV0dXJuIHI9PT12b2lkIDAmJnQ9PT12b2lkIDA/bj1uZXcgVWludDhBcnJheShpKTp0PT09dm9pZCAwP249bmV3IFVpbnQ4QXJyYXkoaSxyKTpuPW5ldyBVaW50OEFycmF5KGkscix0KSxPYmplY3Quc2V0UHJvdG90eXBlT2YobixoLnByb3RvdHlwZSksbn1mdW5jdGlvbiBicihpKXtpZihoLmlzQnVmZmVyKGkpKXtsZXQgcj1IKGkubGVuZ3RoKXwwLHQ9ZChyKTtyZXR1cm4gdC5sZW5ndGg9PT0wfHxpLmNvcHkodCwwLDAsciksdH1pZihpLmxlbmd0aCE9PXZvaWQgMClyZXR1cm4gdHlwZW9mIGkubGVuZ3RoIT1cIm51bWJlclwifHxYKGkubGVuZ3RoKT9kKDApOlkoaSk7aWYoaS50eXBlPT09XCJCdWZmZXJcIiYmQXJyYXkuaXNBcnJheShpLmRhdGEpKXJldHVybiBZKGkuZGF0YSl9ZnVuY3Rpb24gSChpKXtpZihpPj1rKXRocm93IG5ldyBSYW5nZUVycm9yKFwiQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSBzaXplOiAweFwiK2sudG9TdHJpbmcoMTYpK1wiIGJ5dGVzXCIpO3JldHVybiBpfDB9ZnVuY3Rpb24gJHIoaSl7cmV0dXJuK2khPWkmJihpPTApLGguYWxsb2MoK2kpfWguaXNCdWZmZXI9ZnVuY3Rpb24ocil7cmV0dXJuIHIhPW51bGwmJnIuX2lzQnVmZmVyPT09ITAmJnIhPT1oLnByb3RvdHlwZX07aC5jb21wYXJlPWZ1bmN0aW9uKHIsdCl7aWYoRShyLFVpbnQ4QXJyYXkpJiYocj1oLmZyb20ocixyLm9mZnNldCxyLmJ5dGVMZW5ndGgpKSxFKHQsVWludDhBcnJheSkmJih0PWguZnJvbSh0LHQub2Zmc2V0LHQuYnl0ZUxlbmd0aCkpLCFoLmlzQnVmZmVyKHIpfHwhaC5pc0J1ZmZlcih0KSl0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5Jyk7aWYocj09PXQpcmV0dXJuIDA7bGV0IG49ci5sZW5ndGgsZT10Lmxlbmd0aDtmb3IobGV0IG89MCx1PU1hdGgubWluKG4sZSk7bzx1OysrbylpZihyW29dIT09dFtvXSl7bj1yW29dLGU9dFtvXTticmVha31yZXR1cm4gbjxlPy0xOmU8bj8xOjB9O2guaXNFbmNvZGluZz1mdW5jdGlvbihyKXtzd2l0Y2goU3RyaW5nKHIpLnRvTG93ZXJDYXNlKCkpe2Nhc2VcImhleFwiOmNhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOmNhc2VcImFzY2lpXCI6Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6Y2FzZVwiYmFzZTY0XCI6Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4hMX19O2guY29uY2F0PWZ1bmN0aW9uKHIsdCl7aWYoIUFycmF5LmlzQXJyYXkocikpdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyk7aWYoci5sZW5ndGg9PT0wKXJldHVybiBoLmFsbG9jKDApO2xldCBuO2lmKHQ9PT12b2lkIDApZm9yKHQ9MCxuPTA7bjxyLmxlbmd0aDsrK24pdCs9cltuXS5sZW5ndGg7bGV0IGU9aC5hbGxvY1Vuc2FmZSh0KSxvPTA7Zm9yKG49MDtuPHIubGVuZ3RoOysrbil7bGV0IHU9cltuXTtpZihFKHUsVWludDhBcnJheSkpbyt1Lmxlbmd0aD5lLmxlbmd0aD8oaC5pc0J1ZmZlcih1KXx8KHU9aC5mcm9tKHUpKSx1LmNvcHkoZSxvKSk6VWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoZSx1LG8pO2Vsc2UgaWYoaC5pc0J1ZmZlcih1KSl1LmNvcHkoZSxvKTtlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpO28rPXUubGVuZ3RofXJldHVybiBlfTtmdW5jdGlvbiB1cihpLHIpe2lmKGguaXNCdWZmZXIoaSkpcmV0dXJuIGkubGVuZ3RoO2lmKEFycmF5QnVmZmVyLmlzVmlldyhpKXx8RShpLEFycmF5QnVmZmVyKSlyZXR1cm4gaS5ieXRlTGVuZ3RoO2lmKHR5cGVvZiBpIT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiBSZWNlaXZlZCB0eXBlICcrdHlwZW9mIGkpO2xldCB0PWkubGVuZ3RoLG49YXJndW1lbnRzLmxlbmd0aD4yJiZhcmd1bWVudHNbMl09PT0hMDtpZighbiYmdD09PTApcmV0dXJuIDA7bGV0IGU9ITE7Zm9yKDs7KXN3aXRjaChyKXtjYXNlXCJhc2NpaVwiOmNhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOnJldHVybiB0O2Nhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOnJldHVybiBXKGkpLmxlbmd0aDtjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gdCoyO2Nhc2VcImhleFwiOnJldHVybiB0Pj4+MTtjYXNlXCJiYXNlNjRcIjpyZXR1cm4gd3IoaSkubGVuZ3RoO2RlZmF1bHQ6aWYoZSlyZXR1cm4gbj8tMTpXKGkpLmxlbmd0aDtyPShcIlwiK3IpLnRvTG93ZXJDYXNlKCksZT0hMH19aC5ieXRlTGVuZ3RoPXVyO2Z1bmN0aW9uIFByKGkscix0KXtsZXQgbj0hMTtpZigocj09PXZvaWQgMHx8cjwwKSYmKHI9MCkscj50aGlzLmxlbmd0aHx8KCh0PT09dm9pZCAwfHx0PnRoaXMubGVuZ3RoKSYmKHQ9dGhpcy5sZW5ndGgpLHQ8PTApfHwodD4+Pj0wLHI+Pj49MCx0PD1yKSlyZXR1cm5cIlwiO2ZvcihpfHwoaT1cInV0ZjhcIik7Oylzd2l0Y2goaSl7Y2FzZVwiaGV4XCI6cmV0dXJuIHpyKHRoaXMscix0KTtjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpyZXR1cm4gZnIodGhpcyxyLHQpO2Nhc2VcImFzY2lpXCI6cmV0dXJuIFZyKHRoaXMscix0KTtjYXNlXCJsYXRpbjFcIjpjYXNlXCJiaW5hcnlcIjpyZXR1cm4gWHIodGhpcyxyLHQpO2Nhc2VcImJhc2U2NFwiOnJldHVybiBqcih0aGlzLHIsdCk7Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuIEpyKHRoaXMscix0KTtkZWZhdWx0OmlmKG4pdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK2kpO2k9KGkrXCJcIikudG9Mb3dlckNhc2UoKSxuPSEwfX1oLnByb3RvdHlwZS5faXNCdWZmZXI9ITA7ZnVuY3Rpb24gSShpLHIsdCl7bGV0IG49aVtyXTtpW3JdPWlbdF0saVt0XT1ufWgucHJvdG90eXBlLnN3YXAxNj1mdW5jdGlvbigpe2xldCByPXRoaXMubGVuZ3RoO2lmKHIlMiE9PTApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0c1wiKTtmb3IobGV0IHQ9MDt0PHI7dCs9MilJKHRoaXMsdCx0KzEpO3JldHVybiB0aGlzfTtoLnByb3RvdHlwZS5zd2FwMzI9ZnVuY3Rpb24oKXtsZXQgcj10aGlzLmxlbmd0aDtpZihyJTQhPT0wKXRocm93IG5ldyBSYW5nZUVycm9yKFwiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHNcIik7Zm9yKGxldCB0PTA7dDxyO3QrPTQpSSh0aGlzLHQsdCszKSxJKHRoaXMsdCsxLHQrMik7cmV0dXJuIHRoaXN9O2gucHJvdG90eXBlLnN3YXA2ND1mdW5jdGlvbigpe2xldCByPXRoaXMubGVuZ3RoO2lmKHIlOCE9PTApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0c1wiKTtmb3IobGV0IHQ9MDt0PHI7dCs9OClJKHRoaXMsdCx0KzcpLEkodGhpcyx0KzEsdCs2KSxJKHRoaXMsdCsyLHQrNSksSSh0aGlzLHQrMyx0KzQpO3JldHVybiB0aGlzfTtoLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe2xldCByPXRoaXMubGVuZ3RoO3JldHVybiByPT09MD9cIlwiOmFyZ3VtZW50cy5sZW5ndGg9PT0wP2ZyKHRoaXMsMCxyKTpQci5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O2gucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nPWgucHJvdG90eXBlLnRvU3RyaW5nO2gucHJvdG90eXBlLmVxdWFscz1mdW5jdGlvbihyKXtpZighaC5pc0J1ZmZlcihyKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlclwiKTtyZXR1cm4gdGhpcz09PXI/ITA6aC5jb21wYXJlKHRoaXMscik9PT0wfTtoLnByb3RvdHlwZS5pbnNwZWN0PWZ1bmN0aW9uKCl7bGV0IHI9XCJcIix0PVQuSU5TUEVDVF9NQVhfQllURVM7cmV0dXJuIHI9dGhpcy50b1N0cmluZyhcImhleFwiLDAsdCkucmVwbGFjZSgvKC57Mn0pL2csXCIkMSBcIikudHJpbSgpLHRoaXMubGVuZ3RoPnQmJihyKz1cIiAuLi4gXCIpLFwiPEJ1ZmZlciBcIityK1wiPlwifTtyciYmKGgucHJvdG90eXBlW3JyXT1oLnByb3RvdHlwZS5pbnNwZWN0KTtoLnByb3RvdHlwZS5jb21wYXJlPWZ1bmN0aW9uKHIsdCxuLGUsbyl7aWYoRShyLFVpbnQ4QXJyYXkpJiYocj1oLmZyb20ocixyLm9mZnNldCxyLmJ5dGVMZW5ndGgpKSwhaC5pc0J1ZmZlcihyKSl0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiBSZWNlaXZlZCB0eXBlICcrdHlwZW9mIHIpO2lmKHQ9PT12b2lkIDAmJih0PTApLG49PT12b2lkIDAmJihuPXI/ci5sZW5ndGg6MCksZT09PXZvaWQgMCYmKGU9MCksbz09PXZvaWQgMCYmKG89dGhpcy5sZW5ndGgpLHQ8MHx8bj5yLmxlbmd0aHx8ZTwwfHxvPnRoaXMubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwib3V0IG9mIHJhbmdlIGluZGV4XCIpO2lmKGU+PW8mJnQ+PW4pcmV0dXJuIDA7aWYoZT49bylyZXR1cm4tMTtpZih0Pj1uKXJldHVybiAxO2lmKHQ+Pj49MCxuPj4+PTAsZT4+Pj0wLG8+Pj49MCx0aGlzPT09cilyZXR1cm4gMDtsZXQgdT1vLWUsZj1uLXQsYz1NYXRoLm1pbih1LGYpLGw9dGhpcy5zbGljZShlLG8pLHM9ci5zbGljZSh0LG4pO2ZvcihsZXQgcD0wO3A8YzsrK3ApaWYobFtwXSE9PXNbcF0pe3U9bFtwXSxmPXNbcF07YnJlYWt9cmV0dXJuIHU8Zj8tMTpmPHU/MTowfTtmdW5jdGlvbiBocihpLHIsdCxuLGUpe2lmKGkubGVuZ3RoPT09MClyZXR1cm4tMTtpZih0eXBlb2YgdD09XCJzdHJpbmdcIj8obj10LHQ9MCk6dD4yMTQ3NDgzNjQ3P3Q9MjE0NzQ4MzY0Nzp0PC0yMTQ3NDgzNjQ4JiYodD0tMjE0NzQ4MzY0OCksdD0rdCxYKHQpJiYodD1lPzA6aS5sZW5ndGgtMSksdDwwJiYodD1pLmxlbmd0aCt0KSx0Pj1pLmxlbmd0aCl7aWYoZSlyZXR1cm4tMTt0PWkubGVuZ3RoLTF9ZWxzZSBpZih0PDApaWYoZSl0PTA7ZWxzZSByZXR1cm4tMTtpZih0eXBlb2Ygcj09XCJzdHJpbmdcIiYmKHI9aC5mcm9tKHIsbikpLGguaXNCdWZmZXIocikpcmV0dXJuIHIubGVuZ3RoPT09MD8tMTp0cihpLHIsdCxuLGUpO2lmKHR5cGVvZiByPT1cIm51bWJlclwiKXJldHVybiByPXImMjU1LHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mPT1cImZ1bmN0aW9uXCI/ZT9VaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoaSxyLHQpOlVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoaSxyLHQpOnRyKGksW3JdLHQsbixlKTt0aHJvdyBuZXcgVHlwZUVycm9yKFwidmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyXCIpfWZ1bmN0aW9uIHRyKGkscix0LG4sZSl7bGV0IG89MSx1PWkubGVuZ3RoLGY9ci5sZW5ndGg7aWYobiE9PXZvaWQgMCYmKG49U3RyaW5nKG4pLnRvTG93ZXJDYXNlKCksbj09PVwidWNzMlwifHxuPT09XCJ1Y3MtMlwifHxuPT09XCJ1dGYxNmxlXCJ8fG49PT1cInV0Zi0xNmxlXCIpKXtpZihpLmxlbmd0aDwyfHxyLmxlbmd0aDwyKXJldHVybi0xO289Mix1Lz0yLGYvPTIsdC89Mn1mdW5jdGlvbiBjKHMscCl7cmV0dXJuIG89PT0xP3NbcF06cy5yZWFkVUludDE2QkUocCpvKX1sZXQgbDtpZihlKXtsZXQgcz0tMTtmb3IobD10O2w8dTtsKyspaWYoYyhpLGwpPT09YyhyLHM9PT0tMT8wOmwtcykpe2lmKHM9PT0tMSYmKHM9bCksbC1zKzE9PT1mKXJldHVybiBzKm99ZWxzZSBzIT09LTEmJihsLT1sLXMpLHM9LTF9ZWxzZSBmb3IodCtmPnUmJih0PXUtZiksbD10O2w+PTA7bC0tKXtsZXQgcz0hMDtmb3IobGV0IHA9MDtwPGY7cCsrKWlmKGMoaSxsK3ApIT09YyhyLHApKXtzPSExO2JyZWFrfWlmKHMpcmV0dXJuIGx9cmV0dXJuLTF9aC5wcm90b3R5cGUuaW5jbHVkZXM9ZnVuY3Rpb24ocix0LG4pe3JldHVybiB0aGlzLmluZGV4T2Yocix0LG4pIT09LTF9O2gucHJvdG90eXBlLmluZGV4T2Y9ZnVuY3Rpb24ocix0LG4pe3JldHVybiBocih0aGlzLHIsdCxuLCEwKX07aC5wcm90b3R5cGUubGFzdEluZGV4T2Y9ZnVuY3Rpb24ocix0LG4pe3JldHVybiBocih0aGlzLHIsdCxuLCExKX07ZnVuY3Rpb24gT3IoaSxyLHQsbil7dD1OdW1iZXIodCl8fDA7bGV0IGU9aS5sZW5ndGgtdDtuPyhuPU51bWJlcihuKSxuPmUmJihuPWUpKTpuPWU7bGV0IG89ci5sZW5ndGg7bj5vLzImJihuPW8vMik7bGV0IHU7Zm9yKHU9MDt1PG47Kyt1KXtsZXQgZj1wYXJzZUludChyLnN1YnN0cih1KjIsMiksMTYpO2lmKFgoZikpcmV0dXJuIHU7aVt0K3VdPWZ9cmV0dXJuIHV9ZnVuY3Rpb24gR3IoaSxyLHQsbil7cmV0dXJuIEQoVyhyLGkubGVuZ3RoLXQpLGksdCxuKX1mdW5jdGlvbiBZcihpLHIsdCxuKXtyZXR1cm4gRCh2cihyKSxpLHQsbil9ZnVuY3Rpb24gcXIoaSxyLHQsbil7cmV0dXJuIEQod3IociksaSx0LG4pfWZ1bmN0aW9uIFdyKGkscix0LG4pe3JldHVybiBEKHJ0KHIsaS5sZW5ndGgtdCksaSx0LG4pfWgucHJvdG90eXBlLndyaXRlPWZ1bmN0aW9uKHIsdCxuLGUpe2lmKHQ9PT12b2lkIDApZT1cInV0ZjhcIixuPXRoaXMubGVuZ3RoLHQ9MDtlbHNlIGlmKG49PT12b2lkIDAmJnR5cGVvZiB0PT1cInN0cmluZ1wiKWU9dCxuPXRoaXMubGVuZ3RoLHQ9MDtlbHNlIGlmKGlzRmluaXRlKHQpKXQ9dD4+PjAsaXNGaW5pdGUobik/KG49bj4+PjAsZT09PXZvaWQgMCYmKGU9XCJ1dGY4XCIpKTooZT1uLG49dm9pZCAwKTtlbHNlIHRocm93IG5ldyBFcnJvcihcIkJ1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkXCIpO2xldCBvPXRoaXMubGVuZ3RoLXQ7aWYoKG49PT12b2lkIDB8fG4+bykmJihuPW8pLHIubGVuZ3RoPjAmJihuPDB8fHQ8MCl8fHQ+dGhpcy5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kc1wiKTtlfHwoZT1cInV0ZjhcIik7bGV0IHU9ITE7Zm9yKDs7KXN3aXRjaChlKXtjYXNlXCJoZXhcIjpyZXR1cm4gT3IodGhpcyxyLHQsbik7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6cmV0dXJuIEdyKHRoaXMscix0LG4pO2Nhc2VcImFzY2lpXCI6Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6cmV0dXJuIFlyKHRoaXMscix0LG4pO2Nhc2VcImJhc2U2NFwiOnJldHVybiBxcih0aGlzLHIsdCxuKTtjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gV3IodGhpcyxyLHQsbik7ZGVmYXVsdDppZih1KXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIitlKTtlPShcIlwiK2UpLnRvTG93ZXJDYXNlKCksdT0hMH19O2gucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybnt0eXBlOlwiQnVmZmVyXCIsZGF0YTpBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnJ8fHRoaXMsMCl9fTtmdW5jdGlvbiBqcihpLHIsdCl7cmV0dXJuIHI9PT0wJiZ0PT09aS5sZW5ndGg/Ry5mcm9tQnl0ZUFycmF5KGkpOkcuZnJvbUJ5dGVBcnJheShpLnNsaWNlKHIsdCkpfWZ1bmN0aW9uIGZyKGkscix0KXt0PU1hdGgubWluKGkubGVuZ3RoLHQpO2xldCBuPVtdLGU9cjtmb3IoO2U8dDspe2xldCBvPWlbZV0sdT1udWxsLGY9bz4yMzk/NDpvPjIyMz8zOm8+MTkxPzI6MTtpZihlK2Y8PXQpe2xldCBjLGwscyxwO3N3aXRjaChmKXtjYXNlIDE6bzwxMjgmJih1PW8pO2JyZWFrO2Nhc2UgMjpjPWlbZSsxXSwoYyYxOTIpPT09MTI4JiYocD0obyYzMSk8PDZ8YyY2MyxwPjEyNyYmKHU9cCkpO2JyZWFrO2Nhc2UgMzpjPWlbZSsxXSxsPWlbZSsyXSwoYyYxOTIpPT09MTI4JiYobCYxOTIpPT09MTI4JiYocD0obyYxNSk8PDEyfChjJjYzKTw8NnxsJjYzLHA+MjA0NyYmKHA8NTUyOTZ8fHA+NTczNDMpJiYodT1wKSk7YnJlYWs7Y2FzZSA0OmM9aVtlKzFdLGw9aVtlKzJdLHM9aVtlKzNdLChjJjE5Mik9PT0xMjgmJihsJjE5Mik9PT0xMjgmJihzJjE5Mik9PT0xMjgmJihwPShvJjE1KTw8MTh8KGMmNjMpPDwxMnwobCY2Myk8PDZ8cyY2MyxwPjY1NTM1JiZwPDExMTQxMTImJih1PXApKX19dT09PW51bGw/KHU9NjU1MzMsZj0xKTp1PjY1NTM1JiYodS09NjU1MzYsbi5wdXNoKHU+Pj4xMCYxMDIzfDU1Mjk2KSx1PTU2MzIwfHUmMTAyMyksbi5wdXNoKHUpLGUrPWZ9cmV0dXJuIEhyKG4pfXZhciBpcj00MDk2O2Z1bmN0aW9uIEhyKGkpe2xldCByPWkubGVuZ3RoO2lmKHI8PWlyKXJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyxpKTtsZXQgdD1cIlwiLG49MDtmb3IoO248cjspdCs9U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsaS5zbGljZShuLG4rPWlyKSk7cmV0dXJuIHR9ZnVuY3Rpb24gVnIoaSxyLHQpe2xldCBuPVwiXCI7dD1NYXRoLm1pbihpLmxlbmd0aCx0KTtmb3IobGV0IGU9cjtlPHQ7KytlKW4rPVN0cmluZy5mcm9tQ2hhckNvZGUoaVtlXSYxMjcpO3JldHVybiBufWZ1bmN0aW9uIFhyKGkscix0KXtsZXQgbj1cIlwiO3Q9TWF0aC5taW4oaS5sZW5ndGgsdCk7Zm9yKGxldCBlPXI7ZTx0OysrZSluKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGlbZV0pO3JldHVybiBufWZ1bmN0aW9uIHpyKGkscix0KXtsZXQgbj1pLmxlbmd0aDsoIXJ8fHI8MCkmJihyPTApLCghdHx8dDwwfHx0Pm4pJiYodD1uKTtsZXQgZT1cIlwiO2ZvcihsZXQgbz1yO288dDsrK28pZSs9dHRbaVtvXV07cmV0dXJuIGV9ZnVuY3Rpb24gSnIoaSxyLHQpe2xldCBuPWkuc2xpY2Uocix0KSxlPVwiXCI7Zm9yKGxldCBvPTA7bzxuLmxlbmd0aC0xO28rPTIpZSs9U3RyaW5nLmZyb21DaGFyQ29kZShuW29dK25bbysxXSoyNTYpO3JldHVybiBlfWgucHJvdG90eXBlLnNsaWNlPWZ1bmN0aW9uKHIsdCl7bGV0IG49dGhpcy5sZW5ndGg7cj1+fnIsdD10PT09dm9pZCAwP246fn50LHI8MD8ocis9bixyPDAmJihyPTApKTpyPm4mJihyPW4pLHQ8MD8odCs9bix0PDAmJih0PTApKTp0Pm4mJih0PW4pLHQ8ciYmKHQ9cik7bGV0IGU9dGhpcy5zdWJhcnJheShyLHQpO3JldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2YoZSxoLnByb3RvdHlwZSksZX07ZnVuY3Rpb24gYShpLHIsdCl7aWYoaSUxIT09MHx8aTwwKXRocm93IG5ldyBSYW5nZUVycm9yKFwib2Zmc2V0IGlzIG5vdCB1aW50XCIpO2lmKGkrcj50KXRocm93IG5ldyBSYW5nZUVycm9yKFwiVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aFwiKX1oLnByb3RvdHlwZS5yZWFkVWludExFPWgucHJvdG90eXBlLnJlYWRVSW50TEU9ZnVuY3Rpb24ocix0LG4pe3I9cj4+PjAsdD10Pj4+MCxufHxhKHIsdCx0aGlzLmxlbmd0aCk7bGV0IGU9dGhpc1tyXSxvPTEsdT0wO2Zvcig7Kyt1PHQmJihvKj0yNTYpOyllKz10aGlzW3IrdV0qbztyZXR1cm4gZX07aC5wcm90b3R5cGUucmVhZFVpbnRCRT1oLnByb3RvdHlwZS5yZWFkVUludEJFPWZ1bmN0aW9uKHIsdCxuKXtyPXI+Pj4wLHQ9dD4+PjAsbnx8YShyLHQsdGhpcy5sZW5ndGgpO2xldCBlPXRoaXNbcistLXRdLG89MTtmb3IoO3Q+MCYmKG8qPTI1Nik7KWUrPXRoaXNbcistLXRdKm87cmV0dXJuIGV9O2gucHJvdG90eXBlLnJlYWRVaW50OD1oLnByb3RvdHlwZS5yZWFkVUludDg9ZnVuY3Rpb24ocix0KXtyZXR1cm4gcj1yPj4+MCx0fHxhKHIsMSx0aGlzLmxlbmd0aCksdGhpc1tyXX07aC5wcm90b3R5cGUucmVhZFVpbnQxNkxFPWgucHJvdG90eXBlLnJlYWRVSW50MTZMRT1mdW5jdGlvbihyLHQpe3JldHVybiByPXI+Pj4wLHR8fGEociwyLHRoaXMubGVuZ3RoKSx0aGlzW3JdfHRoaXNbcisxXTw8OH07aC5wcm90b3R5cGUucmVhZFVpbnQxNkJFPWgucHJvdG90eXBlLnJlYWRVSW50MTZCRT1mdW5jdGlvbihyLHQpe3JldHVybiByPXI+Pj4wLHR8fGEociwyLHRoaXMubGVuZ3RoKSx0aGlzW3JdPDw4fHRoaXNbcisxXX07aC5wcm90b3R5cGUucmVhZFVpbnQzMkxFPWgucHJvdG90eXBlLnJlYWRVSW50MzJMRT1mdW5jdGlvbihyLHQpe3JldHVybiByPXI+Pj4wLHR8fGEociw0LHRoaXMubGVuZ3RoKSwodGhpc1tyXXx0aGlzW3IrMV08PDh8dGhpc1tyKzJdPDwxNikrdGhpc1tyKzNdKjE2Nzc3MjE2fTtoLnByb3RvdHlwZS5yZWFkVWludDMyQkU9aC5wcm90b3R5cGUucmVhZFVJbnQzMkJFPWZ1bmN0aW9uKHIsdCl7cmV0dXJuIHI9cj4+PjAsdHx8YShyLDQsdGhpcy5sZW5ndGgpLHRoaXNbcl0qMTY3NzcyMTYrKHRoaXNbcisxXTw8MTZ8dGhpc1tyKzJdPDw4fHRoaXNbciszXSl9O2gucHJvdG90eXBlLnJlYWRCaWdVSW50NjRMRT1nKGZ1bmN0aW9uKHIpe3I9cj4+PjAsUihyLFwib2Zmc2V0XCIpO2xldCB0PXRoaXNbcl0sbj10aGlzW3IrN107KHQ9PT12b2lkIDB8fG49PT12b2lkIDApJiZfKHIsdGhpcy5sZW5ndGgtOCk7bGV0IGU9dCt0aGlzWysrcl0qMioqOCt0aGlzWysrcl0qMioqMTYrdGhpc1srK3JdKjIqKjI0LG89dGhpc1srK3JdK3RoaXNbKytyXSoyKio4K3RoaXNbKytyXSoyKioxNituKjIqKjI0O3JldHVybiBCaWdJbnQoZSkrKEJpZ0ludChvKTw8QmlnSW50KDMyKSl9KTtoLnByb3RvdHlwZS5yZWFkQmlnVUludDY0QkU9ZyhmdW5jdGlvbihyKXtyPXI+Pj4wLFIocixcIm9mZnNldFwiKTtsZXQgdD10aGlzW3JdLG49dGhpc1tyKzddOyh0PT09dm9pZCAwfHxuPT09dm9pZCAwKSYmXyhyLHRoaXMubGVuZ3RoLTgpO2xldCBlPXQqMioqMjQrdGhpc1srK3JdKjIqKjE2K3RoaXNbKytyXSoyKio4K3RoaXNbKytyXSxvPXRoaXNbKytyXSoyKioyNCt0aGlzWysrcl0qMioqMTYrdGhpc1srK3JdKjIqKjgrbjtyZXR1cm4oQmlnSW50KGUpPDxCaWdJbnQoMzIpKStCaWdJbnQobyl9KTtoLnByb3RvdHlwZS5yZWFkSW50TEU9ZnVuY3Rpb24ocix0LG4pe3I9cj4+PjAsdD10Pj4+MCxufHxhKHIsdCx0aGlzLmxlbmd0aCk7bGV0IGU9dGhpc1tyXSxvPTEsdT0wO2Zvcig7Kyt1PHQmJihvKj0yNTYpOyllKz10aGlzW3IrdV0qbztyZXR1cm4gbyo9MTI4LGU+PW8mJihlLT1NYXRoLnBvdygyLDgqdCkpLGV9O2gucHJvdG90eXBlLnJlYWRJbnRCRT1mdW5jdGlvbihyLHQsbil7cj1yPj4+MCx0PXQ+Pj4wLG58fGEocix0LHRoaXMubGVuZ3RoKTtsZXQgZT10LG89MSx1PXRoaXNbcistLWVdO2Zvcig7ZT4wJiYobyo9MjU2KTspdSs9dGhpc1tyKy0tZV0qbztyZXR1cm4gbyo9MTI4LHU+PW8mJih1LT1NYXRoLnBvdygyLDgqdCkpLHV9O2gucHJvdG90eXBlLnJlYWRJbnQ4PWZ1bmN0aW9uKHIsdCl7cmV0dXJuIHI9cj4+PjAsdHx8YShyLDEsdGhpcy5sZW5ndGgpLHRoaXNbcl0mMTI4PygyNTUtdGhpc1tyXSsxKSotMTp0aGlzW3JdfTtoLnByb3RvdHlwZS5yZWFkSW50MTZMRT1mdW5jdGlvbihyLHQpe3I9cj4+PjAsdHx8YShyLDIsdGhpcy5sZW5ndGgpO2xldCBuPXRoaXNbcl18dGhpc1tyKzFdPDw4O3JldHVybiBuJjMyNzY4P258NDI5NDkwMTc2MDpufTtoLnByb3RvdHlwZS5yZWFkSW50MTZCRT1mdW5jdGlvbihyLHQpe3I9cj4+PjAsdHx8YShyLDIsdGhpcy5sZW5ndGgpO2xldCBuPXRoaXNbcisxXXx0aGlzW3JdPDw4O3JldHVybiBuJjMyNzY4P258NDI5NDkwMTc2MDpufTtoLnByb3RvdHlwZS5yZWFkSW50MzJMRT1mdW5jdGlvbihyLHQpe3JldHVybiByPXI+Pj4wLHR8fGEociw0LHRoaXMubGVuZ3RoKSx0aGlzW3JdfHRoaXNbcisxXTw8OHx0aGlzW3IrMl08PDE2fHRoaXNbciszXTw8MjR9O2gucHJvdG90eXBlLnJlYWRJbnQzMkJFPWZ1bmN0aW9uKHIsdCl7cmV0dXJuIHI9cj4+PjAsdHx8YShyLDQsdGhpcy5sZW5ndGgpLHRoaXNbcl08PDI0fHRoaXNbcisxXTw8MTZ8dGhpc1tyKzJdPDw4fHRoaXNbciszXX07aC5wcm90b3R5cGUucmVhZEJpZ0ludDY0TEU9ZyhmdW5jdGlvbihyKXtyPXI+Pj4wLFIocixcIm9mZnNldFwiKTtsZXQgdD10aGlzW3JdLG49dGhpc1tyKzddOyh0PT09dm9pZCAwfHxuPT09dm9pZCAwKSYmXyhyLHRoaXMubGVuZ3RoLTgpO2xldCBlPXRoaXNbcis0XSt0aGlzW3IrNV0qMioqOCt0aGlzW3IrNl0qMioqMTYrKG48PDI0KTtyZXR1cm4oQmlnSW50KGUpPDxCaWdJbnQoMzIpKStCaWdJbnQodCt0aGlzWysrcl0qMioqOCt0aGlzWysrcl0qMioqMTYrdGhpc1srK3JdKjIqKjI0KX0pO2gucHJvdG90eXBlLnJlYWRCaWdJbnQ2NEJFPWcoZnVuY3Rpb24ocil7cj1yPj4+MCxSKHIsXCJvZmZzZXRcIik7bGV0IHQ9dGhpc1tyXSxuPXRoaXNbcis3XTsodD09PXZvaWQgMHx8bj09PXZvaWQgMCkmJl8ocix0aGlzLmxlbmd0aC04KTtsZXQgZT0odDw8MjQpK3RoaXNbKytyXSoyKioxNit0aGlzWysrcl0qMioqOCt0aGlzWysrcl07cmV0dXJuKEJpZ0ludChlKTw8QmlnSW50KDMyKSkrQmlnSW50KHRoaXNbKytyXSoyKioyNCt0aGlzWysrcl0qMioqMTYrdGhpc1srK3JdKjIqKjgrbil9KTtoLnByb3RvdHlwZS5yZWFkRmxvYXRMRT1mdW5jdGlvbihyLHQpe3JldHVybiByPXI+Pj4wLHR8fGEociw0LHRoaXMubGVuZ3RoKSxVLnJlYWQodGhpcyxyLCEwLDIzLDQpfTtoLnByb3RvdHlwZS5yZWFkRmxvYXRCRT1mdW5jdGlvbihyLHQpe3JldHVybiByPXI+Pj4wLHR8fGEociw0LHRoaXMubGVuZ3RoKSxVLnJlYWQodGhpcyxyLCExLDIzLDQpfTtoLnByb3RvdHlwZS5yZWFkRG91YmxlTEU9ZnVuY3Rpb24ocix0KXtyZXR1cm4gcj1yPj4+MCx0fHxhKHIsOCx0aGlzLmxlbmd0aCksVS5yZWFkKHRoaXMsciwhMCw1Miw4KX07aC5wcm90b3R5cGUucmVhZERvdWJsZUJFPWZ1bmN0aW9uKHIsdCl7cmV0dXJuIHI9cj4+PjAsdHx8YShyLDgsdGhpcy5sZW5ndGgpLFUucmVhZCh0aGlzLHIsITEsNTIsOCl9O2Z1bmN0aW9uIHkoaSxyLHQsbixlLG8pe2lmKCFoLmlzQnVmZmVyKGkpKXRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpO2lmKHI+ZXx8cjxvKXRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpO2lmKHQrbj5pLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKX1oLnByb3RvdHlwZS53cml0ZVVpbnRMRT1oLnByb3RvdHlwZS53cml0ZVVJbnRMRT1mdW5jdGlvbihyLHQsbixlKXtpZihyPStyLHQ9dD4+PjAsbj1uPj4+MCwhZSl7bGV0IGY9TWF0aC5wb3coMiw4Km4pLTE7eSh0aGlzLHIsdCxuLGYsMCl9bGV0IG89MSx1PTA7Zm9yKHRoaXNbdF09ciYyNTU7Kyt1PG4mJihvKj0yNTYpOyl0aGlzW3QrdV09ci9vJjI1NTtyZXR1cm4gdCtufTtoLnByb3RvdHlwZS53cml0ZVVpbnRCRT1oLnByb3RvdHlwZS53cml0ZVVJbnRCRT1mdW5jdGlvbihyLHQsbixlKXtpZihyPStyLHQ9dD4+PjAsbj1uPj4+MCwhZSl7bGV0IGY9TWF0aC5wb3coMiw4Km4pLTE7eSh0aGlzLHIsdCxuLGYsMCl9bGV0IG89bi0xLHU9MTtmb3IodGhpc1t0K29dPXImMjU1Oy0tbz49MCYmKHUqPTI1Nik7KXRoaXNbdCtvXT1yL3UmMjU1O3JldHVybiB0K259O2gucHJvdG90eXBlLndyaXRlVWludDg9aC5wcm90b3R5cGUud3JpdGVVSW50OD1mdW5jdGlvbihyLHQsbil7cmV0dXJuIHI9K3IsdD10Pj4+MCxufHx5KHRoaXMscix0LDEsMjU1LDApLHRoaXNbdF09ciYyNTUsdCsxfTtoLnByb3RvdHlwZS53cml0ZVVpbnQxNkxFPWgucHJvdG90eXBlLndyaXRlVUludDE2TEU9ZnVuY3Rpb24ocix0LG4pe3JldHVybiByPStyLHQ9dD4+PjAsbnx8eSh0aGlzLHIsdCwyLDY1NTM1LDApLHRoaXNbdF09ciYyNTUsdGhpc1t0KzFdPXI+Pj44LHQrMn07aC5wcm90b3R5cGUud3JpdGVVaW50MTZCRT1oLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFPWZ1bmN0aW9uKHIsdCxuKXtyZXR1cm4gcj0rcix0PXQ+Pj4wLG58fHkodGhpcyxyLHQsMiw2NTUzNSwwKSx0aGlzW3RdPXI+Pj44LHRoaXNbdCsxXT1yJjI1NSx0KzJ9O2gucHJvdG90eXBlLndyaXRlVWludDMyTEU9aC5wcm90b3R5cGUud3JpdGVVSW50MzJMRT1mdW5jdGlvbihyLHQsbil7cmV0dXJuIHI9K3IsdD10Pj4+MCxufHx5KHRoaXMscix0LDQsNDI5NDk2NzI5NSwwKSx0aGlzW3QrM109cj4+PjI0LHRoaXNbdCsyXT1yPj4+MTYsdGhpc1t0KzFdPXI+Pj44LHRoaXNbdF09ciYyNTUsdCs0fTtoLnByb3RvdHlwZS53cml0ZVVpbnQzMkJFPWgucHJvdG90eXBlLndyaXRlVUludDMyQkU9ZnVuY3Rpb24ocix0LG4pe3JldHVybiByPStyLHQ9dD4+PjAsbnx8eSh0aGlzLHIsdCw0LDQyOTQ5NjcyOTUsMCksdGhpc1t0XT1yPj4+MjQsdGhpc1t0KzFdPXI+Pj4xNix0aGlzW3QrMl09cj4+PjgsdGhpc1t0KzNdPXImMjU1LHQrNH07ZnVuY3Rpb24gY3IoaSxyLHQsbixlKXt5cihyLG4sZSxpLHQsNyk7bGV0IG89TnVtYmVyKHImQmlnSW50KDQyOTQ5NjcyOTUpKTtpW3QrK109byxvPW8+PjgsaVt0KytdPW8sbz1vPj44LGlbdCsrXT1vLG89bz4+OCxpW3QrK109bztsZXQgdT1OdW1iZXIocj4+QmlnSW50KDMyKSZCaWdJbnQoNDI5NDk2NzI5NSkpO3JldHVybiBpW3QrK109dSx1PXU+PjgsaVt0KytdPXUsdT11Pj44LGlbdCsrXT11LHU9dT4+OCxpW3QrK109dSx0fWZ1bmN0aW9uIHByKGkscix0LG4sZSl7eXIocixuLGUsaSx0LDcpO2xldCBvPU51bWJlcihyJkJpZ0ludCg0Mjk0OTY3Mjk1KSk7aVt0KzddPW8sbz1vPj44LGlbdCs2XT1vLG89bz4+OCxpW3QrNV09byxvPW8+PjgsaVt0KzRdPW87bGV0IHU9TnVtYmVyKHI+PkJpZ0ludCgzMikmQmlnSW50KDQyOTQ5NjcyOTUpKTtyZXR1cm4gaVt0KzNdPXUsdT11Pj44LGlbdCsyXT11LHU9dT4+OCxpW3QrMV09dSx1PXU+PjgsaVt0XT11LHQrOH1oLnByb3RvdHlwZS53cml0ZUJpZ1VJbnQ2NExFPWcoZnVuY3Rpb24ocix0PTApe3JldHVybiBjcih0aGlzLHIsdCxCaWdJbnQoMCksQmlnSW50KFwiMHhmZmZmZmZmZmZmZmZmZmZmXCIpKX0pO2gucHJvdG90eXBlLndyaXRlQmlnVUludDY0QkU9ZyhmdW5jdGlvbihyLHQ9MCl7cmV0dXJuIHByKHRoaXMscix0LEJpZ0ludCgwKSxCaWdJbnQoXCIweGZmZmZmZmZmZmZmZmZmZmZcIikpfSk7aC5wcm90b3R5cGUud3JpdGVJbnRMRT1mdW5jdGlvbihyLHQsbixlKXtpZihyPStyLHQ9dD4+PjAsIWUpe2xldCBjPU1hdGgucG93KDIsOCpuLTEpO3kodGhpcyxyLHQsbixjLTEsLWMpfWxldCBvPTAsdT0xLGY9MDtmb3IodGhpc1t0XT1yJjI1NTsrK288biYmKHUqPTI1Nik7KXI8MCYmZj09PTAmJnRoaXNbdCtvLTFdIT09MCYmKGY9MSksdGhpc1t0K29dPShyL3U+PjApLWYmMjU1O3JldHVybiB0K259O2gucHJvdG90eXBlLndyaXRlSW50QkU9ZnVuY3Rpb24ocix0LG4sZSl7aWYocj0rcix0PXQ+Pj4wLCFlKXtsZXQgYz1NYXRoLnBvdygyLDgqbi0xKTt5KHRoaXMscix0LG4sYy0xLC1jKX1sZXQgbz1uLTEsdT0xLGY9MDtmb3IodGhpc1t0K29dPXImMjU1Oy0tbz49MCYmKHUqPTI1Nik7KXI8MCYmZj09PTAmJnRoaXNbdCtvKzFdIT09MCYmKGY9MSksdGhpc1t0K29dPShyL3U+PjApLWYmMjU1O3JldHVybiB0K259O2gucHJvdG90eXBlLndyaXRlSW50OD1mdW5jdGlvbihyLHQsbil7cmV0dXJuIHI9K3IsdD10Pj4+MCxufHx5KHRoaXMscix0LDEsMTI3LC0xMjgpLHI8MCYmKHI9MjU1K3IrMSksdGhpc1t0XT1yJjI1NSx0KzF9O2gucHJvdG90eXBlLndyaXRlSW50MTZMRT1mdW5jdGlvbihyLHQsbil7cmV0dXJuIHI9K3IsdD10Pj4+MCxufHx5KHRoaXMscix0LDIsMzI3NjcsLTMyNzY4KSx0aGlzW3RdPXImMjU1LHRoaXNbdCsxXT1yPj4+OCx0KzJ9O2gucHJvdG90eXBlLndyaXRlSW50MTZCRT1mdW5jdGlvbihyLHQsbil7cmV0dXJuIHI9K3IsdD10Pj4+MCxufHx5KHRoaXMscix0LDIsMzI3NjcsLTMyNzY4KSx0aGlzW3RdPXI+Pj44LHRoaXNbdCsxXT1yJjI1NSx0KzJ9O2gucHJvdG90eXBlLndyaXRlSW50MzJMRT1mdW5jdGlvbihyLHQsbil7cmV0dXJuIHI9K3IsdD10Pj4+MCxufHx5KHRoaXMscix0LDQsMjE0NzQ4MzY0NywtMjE0NzQ4MzY0OCksdGhpc1t0XT1yJjI1NSx0aGlzW3QrMV09cj4+PjgsdGhpc1t0KzJdPXI+Pj4xNix0aGlzW3QrM109cj4+PjI0LHQrNH07aC5wcm90b3R5cGUud3JpdGVJbnQzMkJFPWZ1bmN0aW9uKHIsdCxuKXtyZXR1cm4gcj0rcix0PXQ+Pj4wLG58fHkodGhpcyxyLHQsNCwyMTQ3NDgzNjQ3LC0yMTQ3NDgzNjQ4KSxyPDAmJihyPTQyOTQ5NjcyOTUrcisxKSx0aGlzW3RdPXI+Pj4yNCx0aGlzW3QrMV09cj4+PjE2LHRoaXNbdCsyXT1yPj4+OCx0aGlzW3QrM109ciYyNTUsdCs0fTtoLnByb3RvdHlwZS53cml0ZUJpZ0ludDY0TEU9ZyhmdW5jdGlvbihyLHQ9MCl7cmV0dXJuIGNyKHRoaXMscix0LC1CaWdJbnQoXCIweDgwMDAwMDAwMDAwMDAwMDBcIiksQmlnSW50KFwiMHg3ZmZmZmZmZmZmZmZmZmZmXCIpKX0pO2gucHJvdG90eXBlLndyaXRlQmlnSW50NjRCRT1nKGZ1bmN0aW9uKHIsdD0wKXtyZXR1cm4gcHIodGhpcyxyLHQsLUJpZ0ludChcIjB4ODAwMDAwMDAwMDAwMDAwMFwiKSxCaWdJbnQoXCIweDdmZmZmZmZmZmZmZmZmZmZcIikpfSk7ZnVuY3Rpb24gc3IoaSxyLHQsbixlLG8pe2lmKHQrbj5pLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKTtpZih0PDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIil9ZnVuY3Rpb24gbHIoaSxyLHQsbixlKXtyZXR1cm4gcj0rcix0PXQ+Pj4wLGV8fHNyKGkscix0LDQsMzQwMjgyMzQ2NjM4NTI4ODZlMjIsLTM0MDI4MjM0NjYzODUyODg2ZTIyKSxVLndyaXRlKGkscix0LG4sMjMsNCksdCs0fWgucHJvdG90eXBlLndyaXRlRmxvYXRMRT1mdW5jdGlvbihyLHQsbil7cmV0dXJuIGxyKHRoaXMscix0LCEwLG4pfTtoLnByb3RvdHlwZS53cml0ZUZsb2F0QkU9ZnVuY3Rpb24ocix0LG4pe3JldHVybiBscih0aGlzLHIsdCwhMSxuKX07ZnVuY3Rpb24gYXIoaSxyLHQsbixlKXtyZXR1cm4gcj0rcix0PXQ+Pj4wLGV8fHNyKGkscix0LDgsMTc5NzY5MzEzNDg2MjMxNTdlMjkyLC0xNzk3NjkzMTM0ODYyMzE1N2UyOTIpLFUud3JpdGUoaSxyLHQsbiw1Miw4KSx0Kzh9aC5wcm90b3R5cGUud3JpdGVEb3VibGVMRT1mdW5jdGlvbihyLHQsbil7cmV0dXJuIGFyKHRoaXMscix0LCEwLG4pfTtoLnByb3RvdHlwZS53cml0ZURvdWJsZUJFPWZ1bmN0aW9uKHIsdCxuKXtyZXR1cm4gYXIodGhpcyxyLHQsITEsbil9O2gucHJvdG90eXBlLmNvcHk9ZnVuY3Rpb24ocix0LG4sZSl7aWYoIWguaXNCdWZmZXIocikpdGhyb3cgbmV3IFR5cGVFcnJvcihcImFyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlclwiKTtpZihufHwobj0wKSwhZSYmZSE9PTAmJihlPXRoaXMubGVuZ3RoKSx0Pj1yLmxlbmd0aCYmKHQ9ci5sZW5ndGgpLHR8fCh0PTApLGU+MCYmZTxuJiYoZT1uKSxlPT09bnx8ci5sZW5ndGg9PT0wfHx0aGlzLmxlbmd0aD09PTApcmV0dXJuIDA7aWYodDwwKXRocm93IG5ldyBSYW5nZUVycm9yKFwidGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kc1wiKTtpZihuPDB8fG4+PXRoaXMubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpO2lmKGU8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInNvdXJjZUVuZCBvdXQgb2YgYm91bmRzXCIpO2U+dGhpcy5sZW5ndGgmJihlPXRoaXMubGVuZ3RoKSxyLmxlbmd0aC10PGUtbiYmKGU9ci5sZW5ndGgtdCtuKTtsZXQgbz1lLW47cmV0dXJuIHRoaXM9PT1yJiZ0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbj09XCJmdW5jdGlvblwiP3RoaXMuY29weVdpdGhpbih0LG4sZSk6VWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwocix0aGlzLnN1YmFycmF5KG4sZSksdCksb307aC5wcm90b3R5cGUuZmlsbD1mdW5jdGlvbihyLHQsbixlKXtpZih0eXBlb2Ygcj09XCJzdHJpbmdcIil7aWYodHlwZW9mIHQ9PVwic3RyaW5nXCI/KGU9dCx0PTAsbj10aGlzLmxlbmd0aCk6dHlwZW9mIG49PVwic3RyaW5nXCImJihlPW4sbj10aGlzLmxlbmd0aCksZSE9PXZvaWQgMCYmdHlwZW9mIGUhPVwic3RyaW5nXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcImVuY29kaW5nIG11c3QgYmUgYSBzdHJpbmdcIik7aWYodHlwZW9mIGU9PVwic3RyaW5nXCImJiFoLmlzRW5jb2RpbmcoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK2UpO2lmKHIubGVuZ3RoPT09MSl7bGV0IHU9ci5jaGFyQ29kZUF0KDApOyhlPT09XCJ1dGY4XCImJnU8MTI4fHxlPT09XCJsYXRpbjFcIikmJihyPXUpfX1lbHNlIHR5cGVvZiByPT1cIm51bWJlclwiP3I9ciYyNTU6dHlwZW9mIHI9PVwiYm9vbGVhblwiJiYocj1OdW1iZXIocikpO2lmKHQ8MHx8dGhpcy5sZW5ndGg8dHx8dGhpcy5sZW5ndGg8bil0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk91dCBvZiByYW5nZSBpbmRleFwiKTtpZihuPD10KXJldHVybiB0aGlzO3Q9dD4+PjAsbj1uPT09dm9pZCAwP3RoaXMubGVuZ3RoOm4+Pj4wLHJ8fChyPTApO2xldCBvO2lmKHR5cGVvZiByPT1cIm51bWJlclwiKWZvcihvPXQ7bzxuOysrbyl0aGlzW29dPXI7ZWxzZXtsZXQgdT1oLmlzQnVmZmVyKHIpP3I6aC5mcm9tKHIsZSksZj11Lmxlbmd0aDtpZihmPT09MCl0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInK3IrJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpO2ZvcihvPTA7bzxuLXQ7KytvKXRoaXNbbyt0XT11W28lZl19cmV0dXJuIHRoaXN9O3ZhciBBPXt9O2Z1bmN0aW9uIFYoaSxyLHQpe0FbaV09Y2xhc3MgZXh0ZW5kcyB0e2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyxcIm1lc3NhZ2VcIix7dmFsdWU6ci5hcHBseSh0aGlzLGFyZ3VtZW50cyksd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdGhpcy5uYW1lPVwiXCIuY29uY2F0KHRoaXMubmFtZSxcIiBbXCIpLmNvbmNhdChpLFwiXVwiKSx0aGlzLnN0YWNrLGRlbGV0ZSB0aGlzLm5hbWV9Z2V0IGNvZGUoKXtyZXR1cm4gaX1zZXQgY29kZShlKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyxcImNvZGVcIix7Y29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITAsdmFsdWU6ZSx3cml0YWJsZTohMH0pfXRvU3RyaW5nKCl7cmV0dXJuXCJcIi5jb25jYXQodGhpcy5uYW1lLFwiIFtcIikuY29uY2F0KGksXCJdOiBcIikuY29uY2F0KHRoaXMubWVzc2FnZSl9fX1WKFwiRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTXCIsZnVuY3Rpb24oaSl7cmV0dXJuIGk/XCJcIi5jb25jYXQoaSxcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHNcIik6XCJBdHRlbXB0IHRvIGFjY2VzcyBtZW1vcnkgb3V0c2lkZSBidWZmZXIgYm91bmRzXCJ9LFJhbmdlRXJyb3IpO1YoXCJFUlJfSU5WQUxJRF9BUkdfVFlQRVwiLGZ1bmN0aW9uKGkscil7cmV0dXJuJ1RoZSBcIicuY29uY2F0KGksJ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgJykuY29uY2F0KHR5cGVvZiByKX0sVHlwZUVycm9yKTtWKFwiRVJSX09VVF9PRl9SQU5HRVwiLGZ1bmN0aW9uKGkscix0KXtsZXQgbj0nVGhlIHZhbHVlIG9mIFwiJy5jb25jYXQoaSwnXCIgaXMgb3V0IG9mIHJhbmdlLicpLGU9dDtyZXR1cm4gTnVtYmVyLmlzSW50ZWdlcih0KSYmTWF0aC5hYnModCk+MioqMzI/ZT1ucihTdHJpbmcodCkpOnR5cGVvZiB0PT1cImJpZ2ludFwiJiYoZT1TdHJpbmcodCksKHQ+QmlnSW50KDIpKipCaWdJbnQoMzIpfHx0PC0oQmlnSW50KDIpKipCaWdJbnQoMzIpKSkmJihlPW5yKGUpKSxlKz1cIm5cIiksbis9XCIgSXQgbXVzdCBiZSBcIi5jb25jYXQocixcIi4gUmVjZWl2ZWQgXCIpLmNvbmNhdChlKSxufSxSYW5nZUVycm9yKTtmdW5jdGlvbiBucihpKXtsZXQgcj1cIlwiLHQ9aS5sZW5ndGgsbj1pWzBdPT09XCItXCI/MTowO2Zvcig7dD49bis0O3QtPTMpcj1cIl9cIi5jb25jYXQoaS5zbGljZSh0LTMsdCkpLmNvbmNhdChyKTtyZXR1cm5cIlwiLmNvbmNhdChpLnNsaWNlKDAsdCkpLmNvbmNhdChyKX1mdW5jdGlvbiBLcihpLHIsdCl7UihyLFwib2Zmc2V0XCIpLChpW3JdPT09dm9pZCAwfHxpW3IrdF09PT12b2lkIDApJiZfKHIsaS5sZW5ndGgtKHQrMSkpfWZ1bmN0aW9uIHlyKGkscix0LG4sZSxvKXtpZihpPnR8fGk8cil7bGV0IHU9dHlwZW9mIHI9PVwiYmlnaW50XCI/XCJuXCI6XCJcIixmO3Rocm93IG8+Mz9yPT09MHx8cj09PUJpZ0ludCgwKT9mPVwiPj0gMFwiLmNvbmNhdCh1LFwiIGFuZCA8IDJcIikuY29uY2F0KHUsXCIgKiogXCIpLmNvbmNhdCgobysxKSo4KS5jb25jYXQodSk6Zj1cIj49IC0oMlwiLmNvbmNhdCh1LFwiICoqIFwiKS5jb25jYXQoKG8rMSkqOC0xKS5jb25jYXQodSxcIikgYW5kIDwgMiAqKiBcIikrXCJcIi5jb25jYXQoKG8rMSkqOC0xKS5jb25jYXQodSk6Zj1cIj49IFwiLmNvbmNhdChyKS5jb25jYXQodSxcIiBhbmQgPD0gXCIpLmNvbmNhdCh0KS5jb25jYXQodSksbmV3IEEuRVJSX09VVF9PRl9SQU5HRShcInZhbHVlXCIsZixpKX1LcihuLGUsbyl9ZnVuY3Rpb24gUihpLHIpe2lmKHR5cGVvZiBpIT1cIm51bWJlclwiKXRocm93IG5ldyBBLkVSUl9JTlZBTElEX0FSR19UWVBFKHIsXCJudW1iZXJcIixpKX1mdW5jdGlvbiBfKGkscix0KXt0aHJvdyBNYXRoLmZsb29yKGkpIT09aT8oUihpLHQpLG5ldyBBLkVSUl9PVVRfT0ZfUkFOR0UodHx8XCJvZmZzZXRcIixcImFuIGludGVnZXJcIixpKSk6cjwwP25ldyBBLkVSUl9CVUZGRVJfT1VUX09GX0JPVU5EUzpuZXcgQS5FUlJfT1VUX09GX1JBTkdFKHR8fFwib2Zmc2V0XCIsXCI+PSBcIi5jb25jYXQodD8xOjAsXCIgYW5kIDw9IFwiKS5jb25jYXQociksaSl9dmFyIFpyPS9bXisvMC05QS1aYS16LV9dL2c7ZnVuY3Rpb24gUXIoaSl7aWYoaT1pLnNwbGl0KFwiPVwiKVswXSxpPWkudHJpbSgpLnJlcGxhY2UoWnIsXCJcIiksaS5sZW5ndGg8MilyZXR1cm5cIlwiO2Zvcig7aS5sZW5ndGglNCE9PTA7KWk9aStcIj1cIjtyZXR1cm4gaX1mdW5jdGlvbiBXKGkscil7cj1yfHwxLzA7bGV0IHQsbj1pLmxlbmd0aCxlPW51bGwsbz1bXTtmb3IobGV0IHU9MDt1PG47Kyt1KXtpZih0PWkuY2hhckNvZGVBdCh1KSx0PjU1Mjk1JiZ0PDU3MzQ0KXtpZighZSl7aWYodD41NjMxOSl7KHItPTMpPi0xJiZvLnB1c2goMjM5LDE5MSwxODkpO2NvbnRpbnVlfWVsc2UgaWYodSsxPT09bil7KHItPTMpPi0xJiZvLnB1c2goMjM5LDE5MSwxODkpO2NvbnRpbnVlfWU9dDtjb250aW51ZX1pZih0PDU2MzIwKXsoci09Myk+LTEmJm8ucHVzaCgyMzksMTkxLDE4OSksZT10O2NvbnRpbnVlfXQ9KGUtNTUyOTY8PDEwfHQtNTYzMjApKzY1NTM2fWVsc2UgZSYmKHItPTMpPi0xJiZvLnB1c2goMjM5LDE5MSwxODkpO2lmKGU9bnVsbCx0PDEyOCl7aWYoKHItPTEpPDApYnJlYWs7by5wdXNoKHQpfWVsc2UgaWYodDwyMDQ4KXtpZigoci09Mik8MClicmVhaztvLnB1c2godD4+NnwxOTIsdCY2M3wxMjgpfWVsc2UgaWYodDw2NTUzNil7aWYoKHItPTMpPDApYnJlYWs7by5wdXNoKHQ+PjEyfDIyNCx0Pj42JjYzfDEyOCx0JjYzfDEyOCl9ZWxzZSBpZih0PDExMTQxMTIpe2lmKChyLT00KTwwKWJyZWFrO28ucHVzaCh0Pj4xOHwyNDAsdD4+MTImNjN8MTI4LHQ+PjYmNjN8MTI4LHQmNjN8MTI4KX1lbHNlIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29kZSBwb2ludFwiKX1yZXR1cm4gb31mdW5jdGlvbiB2cihpKXtsZXQgcj1bXTtmb3IobGV0IHQ9MDt0PGkubGVuZ3RoOysrdClyLnB1c2goaS5jaGFyQ29kZUF0KHQpJjI1NSk7cmV0dXJuIHJ9ZnVuY3Rpb24gcnQoaSxyKXtsZXQgdCxuLGUsbz1bXTtmb3IobGV0IHU9MDt1PGkubGVuZ3RoJiYhKChyLT0yKTwwKTsrK3UpdD1pLmNoYXJDb2RlQXQodSksbj10Pj44LGU9dCUyNTYsby5wdXNoKGUpLG8ucHVzaChuKTtyZXR1cm4gb31mdW5jdGlvbiB3cihpKXtyZXR1cm4gRy50b0J5dGVBcnJheShRcihpKSl9ZnVuY3Rpb24gRChpLHIsdCxuKXtsZXQgZTtmb3IoZT0wO2U8biYmIShlK3Q+PXIubGVuZ3RofHxlPj1pLmxlbmd0aCk7KytlKXJbZSt0XT1pW2VdO3JldHVybiBlfWZ1bmN0aW9uIEUoaSxyKXtyZXR1cm4gaSBpbnN0YW5jZW9mIHJ8fGkhPW51bGwmJmkuY29uc3RydWN0b3IhPW51bGwmJmkuY29uc3RydWN0b3IubmFtZSE9bnVsbCYmaS5jb25zdHJ1Y3Rvci5uYW1lPT09ci5uYW1lfWZ1bmN0aW9uIFgoaSl7cmV0dXJuIGkhPT1pfXZhciB0dD1mdW5jdGlvbigpe2xldCBpPVwiMDEyMzQ1Njc4OWFiY2RlZlwiLHI9bmV3IEFycmF5KDI1Nik7Zm9yKGxldCB0PTA7dDwxNjsrK3Qpe2xldCBuPXQqMTY7Zm9yKGxldCBlPTA7ZTwxNjsrK2UpcltuK2VdPWlbdF0raVtlXX1yZXR1cm4gcn0oKTtmdW5jdGlvbiBnKGkpe3JldHVybiB0eXBlb2YgQmlnSW50PlwidVwiP2l0Oml9ZnVuY3Rpb24gaXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJCaWdJbnQgbm90IHN1cHBvcnRlZFwiKX19KTt2YXIgQz17fTtGcihDLHtkZWZhdWx0OigpPT5udH0pO21vZHVsZS5leHBvcnRzPUFyKEMpO3ZhciB4cj1KKHooKSk7UyhDLEooeigpKSxtb2R1bGUuZXhwb3J0cyk7dmFyIG50PXhyLmRlZmF1bHQ7XG4vKiEgQnVuZGxlZCBsaWNlbnNlIGluZm9ybWF0aW9uOlxuXG5pZWVlNzU0L2luZGV4LmpzOlxuICAoKiEgaWVlZTc1NC4gQlNELTMtQ2xhdXNlIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqKVxuXG5idWZmZXIvaW5kZXguanM6XG4gICgqIVxuICAgKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAgICpcbiAgICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAgICogQGxpY2Vuc2UgIE1JVFxuICAgKilcbiovXG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5cbi8qKlxuICogQ3JlYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBtZXNzYWdlLCBjb25maWcsIGVycm9yIGNvZGUsIHJlcXVlc3QgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBjcmVhdGVkIGVycm9yLlxuICovXG5mdW5jdGlvbiBBeGlvc0Vycm9yKG1lc3NhZ2UsIGNvZGUsIGNvbmZpZywgcmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgRXJyb3IuY2FsbCh0aGlzKTtcblxuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnN0YWNrID0gKG5ldyBFcnJvcigpKS5zdGFjaztcbiAgfVxuXG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHRoaXMubmFtZSA9ICdBeGlvc0Vycm9yJztcbiAgY29kZSAmJiAodGhpcy5jb2RlID0gY29kZSk7XG4gIGNvbmZpZyAmJiAodGhpcy5jb25maWcgPSBjb25maWcpO1xuICByZXF1ZXN0ICYmICh0aGlzLnJlcXVlc3QgPSByZXF1ZXN0KTtcbiAgcmVzcG9uc2UgJiYgKHRoaXMucmVzcG9uc2UgPSByZXNwb25zZSk7XG59XG5cbnV0aWxzLmluaGVyaXRzKEF4aW9zRXJyb3IsIEVycm9yLCB7XG4gIHRvSlNPTjogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvLyBTdGFuZGFyZFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgLy8gTWljcm9zb2Z0XG4gICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcbiAgICAgIG51bWJlcjogdGhpcy5udW1iZXIsXG4gICAgICAvLyBNb3ppbGxhXG4gICAgICBmaWxlTmFtZTogdGhpcy5maWxlTmFtZSxcbiAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcbiAgICAgIGNvbHVtbk51bWJlcjogdGhpcy5jb2x1bW5OdW1iZXIsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIC8vIEF4aW9zXG4gICAgICBjb25maWc6IHV0aWxzLnRvSlNPTk9iamVjdCh0aGlzLmNvbmZpZyksXG4gICAgICBjb2RlOiB0aGlzLmNvZGUsXG4gICAgICBzdGF0dXM6IHRoaXMucmVzcG9uc2UgJiYgdGhpcy5yZXNwb25zZS5zdGF0dXMgPyB0aGlzLnJlc3BvbnNlLnN0YXR1cyA6IG51bGxcbiAgICB9O1xuICB9XG59KTtcblxuY29uc3QgcHJvdG90eXBlID0gQXhpb3NFcnJvci5wcm90b3R5cGU7XG5jb25zdCBkZXNjcmlwdG9ycyA9IHt9O1xuXG5bXG4gICdFUlJfQkFEX09QVElPTl9WQUxVRScsXG4gICdFUlJfQkFEX09QVElPTicsXG4gICdFQ09OTkFCT1JURUQnLFxuICAnRVRJTUVET1VUJyxcbiAgJ0VSUl9ORVRXT1JLJyxcbiAgJ0VSUl9GUl9UT09fTUFOWV9SRURJUkVDVFMnLFxuICAnRVJSX0RFUFJFQ0FURUQnLFxuICAnRVJSX0JBRF9SRVNQT05TRScsXG4gICdFUlJfQkFEX1JFUVVFU1QnLFxuICAnRVJSX0NBTkNFTEVEJyxcbiAgJ0VSUl9OT1RfU1VQUE9SVCcsXG4gICdFUlJfSU5WQUxJRF9VUkwnXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuXS5mb3JFYWNoKGNvZGUgPT4ge1xuICBkZXNjcmlwdG9yc1tjb2RlXSA9IHt2YWx1ZTogY29kZX07XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQXhpb3NFcnJvciwgZGVzY3JpcHRvcnMpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgJ2lzQXhpb3NFcnJvcicsIHt2YWx1ZTogdHJ1ZX0pO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuQXhpb3NFcnJvci5mcm9tID0gKGVycm9yLCBjb2RlLCBjb25maWcsIHJlcXVlc3QsIHJlc3BvbnNlLCBjdXN0b21Qcm9wcykgPT4ge1xuICBjb25zdCBheGlvc0Vycm9yID0gT2JqZWN0LmNyZWF0ZShwcm90b3R5cGUpO1xuXG4gIHV0aWxzLnRvRmxhdE9iamVjdChlcnJvciwgYXhpb3NFcnJvciwgZnVuY3Rpb24gZmlsdGVyKG9iaikge1xuICAgIHJldHVybiBvYmogIT09IEVycm9yLnByb3RvdHlwZTtcbiAgfSwgcHJvcCA9PiB7XG4gICAgcmV0dXJuIHByb3AgIT09ICdpc0F4aW9zRXJyb3InO1xuICB9KTtcblxuICBBeGlvc0Vycm9yLmNhbGwoYXhpb3NFcnJvciwgZXJyb3IubWVzc2FnZSwgY29kZSwgY29uZmlnLCByZXF1ZXN0LCByZXNwb25zZSk7XG5cbiAgYXhpb3NFcnJvci5jYXVzZSA9IGVycm9yO1xuXG4gIGF4aW9zRXJyb3IubmFtZSA9IGVycm9yLm5hbWU7XG5cbiAgY3VzdG9tUHJvcHMgJiYgT2JqZWN0LmFzc2lnbihheGlvc0Vycm9yLCBjdXN0b21Qcm9wcyk7XG5cbiAgcmV0dXJuIGF4aW9zRXJyb3I7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBBeGlvc0Vycm9yO1xuIiwiLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHN0cmljdFxuZXhwb3J0IGRlZmF1bHQgbnVsbDtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4vLi4vdXRpbHMuanMnO1xuXG5jbGFzcyBJbnRlcmNlcHRvck1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmhhbmRsZXJzID0gW107XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgbmV3IGludGVyY2VwdG9yIHRvIHRoZSBzdGFja1xuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdWxmaWxsZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgdGhlbmAgZm9yIGEgYFByb21pc2VgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHJlamVjdGAgZm9yIGEgYFByb21pc2VgXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn0gQW4gSUQgdXNlZCB0byByZW1vdmUgaW50ZXJjZXB0b3IgbGF0ZXJcbiAgICovXG4gIHVzZShmdWxmaWxsZWQsIHJlamVjdGVkLCBvcHRpb25zKSB7XG4gICAgdGhpcy5oYW5kbGVycy5wdXNoKHtcbiAgICAgIGZ1bGZpbGxlZCxcbiAgICAgIHJlamVjdGVkLFxuICAgICAgc3luY2hyb25vdXM6IG9wdGlvbnMgPyBvcHRpb25zLnN5bmNocm9ub3VzIDogZmFsc2UsXG4gICAgICBydW5XaGVuOiBvcHRpb25zID8gb3B0aW9ucy5ydW5XaGVuIDogbnVsbFxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXJzLmxlbmd0aCAtIDE7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGludGVyY2VwdG9yIGZyb20gdGhlIHN0YWNrXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpZCBUaGUgSUQgdGhhdCB3YXMgcmV0dXJuZWQgYnkgYHVzZWBcbiAgICpcbiAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgaW50ZXJjZXB0b3Igd2FzIHJlbW92ZWQsIGBmYWxzZWAgb3RoZXJ3aXNlXG4gICAqL1xuICBlamVjdChpZCkge1xuICAgIGlmICh0aGlzLmhhbmRsZXJzW2lkXSkge1xuICAgICAgdGhpcy5oYW5kbGVyc1tpZF0gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciBhbGwgaW50ZXJjZXB0b3JzIGZyb20gdGhlIHN0YWNrXG4gICAqXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgY2xlYXIoKSB7XG4gICAgaWYgKHRoaXMuaGFuZGxlcnMpIHtcbiAgICAgIHRoaXMuaGFuZGxlcnMgPSBbXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSXRlcmF0ZSBvdmVyIGFsbCB0aGUgcmVnaXN0ZXJlZCBpbnRlcmNlcHRvcnNcbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3Igc2tpcHBpbmcgb3ZlciBhbnlcbiAgICogaW50ZXJjZXB0b3JzIHRoYXQgbWF5IGhhdmUgYmVjb21lIGBudWxsYCBjYWxsaW5nIGBlamVjdGAuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGludGVyY2VwdG9yXG4gICAqXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZm9yRWFjaChmbikge1xuICAgIHV0aWxzLmZvckVhY2godGhpcy5oYW5kbGVycywgZnVuY3Rpb24gZm9yRWFjaEhhbmRsZXIoaCkge1xuICAgICAgaWYgKGggIT09IG51bGwpIHtcbiAgICAgICAgZm4oaCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSW50ZXJjZXB0b3JNYW5hZ2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdHJhbnNmb3JtRGF0YSBmcm9tICcuL3RyYW5zZm9ybURhdGEuanMnO1xuaW1wb3J0IGlzQ2FuY2VsIGZyb20gJy4uL2NhbmNlbC9pc0NhbmNlbC5qcyc7XG5pbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi4vZGVmYXVsdHMvaW5kZXguanMnO1xuaW1wb3J0IENhbmNlbGVkRXJyb3IgZnJvbSAnLi4vY2FuY2VsL0NhbmNlbGVkRXJyb3IuanMnO1xuaW1wb3J0IEF4aW9zSGVhZGVycyBmcm9tICcuLi9jb3JlL0F4aW9zSGVhZGVycy5qcyc7XG5pbXBvcnQgYWRhcHRlcnMgZnJvbSBcIi4uL2FkYXB0ZXJzL2FkYXB0ZXJzLmpzXCI7XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGVkRXJyb3JgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHRoYXQgaXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlcXVlc3RcbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpIHtcbiAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgIGNvbmZpZy5jYW5jZWxUb2tlbi50aHJvd0lmUmVxdWVzdGVkKCk7XG4gIH1cblxuICBpZiAoY29uZmlnLnNpZ25hbCAmJiBjb25maWcuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICB0aHJvdyBuZXcgQ2FuY2VsZWRFcnJvcihudWxsLCBjb25maWcpO1xuICB9XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgdXNpbmcgdGhlIGNvbmZpZ3VyZWQgYWRhcHRlci5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIFRoZSBjb25maWcgdGhhdCBpcyB0byBiZSB1c2VkIGZvciB0aGUgcmVxdWVzdFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGlzcGF0Y2hSZXF1ZXN0KGNvbmZpZykge1xuICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgY29uZmlnLmhlYWRlcnMgPSBBeGlvc0hlYWRlcnMuZnJvbShjb25maWcuaGVhZGVycyk7XG5cbiAgLy8gVHJhbnNmb3JtIHJlcXVlc3QgZGF0YVxuICBjb25maWcuZGF0YSA9IHRyYW5zZm9ybURhdGEuY2FsbChcbiAgICBjb25maWcsXG4gICAgY29uZmlnLnRyYW5zZm9ybVJlcXVlc3RcbiAgKTtcblxuICBpZiAoWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLmluZGV4T2YoY29uZmlnLm1ldGhvZCkgIT09IC0xKSB7XG4gICAgY29uZmlnLmhlYWRlcnMuc2V0Q29udGVudFR5cGUoJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsIGZhbHNlKTtcbiAgfVxuXG4gIGNvbnN0IGFkYXB0ZXIgPSBhZGFwdGVycy5nZXRBZGFwdGVyKGNvbmZpZy5hZGFwdGVyIHx8IGRlZmF1bHRzLmFkYXB0ZXIpO1xuXG4gIHJldHVybiBhZGFwdGVyKGNvbmZpZykudGhlbihmdW5jdGlvbiBvbkFkYXB0ZXJSZXNvbHV0aW9uKHJlc3BvbnNlKSB7XG4gICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICByZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YS5jYWxsKFxuICAgICAgY29uZmlnLFxuICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlLFxuICAgICAgcmVzcG9uc2VcbiAgICApO1xuXG4gICAgcmVzcG9uc2UuaGVhZGVycyA9IEF4aW9zSGVhZGVycy5mcm9tKHJlc3BvbnNlLmhlYWRlcnMpO1xuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9LCBmdW5jdGlvbiBvbkFkYXB0ZXJSZWplY3Rpb24ocmVhc29uKSB7XG4gICAgaWYgKCFpc0NhbmNlbChyZWFzb24pKSB7XG4gICAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgICBpZiAocmVhc29uICYmIHJlYXNvbi5yZXNwb25zZSkge1xuICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEuY2FsbChcbiAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlLFxuICAgICAgICAgIHJlYXNvbi5yZXNwb25zZVxuICAgICAgICApO1xuICAgICAgICByZWFzb24ucmVzcG9uc2UuaGVhZGVycyA9IEF4aW9zSGVhZGVycy5mcm9tKHJlYXNvbi5yZXNwb25zZS5oZWFkZXJzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocmVhc29uKTtcbiAgfSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLy4uL3V0aWxzLmpzJztcbmltcG9ydCBkZWZhdWx0cyBmcm9tICcuLi9kZWZhdWx0cy9pbmRleC5qcyc7XG5pbXBvcnQgQXhpb3NIZWFkZXJzIGZyb20gJy4uL2NvcmUvQXhpb3NIZWFkZXJzLmpzJztcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIGRhdGEgZm9yIGEgcmVxdWVzdCBvciBhIHJlc3BvbnNlXG4gKlxuICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbn0gZm5zIEEgc2luZ2xlIGZ1bmN0aW9uIG9yIEFycmF5IG9mIGZ1bmN0aW9uc1xuICogQHBhcmFtIHs/T2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2Ugb2JqZWN0XG4gKlxuICogQHJldHVybnMgeyp9IFRoZSByZXN1bHRpbmcgdHJhbnNmb3JtZWQgZGF0YVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0cmFuc2Zvcm1EYXRhKGZucywgcmVzcG9uc2UpIHtcbiAgY29uc3QgY29uZmlnID0gdGhpcyB8fCBkZWZhdWx0cztcbiAgY29uc3QgY29udGV4dCA9IHJlc3BvbnNlIHx8IGNvbmZpZztcbiAgY29uc3QgaGVhZGVycyA9IEF4aW9zSGVhZGVycy5mcm9tKGNvbnRleHQuaGVhZGVycyk7XG4gIGxldCBkYXRhID0gY29udGV4dC5kYXRhO1xuXG4gIHV0aWxzLmZvckVhY2goZm5zLCBmdW5jdGlvbiB0cmFuc2Zvcm0oZm4pIHtcbiAgICBkYXRhID0gZm4uY2FsbChjb25maWcsIGRhdGEsIGhlYWRlcnMubm9ybWFsaXplKCksIHJlc3BvbnNlID8gcmVzcG9uc2Uuc3RhdHVzIDogdW5kZWZpbmVkKTtcbiAgfSk7XG5cbiAgaGVhZGVycy5ub3JtYWxpemUoKTtcblxuICByZXR1cm4gZGF0YTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gJy4uL2NvcmUvQXhpb3NFcnJvci5qcyc7XG5pbXBvcnQgdHJhbnNpdGlvbmFsRGVmYXVsdHMgZnJvbSAnLi90cmFuc2l0aW9uYWwuanMnO1xuaW1wb3J0IHRvRm9ybURhdGEgZnJvbSAnLi4vaGVscGVycy90b0Zvcm1EYXRhLmpzJztcbmltcG9ydCB0b1VSTEVuY29kZWRGb3JtIGZyb20gJy4uL2hlbHBlcnMvdG9VUkxFbmNvZGVkRm9ybS5qcyc7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vcGxhdGZvcm0vaW5kZXguanMnO1xuaW1wb3J0IGZvcm1EYXRhVG9KU09OIGZyb20gJy4uL2hlbHBlcnMvZm9ybURhdGFUb0pTT04uanMnO1xuXG4vKipcbiAqIEl0IHRha2VzIGEgc3RyaW5nLCB0cmllcyB0byBwYXJzZSBpdCwgYW5kIGlmIGl0IGZhaWxzLCBpdCByZXR1cm5zIHRoZSBzdHJpbmdpZmllZCB2ZXJzaW9uXG4gKiBvZiB0aGUgaW5wdXRcbiAqXG4gKiBAcGFyYW0ge2FueX0gcmF3VmFsdWUgLSBUaGUgdmFsdWUgdG8gYmUgc3RyaW5naWZpZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwYXJzZXIgLSBBIGZ1bmN0aW9uIHRoYXQgcGFyc2VzIGEgc3RyaW5nIGludG8gYSBKYXZhU2NyaXB0IG9iamVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVuY29kZXIgLSBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSB2YWx1ZSBhbmQgcmV0dXJucyBhIHN0cmluZy5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIHN0cmluZ2lmaWVkIHZlcnNpb24gb2YgdGhlIHJhd1ZhbHVlLlxuICovXG5mdW5jdGlvbiBzdHJpbmdpZnlTYWZlbHkocmF3VmFsdWUsIHBhcnNlciwgZW5jb2Rlcikge1xuICBpZiAodXRpbHMuaXNTdHJpbmcocmF3VmFsdWUpKSB7XG4gICAgdHJ5IHtcbiAgICAgIChwYXJzZXIgfHwgSlNPTi5wYXJzZSkocmF3VmFsdWUpO1xuICAgICAgcmV0dXJuIHV0aWxzLnRyaW0ocmF3VmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLm5hbWUgIT09ICdTeW50YXhFcnJvcicpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gKGVuY29kZXIgfHwgSlNPTi5zdHJpbmdpZnkpKHJhd1ZhbHVlKTtcbn1cblxuY29uc3QgZGVmYXVsdHMgPSB7XG5cbiAgdHJhbnNpdGlvbmFsOiB0cmFuc2l0aW9uYWxEZWZhdWx0cyxcblxuICBhZGFwdGVyOiBbJ3hocicsICdodHRwJywgJ2ZldGNoJ10sXG5cbiAgdHJhbnNmb3JtUmVxdWVzdDogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlcXVlc3QoZGF0YSwgaGVhZGVycykge1xuICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gaGVhZGVycy5nZXRDb250ZW50VHlwZSgpIHx8ICcnO1xuICAgIGNvbnN0IGhhc0pTT05Db250ZW50VHlwZSA9IGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSA+IC0xO1xuICAgIGNvbnN0IGlzT2JqZWN0UGF5bG9hZCA9IHV0aWxzLmlzT2JqZWN0KGRhdGEpO1xuXG4gICAgaWYgKGlzT2JqZWN0UGF5bG9hZCAmJiB1dGlscy5pc0hUTUxGb3JtKGRhdGEpKSB7XG4gICAgICBkYXRhID0gbmV3IEZvcm1EYXRhKGRhdGEpO1xuICAgIH1cblxuICAgIGNvbnN0IGlzRm9ybURhdGEgPSB1dGlscy5pc0Zvcm1EYXRhKGRhdGEpO1xuXG4gICAgaWYgKGlzRm9ybURhdGEpIHtcbiAgICAgIHJldHVybiBoYXNKU09OQ29udGVudFR5cGUgPyBKU09OLnN0cmluZ2lmeShmb3JtRGF0YVRvSlNPTihkYXRhKSkgOiBkYXRhO1xuICAgIH1cblxuICAgIGlmICh1dGlscy5pc0FycmF5QnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0J1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNTdHJlYW0oZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzRmlsZShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCbG9iKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc1JlYWRhYmxlU3RyZWFtKGRhdGEpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXJWaWV3KGRhdGEpKSB7XG4gICAgICByZXR1cm4gZGF0YS5idWZmZXI7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhkYXRhKSkge1xuICAgICAgaGVhZGVycy5zZXRDb250ZW50VHlwZSgnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9dXRmLTgnLCBmYWxzZSk7XG4gICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuICAgIH1cblxuICAgIGxldCBpc0ZpbGVMaXN0O1xuXG4gICAgaWYgKGlzT2JqZWN0UGF5bG9hZCkge1xuICAgICAgaWYgKGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRvVVJMRW5jb2RlZEZvcm0oZGF0YSwgdGhpcy5mb3JtU2VyaWFsaXplcikudG9TdHJpbmcoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKChpc0ZpbGVMaXN0ID0gdXRpbHMuaXNGaWxlTGlzdChkYXRhKSkgfHwgY29udGVudFR5cGUuaW5kZXhPZignbXVsdGlwYXJ0L2Zvcm0tZGF0YScpID4gLTEpIHtcbiAgICAgICAgY29uc3QgX0Zvcm1EYXRhID0gdGhpcy5lbnYgJiYgdGhpcy5lbnYuRm9ybURhdGE7XG5cbiAgICAgICAgcmV0dXJuIHRvRm9ybURhdGEoXG4gICAgICAgICAgaXNGaWxlTGlzdCA/IHsnZmlsZXNbXSc6IGRhdGF9IDogZGF0YSxcbiAgICAgICAgICBfRm9ybURhdGEgJiYgbmV3IF9Gb3JtRGF0YSgpLFxuICAgICAgICAgIHRoaXMuZm9ybVNlcmlhbGl6ZXJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNPYmplY3RQYXlsb2FkIHx8IGhhc0pTT05Db250ZW50VHlwZSApIHtcbiAgICAgIGhlYWRlcnMuc2V0Q29udGVudFR5cGUoJ2FwcGxpY2F0aW9uL2pzb24nLCBmYWxzZSk7XG4gICAgICByZXR1cm4gc3RyaW5naWZ5U2FmZWx5KGRhdGEpO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICB0cmFuc2Zvcm1SZXNwb25zZTogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlc3BvbnNlKGRhdGEpIHtcbiAgICBjb25zdCB0cmFuc2l0aW9uYWwgPSB0aGlzLnRyYW5zaXRpb25hbCB8fCBkZWZhdWx0cy50cmFuc2l0aW9uYWw7XG4gICAgY29uc3QgZm9yY2VkSlNPTlBhcnNpbmcgPSB0cmFuc2l0aW9uYWwgJiYgdHJhbnNpdGlvbmFsLmZvcmNlZEpTT05QYXJzaW5nO1xuICAgIGNvbnN0IEpTT05SZXF1ZXN0ZWQgPSB0aGlzLnJlc3BvbnNlVHlwZSA9PT0gJ2pzb24nO1xuXG4gICAgaWYgKHV0aWxzLmlzUmVzcG9uc2UoZGF0YSkgfHwgdXRpbHMuaXNSZWFkYWJsZVN0cmVhbShkYXRhKSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEgJiYgdXRpbHMuaXNTdHJpbmcoZGF0YSkgJiYgKChmb3JjZWRKU09OUGFyc2luZyAmJiAhdGhpcy5yZXNwb25zZVR5cGUpIHx8IEpTT05SZXF1ZXN0ZWQpKSB7XG4gICAgICBjb25zdCBzaWxlbnRKU09OUGFyc2luZyA9IHRyYW5zaXRpb25hbCAmJiB0cmFuc2l0aW9uYWwuc2lsZW50SlNPTlBhcnNpbmc7XG4gICAgICBjb25zdCBzdHJpY3RKU09OUGFyc2luZyA9ICFzaWxlbnRKU09OUGFyc2luZyAmJiBKU09OUmVxdWVzdGVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHN0cmljdEpTT05QYXJzaW5nKSB7XG4gICAgICAgICAgaWYgKGUubmFtZSA9PT0gJ1N5bnRheEVycm9yJykge1xuICAgICAgICAgICAgdGhyb3cgQXhpb3NFcnJvci5mcm9tKGUsIEF4aW9zRXJyb3IuRVJSX0JBRF9SRVNQT05TRSwgdGhpcywgbnVsbCwgdGhpcy5yZXNwb25zZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgLyoqXG4gICAqIEEgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gYWJvcnQgYSByZXF1ZXN0LiBJZiBzZXQgdG8gMCAoZGVmYXVsdCkgYVxuICAgKiB0aW1lb3V0IGlzIG5vdCBjcmVhdGVkLlxuICAgKi9cbiAgdGltZW91dDogMCxcblxuICB4c3JmQ29va2llTmFtZTogJ1hTUkYtVE9LRU4nLFxuICB4c3JmSGVhZGVyTmFtZTogJ1gtWFNSRi1UT0tFTicsXG5cbiAgbWF4Q29udGVudExlbmd0aDogLTEsXG4gIG1heEJvZHlMZW5ndGg6IC0xLFxuXG4gIGVudjoge1xuICAgIEZvcm1EYXRhOiBwbGF0Zm9ybS5jbGFzc2VzLkZvcm1EYXRhLFxuICAgIEJsb2I6IHBsYXRmb3JtLmNsYXNzZXMuQmxvYlxuICB9LFxuXG4gIHZhbGlkYXRlU3RhdHVzOiBmdW5jdGlvbiB2YWxpZGF0ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICByZXR1cm4gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDA7XG4gIH0sXG5cbiAgaGVhZGVyczoge1xuICAgIGNvbW1vbjoge1xuICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonLFxuICAgICAgJ0NvbnRlbnQtVHlwZSc6IHVuZGVmaW5lZFxuICAgIH1cbiAgfVxufTtcblxudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCddLCAobWV0aG9kKSA9PiB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHt9O1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmF1bHRzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHNpbGVudEpTT05QYXJzaW5nOiB0cnVlLFxuICBmb3JjZWRKU09OUGFyc2luZzogdHJ1ZSxcbiAgY2xhcmlmeVRpbWVvdXRFcnJvcjogZmFsc2Vcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5pbXBvcnQgdG9Gb3JtRGF0YSBmcm9tICcuL3RvRm9ybURhdGEuanMnO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uL3BsYXRmb3JtL2luZGV4LmpzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdG9VUkxFbmNvZGVkRm9ybShkYXRhLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b0Zvcm1EYXRhKGRhdGEsIG5ldyBwbGF0Zm9ybS5jbGFzc2VzLlVSTFNlYXJjaFBhcmFtcygpLCBPYmplY3QuYXNzaWduKHtcbiAgICB2aXNpdG9yOiBmdW5jdGlvbih2YWx1ZSwga2V5LCBwYXRoLCBoZWxwZXJzKSB7XG4gICAgICBpZiAocGxhdGZvcm0uaXNOb2RlICYmIHV0aWxzLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgICB0aGlzLmFwcGVuZChrZXksIHZhbHVlLnRvU3RyaW5nKCdiYXNlNjQnKSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhlbHBlcnMuZGVmYXVsdFZpc2l0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH0sIG9wdGlvbnMpKTtcbn1cbiIsImltcG9ydCBwbGF0Zm9ybSBmcm9tICcuL25vZGUvaW5kZXguanMnO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi9jb21tb24vdXRpbHMuanMnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIC4uLnV0aWxzLFxuICAuLi5wbGF0Zm9ybVxufVxuIiwiaW1wb3J0IFVSTFNlYXJjaFBhcmFtcyBmcm9tICcuL2NsYXNzZXMvVVJMU2VhcmNoUGFyYW1zLmpzJ1xuaW1wb3J0IEZvcm1EYXRhIGZyb20gJy4vY2xhc3Nlcy9Gb3JtRGF0YS5qcydcbmltcG9ydCBCbG9iIGZyb20gJy4vY2xhc3Nlcy9CbG9iLmpzJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlzQnJvd3NlcjogdHJ1ZSxcbiAgY2xhc3Nlczoge1xuICAgIFVSTFNlYXJjaFBhcmFtcyxcbiAgICBGb3JtRGF0YSxcbiAgICBCbG9iXG4gIH0sXG4gIHByb3RvY29sczogWydodHRwJywgJ2h0dHBzJywgJ2ZpbGUnLCAnYmxvYicsICd1cmwnLCAnZGF0YSddXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQXhpb3NVUkxTZWFyY2hQYXJhbXMgZnJvbSAnLi4vLi4vLi4vaGVscGVycy9BeGlvc1VSTFNlYXJjaFBhcmFtcy5qcyc7XG5leHBvcnQgZGVmYXVsdCB0eXBlb2YgVVJMU2VhcmNoUGFyYW1zICE9PSAndW5kZWZpbmVkJyA/IFVSTFNlYXJjaFBhcmFtcyA6IEF4aW9zVVJMU2VhcmNoUGFyYW1zO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgZGVmYXVsdCB0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnID8gRm9ybURhdGEgOiBudWxsO1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydCBkZWZhdWx0IHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyA/IEJsb2IgOiBudWxsXG4iLCJjb25zdCBoYXNCcm93c2VyRW52ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgd2UncmUgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAqXG4gKiBUaGlzIGFsbG93cyBheGlvcyB0byBydW4gaW4gYSB3ZWIgd29ya2VyLCBhbmQgcmVhY3QtbmF0aXZlLlxuICogQm90aCBlbnZpcm9ubWVudHMgc3VwcG9ydCBYTUxIdHRwUmVxdWVzdCwgYnV0IG5vdCBmdWxseSBzdGFuZGFyZCBnbG9iYWxzLlxuICpcbiAqIHdlYiB3b3JrZXJzOlxuICogIHR5cGVvZiB3aW5kb3cgLT4gdW5kZWZpbmVkXG4gKiAgdHlwZW9mIGRvY3VtZW50IC0+IHVuZGVmaW5lZFxuICpcbiAqIHJlYWN0LW5hdGl2ZTpcbiAqICBuYXZpZ2F0b3IucHJvZHVjdCAtPiAnUmVhY3ROYXRpdmUnXG4gKiBuYXRpdmVzY3JpcHRcbiAqICBuYXZpZ2F0b3IucHJvZHVjdCAtPiAnTmF0aXZlU2NyaXB0JyBvciAnTlMnXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGhhc1N0YW5kYXJkQnJvd3NlckVudiA9IChcbiAgKHByb2R1Y3QpID0+IHtcbiAgICByZXR1cm4gaGFzQnJvd3NlckVudiAmJiBbJ1JlYWN0TmF0aXZlJywgJ05hdGl2ZVNjcmlwdCcsICdOUyddLmluZGV4T2YocHJvZHVjdCkgPCAwXG4gIH0pKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci5wcm9kdWN0KTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgd2UncmUgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgd2ViV29ya2VyIGVudmlyb25tZW50XG4gKlxuICogQWx0aG91Z2ggdGhlIGBpc1N0YW5kYXJkQnJvd3NlckVudmAgbWV0aG9kIGluZGljYXRlcyB0aGF0XG4gKiBgYWxsb3dzIGF4aW9zIHRvIHJ1biBpbiBhIHdlYiB3b3JrZXJgLCB0aGUgV2ViV29ya2VyIHdpbGwgc3RpbGwgYmVcbiAqIGZpbHRlcmVkIG91dCBkdWUgdG8gaXRzIGp1ZGdtZW50IHN0YW5kYXJkXG4gKiBgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ2AuXG4gKiBUaGlzIGxlYWRzIHRvIGEgcHJvYmxlbSB3aGVuIGF4aW9zIHBvc3QgYEZvcm1EYXRhYCBpbiB3ZWJXb3JrZXJcbiAqL1xuY29uc3QgaGFzU3RhbmRhcmRCcm93c2VyV2ViV29ya2VyRW52ID0gKCgpID0+IHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlICYmXG4gICAgdHlwZW9mIHNlbGYuaW1wb3J0U2NyaXB0cyA9PT0gJ2Z1bmN0aW9uJ1xuICApO1xufSkoKTtcblxuY29uc3Qgb3JpZ2luID0gaGFzQnJvd3NlckVudiAmJiB3aW5kb3cubG9jYXRpb24uaHJlZiB8fCAnaHR0cDovL2xvY2FsaG9zdCc7XG5cbmV4cG9ydCB7XG4gIGhhc0Jyb3dzZXJFbnYsXG4gIGhhc1N0YW5kYXJkQnJvd3NlcldlYldvcmtlckVudixcbiAgaGFzU3RhbmRhcmRCcm93c2VyRW52LFxuICBvcmlnaW5cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcblxuLyoqXG4gKiBJdCB0YWtlcyBhIHN0cmluZyBsaWtlIGBmb29beF1beV1bel1gIGFuZCByZXR1cm5zIGFuIGFycmF5IGxpa2UgYFsnZm9vJywgJ3gnLCAneScsICd6J11cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKlxuICogQHJldHVybnMgQW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAqL1xuZnVuY3Rpb24gcGFyc2VQcm9wUGF0aChuYW1lKSB7XG4gIC8vIGZvb1t4XVt5XVt6XVxuICAvLyBmb28ueC55LnpcbiAgLy8gZm9vLXgteS16XG4gIC8vIGZvbyB4IHkgelxuICByZXR1cm4gdXRpbHMubWF0Y2hBbGwoL1xcdyt8XFxbKFxcdyopXS9nLCBuYW1lKS5tYXAobWF0Y2ggPT4ge1xuICAgIHJldHVybiBtYXRjaFswXSA9PT0gJ1tdJyA/ICcnIDogbWF0Y2hbMV0gfHwgbWF0Y2hbMF07XG4gIH0pO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYW4gYXJyYXkgdG8gYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gYXJyIC0gVGhlIGFycmF5IHRvIGNvbnZlcnQgdG8gYW4gb2JqZWN0LlxuICpcbiAqIEByZXR1cm5zIEFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYW5kIHZhbHVlcyBhcyB0aGUgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5VG9PYmplY3QoYXJyKSB7XG4gIGNvbnN0IG9iaiA9IHt9O1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoYXJyKTtcbiAgbGV0IGk7XG4gIGNvbnN0IGxlbiA9IGtleXMubGVuZ3RoO1xuICBsZXQga2V5O1xuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIG9ialtrZXldID0gYXJyW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBJdCB0YWtlcyBhIEZvcm1EYXRhIG9iamVjdCBhbmQgcmV0dXJucyBhIEphdmFTY3JpcHQgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZvcm1EYXRhIFRoZSBGb3JtRGF0YSBvYmplY3QgdG8gY29udmVydCB0byBKU09OLlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3Q8c3RyaW5nLCBhbnk+IHwgbnVsbH0gVGhlIGNvbnZlcnRlZCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGZvcm1EYXRhVG9KU09OKGZvcm1EYXRhKSB7XG4gIGZ1bmN0aW9uIGJ1aWxkUGF0aChwYXRoLCB2YWx1ZSwgdGFyZ2V0LCBpbmRleCkge1xuICAgIGxldCBuYW1lID0gcGF0aFtpbmRleCsrXTtcblxuICAgIGlmIChuYW1lID09PSAnX19wcm90b19fJykgcmV0dXJuIHRydWU7XG5cbiAgICBjb25zdCBpc051bWVyaWNLZXkgPSBOdW1iZXIuaXNGaW5pdGUoK25hbWUpO1xuICAgIGNvbnN0IGlzTGFzdCA9IGluZGV4ID49IHBhdGgubGVuZ3RoO1xuICAgIG5hbWUgPSAhbmFtZSAmJiB1dGlscy5pc0FycmF5KHRhcmdldCkgPyB0YXJnZXQubGVuZ3RoIDogbmFtZTtcblxuICAgIGlmIChpc0xhc3QpIHtcbiAgICAgIGlmICh1dGlscy5oYXNPd25Qcm9wKHRhcmdldCwgbmFtZSkpIHtcbiAgICAgICAgdGFyZ2V0W25hbWVdID0gW3RhcmdldFtuYW1lXSwgdmFsdWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0W25hbWVdID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAhaXNOdW1lcmljS2V5O1xuICAgIH1cblxuICAgIGlmICghdGFyZ2V0W25hbWVdIHx8ICF1dGlscy5pc09iamVjdCh0YXJnZXRbbmFtZV0pKSB7XG4gICAgICB0YXJnZXRbbmFtZV0gPSBbXTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBidWlsZFBhdGgocGF0aCwgdmFsdWUsIHRhcmdldFtuYW1lXSwgaW5kZXgpO1xuXG4gICAgaWYgKHJlc3VsdCAmJiB1dGlscy5pc0FycmF5KHRhcmdldFtuYW1lXSkpIHtcbiAgICAgIHRhcmdldFtuYW1lXSA9IGFycmF5VG9PYmplY3QodGFyZ2V0W25hbWVdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gIWlzTnVtZXJpY0tleTtcbiAgfVxuXG4gIGlmICh1dGlscy5pc0Zvcm1EYXRhKGZvcm1EYXRhKSAmJiB1dGlscy5pc0Z1bmN0aW9uKGZvcm1EYXRhLmVudHJpZXMpKSB7XG4gICAgY29uc3Qgb2JqID0ge307XG5cbiAgICB1dGlscy5mb3JFYWNoRW50cnkoZm9ybURhdGEsIChuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgYnVpbGRQYXRoKHBhcnNlUHJvcFBhdGgobmFtZSksIHZhbHVlLCBvYmosIDApO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmb3JtRGF0YVRvSlNPTjtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCBwYXJzZUhlYWRlcnMgZnJvbSAnLi4vaGVscGVycy9wYXJzZUhlYWRlcnMuanMnO1xuXG5jb25zdCAkaW50ZXJuYWxzID0gU3ltYm9sKCdpbnRlcm5hbHMnKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplSGVhZGVyKGhlYWRlcikge1xuICByZXR1cm4gaGVhZGVyICYmIFN0cmluZyhoZWFkZXIpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gdXRpbHMuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5tYXAobm9ybWFsaXplVmFsdWUpIDogU3RyaW5nKHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VUb2tlbnMoc3RyKSB7XG4gIGNvbnN0IHRva2VucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGNvbnN0IHRva2Vuc1JFID0gLyhbXlxccyw7PV0rKVxccyooPzo9XFxzKihbXiw7XSspKT8vZztcbiAgbGV0IG1hdGNoO1xuXG4gIHdoaWxlICgobWF0Y2ggPSB0b2tlbnNSRS5leGVjKHN0cikpKSB7XG4gICAgdG9rZW5zW21hdGNoWzFdXSA9IG1hdGNoWzJdO1xuICB9XG5cbiAgcmV0dXJuIHRva2Vucztcbn1cblxuY29uc3QgaXNWYWxpZEhlYWRlck5hbWUgPSAoc3RyKSA9PiAvXlstX2EtekEtWjAtOV5gfH4sISMkJSYnKisuXSskLy50ZXN0KHN0ci50cmltKCkpO1xuXG5mdW5jdGlvbiBtYXRjaEhlYWRlclZhbHVlKGNvbnRleHQsIHZhbHVlLCBoZWFkZXIsIGZpbHRlciwgaXNIZWFkZXJOYW1lRmlsdGVyKSB7XG4gIGlmICh1dGlscy5pc0Z1bmN0aW9uKGZpbHRlcikpIHtcbiAgICByZXR1cm4gZmlsdGVyLmNhbGwodGhpcywgdmFsdWUsIGhlYWRlcik7XG4gIH1cblxuICBpZiAoaXNIZWFkZXJOYW1lRmlsdGVyKSB7XG4gICAgdmFsdWUgPSBoZWFkZXI7XG4gIH1cblxuICBpZiAoIXV0aWxzLmlzU3RyaW5nKHZhbHVlKSkgcmV0dXJuO1xuXG4gIGlmICh1dGlscy5pc1N0cmluZyhmaWx0ZXIpKSB7XG4gICAgcmV0dXJuIHZhbHVlLmluZGV4T2YoZmlsdGVyKSAhPT0gLTE7XG4gIH1cblxuICBpZiAodXRpbHMuaXNSZWdFeHAoZmlsdGVyKSkge1xuICAgIHJldHVybiBmaWx0ZXIudGVzdCh2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9ybWF0SGVhZGVyKGhlYWRlcikge1xuICByZXR1cm4gaGVhZGVyLnRyaW0oKVxuICAgIC50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLyhbYS16XFxkXSkoXFx3KikvZywgKHcsIGNoYXIsIHN0cikgPT4ge1xuICAgICAgcmV0dXJuIGNoYXIudG9VcHBlckNhc2UoKSArIHN0cjtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gYnVpbGRBY2Nlc3NvcnMob2JqLCBoZWFkZXIpIHtcbiAgY29uc3QgYWNjZXNzb3JOYW1lID0gdXRpbHMudG9DYW1lbENhc2UoJyAnICsgaGVhZGVyKTtcblxuICBbJ2dldCcsICdzZXQnLCAnaGFzJ10uZm9yRWFjaChtZXRob2ROYW1lID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBtZXRob2ROYW1lICsgYWNjZXNzb3JOYW1lLCB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24oYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgICByZXR1cm4gdGhpc1ttZXRob2ROYW1lXS5jYWxsKHRoaXMsIGhlYWRlciwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgICB9LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0pO1xufVxuXG5jbGFzcyBBeGlvc0hlYWRlcnMge1xuICBjb25zdHJ1Y3RvcihoZWFkZXJzKSB7XG4gICAgaGVhZGVycyAmJiB0aGlzLnNldChoZWFkZXJzKTtcbiAgfVxuXG4gIHNldChoZWFkZXIsIHZhbHVlT3JSZXdyaXRlLCByZXdyaXRlKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICBmdW5jdGlvbiBzZXRIZWFkZXIoX3ZhbHVlLCBfaGVhZGVyLCBfcmV3cml0ZSkge1xuICAgICAgY29uc3QgbEhlYWRlciA9IG5vcm1hbGl6ZUhlYWRlcihfaGVhZGVyKTtcblxuICAgICAgaWYgKCFsSGVhZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGVhZGVyIG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qga2V5ID0gdXRpbHMuZmluZEtleShzZWxmLCBsSGVhZGVyKTtcblxuICAgICAgaWYoIWtleSB8fCBzZWxmW2tleV0gPT09IHVuZGVmaW5lZCB8fCBfcmV3cml0ZSA9PT0gdHJ1ZSB8fCAoX3Jld3JpdGUgPT09IHVuZGVmaW5lZCAmJiBzZWxmW2tleV0gIT09IGZhbHNlKSkge1xuICAgICAgICBzZWxmW2tleSB8fCBfaGVhZGVyXSA9IG5vcm1hbGl6ZVZhbHVlKF92YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc2V0SGVhZGVycyA9IChoZWFkZXJzLCBfcmV3cml0ZSkgPT5cbiAgICAgIHV0aWxzLmZvckVhY2goaGVhZGVycywgKF92YWx1ZSwgX2hlYWRlcikgPT4gc2V0SGVhZGVyKF92YWx1ZSwgX2hlYWRlciwgX3Jld3JpdGUpKTtcblxuICAgIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KGhlYWRlcikgfHwgaGVhZGVyIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3Rvcikge1xuICAgICAgc2V0SGVhZGVycyhoZWFkZXIsIHZhbHVlT3JSZXdyaXRlKVxuICAgIH0gZWxzZSBpZih1dGlscy5pc1N0cmluZyhoZWFkZXIpICYmIChoZWFkZXIgPSBoZWFkZXIudHJpbSgpKSAmJiAhaXNWYWxpZEhlYWRlck5hbWUoaGVhZGVyKSkge1xuICAgICAgc2V0SGVhZGVycyhwYXJzZUhlYWRlcnMoaGVhZGVyKSwgdmFsdWVPclJld3JpdGUpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNIZWFkZXJzKGhlYWRlcikpIHtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGhlYWRlci5lbnRyaWVzKCkpIHtcbiAgICAgICAgc2V0SGVhZGVyKHZhbHVlLCBrZXksIHJld3JpdGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkZXIgIT0gbnVsbCAmJiBzZXRIZWFkZXIodmFsdWVPclJld3JpdGUsIGhlYWRlciwgcmV3cml0ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXQoaGVhZGVyLCBwYXJzZXIpIHtcbiAgICBoZWFkZXIgPSBub3JtYWxpemVIZWFkZXIoaGVhZGVyKTtcblxuICAgIGlmIChoZWFkZXIpIHtcbiAgICAgIGNvbnN0IGtleSA9IHV0aWxzLmZpbmRLZXkodGhpcywgaGVhZGVyKTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXNba2V5XTtcblxuICAgICAgICBpZiAoIXBhcnNlcikge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJzZXIgPT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VUb2tlbnModmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHV0aWxzLmlzRnVuY3Rpb24ocGFyc2VyKSkge1xuICAgICAgICAgIHJldHVybiBwYXJzZXIuY2FsbCh0aGlzLCB2YWx1ZSwga2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1dGlscy5pc1JlZ0V4cChwYXJzZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlci5leGVjKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhcnNlciBtdXN0IGJlIGJvb2xlYW58cmVnZXhwfGZ1bmN0aW9uJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFzKGhlYWRlciwgbWF0Y2hlcikge1xuICAgIGhlYWRlciA9IG5vcm1hbGl6ZUhlYWRlcihoZWFkZXIpO1xuXG4gICAgaWYgKGhlYWRlcikge1xuICAgICAgY29uc3Qga2V5ID0gdXRpbHMuZmluZEtleSh0aGlzLCBoZWFkZXIpO1xuXG4gICAgICByZXR1cm4gISEoa2V5ICYmIHRoaXNba2V5XSAhPT0gdW5kZWZpbmVkICYmICghbWF0Y2hlciB8fCBtYXRjaEhlYWRlclZhbHVlKHRoaXMsIHRoaXNba2V5XSwga2V5LCBtYXRjaGVyKSkpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGRlbGV0ZShoZWFkZXIsIG1hdGNoZXIpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBsZXQgZGVsZXRlZCA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gZGVsZXRlSGVhZGVyKF9oZWFkZXIpIHtcbiAgICAgIF9oZWFkZXIgPSBub3JtYWxpemVIZWFkZXIoX2hlYWRlcik7XG5cbiAgICAgIGlmIChfaGVhZGVyKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHV0aWxzLmZpbmRLZXkoc2VsZiwgX2hlYWRlcik7XG5cbiAgICAgICAgaWYgKGtleSAmJiAoIW1hdGNoZXIgfHwgbWF0Y2hIZWFkZXJWYWx1ZShzZWxmLCBzZWxmW2tleV0sIGtleSwgbWF0Y2hlcikpKSB7XG4gICAgICAgICAgZGVsZXRlIHNlbGZba2V5XTtcblxuICAgICAgICAgIGRlbGV0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHV0aWxzLmlzQXJyYXkoaGVhZGVyKSkge1xuICAgICAgaGVhZGVyLmZvckVhY2goZGVsZXRlSGVhZGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlSGVhZGVyKGhlYWRlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlbGV0ZWQ7XG4gIH1cblxuICBjbGVhcihtYXRjaGVyKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICAgIGxldCBpID0ga2V5cy5sZW5ndGg7XG4gICAgbGV0IGRlbGV0ZWQgPSBmYWxzZTtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICBpZighbWF0Y2hlciB8fCBtYXRjaEhlYWRlclZhbHVlKHRoaXMsIHRoaXNba2V5XSwga2V5LCBtYXRjaGVyLCB0cnVlKSkge1xuICAgICAgICBkZWxldGUgdGhpc1trZXldO1xuICAgICAgICBkZWxldGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGVsZXRlZDtcbiAgfVxuXG4gIG5vcm1hbGl6ZShmb3JtYXQpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCBoZWFkZXJzID0ge307XG5cbiAgICB1dGlscy5mb3JFYWNoKHRoaXMsICh2YWx1ZSwgaGVhZGVyKSA9PiB7XG4gICAgICBjb25zdCBrZXkgPSB1dGlscy5maW5kS2V5KGhlYWRlcnMsIGhlYWRlcik7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgc2VsZltrZXldID0gbm9ybWFsaXplVmFsdWUodmFsdWUpO1xuICAgICAgICBkZWxldGUgc2VsZltoZWFkZXJdO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBmb3JtYXQgPyBmb3JtYXRIZWFkZXIoaGVhZGVyKSA6IFN0cmluZyhoZWFkZXIpLnRyaW0oKTtcblxuICAgICAgaWYgKG5vcm1hbGl6ZWQgIT09IGhlYWRlcikge1xuICAgICAgICBkZWxldGUgc2VsZltoZWFkZXJdO1xuICAgICAgfVxuXG4gICAgICBzZWxmW25vcm1hbGl6ZWRdID0gbm9ybWFsaXplVmFsdWUodmFsdWUpO1xuXG4gICAgICBoZWFkZXJzW25vcm1hbGl6ZWRdID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY29uY2F0KC4uLnRhcmdldHMpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5jb25jYXQodGhpcywgLi4udGFyZ2V0cyk7XG4gIH1cblxuICB0b0pTT04oYXNTdHJpbmdzKSB7XG4gICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIHV0aWxzLmZvckVhY2godGhpcywgKHZhbHVlLCBoZWFkZXIpID0+IHtcbiAgICAgIHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09IGZhbHNlICYmIChvYmpbaGVhZGVyXSA9IGFzU3RyaW5ncyAmJiB1dGlscy5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLmpvaW4oJywgJykgOiB2YWx1ZSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHRoaXMudG9KU09OKCkpW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyh0aGlzLnRvSlNPTigpKS5tYXAoKFtoZWFkZXIsIHZhbHVlXSkgPT4gaGVhZGVyICsgJzogJyArIHZhbHVlKS5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gJ0F4aW9zSGVhZGVycyc7XG4gIH1cblxuICBzdGF0aWMgZnJvbSh0aGluZykge1xuICAgIHJldHVybiB0aGluZyBpbnN0YW5jZW9mIHRoaXMgPyB0aGluZyA6IG5ldyB0aGlzKHRoaW5nKTtcbiAgfVxuXG4gIHN0YXRpYyBjb25jYXQoZmlyc3QsIC4uLnRhcmdldHMpIHtcbiAgICBjb25zdCBjb21wdXRlZCA9IG5ldyB0aGlzKGZpcnN0KTtcblxuICAgIHRhcmdldHMuZm9yRWFjaCgodGFyZ2V0KSA9PiBjb21wdXRlZC5zZXQodGFyZ2V0KSk7XG5cbiAgICByZXR1cm4gY29tcHV0ZWQ7XG4gIH1cblxuICBzdGF0aWMgYWNjZXNzb3IoaGVhZGVyKSB7XG4gICAgY29uc3QgaW50ZXJuYWxzID0gdGhpc1skaW50ZXJuYWxzXSA9ICh0aGlzWyRpbnRlcm5hbHNdID0ge1xuICAgICAgYWNjZXNzb3JzOiB7fVxuICAgIH0pO1xuXG4gICAgY29uc3QgYWNjZXNzb3JzID0gaW50ZXJuYWxzLmFjY2Vzc29ycztcbiAgICBjb25zdCBwcm90b3R5cGUgPSB0aGlzLnByb3RvdHlwZTtcblxuICAgIGZ1bmN0aW9uIGRlZmluZUFjY2Vzc29yKF9oZWFkZXIpIHtcbiAgICAgIGNvbnN0IGxIZWFkZXIgPSBub3JtYWxpemVIZWFkZXIoX2hlYWRlcik7XG5cbiAgICAgIGlmICghYWNjZXNzb3JzW2xIZWFkZXJdKSB7XG4gICAgICAgIGJ1aWxkQWNjZXNzb3JzKHByb3RvdHlwZSwgX2hlYWRlcik7XG4gICAgICAgIGFjY2Vzc29yc1tsSGVhZGVyXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdXRpbHMuaXNBcnJheShoZWFkZXIpID8gaGVhZGVyLmZvckVhY2goZGVmaW5lQWNjZXNzb3IpIDogZGVmaW5lQWNjZXNzb3IoaGVhZGVyKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbkF4aW9zSGVhZGVycy5hY2Nlc3NvcihbJ0NvbnRlbnQtVHlwZScsICdDb250ZW50LUxlbmd0aCcsICdBY2NlcHQnLCAnQWNjZXB0LUVuY29kaW5nJywgJ1VzZXItQWdlbnQnLCAnQXV0aG9yaXphdGlvbiddKTtcblxuLy8gcmVzZXJ2ZWQgbmFtZXMgaG90Zml4XG51dGlscy5yZWR1Y2VEZXNjcmlwdG9ycyhBeGlvc0hlYWRlcnMucHJvdG90eXBlLCAoe3ZhbHVlfSwga2V5KSA9PiB7XG4gIGxldCBtYXBwZWQgPSBrZXlbMF0udG9VcHBlckNhc2UoKSArIGtleS5zbGljZSgxKTsgLy8gbWFwIGBzZXRgID0+IGBTZXRgXG4gIHJldHVybiB7XG4gICAgZ2V0OiAoKSA9PiB2YWx1ZSxcbiAgICBzZXQoaGVhZGVyVmFsdWUpIHtcbiAgICAgIHRoaXNbbWFwcGVkXSA9IGhlYWRlclZhbHVlO1xuICAgIH1cbiAgfVxufSk7XG5cbnV0aWxzLmZyZWV6ZU1ldGhvZHMoQXhpb3NIZWFkZXJzKTtcblxuZXhwb3J0IGRlZmF1bHQgQXhpb3NIZWFkZXJzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi8uLi91dGlscy5qcyc7XG5cbi8vIFJhd0F4aW9zSGVhZGVycyB3aG9zZSBkdXBsaWNhdGVzIGFyZSBpZ25vcmVkIGJ5IG5vZGVcbi8vIGMuZi4gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9odHRwLmh0bWwjaHR0cF9tZXNzYWdlX2hlYWRlcnNcbmNvbnN0IGlnbm9yZUR1cGxpY2F0ZU9mID0gdXRpbHMudG9PYmplY3RTZXQoW1xuICAnYWdlJywgJ2F1dGhvcml6YXRpb24nLCAnY29udGVudC1sZW5ndGgnLCAnY29udGVudC10eXBlJywgJ2V0YWcnLFxuICAnZXhwaXJlcycsICdmcm9tJywgJ2hvc3QnLCAnaWYtbW9kaWZpZWQtc2luY2UnLCAnaWYtdW5tb2RpZmllZC1zaW5jZScsXG4gICdsYXN0LW1vZGlmaWVkJywgJ2xvY2F0aW9uJywgJ21heC1mb3J3YXJkcycsICdwcm94eS1hdXRob3JpemF0aW9uJyxcbiAgJ3JlZmVyZXInLCAncmV0cnktYWZ0ZXInLCAndXNlci1hZ2VudCdcbl0pO1xuXG4vKipcbiAqIFBhcnNlIGhlYWRlcnMgaW50byBhbiBvYmplY3RcbiAqXG4gKiBgYGBcbiAqIERhdGU6IFdlZCwgMjcgQXVnIDIwMTQgMDg6NTg6NDkgR01UXG4gKiBDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2pzb25cbiAqIENvbm5lY3Rpb246IGtlZXAtYWxpdmVcbiAqIFRyYW5zZmVyLUVuY29kaW5nOiBjaHVua2VkXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmF3SGVhZGVycyBIZWFkZXJzIG5lZWRpbmcgdG8gYmUgcGFyc2VkXG4gKlxuICogQHJldHVybnMge09iamVjdH0gSGVhZGVycyBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xuZXhwb3J0IGRlZmF1bHQgcmF3SGVhZGVycyA9PiB7XG4gIGNvbnN0IHBhcnNlZCA9IHt9O1xuICBsZXQga2V5O1xuICBsZXQgdmFsO1xuICBsZXQgaTtcblxuICByYXdIZWFkZXJzICYmIHJhd0hlYWRlcnMuc3BsaXQoJ1xcbicpLmZvckVhY2goZnVuY3Rpb24gcGFyc2VyKGxpbmUpIHtcbiAgICBpID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAga2V5ID0gbGluZS5zdWJzdHJpbmcoMCwgaSkudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFsID0gbGluZS5zdWJzdHJpbmcoaSArIDEpLnRyaW0oKTtcblxuICAgIGlmICgha2V5IHx8IChwYXJzZWRba2V5XSAmJiBpZ25vcmVEdXBsaWNhdGVPZltrZXldKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChrZXkgPT09ICdzZXQtY29va2llJykge1xuICAgICAgaWYgKHBhcnNlZFtrZXldKSB7XG4gICAgICAgIHBhcnNlZFtrZXldLnB1c2godmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gW3ZhbF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnNlZFtrZXldID0gcGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSArICcsICcgKyB2YWwgOiB2YWw7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyc2VkO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNDYW5jZWwodmFsdWUpIHtcbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9fQ0FOQ0VMX18pO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tICcuLi9jb3JlL0F4aW9zRXJyb3IuanMnO1xuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcblxuLyoqXG4gKiBBIGBDYW5jZWxlZEVycm9yYCBpcyBhbiBvYmplY3QgdGhhdCBpcyB0aHJvd24gd2hlbiBhbiBvcGVyYXRpb24gaXMgY2FuY2VsZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmc9fSBtZXNzYWdlIFRoZSBtZXNzYWdlLlxuICogQHBhcmFtIHtPYmplY3Q9fSBjb25maWcgVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gcmVxdWVzdCBUaGUgcmVxdWVzdC5cbiAqXG4gKiBAcmV0dXJucyB7Q2FuY2VsZWRFcnJvcn0gVGhlIGNyZWF0ZWQgZXJyb3IuXG4gKi9cbmZ1bmN0aW9uIENhbmNlbGVkRXJyb3IobWVzc2FnZSwgY29uZmlnLCByZXF1ZXN0KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lcS1udWxsLGVxZXFlcVxuICBBeGlvc0Vycm9yLmNhbGwodGhpcywgbWVzc2FnZSA9PSBudWxsID8gJ2NhbmNlbGVkJyA6IG1lc3NhZ2UsIEF4aW9zRXJyb3IuRVJSX0NBTkNFTEVELCBjb25maWcsIHJlcXVlc3QpO1xuICB0aGlzLm5hbWUgPSAnQ2FuY2VsZWRFcnJvcic7XG59XG5cbnV0aWxzLmluaGVyaXRzKENhbmNlbGVkRXJyb3IsIEF4aW9zRXJyb3IsIHtcbiAgX19DQU5DRUxfXzogdHJ1ZVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IENhbmNlbGVkRXJyb3I7XG4iLCJpbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IGh0dHBBZGFwdGVyIGZyb20gJy4vaHR0cC5qcyc7XG5pbXBvcnQgeGhyQWRhcHRlciBmcm9tICcuL3hoci5qcyc7XG5pbXBvcnQgZmV0Y2hBZGFwdGVyIGZyb20gJy4vZmV0Y2guanMnO1xuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSBcIi4uL2NvcmUvQXhpb3NFcnJvci5qc1wiO1xuXG5jb25zdCBrbm93bkFkYXB0ZXJzID0ge1xuICBodHRwOiBodHRwQWRhcHRlcixcbiAgeGhyOiB4aHJBZGFwdGVyLFxuICBmZXRjaDogZmV0Y2hBZGFwdGVyXG59XG5cbnV0aWxzLmZvckVhY2goa25vd25BZGFwdGVycywgKGZuLCB2YWx1ZSkgPT4ge1xuICBpZiAoZm4pIHtcbiAgICB0cnkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCAnbmFtZScsIHt2YWx1ZX0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sICdhZGFwdGVyTmFtZScsIHt2YWx1ZX0pO1xuICB9XG59KTtcblxuY29uc3QgcmVuZGVyUmVhc29uID0gKHJlYXNvbikgPT4gYC0gJHtyZWFzb259YDtcblxuY29uc3QgaXNSZXNvbHZlZEhhbmRsZSA9IChhZGFwdGVyKSA9PiB1dGlscy5pc0Z1bmN0aW9uKGFkYXB0ZXIpIHx8IGFkYXB0ZXIgPT09IG51bGwgfHwgYWRhcHRlciA9PT0gZmFsc2U7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZ2V0QWRhcHRlcjogKGFkYXB0ZXJzKSA9PiB7XG4gICAgYWRhcHRlcnMgPSB1dGlscy5pc0FycmF5KGFkYXB0ZXJzKSA/IGFkYXB0ZXJzIDogW2FkYXB0ZXJzXTtcblxuICAgIGNvbnN0IHtsZW5ndGh9ID0gYWRhcHRlcnM7XG4gICAgbGV0IG5hbWVPckFkYXB0ZXI7XG4gICAgbGV0IGFkYXB0ZXI7XG5cbiAgICBjb25zdCByZWplY3RlZFJlYXNvbnMgPSB7fTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIG5hbWVPckFkYXB0ZXIgPSBhZGFwdGVyc1tpXTtcbiAgICAgIGxldCBpZDtcblxuICAgICAgYWRhcHRlciA9IG5hbWVPckFkYXB0ZXI7XG5cbiAgICAgIGlmICghaXNSZXNvbHZlZEhhbmRsZShuYW1lT3JBZGFwdGVyKSkge1xuICAgICAgICBhZGFwdGVyID0ga25vd25BZGFwdGVyc1soaWQgPSBTdHJpbmcobmFtZU9yQWRhcHRlcikpLnRvTG93ZXJDYXNlKCldO1xuXG4gICAgICAgIGlmIChhZGFwdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcihgVW5rbm93biBhZGFwdGVyICcke2lkfSdgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYWRhcHRlcikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmVqZWN0ZWRSZWFzb25zW2lkIHx8ICcjJyArIGldID0gYWRhcHRlcjtcbiAgICB9XG5cbiAgICBpZiAoIWFkYXB0ZXIpIHtcblxuICAgICAgY29uc3QgcmVhc29ucyA9IE9iamVjdC5lbnRyaWVzKHJlamVjdGVkUmVhc29ucylcbiAgICAgICAgLm1hcCgoW2lkLCBzdGF0ZV0pID0+IGBhZGFwdGVyICR7aWR9IGAgK1xuICAgICAgICAgIChzdGF0ZSA9PT0gZmFsc2UgPyAnaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgZW52aXJvbm1lbnQnIDogJ2lzIG5vdCBhdmFpbGFibGUgaW4gdGhlIGJ1aWxkJylcbiAgICAgICAgKTtcblxuICAgICAgbGV0IHMgPSBsZW5ndGggP1xuICAgICAgICAocmVhc29ucy5sZW5ndGggPiAxID8gJ3NpbmNlIDpcXG4nICsgcmVhc29ucy5tYXAocmVuZGVyUmVhc29uKS5qb2luKCdcXG4nKSA6ICcgJyArIHJlbmRlclJlYXNvbihyZWFzb25zWzBdKSkgOlxuICAgICAgICAnYXMgbm8gYWRhcHRlciBzcGVjaWZpZWQnO1xuXG4gICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcihcbiAgICAgICAgYFRoZXJlIGlzIG5vIHN1aXRhYmxlIGFkYXB0ZXIgdG8gZGlzcGF0Y2ggdGhlIHJlcXVlc3QgYCArIHMsXG4gICAgICAgICdFUlJfTk9UX1NVUFBPUlQnXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBhZGFwdGVyO1xuICB9LFxuICBhZGFwdGVyczoga25vd25BZGFwdGVyc1xufVxuIiwiaW1wb3J0IHV0aWxzIGZyb20gJy4vLi4vdXRpbHMuanMnO1xuaW1wb3J0IHNldHRsZSBmcm9tICcuLy4uL2NvcmUvc2V0dGxlLmpzJztcbmltcG9ydCB0cmFuc2l0aW9uYWxEZWZhdWx0cyBmcm9tICcuLi9kZWZhdWx0cy90cmFuc2l0aW9uYWwuanMnO1xuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSAnLi4vY29yZS9BeGlvc0Vycm9yLmpzJztcbmltcG9ydCBDYW5jZWxlZEVycm9yIGZyb20gJy4uL2NhbmNlbC9DYW5jZWxlZEVycm9yLmpzJztcbmltcG9ydCBwYXJzZVByb3RvY29sIGZyb20gJy4uL2hlbHBlcnMvcGFyc2VQcm90b2NvbC5qcyc7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vcGxhdGZvcm0vaW5kZXguanMnO1xuaW1wb3J0IEF4aW9zSGVhZGVycyBmcm9tICcuLi9jb3JlL0F4aW9zSGVhZGVycy5qcyc7XG5pbXBvcnQgcHJvZ3Jlc3NFdmVudFJlZHVjZXIgZnJvbSAnLi4vaGVscGVycy9wcm9ncmVzc0V2ZW50UmVkdWNlci5qcyc7XG5pbXBvcnQgcmVzb2x2ZUNvbmZpZyBmcm9tIFwiLi4vaGVscGVycy9yZXNvbHZlQ29uZmlnLmpzXCI7XG5cbmNvbnN0IGlzWEhSQWRhcHRlclN1cHBvcnRlZCA9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCc7XG5cbmV4cG9ydCBkZWZhdWx0IGlzWEhSQWRhcHRlclN1cHBvcnRlZCAmJiBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBkaXNwYXRjaFhoclJlcXVlc3QocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgY29uc3QgX2NvbmZpZyA9IHJlc29sdmVDb25maWcoY29uZmlnKTtcbiAgICBsZXQgcmVxdWVzdERhdGEgPSBfY29uZmlnLmRhdGE7XG4gICAgY29uc3QgcmVxdWVzdEhlYWRlcnMgPSBBeGlvc0hlYWRlcnMuZnJvbShfY29uZmlnLmhlYWRlcnMpLm5vcm1hbGl6ZSgpO1xuICAgIGxldCB7cmVzcG9uc2VUeXBlfSA9IF9jb25maWc7XG4gICAgbGV0IG9uQ2FuY2VsZWQ7XG4gICAgZnVuY3Rpb24gZG9uZSgpIHtcbiAgICAgIGlmIChfY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgICAgIF9jb25maWcuY2FuY2VsVG9rZW4udW5zdWJzY3JpYmUob25DYW5jZWxlZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfY29uZmlnLnNpZ25hbCkge1xuICAgICAgICBfY29uZmlnLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uQ2FuY2VsZWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICByZXF1ZXN0Lm9wZW4oX2NvbmZpZy5tZXRob2QudG9VcHBlckNhc2UoKSwgX2NvbmZpZy51cmwsIHRydWUpO1xuXG4gICAgLy8gU2V0IHRoZSByZXF1ZXN0IHRpbWVvdXQgaW4gTVNcbiAgICByZXF1ZXN0LnRpbWVvdXQgPSBfY29uZmlnLnRpbWVvdXQ7XG5cbiAgICBmdW5jdGlvbiBvbmxvYWRlbmQoKSB7XG4gICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gUHJlcGFyZSB0aGUgcmVzcG9uc2VcbiAgICAgIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IEF4aW9zSGVhZGVycy5mcm9tKFxuICAgICAgICAnZ2V0QWxsUmVzcG9uc2VIZWFkZXJzJyBpbiByZXF1ZXN0ICYmIHJlcXVlc3QuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcbiAgICAgICk7XG4gICAgICBjb25zdCByZXNwb25zZURhdGEgPSAhcmVzcG9uc2VUeXBlIHx8IHJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnIHx8IHJlc3BvbnNlVHlwZSA9PT0gJ2pzb24nID9cbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVRleHQgOiByZXF1ZXN0LnJlc3BvbnNlO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSB7XG4gICAgICAgIGRhdGE6IHJlc3BvbnNlRGF0YSxcbiAgICAgICAgc3RhdHVzOiByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVxdWVzdC5zdGF0dXNUZXh0LFxuICAgICAgICBoZWFkZXJzOiByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgcmVxdWVzdFxuICAgICAgfTtcblxuICAgICAgc2V0dGxlKGZ1bmN0aW9uIF9yZXNvbHZlKHZhbHVlKSB7XG4gICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9LCBmdW5jdGlvbiBfcmVqZWN0KGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSwgcmVzcG9uc2UpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoJ29ubG9hZGVuZCcgaW4gcmVxdWVzdCkge1xuICAgICAgLy8gVXNlIG9ubG9hZGVuZCBpZiBhdmFpbGFibGVcbiAgICAgIHJlcXVlc3Qub25sb2FkZW5kID0gb25sb2FkZW5kO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBMaXN0ZW4gZm9yIHJlYWR5IHN0YXRlIHRvIGVtdWxhdGUgb25sb2FkZW5kXG4gICAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUxvYWQoKSB7XG4gICAgICAgIGlmICghcmVxdWVzdCB8fCByZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgcmVxdWVzdCBlcnJvcmVkIG91dCBhbmQgd2UgZGlkbid0IGdldCBhIHJlc3BvbnNlLCB0aGlzIHdpbGwgYmVcbiAgICAgICAgLy8gaGFuZGxlZCBieSBvbmVycm9yIGluc3RlYWRcbiAgICAgICAgLy8gV2l0aCBvbmUgZXhjZXB0aW9uOiByZXF1ZXN0IHRoYXQgdXNpbmcgZmlsZTogcHJvdG9jb2wsIG1vc3QgYnJvd3NlcnNcbiAgICAgICAgLy8gd2lsbCByZXR1cm4gc3RhdHVzIGFzIDAgZXZlbiB0aG91Z2ggaXQncyBhIHN1Y2Nlc3NmdWwgcmVxdWVzdFxuICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDAgJiYgIShyZXF1ZXN0LnJlc3BvbnNlVVJMICYmIHJlcXVlc3QucmVzcG9uc2VVUkwuaW5kZXhPZignZmlsZTonKSA9PT0gMCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVhZHlzdGF0ZSBoYW5kbGVyIGlzIGNhbGxpbmcgYmVmb3JlIG9uZXJyb3Igb3Igb250aW1lb3V0IGhhbmRsZXJzLFxuICAgICAgICAvLyBzbyB3ZSBzaG91bGQgY2FsbCBvbmxvYWRlbmQgb24gdGhlIG5leHQgJ3RpY2snXG4gICAgICAgIHNldFRpbWVvdXQob25sb2FkZW5kKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGJyb3dzZXIgcmVxdWVzdCBjYW5jZWxsYXRpb24gKGFzIG9wcG9zZWQgdG8gYSBtYW51YWwgY2FuY2VsbGF0aW9uKVxuICAgIHJlcXVlc3Qub25hYm9ydCA9IGZ1bmN0aW9uIGhhbmRsZUFib3J0KCkge1xuICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVqZWN0KG5ldyBBeGlvc0Vycm9yKCdSZXF1ZXN0IGFib3J0ZWQnLCBBeGlvc0Vycm9yLkVDT05OQUJPUlRFRCwgX2NvbmZpZywgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIGxvdyBsZXZlbCBuZXR3b3JrIGVycm9yc1xuICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIGhhbmRsZUVycm9yKCkge1xuICAgICAgLy8gUmVhbCBlcnJvcnMgYXJlIGhpZGRlbiBmcm9tIHVzIGJ5IHRoZSBicm93c2VyXG4gICAgICAvLyBvbmVycm9yIHNob3VsZCBvbmx5IGZpcmUgaWYgaXQncyBhIG5ldHdvcmsgZXJyb3JcbiAgICAgIHJlamVjdChuZXcgQXhpb3NFcnJvcignTmV0d29yayBFcnJvcicsIEF4aW9zRXJyb3IuRVJSX05FVFdPUkssIF9jb25maWcsIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSB0aW1lb3V0XG4gICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBmdW5jdGlvbiBoYW5kbGVUaW1lb3V0KCkge1xuICAgICAgbGV0IHRpbWVvdXRFcnJvck1lc3NhZ2UgPSBfY29uZmlnLnRpbWVvdXQgPyAndGltZW91dCBvZiAnICsgX2NvbmZpZy50aW1lb3V0ICsgJ21zIGV4Y2VlZGVkJyA6ICd0aW1lb3V0IGV4Y2VlZGVkJztcbiAgICAgIGNvbnN0IHRyYW5zaXRpb25hbCA9IF9jb25maWcudHJhbnNpdGlvbmFsIHx8IHRyYW5zaXRpb25hbERlZmF1bHRzO1xuICAgICAgaWYgKF9jb25maWcudGltZW91dEVycm9yTWVzc2FnZSkge1xuICAgICAgICB0aW1lb3V0RXJyb3JNZXNzYWdlID0gX2NvbmZpZy50aW1lb3V0RXJyb3JNZXNzYWdlO1xuICAgICAgfVxuICAgICAgcmVqZWN0KG5ldyBBeGlvc0Vycm9yKFxuICAgICAgICB0aW1lb3V0RXJyb3JNZXNzYWdlLFxuICAgICAgICB0cmFuc2l0aW9uYWwuY2xhcmlmeVRpbWVvdXRFcnJvciA/IEF4aW9zRXJyb3IuRVRJTUVET1VUIDogQXhpb3NFcnJvci5FQ09OTkFCT1JURUQsXG4gICAgICAgIF9jb25maWcsXG4gICAgICAgIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIFJlbW92ZSBDb250ZW50LVR5cGUgaWYgZGF0YSBpcyB1bmRlZmluZWRcbiAgICByZXF1ZXN0RGF0YSA9PT0gdW5kZWZpbmVkICYmIHJlcXVlc3RIZWFkZXJzLnNldENvbnRlbnRUeXBlKG51bGwpO1xuXG4gICAgLy8gQWRkIGhlYWRlcnMgdG8gdGhlIHJlcXVlc3RcbiAgICBpZiAoJ3NldFJlcXVlc3RIZWFkZXInIGluIHJlcXVlc3QpIHtcbiAgICAgIHV0aWxzLmZvckVhY2gocmVxdWVzdEhlYWRlcnMudG9KU09OKCksIGZ1bmN0aW9uIHNldFJlcXVlc3RIZWFkZXIodmFsLCBrZXkpIHtcbiAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEFkZCB3aXRoQ3JlZGVudGlhbHMgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKF9jb25maWcud2l0aENyZWRlbnRpYWxzKSkge1xuICAgICAgcmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSAhIV9jb25maWcud2l0aENyZWRlbnRpYWxzO1xuICAgIH1cblxuICAgIC8vIEFkZCByZXNwb25zZVR5cGUgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAocmVzcG9uc2VUeXBlICYmIHJlc3BvbnNlVHlwZSAhPT0gJ2pzb24nKSB7XG4gICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IF9jb25maWcucmVzcG9uc2VUeXBlO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBwcm9ncmVzcyBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIF9jb25maWcub25Eb3dubG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgcHJvZ3Jlc3NFdmVudFJlZHVjZXIoX2NvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MsIHRydWUpKTtcbiAgICB9XG5cbiAgICAvLyBOb3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgdXBsb2FkIGV2ZW50c1xuICAgIGlmICh0eXBlb2YgX2NvbmZpZy5vblVwbG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nICYmIHJlcXVlc3QudXBsb2FkKSB7XG4gICAgICByZXF1ZXN0LnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIHByb2dyZXNzRXZlbnRSZWR1Y2VyKF9jb25maWcub25VcGxvYWRQcm9ncmVzcykpO1xuICAgIH1cblxuICAgIGlmIChfY29uZmlnLmNhbmNlbFRva2VuIHx8IF9jb25maWcuc2lnbmFsKSB7XG4gICAgICAvLyBIYW5kbGUgY2FuY2VsbGF0aW9uXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICAgICAgb25DYW5jZWxlZCA9IGNhbmNlbCA9PiB7XG4gICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZWplY3QoIWNhbmNlbCB8fCBjYW5jZWwudHlwZSA/IG5ldyBDYW5jZWxlZEVycm9yKG51bGwsIGNvbmZpZywgcmVxdWVzdCkgOiBjYW5jZWwpO1xuICAgICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgX2NvbmZpZy5jYW5jZWxUb2tlbiAmJiBfY29uZmlnLmNhbmNlbFRva2VuLnN1YnNjcmliZShvbkNhbmNlbGVkKTtcbiAgICAgIGlmIChfY29uZmlnLnNpZ25hbCkge1xuICAgICAgICBfY29uZmlnLnNpZ25hbC5hYm9ydGVkID8gb25DYW5jZWxlZCgpIDogX2NvbmZpZy5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBvbkNhbmNlbGVkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwcm90b2NvbCA9IHBhcnNlUHJvdG9jb2woX2NvbmZpZy51cmwpO1xuXG4gICAgaWYgKHByb3RvY29sICYmIHBsYXRmb3JtLnByb3RvY29scy5pbmRleE9mKHByb3RvY29sKSA9PT0gLTEpIHtcbiAgICAgIHJlamVjdChuZXcgQXhpb3NFcnJvcignVW5zdXBwb3J0ZWQgcHJvdG9jb2wgJyArIHByb3RvY29sICsgJzonLCBBeGlvc0Vycm9yLkVSUl9CQURfUkVRVUVTVCwgY29uZmlnKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG5cbiAgICAvLyBTZW5kIHRoZSByZXF1ZXN0XG4gICAgcmVxdWVzdC5zZW5kKHJlcXVlc3REYXRhIHx8IG51bGwpO1xuICB9KTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSAnLi9BeGlvc0Vycm9yLmpzJztcblxuLyoqXG4gKiBSZXNvbHZlIG9yIHJlamVjdCBhIFByb21pc2UgYmFzZWQgb24gcmVzcG9uc2Ugc3RhdHVzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmUgQSBmdW5jdGlvbiB0aGF0IHJlc29sdmVzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0IEEgZnVuY3Rpb24gdGhhdCByZWplY3RzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtvYmplY3R9IHJlc3BvbnNlIFRoZSByZXNwb25zZS5cbiAqXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgcmVzcG9uc2UuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKSB7XG4gIGNvbnN0IHZhbGlkYXRlU3RhdHVzID0gcmVzcG9uc2UuY29uZmlnLnZhbGlkYXRlU3RhdHVzO1xuICBpZiAoIXJlc3BvbnNlLnN0YXR1cyB8fCAhdmFsaWRhdGVTdGF0dXMgfHwgdmFsaWRhdGVTdGF0dXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICB9IGVsc2Uge1xuICAgIHJlamVjdChuZXcgQXhpb3NFcnJvcihcbiAgICAgICdSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlICcgKyByZXNwb25zZS5zdGF0dXMsXG4gICAgICBbQXhpb3NFcnJvci5FUlJfQkFEX1JFUVVFU1QsIEF4aW9zRXJyb3IuRVJSX0JBRF9SRVNQT05TRV1bTWF0aC5mbG9vcihyZXNwb25zZS5zdGF0dXMgLyAxMDApIC0gNF0sXG4gICAgICByZXNwb25zZS5jb25maWcsXG4gICAgICByZXNwb25zZS5yZXF1ZXN0LFxuICAgICAgcmVzcG9uc2VcbiAgICApKTtcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwYXJzZVByb3RvY29sKHVybCkge1xuICBjb25zdCBtYXRjaCA9IC9eKFstK1xcd117MSwyNX0pKDo/XFwvXFwvfDopLy5leGVjKHVybCk7XG4gIHJldHVybiBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbn1cbiIsImltcG9ydCBzcGVlZG9tZXRlciBmcm9tIFwiLi9zcGVlZG9tZXRlci5qc1wiO1xuaW1wb3J0IHRocm90dGxlIGZyb20gXCIuL3Rocm90dGxlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IChsaXN0ZW5lciwgaXNEb3dubG9hZFN0cmVhbSwgZnJlcSA9IDMpID0+IHtcbiAgbGV0IGJ5dGVzTm90aWZpZWQgPSAwO1xuICBjb25zdCBfc3BlZWRvbWV0ZXIgPSBzcGVlZG9tZXRlcig1MCwgMjUwKTtcblxuICByZXR1cm4gdGhyb3R0bGUoZSA9PiB7XG4gICAgY29uc3QgbG9hZGVkID0gZS5sb2FkZWQ7XG4gICAgY29uc3QgdG90YWwgPSBlLmxlbmd0aENvbXB1dGFibGUgPyBlLnRvdGFsIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHByb2dyZXNzQnl0ZXMgPSBsb2FkZWQgLSBieXRlc05vdGlmaWVkO1xuICAgIGNvbnN0IHJhdGUgPSBfc3BlZWRvbWV0ZXIocHJvZ3Jlc3NCeXRlcyk7XG4gICAgY29uc3QgaW5SYW5nZSA9IGxvYWRlZCA8PSB0b3RhbDtcblxuICAgIGJ5dGVzTm90aWZpZWQgPSBsb2FkZWQ7XG5cbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgbG9hZGVkLFxuICAgICAgdG90YWwsXG4gICAgICBwcm9ncmVzczogdG90YWwgPyAobG9hZGVkIC8gdG90YWwpIDogdW5kZWZpbmVkLFxuICAgICAgYnl0ZXM6IHByb2dyZXNzQnl0ZXMsXG4gICAgICByYXRlOiByYXRlID8gcmF0ZSA6IHVuZGVmaW5lZCxcbiAgICAgIGVzdGltYXRlZDogcmF0ZSAmJiB0b3RhbCAmJiBpblJhbmdlID8gKHRvdGFsIC0gbG9hZGVkKSAvIHJhdGUgOiB1bmRlZmluZWQsXG4gICAgICBldmVudDogZSxcbiAgICAgIGxlbmd0aENvbXB1dGFibGU6IHRvdGFsICE9IG51bGxcbiAgICB9O1xuXG4gICAgZGF0YVtpc0Rvd25sb2FkU3RyZWFtID8gJ2Rvd25sb2FkJyA6ICd1cGxvYWQnXSA9IHRydWU7XG5cbiAgICBsaXN0ZW5lcihkYXRhKTtcbiAgfSwgZnJlcSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ2FsY3VsYXRlIGRhdGEgbWF4UmF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtzYW1wbGVzQ291bnQ9IDEwXVxuICogQHBhcmFtIHtOdW1iZXJ9IFttaW49IDEwMDBdXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIHNwZWVkb21ldGVyKHNhbXBsZXNDb3VudCwgbWluKSB7XG4gIHNhbXBsZXNDb3VudCA9IHNhbXBsZXNDb3VudCB8fCAxMDtcbiAgY29uc3QgYnl0ZXMgPSBuZXcgQXJyYXkoc2FtcGxlc0NvdW50KTtcbiAgY29uc3QgdGltZXN0YW1wcyA9IG5ldyBBcnJheShzYW1wbGVzQ291bnQpO1xuICBsZXQgaGVhZCA9IDA7XG4gIGxldCB0YWlsID0gMDtcbiAgbGV0IGZpcnN0U2FtcGxlVFM7XG5cbiAgbWluID0gbWluICE9PSB1bmRlZmluZWQgPyBtaW4gOiAxMDAwO1xuXG4gIHJldHVybiBmdW5jdGlvbiBwdXNoKGNodW5rTGVuZ3RoKSB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcblxuICAgIGNvbnN0IHN0YXJ0ZWRBdCA9IHRpbWVzdGFtcHNbdGFpbF07XG5cbiAgICBpZiAoIWZpcnN0U2FtcGxlVFMpIHtcbiAgICAgIGZpcnN0U2FtcGxlVFMgPSBub3c7XG4gICAgfVxuXG4gICAgYnl0ZXNbaGVhZF0gPSBjaHVua0xlbmd0aDtcbiAgICB0aW1lc3RhbXBzW2hlYWRdID0gbm93O1xuXG4gICAgbGV0IGkgPSB0YWlsO1xuICAgIGxldCBieXRlc0NvdW50ID0gMDtcblxuICAgIHdoaWxlIChpICE9PSBoZWFkKSB7XG4gICAgICBieXRlc0NvdW50ICs9IGJ5dGVzW2krK107XG4gICAgICBpID0gaSAlIHNhbXBsZXNDb3VudDtcbiAgICB9XG5cbiAgICBoZWFkID0gKGhlYWQgKyAxKSAlIHNhbXBsZXNDb3VudDtcblxuICAgIGlmIChoZWFkID09PSB0YWlsKSB7XG4gICAgICB0YWlsID0gKHRhaWwgKyAxKSAlIHNhbXBsZXNDb3VudDtcbiAgICB9XG5cbiAgICBpZiAobm93IC0gZmlyc3RTYW1wbGVUUyA8IG1pbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHBhc3NlZCA9IHN0YXJ0ZWRBdCAmJiBub3cgLSBzdGFydGVkQXQ7XG5cbiAgICByZXR1cm4gcGFzc2VkID8gTWF0aC5yb3VuZChieXRlc0NvdW50ICogMTAwMCAvIHBhc3NlZCkgOiB1bmRlZmluZWQ7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNwZWVkb21ldGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFRocm90dGxlIGRlY29yYXRvclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7TnVtYmVyfSBmcmVxXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gdGhyb3R0bGUoZm4sIGZyZXEpIHtcbiAgbGV0IHRpbWVzdGFtcCA9IDA7XG4gIGNvbnN0IHRocmVzaG9sZCA9IDEwMDAgLyBmcmVxO1xuICBsZXQgdGltZXIgPSBudWxsO1xuICByZXR1cm4gZnVuY3Rpb24gdGhyb3R0bGVkKCkge1xuICAgIGNvbnN0IGZvcmNlID0gdGhpcyA9PT0gdHJ1ZTtcblxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgaWYgKGZvcmNlIHx8IG5vdyAtIHRpbWVzdGFtcCA+IHRocmVzaG9sZCkge1xuICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRpbWVzdGFtcCA9IG5vdztcbiAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBpZiAoIXRpbWVyKSB7XG4gICAgICB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgIHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSwgdGhyZXNob2xkIC0gKG5vdyAtIHRpbWVzdGFtcCkpO1xuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdGhyb3R0bGU7XG4iLCJpbXBvcnQgcGxhdGZvcm0gZnJvbSBcIi4uL3BsYXRmb3JtL2luZGV4LmpzXCI7XG5pbXBvcnQgdXRpbHMgZnJvbSBcIi4uL3V0aWxzLmpzXCI7XG5pbXBvcnQgaXNVUkxTYW1lT3JpZ2luIGZyb20gXCIuL2lzVVJMU2FtZU9yaWdpbi5qc1wiO1xuaW1wb3J0IGNvb2tpZXMgZnJvbSBcIi4vY29va2llcy5qc1wiO1xuaW1wb3J0IGJ1aWxkRnVsbFBhdGggZnJvbSBcIi4uL2NvcmUvYnVpbGRGdWxsUGF0aC5qc1wiO1xuaW1wb3J0IG1lcmdlQ29uZmlnIGZyb20gXCIuLi9jb3JlL21lcmdlQ29uZmlnLmpzXCI7XG5pbXBvcnQgQXhpb3NIZWFkZXJzIGZyb20gXCIuLi9jb3JlL0F4aW9zSGVhZGVycy5qc1wiO1xuaW1wb3J0IGJ1aWxkVVJMIGZyb20gXCIuL2J1aWxkVVJMLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IChjb25maWcpID0+IHtcbiAgY29uc3QgbmV3Q29uZmlnID0gbWVyZ2VDb25maWcoe30sIGNvbmZpZyk7XG5cbiAgbGV0IHtkYXRhLCB3aXRoWFNSRlRva2VuLCB4c3JmSGVhZGVyTmFtZSwgeHNyZkNvb2tpZU5hbWUsIGhlYWRlcnMsIGF1dGh9ID0gbmV3Q29uZmlnO1xuXG4gIG5ld0NvbmZpZy5oZWFkZXJzID0gaGVhZGVycyA9IEF4aW9zSGVhZGVycy5mcm9tKGhlYWRlcnMpO1xuXG4gIG5ld0NvbmZpZy51cmwgPSBidWlsZFVSTChidWlsZEZ1bGxQYXRoKG5ld0NvbmZpZy5iYXNlVVJMLCBuZXdDb25maWcudXJsKSwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpO1xuXG4gIC8vIEhUVFAgYmFzaWMgYXV0aGVudGljYXRpb25cbiAgaWYgKGF1dGgpIHtcbiAgICBoZWFkZXJzLnNldCgnQXV0aG9yaXphdGlvbicsICdCYXNpYyAnICtcbiAgICAgIGJ0b2EoKGF1dGgudXNlcm5hbWUgfHwgJycpICsgJzonICsgKGF1dGgucGFzc3dvcmQgPyB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoYXV0aC5wYXNzd29yZCkpIDogJycpKVxuICAgICk7XG4gIH1cblxuICBsZXQgY29udGVudFR5cGU7XG5cbiAgaWYgKHV0aWxzLmlzRm9ybURhdGEoZGF0YSkpIHtcbiAgICBpZiAocGxhdGZvcm0uaGFzU3RhbmRhcmRCcm93c2VyRW52IHx8IHBsYXRmb3JtLmhhc1N0YW5kYXJkQnJvd3NlcldlYldvcmtlckVudikge1xuICAgICAgaGVhZGVycy5zZXRDb250ZW50VHlwZSh1bmRlZmluZWQpOyAvLyBMZXQgdGhlIGJyb3dzZXIgc2V0IGl0XG4gICAgfSBlbHNlIGlmICgoY29udGVudFR5cGUgPSBoZWFkZXJzLmdldENvbnRlbnRUeXBlKCkpICE9PSBmYWxzZSkge1xuICAgICAgLy8gZml4IHNlbWljb2xvbiBkdXBsaWNhdGlvbiBpc3N1ZSBmb3IgUmVhY3ROYXRpdmUgRm9ybURhdGEgaW1wbGVtZW50YXRpb25cbiAgICAgIGNvbnN0IFt0eXBlLCAuLi50b2tlbnNdID0gY29udGVudFR5cGUgPyBjb250ZW50VHlwZS5zcGxpdCgnOycpLm1hcCh0b2tlbiA9PiB0b2tlbi50cmltKCkpLmZpbHRlcihCb29sZWFuKSA6IFtdO1xuICAgICAgaGVhZGVycy5zZXRDb250ZW50VHlwZShbdHlwZSB8fCAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScsIC4uLnRva2Vuc10uam9pbignOyAnKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gIC8vIFRoaXMgaXMgb25seSBkb25lIGlmIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50LlxuICAvLyBTcGVjaWZpY2FsbHkgbm90IGlmIHdlJ3JlIGluIGEgd2ViIHdvcmtlciwgb3IgcmVhY3QtbmF0aXZlLlxuXG4gIGlmIChwbGF0Zm9ybS5oYXNTdGFuZGFyZEJyb3dzZXJFbnYpIHtcbiAgICB3aXRoWFNSRlRva2VuICYmIHV0aWxzLmlzRnVuY3Rpb24od2l0aFhTUkZUb2tlbikgJiYgKHdpdGhYU1JGVG9rZW4gPSB3aXRoWFNSRlRva2VuKG5ld0NvbmZpZykpO1xuXG4gICAgaWYgKHdpdGhYU1JGVG9rZW4gfHwgKHdpdGhYU1JGVG9rZW4gIT09IGZhbHNlICYmIGlzVVJMU2FtZU9yaWdpbihuZXdDb25maWcudXJsKSkpIHtcbiAgICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgICAgY29uc3QgeHNyZlZhbHVlID0geHNyZkhlYWRlck5hbWUgJiYgeHNyZkNvb2tpZU5hbWUgJiYgY29va2llcy5yZWFkKHhzcmZDb29raWVOYW1lKTtcblxuICAgICAgaWYgKHhzcmZWYWx1ZSkge1xuICAgICAgICBoZWFkZXJzLnNldCh4c3JmSGVhZGVyTmFtZSwgeHNyZlZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3Q29uZmlnO1xufVxuXG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLy4uL3V0aWxzLmpzJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9wbGF0Zm9ybS9pbmRleC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHBsYXRmb3JtLmhhc1N0YW5kYXJkQnJvd3NlckVudiA/XG5cbi8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBoYXZlIGZ1bGwgc3VwcG9ydCBvZiB0aGUgQVBJcyBuZWVkZWQgdG8gdGVzdFxuLy8gd2hldGhlciB0aGUgcmVxdWVzdCBVUkwgaXMgb2YgdGhlIHNhbWUgb3JpZ2luIGFzIGN1cnJlbnQgbG9jYXRpb24uXG4gIChmdW5jdGlvbiBzdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgY29uc3QgbXNpZSA9IC8obXNpZXx0cmlkZW50KS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgY29uc3QgdXJsUGFyc2luZ05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgbGV0IG9yaWdpblVSTDtcblxuICAgIC8qKlxuICAgICogUGFyc2UgYSBVUkwgdG8gZGlzY292ZXIgaXRzIGNvbXBvbmVudHNcbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFRoZSBVUkwgdG8gYmUgcGFyc2VkXG4gICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICovXG4gICAgZnVuY3Rpb24gcmVzb2x2ZVVSTCh1cmwpIHtcbiAgICAgIGxldCBocmVmID0gdXJsO1xuXG4gICAgICBpZiAobXNpZSkge1xuICAgICAgICAvLyBJRSBuZWVkcyBhdHRyaWJ1dGUgc2V0IHR3aWNlIHRvIG5vcm1hbGl6ZSBwcm9wZXJ0aWVzXG4gICAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuICAgICAgICBocmVmID0gdXJsUGFyc2luZ05vZGUuaHJlZjtcbiAgICAgIH1cblxuICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG5cbiAgICAgIC8vIHVybFBhcnNpbmdOb2RlIHByb3ZpZGVzIHRoZSBVcmxVdGlscyBpbnRlcmZhY2UgLSBodHRwOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsdXRpbHNcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhyZWY6IHVybFBhcnNpbmdOb2RlLmhyZWYsXG4gICAgICAgIHByb3RvY29sOiB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbCA/IHVybFBhcnNpbmdOb2RlLnByb3RvY29sLnJlcGxhY2UoLzokLywgJycpIDogJycsXG4gICAgICAgIGhvc3Q6IHVybFBhcnNpbmdOb2RlLmhvc3QsXG4gICAgICAgIHNlYXJjaDogdXJsUGFyc2luZ05vZGUuc2VhcmNoID8gdXJsUGFyc2luZ05vZGUuc2VhcmNoLnJlcGxhY2UoL15cXD8vLCAnJykgOiAnJyxcbiAgICAgICAgaGFzaDogdXJsUGFyc2luZ05vZGUuaGFzaCA/IHVybFBhcnNpbmdOb2RlLmhhc2gucmVwbGFjZSgvXiMvLCAnJykgOiAnJyxcbiAgICAgICAgaG9zdG5hbWU6IHVybFBhcnNpbmdOb2RlLmhvc3RuYW1lLFxuICAgICAgICBwb3J0OiB1cmxQYXJzaW5nTm9kZS5wb3J0LFxuICAgICAgICBwYXRobmFtZTogKHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSA/XG4gICAgICAgICAgdXJsUGFyc2luZ05vZGUucGF0aG5hbWUgOlxuICAgICAgICAgICcvJyArIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lXG4gICAgICB9O1xuICAgIH1cblxuICAgIG9yaWdpblVSTCA9IHJlc29sdmVVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuXG4gICAgLyoqXG4gICAgKiBEZXRlcm1pbmUgaWYgYSBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiBhcyB0aGUgY3VycmVudCBsb2NhdGlvblxuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0VVJMIFRoZSBVUkwgdG8gdGVzdFxuICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4sIG90aGVyd2lzZSBmYWxzZVxuICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbihyZXF1ZXN0VVJMKSB7XG4gICAgICBjb25zdCBwYXJzZWQgPSAodXRpbHMuaXNTdHJpbmcocmVxdWVzdFVSTCkpID8gcmVzb2x2ZVVSTChyZXF1ZXN0VVJMKSA6IHJlcXVlc3RVUkw7XG4gICAgICByZXR1cm4gKHBhcnNlZC5wcm90b2NvbCA9PT0gb3JpZ2luVVJMLnByb3RvY29sICYmXG4gICAgICAgICAgcGFyc2VkLmhvc3QgPT09IG9yaWdpblVSTC5ob3N0KTtcbiAgICB9O1xuICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnZzICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4oKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9KSgpO1xuIiwiaW1wb3J0IHV0aWxzIGZyb20gJy4vLi4vdXRpbHMuanMnO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uL3BsYXRmb3JtL2luZGV4LmpzJztcblxuZXhwb3J0IGRlZmF1bHQgcGxhdGZvcm0uaGFzU3RhbmRhcmRCcm93c2VyRW52ID9cblxuICAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgc3VwcG9ydCBkb2N1bWVudC5jb29raWVcbiAge1xuICAgIHdyaXRlKG5hbWUsIHZhbHVlLCBleHBpcmVzLCBwYXRoLCBkb21haW4sIHNlY3VyZSkge1xuICAgICAgY29uc3QgY29va2llID0gW25hbWUgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpXTtcblxuICAgICAgdXRpbHMuaXNOdW1iZXIoZXhwaXJlcykgJiYgY29va2llLnB1c2goJ2V4cGlyZXM9JyArIG5ldyBEYXRlKGV4cGlyZXMpLnRvR01UU3RyaW5nKCkpO1xuXG4gICAgICB1dGlscy5pc1N0cmluZyhwYXRoKSAmJiBjb29raWUucHVzaCgncGF0aD0nICsgcGF0aCk7XG5cbiAgICAgIHV0aWxzLmlzU3RyaW5nKGRvbWFpbikgJiYgY29va2llLnB1c2goJ2RvbWFpbj0nICsgZG9tYWluKTtcblxuICAgICAgc2VjdXJlID09PSB0cnVlICYmIGNvb2tpZS5wdXNoKCdzZWN1cmUnKTtcblxuICAgICAgZG9jdW1lbnQuY29va2llID0gY29va2llLmpvaW4oJzsgJyk7XG4gICAgfSxcblxuICAgIHJlYWQobmFtZSkge1xuICAgICAgY29uc3QgbWF0Y2ggPSBkb2N1bWVudC5jb29raWUubWF0Y2gobmV3IFJlZ0V4cCgnKF58O1xcXFxzKikoJyArIG5hbWUgKyAnKT0oW147XSopJykpO1xuICAgICAgcmV0dXJuIChtYXRjaCA/IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFszXSkgOiBudWxsKTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlKG5hbWUpIHtcbiAgICAgIHRoaXMud3JpdGUobmFtZSwgJycsIERhdGUubm93KCkgLSA4NjQwMDAwMCk7XG4gICAgfVxuICB9XG5cbiAgOlxuXG4gIC8vIE5vbi1zdGFuZGFyZCBicm93c2VyIGVudiAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbiAge1xuICAgIHdyaXRlKCkge30sXG4gICAgcmVhZCgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgcmVtb3ZlKCkge31cbiAgfTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgaXNBYnNvbHV0ZVVSTCBmcm9tICcuLi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwuanMnO1xuaW1wb3J0IGNvbWJpbmVVUkxzIGZyb20gJy4uL2hlbHBlcnMvY29tYmluZVVSTHMuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgYmFzZVVSTCB3aXRoIHRoZSByZXF1ZXN0ZWRVUkwsXG4gKiBvbmx5IHdoZW4gdGhlIHJlcXVlc3RlZFVSTCBpcyBub3QgYWxyZWFkeSBhbiBhYnNvbHV0ZSBVUkwuXG4gKiBJZiB0aGUgcmVxdWVzdFVSTCBpcyBhYnNvbHV0ZSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSByZXF1ZXN0ZWRVUkwgdW50b3VjaGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlcXVlc3RlZFVSTCBBYnNvbHV0ZSBvciByZWxhdGl2ZSBVUkwgdG8gY29tYmluZVxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBmdWxsIHBhdGhcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYnVpbGRGdWxsUGF0aChiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpIHtcbiAgaWYgKGJhc2VVUkwgJiYgIWlzQWJzb2x1dGVVUkwocmVxdWVzdGVkVVJMKSkge1xuICAgIHJldHVybiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpO1xuICB9XG4gIHJldHVybiByZXF1ZXN0ZWRVUkw7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzQWJzb2x1dGVVUkwodXJsKSB7XG4gIC8vIEEgVVJMIGlzIGNvbnNpZGVyZWQgYWJzb2x1dGUgaWYgaXQgYmVnaW5zIHdpdGggXCI8c2NoZW1lPjovL1wiIG9yIFwiLy9cIiAocHJvdG9jb2wtcmVsYXRpdmUgVVJMKS5cbiAgLy8gUkZDIDM5ODYgZGVmaW5lcyBzY2hlbWUgbmFtZSBhcyBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgYmVnaW5uaW5nIHdpdGggYSBsZXR0ZXIgYW5kIGZvbGxvd2VkXG4gIC8vIGJ5IGFueSBjb21iaW5hdGlvbiBvZiBsZXR0ZXJzLCBkaWdpdHMsIHBsdXMsIHBlcmlvZCwgb3IgaHlwaGVuLlxuICByZXR1cm4gL14oW2Etel1bYS16XFxkK1xcLS5dKjopP1xcL1xcLy9pLnRlc3QodXJsKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIHNwZWNpZmllZCBVUkxzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVsYXRpdmVVUkwgVGhlIHJlbGF0aXZlIFVSTFxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBVUkxcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVsYXRpdmVVUkwpIHtcbiAgcmV0dXJuIHJlbGF0aXZlVVJMXG4gICAgPyBiYXNlVVJMLnJlcGxhY2UoL1xcLz9cXC8kLywgJycpICsgJy8nICsgcmVsYXRpdmVVUkwucmVwbGFjZSgvXlxcLysvLCAnJylcbiAgICA6IGJhc2VVUkw7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5pbXBvcnQgQXhpb3NIZWFkZXJzIGZyb20gXCIuL0F4aW9zSGVhZGVycy5qc1wiO1xuXG5jb25zdCBoZWFkZXJzVG9PYmplY3QgPSAodGhpbmcpID0+IHRoaW5nIGluc3RhbmNlb2YgQXhpb3NIZWFkZXJzID8geyAuLi50aGluZyB9IDogdGhpbmc7XG5cbi8qKlxuICogQ29uZmlnLXNwZWNpZmljIG1lcmdlLWZ1bmN0aW9uIHdoaWNoIGNyZWF0ZXMgYSBuZXcgY29uZmlnLW9iamVjdFxuICogYnkgbWVyZ2luZyB0d28gY29uZmlndXJhdGlvbiBvYmplY3RzIHRvZ2V0aGVyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcxXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnMlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9IE5ldyBvYmplY3QgcmVzdWx0aW5nIGZyb20gbWVyZ2luZyBjb25maWcyIHRvIGNvbmZpZzFcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWVyZ2VDb25maWcoY29uZmlnMSwgY29uZmlnMikge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgY29uZmlnMiA9IGNvbmZpZzIgfHwge307XG4gIGNvbnN0IGNvbmZpZyA9IHt9O1xuXG4gIGZ1bmN0aW9uIGdldE1lcmdlZFZhbHVlKHRhcmdldCwgc291cmNlLCBjYXNlbGVzcykge1xuICAgIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KHRhcmdldCkgJiYgdXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdXRpbHMubWVyZ2UuY2FsbCh7Y2FzZWxlc3N9LCB0YXJnZXQsIHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB1dGlscy5tZXJnZSh7fSwgc291cmNlKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHNvdXJjZS5zbGljZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc291cmNlO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIGZ1bmN0aW9uIG1lcmdlRGVlcFByb3BlcnRpZXMoYSwgYiwgY2FzZWxlc3MpIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGIpKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUoYSwgYiwgY2FzZWxlc3MpO1xuICAgIH0gZWxzZSBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGEpKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBhLCBjYXNlbGVzcyk7XG4gICAgfVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIGZ1bmN0aW9uIHZhbHVlRnJvbUNvbmZpZzIoYSwgYikge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoYikpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICBmdW5jdGlvbiBkZWZhdWx0VG9Db25maWcyKGEsIGIpIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGIpKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBiKTtcbiAgICB9IGVsc2UgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChhKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgYSk7XG4gICAgfVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIGZ1bmN0aW9uIG1lcmdlRGlyZWN0S2V5cyhhLCBiLCBwcm9wKSB7XG4gICAgaWYgKHByb3AgaW4gY29uZmlnMikge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKGEsIGIpO1xuICAgIH0gZWxzZSBpZiAocHJvcCBpbiBjb25maWcxKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBhKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBtZXJnZU1hcCA9IHtcbiAgICB1cmw6IHZhbHVlRnJvbUNvbmZpZzIsXG4gICAgbWV0aG9kOiB2YWx1ZUZyb21Db25maWcyLFxuICAgIGRhdGE6IHZhbHVlRnJvbUNvbmZpZzIsXG4gICAgYmFzZVVSTDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB0cmFuc2Zvcm1SZXF1ZXN0OiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHRyYW5zZm9ybVJlc3BvbnNlOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHBhcmFtc1NlcmlhbGl6ZXI6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgdGltZW91dDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB0aW1lb3V0TWVzc2FnZTogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB3aXRoQ3JlZGVudGlhbHM6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgd2l0aFhTUkZUb2tlbjogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBhZGFwdGVyOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHJlc3BvbnNlVHlwZTogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB4c3JmQ29va2llTmFtZTogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB4c3JmSGVhZGVyTmFtZTogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBvblVwbG9hZFByb2dyZXNzOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIG9uRG93bmxvYWRQcm9ncmVzczogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBkZWNvbXByZXNzOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIG1heENvbnRlbnRMZW5ndGg6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgbWF4Qm9keUxlbmd0aDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBiZWZvcmVSZWRpcmVjdDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB0cmFuc3BvcnQ6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgaHR0cEFnZW50OiBkZWZhdWx0VG9Db25maWcyLFxuICAgIGh0dHBzQWdlbnQ6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgY2FuY2VsVG9rZW46IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgc29ja2V0UGF0aDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICByZXNwb25zZUVuY29kaW5nOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHZhbGlkYXRlU3RhdHVzOiBtZXJnZURpcmVjdEtleXMsXG4gICAgaGVhZGVyczogKGEsIGIpID0+IG1lcmdlRGVlcFByb3BlcnRpZXMoaGVhZGVyc1RvT2JqZWN0KGEpLCBoZWFkZXJzVG9PYmplY3QoYiksIHRydWUpXG4gIH07XG5cbiAgdXRpbHMuZm9yRWFjaChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCBjb25maWcxLCBjb25maWcyKSksIGZ1bmN0aW9uIGNvbXB1dGVDb25maWdWYWx1ZShwcm9wKSB7XG4gICAgY29uc3QgbWVyZ2UgPSBtZXJnZU1hcFtwcm9wXSB8fCBtZXJnZURlZXBQcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGNvbmZpZ1ZhbHVlID0gbWVyZ2UoY29uZmlnMVtwcm9wXSwgY29uZmlnMltwcm9wXSwgcHJvcCk7XG4gICAgKHV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZ1ZhbHVlKSAmJiBtZXJnZSAhPT0gbWVyZ2VEaXJlY3RLZXlzKSB8fCAoY29uZmlnW3Byb3BdID0gY29uZmlnVmFsdWUpO1xuICB9KTtcblxuICByZXR1cm4gY29uZmlnO1xufVxuIiwiaW1wb3J0IHBsYXRmb3JtIGZyb20gXCIuLi9wbGF0Zm9ybS9pbmRleC5qc1wiO1xuaW1wb3J0IHV0aWxzIGZyb20gXCIuLi91dGlscy5qc1wiO1xuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSBcIi4uL2NvcmUvQXhpb3NFcnJvci5qc1wiO1xuaW1wb3J0IGNvbXBvc2VTaWduYWxzIGZyb20gXCIuLi9oZWxwZXJzL2NvbXBvc2VTaWduYWxzLmpzXCI7XG5pbXBvcnQge3RyYWNrU3RyZWFtfSBmcm9tIFwiLi4vaGVscGVycy90cmFja1N0cmVhbS5qc1wiO1xuaW1wb3J0IEF4aW9zSGVhZGVycyBmcm9tIFwiLi4vY29yZS9BeGlvc0hlYWRlcnMuanNcIjtcbmltcG9ydCBwcm9ncmVzc0V2ZW50UmVkdWNlciBmcm9tIFwiLi4vaGVscGVycy9wcm9ncmVzc0V2ZW50UmVkdWNlci5qc1wiO1xuaW1wb3J0IHJlc29sdmVDb25maWcgZnJvbSBcIi4uL2hlbHBlcnMvcmVzb2x2ZUNvbmZpZy5qc1wiO1xuaW1wb3J0IHNldHRsZSBmcm9tIFwiLi4vY29yZS9zZXR0bGUuanNcIjtcblxuY29uc3QgZmV0Y2hQcm9ncmVzc0RlY29yYXRvciA9ICh0b3RhbCwgZm4pID0+IHtcbiAgY29uc3QgbGVuZ3RoQ29tcHV0YWJsZSA9IHRvdGFsICE9IG51bGw7XG4gIHJldHVybiAobG9hZGVkKSA9PiBzZXRUaW1lb3V0KCgpID0+IGZuKHtcbiAgICBsZW5ndGhDb21wdXRhYmxlLFxuICAgIHRvdGFsLFxuICAgIGxvYWRlZFxuICB9KSk7XG59XG5cbmNvbnN0IGlzRmV0Y2hTdXBwb3J0ZWQgPSB0eXBlb2YgZmV0Y2ggPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFJlcXVlc3QgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFJlc3BvbnNlID09PSAnZnVuY3Rpb24nO1xuY29uc3QgaXNSZWFkYWJsZVN0cmVhbVN1cHBvcnRlZCA9IGlzRmV0Y2hTdXBwb3J0ZWQgJiYgdHlwZW9mIFJlYWRhYmxlU3RyZWFtID09PSAnZnVuY3Rpb24nO1xuXG4vLyB1c2VkIG9ubHkgaW5zaWRlIHRoZSBmZXRjaCBhZGFwdGVyXG5jb25zdCBlbmNvZGVUZXh0ID0gaXNGZXRjaFN1cHBvcnRlZCAmJiAodHlwZW9mIFRleHRFbmNvZGVyID09PSAnZnVuY3Rpb24nID9cbiAgICAoKGVuY29kZXIpID0+IChzdHIpID0+IGVuY29kZXIuZW5jb2RlKHN0cikpKG5ldyBUZXh0RW5jb2RlcigpKSA6XG4gICAgYXN5bmMgKHN0cikgPT4gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgbmV3IFJlc3BvbnNlKHN0cikuYXJyYXlCdWZmZXIoKSlcbik7XG5cbmNvbnN0IHN1cHBvcnRzUmVxdWVzdFN0cmVhbSA9IGlzUmVhZGFibGVTdHJlYW1TdXBwb3J0ZWQgJiYgKCgpID0+IHtcbiAgbGV0IGR1cGxleEFjY2Vzc2VkID0gZmFsc2U7XG5cbiAgY29uc3QgaGFzQ29udGVudFR5cGUgPSBuZXcgUmVxdWVzdChwbGF0Zm9ybS5vcmlnaW4sIHtcbiAgICBib2R5OiBuZXcgUmVhZGFibGVTdHJlYW0oKSxcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICBnZXQgZHVwbGV4KCkge1xuICAgICAgZHVwbGV4QWNjZXNzZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuICdoYWxmJztcbiAgICB9LFxuICB9KS5oZWFkZXJzLmhhcygnQ29udGVudC1UeXBlJyk7XG5cbiAgcmV0dXJuIGR1cGxleEFjY2Vzc2VkICYmICFoYXNDb250ZW50VHlwZTtcbn0pKCk7XG5cbmNvbnN0IERFRkFVTFRfQ0hVTktfU0laRSA9IDY0ICogMTAyNDtcblxuY29uc3Qgc3VwcG9ydHNSZXNwb25zZVN0cmVhbSA9IGlzUmVhZGFibGVTdHJlYW1TdXBwb3J0ZWQgJiYgISEoKCk9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHV0aWxzLmlzUmVhZGFibGVTdHJlYW0obmV3IFJlc3BvbnNlKCcnKS5ib2R5KTtcbiAgfSBjYXRjaChlcnIpIHtcbiAgICAvLyByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbn0pKCk7XG5cbmNvbnN0IHJlc29sdmVycyA9IHtcbiAgc3RyZWFtOiBzdXBwb3J0c1Jlc3BvbnNlU3RyZWFtICYmICgocmVzKSA9PiByZXMuYm9keSlcbn07XG5cbmlzRmV0Y2hTdXBwb3J0ZWQgJiYgKCgocmVzKSA9PiB7XG4gIFsndGV4dCcsICdhcnJheUJ1ZmZlcicsICdibG9iJywgJ2Zvcm1EYXRhJywgJ3N0cmVhbSddLmZvckVhY2godHlwZSA9PiB7XG4gICAgIXJlc29sdmVyc1t0eXBlXSAmJiAocmVzb2x2ZXJzW3R5cGVdID0gdXRpbHMuaXNGdW5jdGlvbihyZXNbdHlwZV0pID8gKHJlcykgPT4gcmVzW3R5cGVdKCkgOlxuICAgICAgKF8sIGNvbmZpZykgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcihgUmVzcG9uc2UgdHlwZSAnJHt0eXBlfScgaXMgbm90IHN1cHBvcnRlZGAsIEF4aW9zRXJyb3IuRVJSX05PVF9TVVBQT1JULCBjb25maWcpO1xuICAgICAgfSlcbiAgfSk7XG59KShuZXcgUmVzcG9uc2UpKTtcblxuY29uc3QgZ2V0Qm9keUxlbmd0aCA9IGFzeW5jIChib2R5KSA9PiB7XG4gIGlmIChib2R5ID09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGlmKHV0aWxzLmlzQmxvYihib2R5KSkge1xuICAgIHJldHVybiBib2R5LnNpemU7XG4gIH1cblxuICBpZih1dGlscy5pc1NwZWNDb21wbGlhbnRGb3JtKGJvZHkpKSB7XG4gICAgcmV0dXJuIChhd2FpdCBuZXcgUmVxdWVzdChib2R5KS5hcnJheUJ1ZmZlcigpKS5ieXRlTGVuZ3RoO1xuICB9XG5cbiAgaWYodXRpbHMuaXNBcnJheUJ1ZmZlclZpZXcoYm9keSkpIHtcbiAgICByZXR1cm4gYm9keS5ieXRlTGVuZ3RoO1xuICB9XG5cbiAgaWYodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMoYm9keSkpIHtcbiAgICBib2R5ID0gYm9keSArICcnO1xuICB9XG5cbiAgaWYodXRpbHMuaXNTdHJpbmcoYm9keSkpIHtcbiAgICByZXR1cm4gKGF3YWl0IGVuY29kZVRleHQoYm9keSkpLmJ5dGVMZW5ndGg7XG4gIH1cbn1cblxuY29uc3QgcmVzb2x2ZUJvZHlMZW5ndGggPSBhc3luYyAoaGVhZGVycywgYm9keSkgPT4ge1xuICBjb25zdCBsZW5ndGggPSB1dGlscy50b0Zpbml0ZU51bWJlcihoZWFkZXJzLmdldENvbnRlbnRMZW5ndGgoKSk7XG5cbiAgcmV0dXJuIGxlbmd0aCA9PSBudWxsID8gZ2V0Qm9keUxlbmd0aChib2R5KSA6IGxlbmd0aDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNGZXRjaFN1cHBvcnRlZCAmJiAoYXN5bmMgKGNvbmZpZykgPT4ge1xuICBsZXQge1xuICAgIHVybCxcbiAgICBtZXRob2QsXG4gICAgZGF0YSxcbiAgICBzaWduYWwsXG4gICAgY2FuY2VsVG9rZW4sXG4gICAgdGltZW91dCxcbiAgICBvbkRvd25sb2FkUHJvZ3Jlc3MsXG4gICAgb25VcGxvYWRQcm9ncmVzcyxcbiAgICByZXNwb25zZVR5cGUsXG4gICAgaGVhZGVycyxcbiAgICB3aXRoQ3JlZGVudGlhbHMgPSAnc2FtZS1vcmlnaW4nLFxuICAgIGZldGNoT3B0aW9uc1xuICB9ID0gcmVzb2x2ZUNvbmZpZyhjb25maWcpO1xuXG4gIHJlc3BvbnNlVHlwZSA9IHJlc3BvbnNlVHlwZSA/IChyZXNwb25zZVR5cGUgKyAnJykudG9Mb3dlckNhc2UoKSA6ICd0ZXh0JztcblxuICBsZXQgW2NvbXBvc2VkU2lnbmFsLCBzdG9wVGltZW91dF0gPSAoc2lnbmFsIHx8IGNhbmNlbFRva2VuIHx8IHRpbWVvdXQpID9cbiAgICBjb21wb3NlU2lnbmFscyhbc2lnbmFsLCBjYW5jZWxUb2tlbl0sIHRpbWVvdXQpIDogW107XG5cbiAgbGV0IGZpbmlzaGVkLCByZXF1ZXN0O1xuXG4gIGNvbnN0IG9uRmluaXNoID0gKCkgPT4ge1xuICAgICFmaW5pc2hlZCAmJiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGNvbXBvc2VkU2lnbmFsICYmIGNvbXBvc2VkU2lnbmFsLnVuc3Vic2NyaWJlKCk7XG4gICAgfSk7XG5cbiAgICBmaW5pc2hlZCA9IHRydWU7XG4gIH1cblxuICBsZXQgcmVxdWVzdENvbnRlbnRMZW5ndGg7XG5cbiAgdHJ5IHtcbiAgICBpZiAoXG4gICAgICBvblVwbG9hZFByb2dyZXNzICYmIHN1cHBvcnRzUmVxdWVzdFN0cmVhbSAmJiBtZXRob2QgIT09ICdnZXQnICYmIG1ldGhvZCAhPT0gJ2hlYWQnICYmXG4gICAgICAocmVxdWVzdENvbnRlbnRMZW5ndGggPSBhd2FpdCByZXNvbHZlQm9keUxlbmd0aChoZWFkZXJzLCBkYXRhKSkgIT09IDBcbiAgICApIHtcbiAgICAgIGxldCBfcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHVybCwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgYm9keTogZGF0YSxcbiAgICAgICAgZHVwbGV4OiBcImhhbGZcIlxuICAgICAgfSk7XG5cbiAgICAgIGxldCBjb250ZW50VHlwZUhlYWRlcjtcblxuICAgICAgaWYgKHV0aWxzLmlzRm9ybURhdGEoZGF0YSkgJiYgKGNvbnRlbnRUeXBlSGVhZGVyID0gX3JlcXVlc3QuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpKSkge1xuICAgICAgICBoZWFkZXJzLnNldENvbnRlbnRUeXBlKGNvbnRlbnRUeXBlSGVhZGVyKVxuICAgICAgfVxuXG4gICAgICBpZiAoX3JlcXVlc3QuYm9keSkge1xuICAgICAgICBkYXRhID0gdHJhY2tTdHJlYW0oX3JlcXVlc3QuYm9keSwgREVGQVVMVF9DSFVOS19TSVpFLCBmZXRjaFByb2dyZXNzRGVjb3JhdG9yKFxuICAgICAgICAgIHJlcXVlc3RDb250ZW50TGVuZ3RoLFxuICAgICAgICAgIHByb2dyZXNzRXZlbnRSZWR1Y2VyKG9uVXBsb2FkUHJvZ3Jlc3MpXG4gICAgICAgICksIG51bGwsIGVuY29kZVRleHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdXRpbHMuaXNTdHJpbmcod2l0aENyZWRlbnRpYWxzKSkge1xuICAgICAgd2l0aENyZWRlbnRpYWxzID0gd2l0aENyZWRlbnRpYWxzID8gJ2NvcnMnIDogJ29taXQnO1xuICAgIH1cblxuICAgIHJlcXVlc3QgPSBuZXcgUmVxdWVzdCh1cmwsIHtcbiAgICAgIC4uLmZldGNoT3B0aW9ucyxcbiAgICAgIHNpZ25hbDogY29tcG9zZWRTaWduYWwsXG4gICAgICBtZXRob2Q6IG1ldGhvZC50b1VwcGVyQ2FzZSgpLFxuICAgICAgaGVhZGVyczogaGVhZGVycy5ub3JtYWxpemUoKS50b0pTT04oKSxcbiAgICAgIGJvZHk6IGRhdGEsXG4gICAgICBkdXBsZXg6IFwiaGFsZlwiLFxuICAgICAgd2l0aENyZWRlbnRpYWxzXG4gICAgfSk7XG5cbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChyZXF1ZXN0KTtcblxuICAgIGNvbnN0IGlzU3RyZWFtUmVzcG9uc2UgPSBzdXBwb3J0c1Jlc3BvbnNlU3RyZWFtICYmIChyZXNwb25zZVR5cGUgPT09ICdzdHJlYW0nIHx8IHJlc3BvbnNlVHlwZSA9PT0gJ3Jlc3BvbnNlJyk7XG5cbiAgICBpZiAoc3VwcG9ydHNSZXNwb25zZVN0cmVhbSAmJiAob25Eb3dubG9hZFByb2dyZXNzIHx8IGlzU3RyZWFtUmVzcG9uc2UpKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0ge307XG5cbiAgICAgIFsnc3RhdHVzJywgJ3N0YXR1c1RleHQnLCAnaGVhZGVycyddLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICAgIG9wdGlvbnNbcHJvcF0gPSByZXNwb25zZVtwcm9wXTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXNwb25zZUNvbnRlbnRMZW5ndGggPSB1dGlscy50b0Zpbml0ZU51bWJlcihyZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC1sZW5ndGgnKSk7XG5cbiAgICAgIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKFxuICAgICAgICB0cmFja1N0cmVhbShyZXNwb25zZS5ib2R5LCBERUZBVUxUX0NIVU5LX1NJWkUsIG9uRG93bmxvYWRQcm9ncmVzcyAmJiBmZXRjaFByb2dyZXNzRGVjb3JhdG9yKFxuICAgICAgICAgIHJlc3BvbnNlQ29udGVudExlbmd0aCxcbiAgICAgICAgICBwcm9ncmVzc0V2ZW50UmVkdWNlcihvbkRvd25sb2FkUHJvZ3Jlc3MsIHRydWUpXG4gICAgICAgICksIGlzU3RyZWFtUmVzcG9uc2UgJiYgb25GaW5pc2gsIGVuY29kZVRleHQpLFxuICAgICAgICBvcHRpb25zXG4gICAgICApO1xuICAgIH1cblxuICAgIHJlc3BvbnNlVHlwZSA9IHJlc3BvbnNlVHlwZSB8fCAndGV4dCc7XG5cbiAgICBsZXQgcmVzcG9uc2VEYXRhID0gYXdhaXQgcmVzb2x2ZXJzW3V0aWxzLmZpbmRLZXkocmVzb2x2ZXJzLCByZXNwb25zZVR5cGUpIHx8ICd0ZXh0J10ocmVzcG9uc2UsIGNvbmZpZyk7XG5cbiAgICAhaXNTdHJlYW1SZXNwb25zZSAmJiBvbkZpbmlzaCgpO1xuXG4gICAgc3RvcFRpbWVvdXQgJiYgc3RvcFRpbWVvdXQoKTtcblxuICAgIHJldHVybiBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB7XG4gICAgICAgIGRhdGE6IHJlc3BvbnNlRGF0YSxcbiAgICAgICAgaGVhZGVyczogQXhpb3NIZWFkZXJzLmZyb20ocmVzcG9uc2UuaGVhZGVycyksXG4gICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICBjb25maWcsXG4gICAgICAgIHJlcXVlc3RcbiAgICAgIH0pXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgb25GaW5pc2goKTtcblxuICAgIGlmIChlcnIgJiYgZXJyLm5hbWUgPT09ICdUeXBlRXJyb3InICYmIC9mZXRjaC9pLnRlc3QoZXJyLm1lc3NhZ2UpKSB7XG4gICAgICB0aHJvdyBPYmplY3QuYXNzaWduKFxuICAgICAgICBuZXcgQXhpb3NFcnJvcignTmV0d29yayBFcnJvcicsIEF4aW9zRXJyb3IuRVJSX05FVFdPUkssIGNvbmZpZywgcmVxdWVzdCksXG4gICAgICAgIHtcbiAgICAgICAgICBjYXVzZTogZXJyLmNhdXNlIHx8IGVyclxuICAgICAgICB9XG4gICAgICApXG4gICAgfVxuXG4gICAgdGhyb3cgQXhpb3NFcnJvci5mcm9tKGVyciwgZXJyICYmIGVyci5jb2RlLCBjb25maWcsIHJlcXVlc3QpO1xuICB9XG59KTtcblxuXG4iLCJpbXBvcnQgQ2FuY2VsZWRFcnJvciBmcm9tIFwiLi4vY2FuY2VsL0NhbmNlbGVkRXJyb3IuanNcIjtcbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gXCIuLi9jb3JlL0F4aW9zRXJyb3IuanNcIjtcblxuY29uc3QgY29tcG9zZVNpZ25hbHMgPSAoc2lnbmFscywgdGltZW91dCkgPT4ge1xuICBsZXQgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcblxuICBsZXQgYWJvcnRlZDtcblxuICBjb25zdCBvbmFib3J0ID0gZnVuY3Rpb24gKGNhbmNlbCkge1xuICAgIGlmICghYWJvcnRlZCkge1xuICAgICAgYWJvcnRlZCA9IHRydWU7XG4gICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgY29uc3QgZXJyID0gY2FuY2VsIGluc3RhbmNlb2YgRXJyb3IgPyBjYW5jZWwgOiB0aGlzLnJlYXNvbjtcbiAgICAgIGNvbnRyb2xsZXIuYWJvcnQoZXJyIGluc3RhbmNlb2YgQXhpb3NFcnJvciA/IGVyciA6IG5ldyBDYW5jZWxlZEVycm9yKGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBlcnIpKTtcbiAgICB9XG4gIH1cblxuICBsZXQgdGltZXIgPSB0aW1lb3V0ICYmIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIG9uYWJvcnQobmV3IEF4aW9zRXJyb3IoYHRpbWVvdXQgJHt0aW1lb3V0fSBvZiBtcyBleGNlZWRlZGAsIEF4aW9zRXJyb3IuRVRJTUVET1VUKSlcbiAgfSwgdGltZW91dClcblxuICBjb25zdCB1bnN1YnNjcmliZSA9ICgpID0+IHtcbiAgICBpZiAoc2lnbmFscykge1xuICAgICAgdGltZXIgJiYgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgIHNpZ25hbHMuZm9yRWFjaChzaWduYWwgPT4ge1xuICAgICAgICBzaWduYWwgJiZcbiAgICAgICAgKHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyID8gc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0Jywgb25hYm9ydCkgOiBzaWduYWwudW5zdWJzY3JpYmUob25hYm9ydCkpO1xuICAgICAgfSk7XG4gICAgICBzaWduYWxzID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBzaWduYWxzLmZvckVhY2goKHNpZ25hbCkgPT4gc2lnbmFsICYmIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyICYmIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uYWJvcnQpKTtcblxuICBjb25zdCB7c2lnbmFsfSA9IGNvbnRyb2xsZXI7XG5cbiAgc2lnbmFsLnVuc3Vic2NyaWJlID0gdW5zdWJzY3JpYmU7XG5cbiAgcmV0dXJuIFtzaWduYWwsICgpID0+IHtcbiAgICB0aW1lciAmJiBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgIHRpbWVyID0gbnVsbDtcbiAgfV07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvbXBvc2VTaWduYWxzO1xuIiwiXG5cbmV4cG9ydCBjb25zdCBzdHJlYW1DaHVuayA9IGZ1bmN0aW9uKiAoY2h1bmssIGNodW5rU2l6ZSkge1xuICBsZXQgbGVuID0gY2h1bmsuYnl0ZUxlbmd0aDtcblxuICBpZiAoIWNodW5rU2l6ZSB8fCBsZW4gPCBjaHVua1NpemUpIHtcbiAgICB5aWVsZCBjaHVuaztcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgcG9zID0gMDtcbiAgbGV0IGVuZDtcblxuICB3aGlsZSAocG9zIDwgbGVuKSB7XG4gICAgZW5kID0gcG9zICsgY2h1bmtTaXplO1xuICAgIHlpZWxkIGNodW5rLnNsaWNlKHBvcywgZW5kKTtcbiAgICBwb3MgPSBlbmQ7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHJlYWRCeXRlcyA9IGFzeW5jIGZ1bmN0aW9uKiAoaXRlcmFibGUsIGNodW5rU2l6ZSwgZW5jb2RlKSB7XG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgaXRlcmFibGUpIHtcbiAgICB5aWVsZCogc3RyZWFtQ2h1bmsoQXJyYXlCdWZmZXIuaXNWaWV3KGNodW5rKSA/IGNodW5rIDogKGF3YWl0IGVuY29kZShTdHJpbmcoY2h1bmspKSksIGNodW5rU2l6ZSk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHRyYWNrU3RyZWFtID0gKHN0cmVhbSwgY2h1bmtTaXplLCBvblByb2dyZXNzLCBvbkZpbmlzaCwgZW5jb2RlKSA9PiB7XG4gIGNvbnN0IGl0ZXJhdG9yID0gcmVhZEJ5dGVzKHN0cmVhbSwgY2h1bmtTaXplLCBlbmNvZGUpO1xuXG4gIGxldCBieXRlcyA9IDA7XG5cbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgdHlwZTogJ2J5dGVzJyxcblxuICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgY29uc3Qge2RvbmUsIHZhbHVlfSA9IGF3YWl0IGl0ZXJhdG9yLm5leHQoKTtcblxuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICBvbkZpbmlzaCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBsZW4gPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuICAgICAgb25Qcm9ncmVzcyAmJiBvblByb2dyZXNzKGJ5dGVzICs9IGxlbik7XG4gICAgICBjb250cm9sbGVyLmVucXVldWUobmV3IFVpbnQ4QXJyYXkodmFsdWUpKTtcbiAgICB9LFxuICAgIGNhbmNlbChyZWFzb24pIHtcbiAgICAgIG9uRmluaXNoKHJlYXNvbik7XG4gICAgICByZXR1cm4gaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgfVxuICB9LCB7XG4gICAgaGlnaFdhdGVyTWFyazogMlxuICB9KVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQge1ZFUlNJT059IGZyb20gJy4uL2Vudi9kYXRhLmpzJztcbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gJy4uL2NvcmUvQXhpb3NFcnJvci5qcyc7XG5cbmNvbnN0IHZhbGlkYXRvcnMgPSB7fTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblsnb2JqZWN0JywgJ2Jvb2xlYW4nLCAnbnVtYmVyJywgJ2Z1bmN0aW9uJywgJ3N0cmluZycsICdzeW1ib2wnXS5mb3JFYWNoKCh0eXBlLCBpKSA9PiB7XG4gIHZhbGlkYXRvcnNbdHlwZV0gPSBmdW5jdGlvbiB2YWxpZGF0b3IodGhpbmcpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaW5nID09PSB0eXBlIHx8ICdhJyArIChpIDwgMSA/ICduICcgOiAnICcpICsgdHlwZTtcbiAgfTtcbn0pO1xuXG5jb25zdCBkZXByZWNhdGVkV2FybmluZ3MgPSB7fTtcblxuLyoqXG4gKiBUcmFuc2l0aW9uYWwgb3B0aW9uIHZhbGlkYXRvclxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb258Ym9vbGVhbj99IHZhbGlkYXRvciAtIHNldCB0byBmYWxzZSBpZiB0aGUgdHJhbnNpdGlvbmFsIG9wdGlvbiBoYXMgYmVlbiByZW1vdmVkXG4gKiBAcGFyYW0ge3N0cmluZz99IHZlcnNpb24gLSBkZXByZWNhdGVkIHZlcnNpb24gLyByZW1vdmVkIHNpbmNlIHZlcnNpb25cbiAqIEBwYXJhbSB7c3RyaW5nP30gbWVzc2FnZSAtIHNvbWUgbWVzc2FnZSB3aXRoIGFkZGl0aW9uYWwgaW5mb1xuICpcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn1cbiAqL1xudmFsaWRhdG9ycy50cmFuc2l0aW9uYWwgPSBmdW5jdGlvbiB0cmFuc2l0aW9uYWwodmFsaWRhdG9yLCB2ZXJzaW9uLCBtZXNzYWdlKSB7XG4gIGZ1bmN0aW9uIGZvcm1hdE1lc3NhZ2Uob3B0LCBkZXNjKSB7XG4gICAgcmV0dXJuICdbQXhpb3MgdicgKyBWRVJTSU9OICsgJ10gVHJhbnNpdGlvbmFsIG9wdGlvbiBcXCcnICsgb3B0ICsgJ1xcJycgKyBkZXNjICsgKG1lc3NhZ2UgPyAnLiAnICsgbWVzc2FnZSA6ICcnKTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gIHJldHVybiAodmFsdWUsIG9wdCwgb3B0cykgPT4ge1xuICAgIGlmICh2YWxpZGF0b3IgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcihcbiAgICAgICAgZm9ybWF0TWVzc2FnZShvcHQsICcgaGFzIGJlZW4gcmVtb3ZlZCcgKyAodmVyc2lvbiA/ICcgaW4gJyArIHZlcnNpb24gOiAnJykpLFxuICAgICAgICBBeGlvc0Vycm9yLkVSUl9ERVBSRUNBVEVEXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh2ZXJzaW9uICYmICFkZXByZWNhdGVkV2FybmluZ3Nbb3B0XSkge1xuICAgICAgZGVwcmVjYXRlZFdhcm5pbmdzW29wdF0gPSB0cnVlO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgZm9ybWF0TWVzc2FnZShcbiAgICAgICAgICBvcHQsXG4gICAgICAgICAgJyBoYXMgYmVlbiBkZXByZWNhdGVkIHNpbmNlIHYnICsgdmVyc2lvbiArICcgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmVhciBmdXR1cmUnXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbGlkYXRvciA/IHZhbGlkYXRvcih2YWx1ZSwgb3B0LCBvcHRzKSA6IHRydWU7XG4gIH07XG59O1xuXG4vKipcbiAqIEFzc2VydCBvYmplY3QncyBwcm9wZXJ0aWVzIHR5cGVcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtvYmplY3R9IHNjaGVtYVxuICogQHBhcmFtIHtib29sZWFuP30gYWxsb3dVbmtub3duXG4gKlxuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBhc3NlcnRPcHRpb25zKG9wdGlvbnMsIHNjaGVtYSwgYWxsb3dVbmtub3duKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcignb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcsIEF4aW9zRXJyb3IuRVJSX0JBRF9PUFRJT05fVkFMVUUpO1xuICB9XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgbGV0IGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSA+IDApIHtcbiAgICBjb25zdCBvcHQgPSBrZXlzW2ldO1xuICAgIGNvbnN0IHZhbGlkYXRvciA9IHNjaGVtYVtvcHRdO1xuICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb3B0aW9uc1tvcHRdO1xuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWxpZGF0b3IodmFsdWUsIG9wdCwgb3B0aW9ucyk7XG4gICAgICBpZiAocmVzdWx0ICE9PSB0cnVlKSB7XG4gICAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKCdvcHRpb24gJyArIG9wdCArICcgbXVzdCBiZSAnICsgcmVzdWx0LCBBeGlvc0Vycm9yLkVSUl9CQURfT1BUSU9OX1ZBTFVFKTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoYWxsb3dVbmtub3duICE9PSB0cnVlKSB7XG4gICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcignVW5rbm93biBvcHRpb24gJyArIG9wdCwgQXhpb3NFcnJvci5FUlJfQkFEX09QVElPTik7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgYXNzZXJ0T3B0aW9ucyxcbiAgdmFsaWRhdG9yc1xufTtcbiIsImV4cG9ydCBjb25zdCBWRVJTSU9OID0gXCIxLjcuMlwiOyIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IENhbmNlbGVkRXJyb3IgZnJvbSAnLi9DYW5jZWxlZEVycm9yLmpzJztcblxuLyoqXG4gKiBBIGBDYW5jZWxUb2tlbmAgaXMgYW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVxdWVzdCBjYW5jZWxsYXRpb24gb2YgYW4gb3BlcmF0aW9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGV4ZWN1dG9yIFRoZSBleGVjdXRvciBmdW5jdGlvbi5cbiAqXG4gKiBAcmV0dXJucyB7Q2FuY2VsVG9rZW59XG4gKi9cbmNsYXNzIENhbmNlbFRva2VuIHtcbiAgY29uc3RydWN0b3IoZXhlY3V0b3IpIHtcbiAgICBpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgbGV0IHJlc29sdmVQcm9taXNlO1xuXG4gICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gcHJvbWlzZUV4ZWN1dG9yKHJlc29sdmUpIHtcbiAgICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHRva2VuID0gdGhpcztcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gICAgdGhpcy5wcm9taXNlLnRoZW4oY2FuY2VsID0+IHtcbiAgICAgIGlmICghdG9rZW4uX2xpc3RlbmVycykgcmV0dXJuO1xuXG4gICAgICBsZXQgaSA9IHRva2VuLl9saXN0ZW5lcnMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgICB0b2tlbi5fbGlzdGVuZXJzW2ldKGNhbmNlbCk7XG4gICAgICB9XG4gICAgICB0b2tlbi5fbGlzdGVuZXJzID0gbnVsbDtcbiAgICB9KTtcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gICAgdGhpcy5wcm9taXNlLnRoZW4gPSBvbmZ1bGZpbGxlZCA9PiB7XG4gICAgICBsZXQgX3Jlc29sdmU7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICB0b2tlbi5zdWJzY3JpYmUocmVzb2x2ZSk7XG4gICAgICAgIF9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIH0pLnRoZW4ob25mdWxmaWxsZWQpO1xuXG4gICAgICBwcm9taXNlLmNhbmNlbCA9IGZ1bmN0aW9uIHJlamVjdCgpIHtcbiAgICAgICAgdG9rZW4udW5zdWJzY3JpYmUoX3Jlc29sdmUpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcblxuICAgIGV4ZWN1dG9yKGZ1bmN0aW9uIGNhbmNlbChtZXNzYWdlLCBjb25maWcsIHJlcXVlc3QpIHtcbiAgICAgIGlmICh0b2tlbi5yZWFzb24pIHtcbiAgICAgICAgLy8gQ2FuY2VsbGF0aW9uIGhhcyBhbHJlYWR5IGJlZW4gcmVxdWVzdGVkXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdG9rZW4ucmVhc29uID0gbmV3IENhbmNlbGVkRXJyb3IobWVzc2FnZSwgY29uZmlnLCByZXF1ZXN0KTtcbiAgICAgIHJlc29sdmVQcm9taXNlKHRva2VuLnJlYXNvbik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVGhyb3dzIGEgYENhbmNlbGVkRXJyb3JgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gICAqL1xuICB0aHJvd0lmUmVxdWVzdGVkKCkge1xuICAgIGlmICh0aGlzLnJlYXNvbikge1xuICAgICAgdGhyb3cgdGhpcy5yZWFzb247XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN1YnNjcmliZSB0byB0aGUgY2FuY2VsIHNpZ25hbFxuICAgKi9cblxuICBzdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICAgIGxpc3RlbmVyKHRoaXMucmVhc29uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGlzdGVuZXJzKSB7XG4gICAgICB0aGlzLl9saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2xpc3RlbmVycyA9IFtsaXN0ZW5lcl07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVuc3Vic2NyaWJlIGZyb20gdGhlIGNhbmNlbCBzaWduYWxcbiAgICovXG5cbiAgdW5zdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgICBpZiAoIXRoaXMuX2xpc3RlbmVycykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX2xpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLl9saXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBjb250YWlucyBhIG5ldyBgQ2FuY2VsVG9rZW5gIGFuZCBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLFxuICAgKiBjYW5jZWxzIHRoZSBgQ2FuY2VsVG9rZW5gLlxuICAgKi9cbiAgc3RhdGljIHNvdXJjZSgpIHtcbiAgICBsZXQgY2FuY2VsO1xuICAgIGNvbnN0IHRva2VuID0gbmV3IENhbmNlbFRva2VuKGZ1bmN0aW9uIGV4ZWN1dG9yKGMpIHtcbiAgICAgIGNhbmNlbCA9IGM7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VuLFxuICAgICAgY2FuY2VsXG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDYW5jZWxUb2tlbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTeW50YWN0aWMgc3VnYXIgZm9yIGludm9raW5nIGEgZnVuY3Rpb24gYW5kIGV4cGFuZGluZyBhbiBhcnJheSBmb3IgYXJndW1lbnRzLlxuICpcbiAqIENvbW1vbiB1c2UgY2FzZSB3b3VsZCBiZSB0byB1c2UgYEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseWAuXG4gKlxuICogIGBgYGpzXG4gKiAgZnVuY3Rpb24gZih4LCB5LCB6KSB7fVxuICogIHZhciBhcmdzID0gWzEsIDIsIDNdO1xuICogIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gKiAgYGBgXG4gKlxuICogV2l0aCBgc3ByZWFkYCB0aGlzIGV4YW1wbGUgY2FuIGJlIHJlLXdyaXR0ZW4uXG4gKlxuICogIGBgYGpzXG4gKiAgc3ByZWFkKGZ1bmN0aW9uKHgsIHksIHopIHt9KShbMSwgMiwgM10pO1xuICogIGBgYFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzcHJlYWQoY2FsbGJhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoYXJyKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFycik7XG4gIH07XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLy4uL3V0aWxzLmpzJztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHBheWxvYWQgaXMgYW4gZXJyb3IgdGhyb3duIGJ5IEF4aW9zXG4gKlxuICogQHBhcmFtIHsqfSBwYXlsb2FkIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHBheWxvYWQgaXMgYW4gZXJyb3IgdGhyb3duIGJ5IEF4aW9zLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNBeGlvc0Vycm9yKHBheWxvYWQpIHtcbiAgcmV0dXJuIHV0aWxzLmlzT2JqZWN0KHBheWxvYWQpICYmIChwYXlsb2FkLmlzQXhpb3NFcnJvciA9PT0gdHJ1ZSk7XG59XG4iLCJjb25zdCBIdHRwU3RhdHVzQ29kZSA9IHtcbiAgQ29udGludWU6IDEwMCxcbiAgU3dpdGNoaW5nUHJvdG9jb2xzOiAxMDEsXG4gIFByb2Nlc3Npbmc6IDEwMixcbiAgRWFybHlIaW50czogMTAzLFxuICBPazogMjAwLFxuICBDcmVhdGVkOiAyMDEsXG4gIEFjY2VwdGVkOiAyMDIsXG4gIE5vbkF1dGhvcml0YXRpdmVJbmZvcm1hdGlvbjogMjAzLFxuICBOb0NvbnRlbnQ6IDIwNCxcbiAgUmVzZXRDb250ZW50OiAyMDUsXG4gIFBhcnRpYWxDb250ZW50OiAyMDYsXG4gIE11bHRpU3RhdHVzOiAyMDcsXG4gIEFscmVhZHlSZXBvcnRlZDogMjA4LFxuICBJbVVzZWQ6IDIyNixcbiAgTXVsdGlwbGVDaG9pY2VzOiAzMDAsXG4gIE1vdmVkUGVybWFuZW50bHk6IDMwMSxcbiAgRm91bmQ6IDMwMixcbiAgU2VlT3RoZXI6IDMwMyxcbiAgTm90TW9kaWZpZWQ6IDMwNCxcbiAgVXNlUHJveHk6IDMwNSxcbiAgVW51c2VkOiAzMDYsXG4gIFRlbXBvcmFyeVJlZGlyZWN0OiAzMDcsXG4gIFBlcm1hbmVudFJlZGlyZWN0OiAzMDgsXG4gIEJhZFJlcXVlc3Q6IDQwMCxcbiAgVW5hdXRob3JpemVkOiA0MDEsXG4gIFBheW1lbnRSZXF1aXJlZDogNDAyLFxuICBGb3JiaWRkZW46IDQwMyxcbiAgTm90Rm91bmQ6IDQwNCxcbiAgTWV0aG9kTm90QWxsb3dlZDogNDA1LFxuICBOb3RBY2NlcHRhYmxlOiA0MDYsXG4gIFByb3h5QXV0aGVudGljYXRpb25SZXF1aXJlZDogNDA3LFxuICBSZXF1ZXN0VGltZW91dDogNDA4LFxuICBDb25mbGljdDogNDA5LFxuICBHb25lOiA0MTAsXG4gIExlbmd0aFJlcXVpcmVkOiA0MTEsXG4gIFByZWNvbmRpdGlvbkZhaWxlZDogNDEyLFxuICBQYXlsb2FkVG9vTGFyZ2U6IDQxMyxcbiAgVXJpVG9vTG9uZzogNDE0LFxuICBVbnN1cHBvcnRlZE1lZGlhVHlwZTogNDE1LFxuICBSYW5nZU5vdFNhdGlzZmlhYmxlOiA0MTYsXG4gIEV4cGVjdGF0aW9uRmFpbGVkOiA0MTcsXG4gIEltQVRlYXBvdDogNDE4LFxuICBNaXNkaXJlY3RlZFJlcXVlc3Q6IDQyMSxcbiAgVW5wcm9jZXNzYWJsZUVudGl0eTogNDIyLFxuICBMb2NrZWQ6IDQyMyxcbiAgRmFpbGVkRGVwZW5kZW5jeTogNDI0LFxuICBUb29FYXJseTogNDI1LFxuICBVcGdyYWRlUmVxdWlyZWQ6IDQyNixcbiAgUHJlY29uZGl0aW9uUmVxdWlyZWQ6IDQyOCxcbiAgVG9vTWFueVJlcXVlc3RzOiA0MjksXG4gIFJlcXVlc3RIZWFkZXJGaWVsZHNUb29MYXJnZTogNDMxLFxuICBVbmF2YWlsYWJsZUZvckxlZ2FsUmVhc29uczogNDUxLFxuICBJbnRlcm5hbFNlcnZlckVycm9yOiA1MDAsXG4gIE5vdEltcGxlbWVudGVkOiA1MDEsXG4gIEJhZEdhdGV3YXk6IDUwMixcbiAgU2VydmljZVVuYXZhaWxhYmxlOiA1MDMsXG4gIEdhdGV3YXlUaW1lb3V0OiA1MDQsXG4gIEh0dHBWZXJzaW9uTm90U3VwcG9ydGVkOiA1MDUsXG4gIFZhcmlhbnRBbHNvTmVnb3RpYXRlczogNTA2LFxuICBJbnN1ZmZpY2llbnRTdG9yYWdlOiA1MDcsXG4gIExvb3BEZXRlY3RlZDogNTA4LFxuICBOb3RFeHRlbmRlZDogNTEwLFxuICBOZXR3b3JrQXV0aGVudGljYXRpb25SZXF1aXJlZDogNTExLFxufTtcblxuT2JqZWN0LmVudHJpZXMoSHR0cFN0YXR1c0NvZGUpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICBIdHRwU3RhdHVzQ29kZVt2YWx1ZV0gPSBrZXk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgSHR0cFN0YXR1c0NvZGU7XG4iLCJpbXBvcnQgdHlwZSB7IEF4aW9zUmVxdWVzdENvbmZpZyB9IGZyb20gXCJheGlvc1wiXG5cbmltcG9ydCB7IEFMQVJNUywgTFNfS0VZUyB9IGZyb20gXCJ+bGliL2NvbnN0YW50c1wiXG5pbXBvcnQgeyBzdXBhYmFzZSB9IGZyb20gXCJ+bGliL3N1cGFiYXNlXCJcbmltcG9ydCB7IGxvY2FsU3RvcmFnZSB9IGZyb20gXCJ+bGliL3V0aWxzXCJcblxuZXhwb3J0IGNvbnN0IGdldEFjY2Vzc1Rva2VuID0gYXN5bmMgKCk6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiA9PiB7XG4gIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRTZXNzaW9uKClcbiAgaWYgKGRhdGEuc2Vzc2lvbikgcmV0dXJuIGRhdGEuc2Vzc2lvbi5hY2Nlc3NfdG9rZW5cbiAgcmV0dXJuIHVuZGVmaW5lZFxufVxuXG5leHBvcnQgY29uc3QgZ2V0QXV0aEhlYWRlcnMgPSBhc3luYyAoKTogUHJvbWlzZTxBeGlvc1JlcXVlc3RDb25maWc+ID0+IHtcbiAgY29uc3QgdG9rZW4gPSBhd2FpdCBnZXRBY2Nlc3NUb2tlbigpXG4gIGlmICghdG9rZW4pIHtcbiAgICBjaHJvbWUucnVudGltZS5vcGVuT3B0aW9uc1BhZ2UoKVxuICAgIHRocm93IFwiVXNlciBub3QgYXV0aGVudGljYXRlZFwiXG4gIH1cbiAgY29uc3QgY29uZmlnOiBBeGlvc1JlcXVlc3RDb25maWcgPSB7XG4gICAgaGVhZGVyczoge1xuICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbmZpZ1xufVxuXG5leHBvcnQgY29uc3QgdXBkYXRlQXV0aCA9IGFzeW5jICgpID0+IHtcbiAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFNlc3Npb24oKVxuICBjb25zdCB1c2VyID0gZGF0YS5zZXNzaW9uPy51c2VyID8/IG51bGxcbiAgY29uc29sZS5sb2coXCJVcGRhdGluZyB1c2VyIGRhdGE6IFwiLCB1c2VyKVxuICBhd2FpdCBsb2NhbFN0b3JhZ2UoKS5zZXQoTFNfS0VZUy5VU0VSX0RBVEEsIHVzZXIpXG59XG4iLCJpbXBvcnQgeyBjcmVhdGVDbGllbnQsIHR5cGUgU3VwcG9ydGVkU3RvcmFnZSB9IGZyb20gXCJAc3VwYWJhc2Uvc3VwYWJhc2UtanNcIlxuXG5pbXBvcnQgeyBTdG9yYWdlIH0gZnJvbSBcIkBwbGFzbW9ocS9zdG9yYWdlXCJcblxuaW1wb3J0IHsgbG9jYWxTdG9yYWdlIH0gZnJvbSBcIi4vdXRpbHNcIlxuXG5jbGFzcyBTdG9yYWdlV3JhcHBlciBpbXBsZW1lbnRzIFN1cHBvcnRlZFN0b3JhZ2Uge1xuICBwcml2YXRlIHN0b3JhZ2U6IFN0b3JhZ2VcblxuICBjb25zdHJ1Y3RvcihzdG9yYWdlOiBTdG9yYWdlKSB7XG4gICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZVxuICB9XG5cbiAgYXN5bmMgZ2V0SXRlbShrZXk6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc3RvcmFnZS5nZXRJdGVtKGtleSlcbiAgICByZXR1cm4gcmVzdWx0ICE9PSB1bmRlZmluZWQgPyByZXN1bHQgOiBudWxsXG4gIH1cblxuICBzZXRJdGVtKGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKTogdm9pZCB8IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLnN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKVxuICB9XG5cbiAgcmVtb3ZlSXRlbShrZXk6IHN0cmluZyk6IHZvaWQgfCBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzdXBhYmFzZSA9IGNyZWF0ZUNsaWVudChcbiAgcHJvY2Vzcy5lbnYuUExBU01PX1BVQkxJQ19TVVBBQkFTRV9VUkwgYXMgc3RyaW5nLFxuICBwcm9jZXNzLmVudi5QTEFTTU9fUFVCTElDX1NVUEFCQVNFX0tFWSBhcyBzdHJpbmcsXG4gIHtcbiAgICBhdXRoOiB7XG4gICAgICBzdG9yYWdlOiBuZXcgU3RvcmFnZVdyYXBwZXIobG9jYWxTdG9yYWdlKCkpLFxuICAgICAgYXV0b1JlZnJlc2hUb2tlbjogdHJ1ZSxcbiAgICAgIHBlcnNpc3RTZXNzaW9uOiB0cnVlLFxuICAgICAgZGV0ZWN0U2Vzc2lvbkluVXJsOiB0cnVlXG4gICAgfVxuICB9XG4pIiwiaW1wb3J0IFN1cGFiYXNlQ2xpZW50IGZyb20gJy4vU3VwYWJhc2VDbGllbnQnO1xuZXhwb3J0ICogZnJvbSAnQHN1cGFiYXNlL2F1dGgtanMnO1xuZXhwb3J0IHsgRnVuY3Rpb25zSHR0cEVycm9yLCBGdW5jdGlvbnNGZXRjaEVycm9yLCBGdW5jdGlvbnNSZWxheUVycm9yLCBGdW5jdGlvbnNFcnJvciwgRnVuY3Rpb25SZWdpb24sIH0gZnJvbSAnQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcyc7XG5leHBvcnQgKiBmcm9tICdAc3VwYWJhc2UvcmVhbHRpbWUtanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTdXBhYmFzZUNsaWVudCB9IGZyb20gJy4vU3VwYWJhc2VDbGllbnQnO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFN1cGFiYXNlIENsaWVudC5cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUNsaWVudCA9IChzdXBhYmFzZVVybCwgc3VwYWJhc2VLZXksIG9wdGlvbnMpID0+IHtcbiAgICByZXR1cm4gbmV3IFN1cGFiYXNlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUtleSwgb3B0aW9ucyk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0IFN1cGFiYXNlQ2xpZW50IGZyb20gJy4vU3VwYWJhc2VDbGllbnQnXG5pbXBvcnQgdHlwZSB7IEdlbmVyaWNTY2hlbWEsIFN1cGFiYXNlQ2xpZW50T3B0aW9ucyB9IGZyb20gJy4vbGliL3R5cGVzJ1xuXG5leHBvcnQgKiBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcydcbmV4cG9ydCB0eXBlIHsgVXNlciBhcyBBdXRoVXNlciwgU2Vzc2lvbiBhcyBBdXRoU2Vzc2lvbiB9IGZyb20gJ0BzdXBhYmFzZS9hdXRoLWpzJ1xuZXhwb3J0IHR5cGUge1xuICBQb3N0Z3Jlc3RSZXNwb25zZSxcbiAgUG9zdGdyZXN0U2luZ2xlUmVzcG9uc2UsXG4gIFBvc3RncmVzdE1heWJlU2luZ2xlUmVzcG9uc2UsXG4gIFBvc3RncmVzdEVycm9yLFxufSBmcm9tICdAc3VwYWJhc2UvcG9zdGdyZXN0LWpzJ1xuZXhwb3J0IHtcbiAgRnVuY3Rpb25zSHR0cEVycm9yLFxuICBGdW5jdGlvbnNGZXRjaEVycm9yLFxuICBGdW5jdGlvbnNSZWxheUVycm9yLFxuICBGdW5jdGlvbnNFcnJvcixcbiAgdHlwZSBGdW5jdGlvbkludm9rZU9wdGlvbnMsXG4gIEZ1bmN0aW9uUmVnaW9uLFxufSBmcm9tICdAc3VwYWJhc2UvZnVuY3Rpb25zLWpzJ1xuZXhwb3J0ICogZnJvbSAnQHN1cGFiYXNlL3JlYWx0aW1lLWpzJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTdXBhYmFzZUNsaWVudCB9IGZyb20gJy4vU3VwYWJhc2VDbGllbnQnXG5leHBvcnQgdHlwZSB7IFN1cGFiYXNlQ2xpZW50T3B0aW9ucywgUXVlcnlSZXN1bHQsIFF1ZXJ5RGF0YSwgUXVlcnlFcnJvciB9IGZyb20gJy4vbGliL3R5cGVzJ1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgU3VwYWJhc2UgQ2xpZW50LlxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlQ2xpZW50ID0gPFxuICBEYXRhYmFzZSA9IGFueSxcbiAgU2NoZW1hTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIERhdGFiYXNlID0gJ3B1YmxpYycgZXh0ZW5kcyBrZXlvZiBEYXRhYmFzZVxuICAgID8gJ3B1YmxpYydcbiAgICA6IHN0cmluZyAmIGtleW9mIERhdGFiYXNlLFxuICBTY2hlbWEgZXh0ZW5kcyBHZW5lcmljU2NoZW1hID0gRGF0YWJhc2VbU2NoZW1hTmFtZV0gZXh0ZW5kcyBHZW5lcmljU2NoZW1hXG4gICAgPyBEYXRhYmFzZVtTY2hlbWFOYW1lXVxuICAgIDogYW55XG4+KFxuICBzdXBhYmFzZVVybDogc3RyaW5nLFxuICBzdXBhYmFzZUtleTogc3RyaW5nLFxuICBvcHRpb25zPzogU3VwYWJhc2VDbGllbnRPcHRpb25zPFNjaGVtYU5hbWU+XG4pOiBTdXBhYmFzZUNsaWVudDxEYXRhYmFzZSwgU2NoZW1hTmFtZSwgU2NoZW1hPiA9PiB7XG4gIHJldHVybiBuZXcgU3VwYWJhc2VDbGllbnQ8RGF0YWJhc2UsIFNjaGVtYU5hbWUsIFNjaGVtYT4oc3VwYWJhc2VVcmwsIHN1cGFiYXNlS2V5LCBvcHRpb25zKVxufVxuIiwidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBGdW5jdGlvbnNDbGllbnQgfSBmcm9tICdAc3VwYWJhc2UvZnVuY3Rpb25zLWpzJztcbmltcG9ydCB7IFBvc3RncmVzdENsaWVudCwgfSBmcm9tICdAc3VwYWJhc2UvcG9zdGdyZXN0LWpzJztcbmltcG9ydCB7IFJlYWx0aW1lQ2xpZW50LCB9IGZyb20gJ0BzdXBhYmFzZS9yZWFsdGltZS1qcyc7XG5pbXBvcnQgeyBTdG9yYWdlQ2xpZW50IGFzIFN1cGFiYXNlU3RvcmFnZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9zdG9yYWdlLWpzJztcbmltcG9ydCB7IERFRkFVTFRfR0xPQkFMX09QVElPTlMsIERFRkFVTFRfREJfT1BUSU9OUywgREVGQVVMVF9BVVRIX09QVElPTlMsIERFRkFVTFRfUkVBTFRJTUVfT1BUSU9OUywgfSBmcm9tICcuL2xpYi9jb25zdGFudHMnO1xuaW1wb3J0IHsgZmV0Y2hXaXRoQXV0aCB9IGZyb20gJy4vbGliL2ZldGNoJztcbmltcG9ydCB7IHN0cmlwVHJhaWxpbmdTbGFzaCwgYXBwbHlTZXR0aW5nRGVmYXVsdHMgfSBmcm9tICcuL2xpYi9oZWxwZXJzJztcbmltcG9ydCB7IFN1cGFiYXNlQXV0aENsaWVudCB9IGZyb20gJy4vbGliL1N1cGFiYXNlQXV0aENsaWVudCc7XG4vKipcbiAqIFN1cGFiYXNlIENsaWVudC5cbiAqXG4gKiBBbiBpc29tb3JwaGljIEphdmFzY3JpcHQgY2xpZW50IGZvciBpbnRlcmFjdGluZyB3aXRoIFBvc3RncmVzLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdXBhYmFzZUNsaWVudCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGNsaWVudCBmb3IgdXNlIGluIHRoZSBicm93c2VyLlxuICAgICAqIEBwYXJhbSBzdXBhYmFzZVVybCBUaGUgdW5pcXVlIFN1cGFiYXNlIFVSTCB3aGljaCBpcyBzdXBwbGllZCB3aGVuIHlvdSBjcmVhdGUgYSBuZXcgcHJvamVjdCBpbiB5b3VyIHByb2plY3QgZGFzaGJvYXJkLlxuICAgICAqIEBwYXJhbSBzdXBhYmFzZUtleSBUaGUgdW5pcXVlIFN1cGFiYXNlIEtleSB3aGljaCBpcyBzdXBwbGllZCB3aGVuIHlvdSBjcmVhdGUgYSBuZXcgcHJvamVjdCBpbiB5b3VyIHByb2plY3QgZGFzaGJvYXJkLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmRiLnNjaGVtYSBZb3UgY2FuIHN3aXRjaCBpbiBiZXR3ZWVuIHNjaGVtYXMuIFRoZSBzY2hlbWEgbmVlZHMgdG8gYmUgb24gdGhlIGxpc3Qgb2YgZXhwb3NlZCBzY2hlbWFzIGluc2lkZSBTdXBhYmFzZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hdXRoLmF1dG9SZWZyZXNoVG9rZW4gU2V0IHRvIFwidHJ1ZVwiIGlmIHlvdSB3YW50IHRvIGF1dG9tYXRpY2FsbHkgcmVmcmVzaCB0aGUgdG9rZW4gYmVmb3JlIGV4cGlyaW5nLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmF1dGgucGVyc2lzdFNlc3Npb24gU2V0IHRvIFwidHJ1ZVwiIGlmIHlvdSB3YW50IHRvIGF1dG9tYXRpY2FsbHkgc2F2ZSB0aGUgdXNlciBzZXNzaW9uIGludG8gbG9jYWwgc3RvcmFnZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hdXRoLmRldGVjdFNlc3Npb25JblVybCBTZXQgdG8gXCJ0cnVlXCIgaWYgeW91IHdhbnQgdG8gYXV0b21hdGljYWxseSBkZXRlY3RzIE9BdXRoIGdyYW50cyBpbiB0aGUgVVJMIGFuZCBzaWducyBpbiB0aGUgdXNlci5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5yZWFsdGltZSBPcHRpb25zIHBhc3NlZCBhbG9uZyB0byByZWFsdGltZS1qcyBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5nbG9iYWwuZmV0Y2ggQSBjdXN0b20gZmV0Y2ggaW1wbGVtZW50YXRpb24uXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZ2xvYmFsLmhlYWRlcnMgQW55IGFkZGl0aW9uYWwgaGVhZGVycyB0byBzZW5kIHdpdGggZWFjaCBuZXR3b3JrIHJlcXVlc3QuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc3VwYWJhc2VVcmwsIHN1cGFiYXNlS2V5LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICB0aGlzLnN1cGFiYXNlVXJsID0gc3VwYWJhc2VVcmw7XG4gICAgICAgIHRoaXMuc3VwYWJhc2VLZXkgPSBzdXBhYmFzZUtleTtcbiAgICAgICAgaWYgKCFzdXBhYmFzZVVybClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3VwYWJhc2VVcmwgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgIGlmICghc3VwYWJhc2VLZXkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N1cGFiYXNlS2V5IGlzIHJlcXVpcmVkLicpO1xuICAgICAgICBjb25zdCBfc3VwYWJhc2VVcmwgPSBzdHJpcFRyYWlsaW5nU2xhc2goc3VwYWJhc2VVcmwpO1xuICAgICAgICB0aGlzLnJlYWx0aW1lVXJsID0gYCR7X3N1cGFiYXNlVXJsfS9yZWFsdGltZS92MWAucmVwbGFjZSgvXmh0dHAvaSwgJ3dzJyk7XG4gICAgICAgIHRoaXMuYXV0aFVybCA9IGAke19zdXBhYmFzZVVybH0vYXV0aC92MWA7XG4gICAgICAgIHRoaXMuc3RvcmFnZVVybCA9IGAke19zdXBhYmFzZVVybH0vc3RvcmFnZS92MWA7XG4gICAgICAgIHRoaXMuZnVuY3Rpb25zVXJsID0gYCR7X3N1cGFiYXNlVXJsfS9mdW5jdGlvbnMvdjFgO1xuICAgICAgICAvLyBkZWZhdWx0IHN0b3JhZ2Uga2V5IHVzZXMgdGhlIHN1cGFiYXNlIHByb2plY3QgcmVmIGFzIGEgbmFtZXNwYWNlXG4gICAgICAgIGNvbnN0IGRlZmF1bHRTdG9yYWdlS2V5ID0gYHNiLSR7bmV3IFVSTCh0aGlzLmF1dGhVcmwpLmhvc3RuYW1lLnNwbGl0KCcuJylbMF19LWF1dGgtdG9rZW5gO1xuICAgICAgICBjb25zdCBERUZBVUxUUyA9IHtcbiAgICAgICAgICAgIGRiOiBERUZBVUxUX0RCX09QVElPTlMsXG4gICAgICAgICAgICByZWFsdGltZTogREVGQVVMVF9SRUFMVElNRV9PUFRJT05TLFxuICAgICAgICAgICAgYXV0aDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX0FVVEhfT1BUSU9OUyksIHsgc3RvcmFnZUtleTogZGVmYXVsdFN0b3JhZ2VLZXkgfSksXG4gICAgICAgICAgICBnbG9iYWw6IERFRkFVTFRfR0xPQkFMX09QVElPTlMsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gYXBwbHlTZXR0aW5nRGVmYXVsdHMob3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge30sIERFRkFVTFRTKTtcbiAgICAgICAgdGhpcy5zdG9yYWdlS2V5ID0gKF9hID0gc2V0dGluZ3MuYXV0aC5zdG9yYWdlS2V5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJztcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gKF9iID0gc2V0dGluZ3MuZ2xvYmFsLmhlYWRlcnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHt9O1xuICAgICAgICB0aGlzLmF1dGggPSB0aGlzLl9pbml0U3VwYWJhc2VBdXRoQ2xpZW50KChfYyA9IHNldHRpbmdzLmF1dGgpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHt9LCB0aGlzLmhlYWRlcnMsIHNldHRpbmdzLmdsb2JhbC5mZXRjaCk7XG4gICAgICAgIHRoaXMuZmV0Y2ggPSBmZXRjaFdpdGhBdXRoKHN1cGFiYXNlS2V5LCB0aGlzLl9nZXRBY2Nlc3NUb2tlbi5iaW5kKHRoaXMpLCBzZXR0aW5ncy5nbG9iYWwuZmV0Y2gpO1xuICAgICAgICB0aGlzLnJlYWx0aW1lID0gdGhpcy5faW5pdFJlYWx0aW1lQ2xpZW50KE9iamVjdC5hc3NpZ24oeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSwgc2V0dGluZ3MucmVhbHRpbWUpKTtcbiAgICAgICAgdGhpcy5yZXN0ID0gbmV3IFBvc3RncmVzdENsaWVudChgJHtfc3VwYWJhc2VVcmx9L3Jlc3QvdjFgLCB7XG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzY2hlbWE6IHNldHRpbmdzLmRiLnNjaGVtYSxcbiAgICAgICAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fbGlzdGVuRm9yQXV0aEV2ZW50cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdXBhYmFzZSBGdW5jdGlvbnMgYWxsb3dzIHlvdSB0byBkZXBsb3kgYW5kIGludm9rZSBlZGdlIGZ1bmN0aW9ucy5cbiAgICAgKi9cbiAgICBnZXQgZnVuY3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uc0NsaWVudCh0aGlzLmZ1bmN0aW9uc1VybCwge1xuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgY3VzdG9tRmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdXBhYmFzZSBTdG9yYWdlIGFsbG93cyB5b3UgdG8gbWFuYWdlIHVzZXItZ2VuZXJhdGVkIGNvbnRlbnQsIHN1Y2ggYXMgcGhvdG9zIG9yIHZpZGVvcy5cbiAgICAgKi9cbiAgICBnZXQgc3RvcmFnZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdXBhYmFzZVN0b3JhZ2VDbGllbnQodGhpcy5zdG9yYWdlVXJsLCB0aGlzLmhlYWRlcnMsIHRoaXMuZmV0Y2gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGEgcXVlcnkgb24gYSB0YWJsZSBvciBhIHZpZXcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVsYXRpb24gLSBUaGUgdGFibGUgb3IgdmlldyBuYW1lIHRvIHF1ZXJ5XG4gICAgICovXG4gICAgZnJvbShyZWxhdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN0LmZyb20ocmVsYXRpb24pO1xuICAgIH1cbiAgICAvLyBOT1RFOiBzaWduYXR1cmVzIG11c3QgYmUga2VwdCBpbiBzeW5jIHdpdGggUG9zdGdyZXN0Q2xpZW50LnNjaGVtYVxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBhIHNjaGVtYSB0byBxdWVyeSBvciBwZXJmb3JtIGFuIGZ1bmN0aW9uIChycGMpIGNhbGwuXG4gICAgICpcbiAgICAgKiBUaGUgc2NoZW1hIG5lZWRzIHRvIGJlIG9uIHRoZSBsaXN0IG9mIGV4cG9zZWQgc2NoZW1hcyBpbnNpZGUgU3VwYWJhc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2NoZW1hIC0gVGhlIHNjaGVtYSB0byBxdWVyeVxuICAgICAqL1xuICAgIHNjaGVtYShzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdC5zY2hlbWEoc2NoZW1hKTtcbiAgICB9XG4gICAgLy8gTk9URTogc2lnbmF0dXJlcyBtdXN0IGJlIGtlcHQgaW4gc3luYyB3aXRoIFBvc3RncmVzdENsaWVudC5ycGNcbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGEgZnVuY3Rpb24gY2FsbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmbiAtIFRoZSBmdW5jdGlvbiBuYW1lIHRvIGNhbGxcbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgZnVuY3Rpb24gY2FsbFxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLmhlYWQgLSBXaGVuIHNldCB0byBgdHJ1ZWAsIGBkYXRhYCB3aWxsIG5vdCBiZSByZXR1cm5lZC5cbiAgICAgKiBVc2VmdWwgaWYgeW91IG9ubHkgbmVlZCB0aGUgY291bnQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZ2V0IC0gV2hlbiBzZXQgdG8gYHRydWVgLCB0aGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2l0aFxuICAgICAqIHJlYWQtb25seSBhY2Nlc3MgbW9kZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jb3VudCAtIENvdW50IGFsZ29yaXRobSB0byB1c2UgdG8gY291bnQgcm93cyByZXR1cm5lZCBieSB0aGVcbiAgICAgKiBmdW5jdGlvbi4gT25seSBhcHBsaWNhYmxlIGZvciBbc2V0LXJldHVybmluZ1xuICAgICAqIGZ1bmN0aW9uc10oaHR0cHM6Ly93d3cucG9zdGdyZXNxbC5vcmcvZG9jcy9jdXJyZW50L2Z1bmN0aW9ucy1zcmYuaHRtbCkuXG4gICAgICpcbiAgICAgKiBgXCJleGFjdFwiYDogRXhhY3QgYnV0IHNsb3cgY291bnQgYWxnb3JpdGhtLiBQZXJmb3JtcyBhIGBDT1VOVCgqKWAgdW5kZXIgdGhlXG4gICAgICogaG9vZC5cbiAgICAgKlxuICAgICAqIGBcInBsYW5uZWRcImA6IEFwcHJveGltYXRlZCBidXQgZmFzdCBjb3VudCBhbGdvcml0aG0uIFVzZXMgdGhlIFBvc3RncmVzXG4gICAgICogc3RhdGlzdGljcyB1bmRlciB0aGUgaG9vZC5cbiAgICAgKlxuICAgICAqIGBcImVzdGltYXRlZFwiYDogVXNlcyBleGFjdCBjb3VudCBmb3IgbG93IG51bWJlcnMgYW5kIHBsYW5uZWQgY291bnQgZm9yIGhpZ2hcbiAgICAgKiBudW1iZXJzLlxuICAgICAqL1xuICAgIHJwYyhmbiwgYXJncyA9IHt9LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdC5ycGMoZm4sIGFyZ3MsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgUmVhbHRpbWUgY2hhbm5lbCB3aXRoIEJyb2FkY2FzdCwgUHJlc2VuY2UsIGFuZCBQb3N0Z3JlcyBDaGFuZ2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgUmVhbHRpbWUgY2hhbm5lbC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIFRoZSBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIFJlYWx0aW1lIGNoYW5uZWwuXG4gICAgICpcbiAgICAgKi9cbiAgICBjaGFubmVsKG5hbWUsIG9wdHMgPSB7IGNvbmZpZzoge30gfSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFsdGltZS5jaGFubmVsKG5hbWUsIG9wdHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBSZWFsdGltZSBjaGFubmVscy5cbiAgICAgKi9cbiAgICBnZXRDaGFubmVscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhbHRpbWUuZ2V0Q2hhbm5lbHMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmVzIGFuZCByZW1vdmVzIFJlYWx0aW1lIGNoYW5uZWwgZnJvbSBSZWFsdGltZSBjbGllbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWx0aW1lQ2hhbm5lbH0gY2hhbm5lbCAtIFRoZSBuYW1lIG9mIHRoZSBSZWFsdGltZSBjaGFubmVsLlxuICAgICAqXG4gICAgICovXG4gICAgcmVtb3ZlQ2hhbm5lbChjaGFubmVsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWx0aW1lLnJlbW92ZUNoYW5uZWwoY2hhbm5lbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlcyBhbmQgcmVtb3ZlcyBhbGwgUmVhbHRpbWUgY2hhbm5lbHMgZnJvbSBSZWFsdGltZSBjbGllbnQuXG4gICAgICovXG4gICAgcmVtb3ZlQWxsQ2hhbm5lbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWx0aW1lLnJlbW92ZUFsbENoYW5uZWxzKCk7XG4gICAgfVxuICAgIF9nZXRBY2Nlc3NUb2tlbigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSB9ID0geWllbGQgdGhpcy5hdXRoLmdldFNlc3Npb24oKTtcbiAgICAgICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSBkYXRhLnNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY2Nlc3NfdG9rZW4pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfaW5pdFN1cGFiYXNlQXV0aENsaWVudCh7IGF1dG9SZWZyZXNoVG9rZW4sIHBlcnNpc3RTZXNzaW9uLCBkZXRlY3RTZXNzaW9uSW5VcmwsIHN0b3JhZ2UsIHN0b3JhZ2VLZXksIGZsb3dUeXBlLCBkZWJ1ZywgfSwgaGVhZGVycywgZmV0Y2gpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBhdXRoSGVhZGVycyA9IHtcbiAgICAgICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0aGlzLnN1cGFiYXNlS2V5fWAsXG4gICAgICAgICAgICBhcGlrZXk6IGAke3RoaXMuc3VwYWJhc2VLZXl9YCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBTdXBhYmFzZUF1dGhDbGllbnQoe1xuICAgICAgICAgICAgdXJsOiB0aGlzLmF1dGhVcmwsXG4gICAgICAgICAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGF1dGhIZWFkZXJzKSwgaGVhZGVycyksXG4gICAgICAgICAgICBzdG9yYWdlS2V5OiBzdG9yYWdlS2V5LFxuICAgICAgICAgICAgYXV0b1JlZnJlc2hUb2tlbixcbiAgICAgICAgICAgIHBlcnNpc3RTZXNzaW9uLFxuICAgICAgICAgICAgZGV0ZWN0U2Vzc2lvbkluVXJsLFxuICAgICAgICAgICAgc3RvcmFnZSxcbiAgICAgICAgICAgIGZsb3dUeXBlLFxuICAgICAgICAgICAgZGVidWcsXG4gICAgICAgICAgICBmZXRjaCxcbiAgICAgICAgICAgIC8vIGF1dGggY2hlY2tzIGlmIHRoZXJlIGlzIGEgY3VzdG9tIGF1dGhvcml6YWl0b24gaGVhZGVyIHVzaW5nIHRoaXMgZmxhZ1xuICAgICAgICAgICAgLy8gc28gaXQga25vd3Mgd2hldGhlciB0byByZXR1cm4gYW4gZXJyb3Igd2hlbiBnZXRVc2VyIGlzIGNhbGxlZCB3aXRoIG5vIHNlc3Npb25cbiAgICAgICAgICAgIGhhc0N1c3RvbUF1dGhvcml6YXRpb25IZWFkZXI6IChfYSA9ICdBdXRob3JpemF0aW9uJyBpbiB0aGlzLmhlYWRlcnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2luaXRSZWFsdGltZUNsaWVudChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVhbHRpbWVDbGllbnQodGhpcy5yZWFsdGltZVVybCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBwYXJhbXM6IE9iamVjdC5hc3NpZ24oeyBhcGlrZXk6IHRoaXMuc3VwYWJhc2VLZXkgfSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnBhcmFtcykgfSkpO1xuICAgIH1cbiAgICBfbGlzdGVuRm9yQXV0aEV2ZW50cygpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmF1dGgub25BdXRoU3RhdGVDaGFuZ2UoKGV2ZW50LCBzZXNzaW9uKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVUb2tlbkNoYW5nZWQoZXZlbnQsICdDTElFTlQnLCBzZXNzaW9uID09PSBudWxsIHx8IHNlc3Npb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlc3Npb24uYWNjZXNzX3Rva2VuKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBfaGFuZGxlVG9rZW5DaGFuZ2VkKGV2ZW50LCBzb3VyY2UsIHRva2VuKSB7XG4gICAgICAgIGlmICgoZXZlbnQgPT09ICdUT0tFTl9SRUZSRVNIRUQnIHx8IGV2ZW50ID09PSAnU0lHTkVEX0lOJykgJiZcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlZEFjY2Vzc1Rva2VuICE9PSB0b2tlbikge1xuICAgICAgICAgICAgLy8gVG9rZW4gaGFzIGNoYW5nZWRcbiAgICAgICAgICAgIHRoaXMucmVhbHRpbWUuc2V0QXV0aCh0b2tlbiAhPT0gbnVsbCAmJiB0b2tlbiAhPT0gdm9pZCAwID8gdG9rZW4gOiBudWxsKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlZEFjY2Vzc1Rva2VuID0gdG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXZlbnQgPT09ICdTSUdORURfT1VUJykge1xuICAgICAgICAgICAgLy8gVG9rZW4gaXMgcmVtb3ZlZFxuICAgICAgICAgICAgdGhpcy5yZWFsdGltZS5zZXRBdXRoKHRoaXMuc3VwYWJhc2VLZXkpO1xuICAgICAgICAgICAgaWYgKHNvdXJjZSA9PSAnU1RPUkFHRScpXG4gICAgICAgICAgICAgICAgdGhpcy5hdXRoLnNpZ25PdXQoKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlZEFjY2Vzc1Rva2VuID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3VwYWJhc2VDbGllbnQuanMubWFwIiwiaW1wb3J0IHsgRnVuY3Rpb25zQ2xpZW50IH0gZnJvbSAnQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcydcbmltcG9ydCB7IEF1dGhDaGFuZ2VFdmVudCB9IGZyb20gJ0BzdXBhYmFzZS9hdXRoLWpzJ1xuaW1wb3J0IHtcbiAgUG9zdGdyZXN0Q2xpZW50LFxuICBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyLFxuICBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIsXG59IGZyb20gJ0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMnXG5pbXBvcnQge1xuICBSZWFsdGltZUNoYW5uZWwsXG4gIFJlYWx0aW1lQ2hhbm5lbE9wdGlvbnMsXG4gIFJlYWx0aW1lQ2xpZW50LFxuICBSZWFsdGltZUNsaWVudE9wdGlvbnMsXG59IGZyb20gJ0BzdXBhYmFzZS9yZWFsdGltZS1qcydcbmltcG9ydCB7IFN0b3JhZ2VDbGllbnQgYXMgU3VwYWJhc2VTdG9yYWdlQ2xpZW50IH0gZnJvbSAnQHN1cGFiYXNlL3N0b3JhZ2UtanMnXG5pbXBvcnQge1xuICBERUZBVUxUX0dMT0JBTF9PUFRJT05TLFxuICBERUZBVUxUX0RCX09QVElPTlMsXG4gIERFRkFVTFRfQVVUSF9PUFRJT05TLFxuICBERUZBVUxUX1JFQUxUSU1FX09QVElPTlMsXG59IGZyb20gJy4vbGliL2NvbnN0YW50cydcbmltcG9ydCB7IGZldGNoV2l0aEF1dGggfSBmcm9tICcuL2xpYi9mZXRjaCdcbmltcG9ydCB7IHN0cmlwVHJhaWxpbmdTbGFzaCwgYXBwbHlTZXR0aW5nRGVmYXVsdHMgfSBmcm9tICcuL2xpYi9oZWxwZXJzJ1xuaW1wb3J0IHsgU3VwYWJhc2VBdXRoQ2xpZW50IH0gZnJvbSAnLi9saWIvU3VwYWJhc2VBdXRoQ2xpZW50J1xuaW1wb3J0IHsgRmV0Y2gsIEdlbmVyaWNTY2hlbWEsIFN1cGFiYXNlQ2xpZW50T3B0aW9ucywgU3VwYWJhc2VBdXRoQ2xpZW50T3B0aW9ucyB9IGZyb20gJy4vbGliL3R5cGVzJ1xuXG4vKipcbiAqIFN1cGFiYXNlIENsaWVudC5cbiAqXG4gKiBBbiBpc29tb3JwaGljIEphdmFzY3JpcHQgY2xpZW50IGZvciBpbnRlcmFjdGluZyB3aXRoIFBvc3RncmVzLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdXBhYmFzZUNsaWVudDxcbiAgRGF0YWJhc2UgPSBhbnksXG4gIFNjaGVtYU5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBEYXRhYmFzZSA9ICdwdWJsaWMnIGV4dGVuZHMga2V5b2YgRGF0YWJhc2VcbiAgICA/ICdwdWJsaWMnXG4gICAgOiBzdHJpbmcgJiBrZXlvZiBEYXRhYmFzZSxcbiAgU2NoZW1hIGV4dGVuZHMgR2VuZXJpY1NjaGVtYSA9IERhdGFiYXNlW1NjaGVtYU5hbWVdIGV4dGVuZHMgR2VuZXJpY1NjaGVtYVxuICAgID8gRGF0YWJhc2VbU2NoZW1hTmFtZV1cbiAgICA6IGFueVxuPiB7XG4gIC8qKlxuICAgKiBTdXBhYmFzZSBBdXRoIGFsbG93cyB5b3UgdG8gY3JlYXRlIGFuZCBtYW5hZ2UgdXNlciBzZXNzaW9ucyBmb3IgYWNjZXNzIHRvIGRhdGEgdGhhdCBpcyBzZWN1cmVkIGJ5IGFjY2VzcyBwb2xpY2llcy5cbiAgICovXG4gIGF1dGg6IFN1cGFiYXNlQXV0aENsaWVudFxuICByZWFsdGltZTogUmVhbHRpbWVDbGllbnRcblxuICBwcm90ZWN0ZWQgcmVhbHRpbWVVcmw6IHN0cmluZ1xuICBwcm90ZWN0ZWQgYXV0aFVybDogc3RyaW5nXG4gIHByb3RlY3RlZCBzdG9yYWdlVXJsOiBzdHJpbmdcbiAgcHJvdGVjdGVkIGZ1bmN0aW9uc1VybDogc3RyaW5nXG4gIHByb3RlY3RlZCByZXN0OiBQb3N0Z3Jlc3RDbGllbnQ8RGF0YWJhc2UsIFNjaGVtYU5hbWU+XG4gIHByb3RlY3RlZCBzdG9yYWdlS2V5OiBzdHJpbmdcbiAgcHJvdGVjdGVkIGZldGNoPzogRmV0Y2hcbiAgcHJvdGVjdGVkIGNoYW5nZWRBY2Nlc3NUb2tlbj86IHN0cmluZ1xuXG4gIHByb3RlY3RlZCBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBjbGllbnQgZm9yIHVzZSBpbiB0aGUgYnJvd3Nlci5cbiAgICogQHBhcmFtIHN1cGFiYXNlVXJsIFRoZSB1bmlxdWUgU3VwYWJhc2UgVVJMIHdoaWNoIGlzIHN1cHBsaWVkIHdoZW4geW91IGNyZWF0ZSBhIG5ldyBwcm9qZWN0IGluIHlvdXIgcHJvamVjdCBkYXNoYm9hcmQuXG4gICAqIEBwYXJhbSBzdXBhYmFzZUtleSBUaGUgdW5pcXVlIFN1cGFiYXNlIEtleSB3aGljaCBpcyBzdXBwbGllZCB3aGVuIHlvdSBjcmVhdGUgYSBuZXcgcHJvamVjdCBpbiB5b3VyIHByb2plY3QgZGFzaGJvYXJkLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5kYi5zY2hlbWEgWW91IGNhbiBzd2l0Y2ggaW4gYmV0d2VlbiBzY2hlbWFzLiBUaGUgc2NoZW1hIG5lZWRzIHRvIGJlIG9uIHRoZSBsaXN0IG9mIGV4cG9zZWQgc2NoZW1hcyBpbnNpZGUgU3VwYWJhc2UuXG4gICAqIEBwYXJhbSBvcHRpb25zLmF1dGguYXV0b1JlZnJlc2hUb2tlbiBTZXQgdG8gXCJ0cnVlXCIgaWYgeW91IHdhbnQgdG8gYXV0b21hdGljYWxseSByZWZyZXNoIHRoZSB0b2tlbiBiZWZvcmUgZXhwaXJpbmcuXG4gICAqIEBwYXJhbSBvcHRpb25zLmF1dGgucGVyc2lzdFNlc3Npb24gU2V0IHRvIFwidHJ1ZVwiIGlmIHlvdSB3YW50IHRvIGF1dG9tYXRpY2FsbHkgc2F2ZSB0aGUgdXNlciBzZXNzaW9uIGludG8gbG9jYWwgc3RvcmFnZS5cbiAgICogQHBhcmFtIG9wdGlvbnMuYXV0aC5kZXRlY3RTZXNzaW9uSW5VcmwgU2V0IHRvIFwidHJ1ZVwiIGlmIHlvdSB3YW50IHRvIGF1dG9tYXRpY2FsbHkgZGV0ZWN0cyBPQXV0aCBncmFudHMgaW4gdGhlIFVSTCBhbmQgc2lnbnMgaW4gdGhlIHVzZXIuXG4gICAqIEBwYXJhbSBvcHRpb25zLnJlYWx0aW1lIE9wdGlvbnMgcGFzc2VkIGFsb25nIHRvIHJlYWx0aW1lLWpzIGNvbnN0cnVjdG9yLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5nbG9iYWwuZmV0Y2ggQSBjdXN0b20gZmV0Y2ggaW1wbGVtZW50YXRpb24uXG4gICAqIEBwYXJhbSBvcHRpb25zLmdsb2JhbC5oZWFkZXJzIEFueSBhZGRpdGlvbmFsIGhlYWRlcnMgdG8gc2VuZCB3aXRoIGVhY2ggbmV0d29yayByZXF1ZXN0LlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcHJvdGVjdGVkIHN1cGFiYXNlVXJsOiBzdHJpbmcsXG4gICAgcHJvdGVjdGVkIHN1cGFiYXNlS2V5OiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IFN1cGFiYXNlQ2xpZW50T3B0aW9uczxTY2hlbWFOYW1lPlxuICApIHtcbiAgICBpZiAoIXN1cGFiYXNlVXJsKSB0aHJvdyBuZXcgRXJyb3IoJ3N1cGFiYXNlVXJsIGlzIHJlcXVpcmVkLicpXG4gICAgaWYgKCFzdXBhYmFzZUtleSkgdGhyb3cgbmV3IEVycm9yKCdzdXBhYmFzZUtleSBpcyByZXF1aXJlZC4nKVxuXG4gICAgY29uc3QgX3N1cGFiYXNlVXJsID0gc3RyaXBUcmFpbGluZ1NsYXNoKHN1cGFiYXNlVXJsKVxuXG4gICAgdGhpcy5yZWFsdGltZVVybCA9IGAke19zdXBhYmFzZVVybH0vcmVhbHRpbWUvdjFgLnJlcGxhY2UoL15odHRwL2ksICd3cycpXG4gICAgdGhpcy5hdXRoVXJsID0gYCR7X3N1cGFiYXNlVXJsfS9hdXRoL3YxYFxuICAgIHRoaXMuc3RvcmFnZVVybCA9IGAke19zdXBhYmFzZVVybH0vc3RvcmFnZS92MWBcbiAgICB0aGlzLmZ1bmN0aW9uc1VybCA9IGAke19zdXBhYmFzZVVybH0vZnVuY3Rpb25zL3YxYFxuXG4gICAgLy8gZGVmYXVsdCBzdG9yYWdlIGtleSB1c2VzIHRoZSBzdXBhYmFzZSBwcm9qZWN0IHJlZiBhcyBhIG5hbWVzcGFjZVxuICAgIGNvbnN0IGRlZmF1bHRTdG9yYWdlS2V5ID0gYHNiLSR7bmV3IFVSTCh0aGlzLmF1dGhVcmwpLmhvc3RuYW1lLnNwbGl0KCcuJylbMF19LWF1dGgtdG9rZW5gXG4gICAgY29uc3QgREVGQVVMVFMgPSB7XG4gICAgICBkYjogREVGQVVMVF9EQl9PUFRJT05TLFxuICAgICAgcmVhbHRpbWU6IERFRkFVTFRfUkVBTFRJTUVfT1BUSU9OUyxcbiAgICAgIGF1dGg6IHsgLi4uREVGQVVMVF9BVVRIX09QVElPTlMsIHN0b3JhZ2VLZXk6IGRlZmF1bHRTdG9yYWdlS2V5IH0sXG4gICAgICBnbG9iYWw6IERFRkFVTFRfR0xPQkFMX09QVElPTlMsXG4gICAgfVxuXG4gICAgY29uc3Qgc2V0dGluZ3MgPSBhcHBseVNldHRpbmdEZWZhdWx0cyhvcHRpb25zID8/IHt9LCBERUZBVUxUUylcblxuICAgIHRoaXMuc3RvcmFnZUtleSA9IHNldHRpbmdzLmF1dGguc3RvcmFnZUtleSA/PyAnJ1xuICAgIHRoaXMuaGVhZGVycyA9IHNldHRpbmdzLmdsb2JhbC5oZWFkZXJzID8/IHt9XG5cbiAgICB0aGlzLmF1dGggPSB0aGlzLl9pbml0U3VwYWJhc2VBdXRoQ2xpZW50KFxuICAgICAgc2V0dGluZ3MuYXV0aCA/PyB7fSxcbiAgICAgIHRoaXMuaGVhZGVycyxcbiAgICAgIHNldHRpbmdzLmdsb2JhbC5mZXRjaFxuICAgIClcbiAgICB0aGlzLmZldGNoID0gZmV0Y2hXaXRoQXV0aChzdXBhYmFzZUtleSwgdGhpcy5fZ2V0QWNjZXNzVG9rZW4uYmluZCh0aGlzKSwgc2V0dGluZ3MuZ2xvYmFsLmZldGNoKVxuXG4gICAgdGhpcy5yZWFsdGltZSA9IHRoaXMuX2luaXRSZWFsdGltZUNsaWVudCh7IGhlYWRlcnM6IHRoaXMuaGVhZGVycywgLi4uc2V0dGluZ3MucmVhbHRpbWUgfSlcbiAgICB0aGlzLnJlc3QgPSBuZXcgUG9zdGdyZXN0Q2xpZW50KGAke19zdXBhYmFzZVVybH0vcmVzdC92MWAsIHtcbiAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgIHNjaGVtYTogc2V0dGluZ3MuZGIuc2NoZW1hLFxuICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgfSlcblxuICAgIHRoaXMuX2xpc3RlbkZvckF1dGhFdmVudHMoKVxuICB9XG5cbiAgLyoqXG4gICAqIFN1cGFiYXNlIEZ1bmN0aW9ucyBhbGxvd3MgeW91IHRvIGRlcGxveSBhbmQgaW52b2tlIGVkZ2UgZnVuY3Rpb25zLlxuICAgKi9cbiAgZ2V0IGZ1bmN0aW9ucygpOiBGdW5jdGlvbnNDbGllbnQge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb25zQ2xpZW50KHRoaXMuZnVuY3Rpb25zVXJsLCB7XG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICBjdXN0b21GZXRjaDogdGhpcy5mZXRjaCxcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFN1cGFiYXNlIFN0b3JhZ2UgYWxsb3dzIHlvdSB0byBtYW5hZ2UgdXNlci1nZW5lcmF0ZWQgY29udGVudCwgc3VjaCBhcyBwaG90b3Mgb3IgdmlkZW9zLlxuICAgKi9cbiAgZ2V0IHN0b3JhZ2UoKTogU3VwYWJhc2VTdG9yYWdlQ2xpZW50IHtcbiAgICByZXR1cm4gbmV3IFN1cGFiYXNlU3RvcmFnZUNsaWVudCh0aGlzLnN0b3JhZ2VVcmwsIHRoaXMuaGVhZGVycywgdGhpcy5mZXRjaClcbiAgfVxuXG4gIC8vIE5PVEU6IHNpZ25hdHVyZXMgbXVzdCBiZSBrZXB0IGluIHN5bmMgd2l0aCBQb3N0Z3Jlc3RDbGllbnQuZnJvbVxuICBmcm9tPFxuICAgIFRhYmxlTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFNjaGVtYVsnVGFibGVzJ10sXG4gICAgVGFibGUgZXh0ZW5kcyBTY2hlbWFbJ1RhYmxlcyddW1RhYmxlTmFtZV1cbiAgPihyZWxhdGlvbjogVGFibGVOYW1lKTogUG9zdGdyZXN0UXVlcnlCdWlsZGVyPFNjaGVtYSwgVGFibGUsIFRhYmxlTmFtZT5cbiAgZnJvbTxWaWV3TmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFNjaGVtYVsnVmlld3MnXSwgVmlldyBleHRlbmRzIFNjaGVtYVsnVmlld3MnXVtWaWV3TmFtZV0+KFxuICAgIHJlbGF0aW9uOiBWaWV3TmFtZVxuICApOiBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXI8U2NoZW1hLCBWaWV3LCBWaWV3TmFtZT5cbiAgLyoqXG4gICAqIFBlcmZvcm0gYSBxdWVyeSBvbiBhIHRhYmxlIG9yIGEgdmlldy5cbiAgICpcbiAgICogQHBhcmFtIHJlbGF0aW9uIC0gVGhlIHRhYmxlIG9yIHZpZXcgbmFtZSB0byBxdWVyeVxuICAgKi9cbiAgZnJvbShyZWxhdGlvbjogc3RyaW5nKTogUG9zdGdyZXN0UXVlcnlCdWlsZGVyPFNjaGVtYSwgYW55LCBhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5yZXN0LmZyb20ocmVsYXRpb24pXG4gIH1cblxuICAvLyBOT1RFOiBzaWduYXR1cmVzIG11c3QgYmUga2VwdCBpbiBzeW5jIHdpdGggUG9zdGdyZXN0Q2xpZW50LnNjaGVtYVxuICAvKipcbiAgICogU2VsZWN0IGEgc2NoZW1hIHRvIHF1ZXJ5IG9yIHBlcmZvcm0gYW4gZnVuY3Rpb24gKHJwYykgY2FsbC5cbiAgICpcbiAgICogVGhlIHNjaGVtYSBuZWVkcyB0byBiZSBvbiB0aGUgbGlzdCBvZiBleHBvc2VkIHNjaGVtYXMgaW5zaWRlIFN1cGFiYXNlLlxuICAgKlxuICAgKiBAcGFyYW0gc2NoZW1hIC0gVGhlIHNjaGVtYSB0byBxdWVyeVxuICAgKi9cbiAgc2NoZW1hPER5bmFtaWNTY2hlbWEgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBEYXRhYmFzZT4oXG4gICAgc2NoZW1hOiBEeW5hbWljU2NoZW1hXG4gICk6IFBvc3RncmVzdENsaWVudDxcbiAgICBEYXRhYmFzZSxcbiAgICBEeW5hbWljU2NoZW1hLFxuICAgIERhdGFiYXNlW0R5bmFtaWNTY2hlbWFdIGV4dGVuZHMgR2VuZXJpY1NjaGVtYSA/IERhdGFiYXNlW0R5bmFtaWNTY2hlbWFdIDogYW55XG4gID4ge1xuICAgIHJldHVybiB0aGlzLnJlc3Quc2NoZW1hPER5bmFtaWNTY2hlbWE+KHNjaGVtYSlcbiAgfVxuXG4gIC8vIE5PVEU6IHNpZ25hdHVyZXMgbXVzdCBiZSBrZXB0IGluIHN5bmMgd2l0aCBQb3N0Z3Jlc3RDbGllbnQucnBjXG4gIC8qKlxuICAgKiBQZXJmb3JtIGEgZnVuY3Rpb24gY2FsbC5cbiAgICpcbiAgICogQHBhcmFtIGZuIC0gVGhlIGZ1bmN0aW9uIG5hbWUgdG8gY2FsbFxuICAgKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgZnVuY3Rpb24gY2FsbFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIG9wdGlvbnMuaGVhZCAtIFdoZW4gc2V0IHRvIGB0cnVlYCwgYGRhdGFgIHdpbGwgbm90IGJlIHJldHVybmVkLlxuICAgKiBVc2VmdWwgaWYgeW91IG9ubHkgbmVlZCB0aGUgY291bnQuXG4gICAqIEBwYXJhbSBvcHRpb25zLmdldCAtIFdoZW4gc2V0IHRvIGB0cnVlYCwgdGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdpdGhcbiAgICogcmVhZC1vbmx5IGFjY2VzcyBtb2RlLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5jb3VudCAtIENvdW50IGFsZ29yaXRobSB0byB1c2UgdG8gY291bnQgcm93cyByZXR1cm5lZCBieSB0aGVcbiAgICogZnVuY3Rpb24uIE9ubHkgYXBwbGljYWJsZSBmb3IgW3NldC1yZXR1cm5pbmdcbiAgICogZnVuY3Rpb25zXShodHRwczovL3d3dy5wb3N0Z3Jlc3FsLm9yZy9kb2NzL2N1cnJlbnQvZnVuY3Rpb25zLXNyZi5odG1sKS5cbiAgICpcbiAgICogYFwiZXhhY3RcImA6IEV4YWN0IGJ1dCBzbG93IGNvdW50IGFsZ29yaXRobS4gUGVyZm9ybXMgYSBgQ09VTlQoKilgIHVuZGVyIHRoZVxuICAgKiBob29kLlxuICAgKlxuICAgKiBgXCJwbGFubmVkXCJgOiBBcHByb3hpbWF0ZWQgYnV0IGZhc3QgY291bnQgYWxnb3JpdGhtLiBVc2VzIHRoZSBQb3N0Z3Jlc1xuICAgKiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuICAgKlxuICAgKiBgXCJlc3RpbWF0ZWRcImA6IFVzZXMgZXhhY3QgY291bnQgZm9yIGxvdyBudW1iZXJzIGFuZCBwbGFubmVkIGNvdW50IGZvciBoaWdoXG4gICAqIG51bWJlcnMuXG4gICAqL1xuICBycGM8Rm5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgU2NoZW1hWydGdW5jdGlvbnMnXSwgRm4gZXh0ZW5kcyBTY2hlbWFbJ0Z1bmN0aW9ucyddW0ZuTmFtZV0+KFxuICAgIGZuOiBGbk5hbWUsXG4gICAgYXJnczogRm5bJ0FyZ3MnXSA9IHt9LFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIGhlYWQ/OiBib29sZWFuXG4gICAgICBnZXQ/OiBib29sZWFuXG4gICAgICBjb3VudD86ICdleGFjdCcgfCAncGxhbm5lZCcgfCAnZXN0aW1hdGVkJ1xuICAgIH0gPSB7fVxuICApOiBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyPFxuICAgIFNjaGVtYSxcbiAgICBGblsnUmV0dXJucyddIGV4dGVuZHMgYW55W11cbiAgICAgID8gRm5bJ1JldHVybnMnXVtudW1iZXJdIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbiAgICAgICAgPyBGblsnUmV0dXJucyddW251bWJlcl1cbiAgICAgICAgOiBuZXZlclxuICAgICAgOiBuZXZlcixcbiAgICBGblsnUmV0dXJucyddXG4gID4ge1xuICAgIHJldHVybiB0aGlzLnJlc3QucnBjKGZuLCBhcmdzLCBvcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBSZWFsdGltZSBjaGFubmVsIHdpdGggQnJvYWRjYXN0LCBQcmVzZW5jZSwgYW5kIFBvc3RncmVzIENoYW5nZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIFJlYWx0aW1lIGNoYW5uZWwuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gVGhlIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgUmVhbHRpbWUgY2hhbm5lbC5cbiAgICpcbiAgICovXG4gIGNoYW5uZWwobmFtZTogc3RyaW5nLCBvcHRzOiBSZWFsdGltZUNoYW5uZWxPcHRpb25zID0geyBjb25maWc6IHt9IH0pOiBSZWFsdGltZUNoYW5uZWwge1xuICAgIHJldHVybiB0aGlzLnJlYWx0aW1lLmNoYW5uZWwobmFtZSwgb3B0cylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBSZWFsdGltZSBjaGFubmVscy5cbiAgICovXG4gIGdldENoYW5uZWxzKCk6IFJlYWx0aW1lQ2hhbm5lbFtdIHtcbiAgICByZXR1cm4gdGhpcy5yZWFsdGltZS5nZXRDaGFubmVscygpXG4gIH1cblxuICAvKipcbiAgICogVW5zdWJzY3JpYmVzIGFuZCByZW1vdmVzIFJlYWx0aW1lIGNoYW5uZWwgZnJvbSBSZWFsdGltZSBjbGllbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhbHRpbWVDaGFubmVsfSBjaGFubmVsIC0gVGhlIG5hbWUgb2YgdGhlIFJlYWx0aW1lIGNoYW5uZWwuXG4gICAqXG4gICAqL1xuICByZW1vdmVDaGFubmVsKGNoYW5uZWw6IFJlYWx0aW1lQ2hhbm5lbCk6IFByb21pc2U8J29rJyB8ICd0aW1lZCBvdXQnIHwgJ2Vycm9yJz4ge1xuICAgIHJldHVybiB0aGlzLnJlYWx0aW1lLnJlbW92ZUNoYW5uZWwoY2hhbm5lbClcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnN1YnNjcmliZXMgYW5kIHJlbW92ZXMgYWxsIFJlYWx0aW1lIGNoYW5uZWxzIGZyb20gUmVhbHRpbWUgY2xpZW50LlxuICAgKi9cbiAgcmVtb3ZlQWxsQ2hhbm5lbHMoKTogUHJvbWlzZTwoJ29rJyB8ICd0aW1lZCBvdXQnIHwgJ2Vycm9yJylbXT4ge1xuICAgIHJldHVybiB0aGlzLnJlYWx0aW1lLnJlbW92ZUFsbENoYW5uZWxzKClcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX2dldEFjY2Vzc1Rva2VuKCkge1xuICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgdGhpcy5hdXRoLmdldFNlc3Npb24oKVxuXG4gICAgcmV0dXJuIGRhdGEuc2Vzc2lvbj8uYWNjZXNzX3Rva2VuID8/IG51bGxcbiAgfVxuXG4gIHByaXZhdGUgX2luaXRTdXBhYmFzZUF1dGhDbGllbnQoXG4gICAge1xuICAgICAgYXV0b1JlZnJlc2hUb2tlbixcbiAgICAgIHBlcnNpc3RTZXNzaW9uLFxuICAgICAgZGV0ZWN0U2Vzc2lvbkluVXJsLFxuICAgICAgc3RvcmFnZSxcbiAgICAgIHN0b3JhZ2VLZXksXG4gICAgICBmbG93VHlwZSxcbiAgICAgIGRlYnVnLFxuICAgIH06IFN1cGFiYXNlQXV0aENsaWVudE9wdGlvbnMsXG4gICAgaGVhZGVycz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz4sXG4gICAgZmV0Y2g/OiBGZXRjaFxuICApIHtcbiAgICBjb25zdCBhdXRoSGVhZGVycyA9IHtcbiAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0aGlzLnN1cGFiYXNlS2V5fWAsXG4gICAgICBhcGlrZXk6IGAke3RoaXMuc3VwYWJhc2VLZXl9YCxcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdXBhYmFzZUF1dGhDbGllbnQoe1xuICAgICAgdXJsOiB0aGlzLmF1dGhVcmwsXG4gICAgICBoZWFkZXJzOiB7IC4uLmF1dGhIZWFkZXJzLCAuLi5oZWFkZXJzIH0sXG4gICAgICBzdG9yYWdlS2V5OiBzdG9yYWdlS2V5LFxuICAgICAgYXV0b1JlZnJlc2hUb2tlbixcbiAgICAgIHBlcnNpc3RTZXNzaW9uLFxuICAgICAgZGV0ZWN0U2Vzc2lvbkluVXJsLFxuICAgICAgc3RvcmFnZSxcbiAgICAgIGZsb3dUeXBlLFxuICAgICAgZGVidWcsXG4gICAgICBmZXRjaCxcbiAgICAgIC8vIGF1dGggY2hlY2tzIGlmIHRoZXJlIGlzIGEgY3VzdG9tIGF1dGhvcml6YWl0b24gaGVhZGVyIHVzaW5nIHRoaXMgZmxhZ1xuICAgICAgLy8gc28gaXQga25vd3Mgd2hldGhlciB0byByZXR1cm4gYW4gZXJyb3Igd2hlbiBnZXRVc2VyIGlzIGNhbGxlZCB3aXRoIG5vIHNlc3Npb25cbiAgICAgIGhhc0N1c3RvbUF1dGhvcml6YXRpb25IZWFkZXI6ICdBdXRob3JpemF0aW9uJyBpbiB0aGlzLmhlYWRlcnMgPz8gZmFsc2UsXG4gICAgfSlcbiAgfVxuXG4gIHByaXZhdGUgX2luaXRSZWFsdGltZUNsaWVudChvcHRpb25zOiBSZWFsdGltZUNsaWVudE9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFJlYWx0aW1lQ2xpZW50KHRoaXMucmVhbHRpbWVVcmwsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBwYXJhbXM6IHsgLi4ueyBhcGlrZXk6IHRoaXMuc3VwYWJhc2VLZXkgfSwgLi4ub3B0aW9ucz8ucGFyYW1zIH0sXG4gICAgfSlcbiAgfVxuXG4gIHByaXZhdGUgX2xpc3RlbkZvckF1dGhFdmVudHMoKSB7XG4gICAgbGV0IGRhdGEgPSB0aGlzLmF1dGgub25BdXRoU3RhdGVDaGFuZ2UoKGV2ZW50LCBzZXNzaW9uKSA9PiB7XG4gICAgICB0aGlzLl9oYW5kbGVUb2tlbkNoYW5nZWQoZXZlbnQsICdDTElFTlQnLCBzZXNzaW9uPy5hY2Nlc3NfdG9rZW4pXG4gICAgfSlcbiAgICByZXR1cm4gZGF0YVxuICB9XG5cbiAgcHJpdmF0ZSBfaGFuZGxlVG9rZW5DaGFuZ2VkKFxuICAgIGV2ZW50OiBBdXRoQ2hhbmdlRXZlbnQsXG4gICAgc291cmNlOiAnQ0xJRU5UJyB8ICdTVE9SQUdFJyxcbiAgICB0b2tlbj86IHN0cmluZ1xuICApIHtcbiAgICBpZiAoXG4gICAgICAoZXZlbnQgPT09ICdUT0tFTl9SRUZSRVNIRUQnIHx8IGV2ZW50ID09PSAnU0lHTkVEX0lOJykgJiZcbiAgICAgIHRoaXMuY2hhbmdlZEFjY2Vzc1Rva2VuICE9PSB0b2tlblxuICAgICkge1xuICAgICAgLy8gVG9rZW4gaGFzIGNoYW5nZWRcbiAgICAgIHRoaXMucmVhbHRpbWUuc2V0QXV0aCh0b2tlbiA/PyBudWxsKVxuXG4gICAgICB0aGlzLmNoYW5nZWRBY2Nlc3NUb2tlbiA9IHRva2VuXG4gICAgfSBlbHNlIGlmIChldmVudCA9PT0gJ1NJR05FRF9PVVQnKSB7XG4gICAgICAvLyBUb2tlbiBpcyByZW1vdmVkXG4gICAgICB0aGlzLnJlYWx0aW1lLnNldEF1dGgodGhpcy5zdXBhYmFzZUtleSlcbiAgICAgIGlmIChzb3VyY2UgPT0gJ1NUT1JBR0UnKSB0aGlzLmF1dGguc2lnbk91dCgpXG4gICAgICB0aGlzLmNoYW5nZWRBY2Nlc3NUb2tlbiA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfVxufVxuIiwiZXhwb3J0IHsgRnVuY3Rpb25zQ2xpZW50IH0gZnJvbSAnLi9GdW5jdGlvbnNDbGllbnQnO1xuZXhwb3J0IHsgRnVuY3Rpb25zRXJyb3IsIEZ1bmN0aW9uc0ZldGNoRXJyb3IsIEZ1bmN0aW9uc0h0dHBFcnJvciwgRnVuY3Rpb25zUmVsYXlFcnJvciwgRnVuY3Rpb25SZWdpb24sIH0gZnJvbSAnLi90eXBlcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJleHBvcnQgeyBGdW5jdGlvbnNDbGllbnQgfSBmcm9tICcuL0Z1bmN0aW9uc0NsaWVudCdcbmV4cG9ydCB7XG4gIHR5cGUgRnVuY3Rpb25JbnZva2VPcHRpb25zLFxuICBGdW5jdGlvbnNFcnJvcixcbiAgRnVuY3Rpb25zRmV0Y2hFcnJvcixcbiAgRnVuY3Rpb25zSHR0cEVycm9yLFxuICBGdW5jdGlvbnNSZWxheUVycm9yLFxuICBGdW5jdGlvblJlZ2lvbixcbiAgdHlwZSBGdW5jdGlvbnNSZXNwb25zZSxcbn0gZnJvbSAnLi90eXBlcydcbiIsInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgcmVzb2x2ZUZldGNoIH0gZnJvbSAnLi9oZWxwZXInO1xuaW1wb3J0IHsgRnVuY3Rpb25zRmV0Y2hFcnJvciwgRnVuY3Rpb25zSHR0cEVycm9yLCBGdW5jdGlvbnNSZWxheUVycm9yLCBGdW5jdGlvblJlZ2lvbiwgfSBmcm9tICcuL3R5cGVzJztcbmV4cG9ydCBjbGFzcyBGdW5jdGlvbnNDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKHVybCwgeyBoZWFkZXJzID0ge30sIGN1c3RvbUZldGNoLCByZWdpb24gPSBGdW5jdGlvblJlZ2lvbi5BbnksIH0gPSB7fSkge1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICAgICAgdGhpcy5yZWdpb24gPSByZWdpb247XG4gICAgICAgIHRoaXMuZmV0Y2ggPSByZXNvbHZlRmV0Y2goY3VzdG9tRmV0Y2gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBhdXRob3JpemF0aW9uIGhlYWRlclxuICAgICAqIEBwYXJhbSB0b2tlbiAtIHRoZSBuZXcgand0IHRva2VuIHNlbnQgaW4gdGhlIGF1dGhvcmlzYXRpb24gaGVhZGVyXG4gICAgICovXG4gICAgc2V0QXV0aCh0b2tlbikge1xuICAgICAgICB0aGlzLmhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IGBCZWFyZXIgJHt0b2tlbn1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIGEgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0gZnVuY3Rpb25OYW1lIC0gVGhlIG5hbWUgb2YgdGhlIEZ1bmN0aW9uIHRvIGludm9rZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIGludm9raW5nIHRoZSBGdW5jdGlvbi5cbiAgICAgKi9cbiAgICBpbnZva2UoZnVuY3Rpb25OYW1lLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGhlYWRlcnMsIG1ldGhvZCwgYm9keTogZnVuY3Rpb25BcmdzIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgICAgIGxldCBfaGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgICAgIGxldCB7IHJlZ2lvbiB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgICAgICBpZiAoIXJlZ2lvbikge1xuICAgICAgICAgICAgICAgICAgICByZWdpb24gPSB0aGlzLnJlZ2lvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlZ2lvbiAmJiByZWdpb24gIT09ICdhbnknKSB7XG4gICAgICAgICAgICAgICAgICAgIF9oZWFkZXJzWyd4LXJlZ2lvbiddID0gcmVnaW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgICAgICAgICBpZiAoZnVuY3Rpb25BcmdzICYmXG4gICAgICAgICAgICAgICAgICAgICgoaGVhZGVycyAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhlYWRlcnMsICdDb250ZW50LVR5cGUnKSkgfHwgIWhlYWRlcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIGZ1bmN0aW9uQXJncyBpbnN0YW5jZW9mIEJsb2IpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkFyZ3MgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2lsbCB3b3JrIGZvciBGaWxlIGFzIEZpbGUgaW5oZXJpdHMgQmxvYlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxzbyB3b3JrcyBmb3IgQXJyYXlCdWZmZXIgYXMgaXQgaXMgdGhlIHNhbWUgdW5kZXJseWluZyBzdHJ1Y3R1cmUgYXMgYSBCbG9iXG4gICAgICAgICAgICAgICAgICAgICAgICBfaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSBmdW5jdGlvbkFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGZ1bmN0aW9uQXJncyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBsYWluIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgX2hlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ3RleHQvcGxhaW4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keSA9IGZ1bmN0aW9uQXJncztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnICYmIGZ1bmN0aW9uQXJncyBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBzZXQgY29udGVudC10eXBlIGhlYWRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlcXVlc3Qgd2lsbCBhdXRvbWF0aWNhbGx5IGFkZCB0aGUgcmlnaHQgYm91bmRhcnkgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSBmdW5jdGlvbkFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWZhdWx0LCBhc3N1bWUgdGhpcyBpcyBKU09OXG4gICAgICAgICAgICAgICAgICAgICAgICBfaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gSlNPTi5zdHJpbmdpZnkoZnVuY3Rpb25BcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZmV0Y2goYCR7dGhpcy51cmx9LyR7ZnVuY3Rpb25OYW1lfWAsIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QgfHwgJ1BPU1QnLFxuICAgICAgICAgICAgICAgICAgICAvLyBoZWFkZXJzIHByaW9yaXR5IGlzIChoaWdoIHRvIGxvdyk6XG4gICAgICAgICAgICAgICAgICAgIC8vIDEuIGludm9rZS1sZXZlbCBoZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgIC8vIDIuIGNsaWVudC1sZXZlbCBoZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgIC8vIDMuIGRlZmF1bHQgQ29udGVudC1UeXBlIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgX2hlYWRlcnMpLCB0aGlzLmhlYWRlcnMpLCBoZWFkZXJzKSxcbiAgICAgICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZmV0Y2hFcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRnVuY3Rpb25zRmV0Y2hFcnJvcihmZXRjaEVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1JlbGF5RXJyb3IgPSByZXNwb25zZS5oZWFkZXJzLmdldCgneC1yZWxheS1lcnJvcicpO1xuICAgICAgICAgICAgICAgIGlmIChpc1JlbGF5RXJyb3IgJiYgaXNSZWxheUVycm9yID09PSAndHJ1ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZ1bmN0aW9uc1JlbGF5RXJyb3IocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGdW5jdGlvbnNIdHRwRXJyb3IocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcmVzcG9uc2VUeXBlID0gKChfYSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ3RleHQvcGxhaW4nKS5zcGxpdCgnOycpWzBdLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VUeXBlID09PSAnYXBwbGljYXRpb24vanNvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHlpZWxkIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzcG9uc2VUeXBlID09PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0geWllbGQgcmVzcG9uc2UuYmxvYigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXNwb25zZVR5cGUgPT09ICd0ZXh0L2V2ZW50LXN0cmVhbScpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXNwb25zZVR5cGUgPT09ICdtdWx0aXBhcnQvZm9ybS1kYXRhJykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0geWllbGQgcmVzcG9uc2UuZm9ybURhdGEoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gdGV4dFxuICAgICAgICAgICAgICAgICAgICBkYXRhID0geWllbGQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RnVuY3Rpb25zQ2xpZW50LmpzLm1hcCIsImltcG9ydCB7IHJlc29sdmVGZXRjaCB9IGZyb20gJy4vaGVscGVyJ1xuaW1wb3J0IHtcbiAgRmV0Y2gsXG4gIEZ1bmN0aW9uc0ZldGNoRXJyb3IsXG4gIEZ1bmN0aW9uc0h0dHBFcnJvcixcbiAgRnVuY3Rpb25zUmVsYXlFcnJvcixcbiAgRnVuY3Rpb25zUmVzcG9uc2UsXG4gIEZ1bmN0aW9uSW52b2tlT3B0aW9ucyxcbiAgRnVuY3Rpb25SZWdpb24sXG59IGZyb20gJy4vdHlwZXMnXG5cbmV4cG9ydCBjbGFzcyBGdW5jdGlvbnNDbGllbnQge1xuICBwcm90ZWN0ZWQgdXJsOiBzdHJpbmdcbiAgcHJvdGVjdGVkIGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgcHJvdGVjdGVkIHJlZ2lvbjogRnVuY3Rpb25SZWdpb25cbiAgcHJvdGVjdGVkIGZldGNoOiBGZXRjaFxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHVybDogc3RyaW5nLFxuICAgIHtcbiAgICAgIGhlYWRlcnMgPSB7fSxcbiAgICAgIGN1c3RvbUZldGNoLFxuICAgICAgcmVnaW9uID0gRnVuY3Rpb25SZWdpb24uQW55LFxuICAgIH06IHtcbiAgICAgIGhlYWRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gICAgICBjdXN0b21GZXRjaD86IEZldGNoXG4gICAgICByZWdpb24/OiBGdW5jdGlvblJlZ2lvblxuICAgIH0gPSB7fVxuICApIHtcbiAgICB0aGlzLnVybCA9IHVybFxuICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnNcbiAgICB0aGlzLnJlZ2lvbiA9IHJlZ2lvblxuICAgIHRoaXMuZmV0Y2ggPSByZXNvbHZlRmV0Y2goY3VzdG9tRmV0Y2gpXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgYXV0aG9yaXphdGlvbiBoZWFkZXJcbiAgICogQHBhcmFtIHRva2VuIC0gdGhlIG5ldyBqd3QgdG9rZW4gc2VudCBpbiB0aGUgYXV0aG9yaXNhdGlvbiBoZWFkZXJcbiAgICovXG4gIHNldEF1dGgodG9rZW46IHN0cmluZykge1xuICAgIHRoaXMuaGVhZGVycy5BdXRob3JpemF0aW9uID0gYEJlYXJlciAke3Rva2VufWBcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VzIGEgZnVuY3Rpb25cbiAgICogQHBhcmFtIGZ1bmN0aW9uTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBGdW5jdGlvbiB0byBpbnZva2UuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgaW52b2tpbmcgdGhlIEZ1bmN0aW9uLlxuICAgKi9cbiAgYXN5bmMgaW52b2tlPFQgPSBhbnk+KFxuICAgIGZ1bmN0aW9uTmFtZTogc3RyaW5nLFxuICAgIG9wdGlvbnM6IEZ1bmN0aW9uSW52b2tlT3B0aW9ucyA9IHt9XG4gICk6IFByb21pc2U8RnVuY3Rpb25zUmVzcG9uc2U8VD4+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBoZWFkZXJzLCBtZXRob2QsIGJvZHk6IGZ1bmN0aW9uQXJncyB9ID0gb3B0aW9uc1xuICAgICAgbGV0IF9oZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge31cbiAgICAgIGxldCB7IHJlZ2lvbiB9ID0gb3B0aW9uc1xuICAgICAgaWYgKCFyZWdpb24pIHtcbiAgICAgICAgcmVnaW9uID0gdGhpcy5yZWdpb25cbiAgICAgIH1cbiAgICAgIGlmIChyZWdpb24gJiYgcmVnaW9uICE9PSAnYW55Jykge1xuICAgICAgICBfaGVhZGVyc1sneC1yZWdpb24nXSA9IHJlZ2lvblxuICAgICAgfVxuICAgICAgbGV0IGJvZHk6IGFueVxuICAgICAgaWYgKFxuICAgICAgICBmdW5jdGlvbkFyZ3MgJiZcbiAgICAgICAgKChoZWFkZXJzICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaGVhZGVycywgJ0NvbnRlbnQtVHlwZScpKSB8fCAhaGVhZGVycylcbiAgICAgICkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgKHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiBmdW5jdGlvbkFyZ3MgaW5zdGFuY2VvZiBCbG9iKSB8fFxuICAgICAgICAgIGZ1bmN0aW9uQXJncyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIHdpbGwgd29yayBmb3IgRmlsZSBhcyBGaWxlIGluaGVyaXRzIEJsb2JcbiAgICAgICAgICAvLyBhbHNvIHdvcmtzIGZvciBBcnJheUJ1ZmZlciBhcyBpdCBpcyB0aGUgc2FtZSB1bmRlcmx5aW5nIHN0cnVjdHVyZSBhcyBhIEJsb2JcbiAgICAgICAgICBfaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJ1xuICAgICAgICAgIGJvZHkgPSBmdW5jdGlvbkFyZ3NcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZnVuY3Rpb25BcmdzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIC8vIHBsYWluIHN0cmluZ1xuICAgICAgICAgIF9oZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICd0ZXh0L3BsYWluJ1xuICAgICAgICAgIGJvZHkgPSBmdW5jdGlvbkFyZ3NcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnICYmIGZ1bmN0aW9uQXJncyBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG4gICAgICAgICAgLy8gZG9uJ3Qgc2V0IGNvbnRlbnQtdHlwZSBoZWFkZXJzXG4gICAgICAgICAgLy8gUmVxdWVzdCB3aWxsIGF1dG9tYXRpY2FsbHkgYWRkIHRoZSByaWdodCBib3VuZGFyeSB2YWx1ZVxuICAgICAgICAgIGJvZHkgPSBmdW5jdGlvbkFyZ3NcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBkZWZhdWx0LCBhc3N1bWUgdGhpcyBpcyBKU09OXG4gICAgICAgICAgX2hlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgICAgYm9keSA9IEpTT04uc3RyaW5naWZ5KGZ1bmN0aW9uQXJncylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2goYCR7dGhpcy51cmx9LyR7ZnVuY3Rpb25OYW1lfWAsIHtcbiAgICAgICAgbWV0aG9kOiBtZXRob2QgfHwgJ1BPU1QnLFxuICAgICAgICAvLyBoZWFkZXJzIHByaW9yaXR5IGlzIChoaWdoIHRvIGxvdyk6XG4gICAgICAgIC8vIDEuIGludm9rZS1sZXZlbCBoZWFkZXJzXG4gICAgICAgIC8vIDIuIGNsaWVudC1sZXZlbCBoZWFkZXJzXG4gICAgICAgIC8vIDMuIGRlZmF1bHQgQ29udGVudC1UeXBlIGhlYWRlclxuICAgICAgICBoZWFkZXJzOiB7IC4uLl9oZWFkZXJzLCAuLi50aGlzLmhlYWRlcnMsIC4uLmhlYWRlcnMgfSxcbiAgICAgICAgYm9keSxcbiAgICAgIH0pLmNhdGNoKChmZXRjaEVycm9yKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBGdW5jdGlvbnNGZXRjaEVycm9yKGZldGNoRXJyb3IpXG4gICAgICB9KVxuXG4gICAgICBjb25zdCBpc1JlbGF5RXJyb3IgPSByZXNwb25zZS5oZWFkZXJzLmdldCgneC1yZWxheS1lcnJvcicpXG4gICAgICBpZiAoaXNSZWxheUVycm9yICYmIGlzUmVsYXlFcnJvciA9PT0gJ3RydWUnKSB7XG4gICAgICAgIHRocm93IG5ldyBGdW5jdGlvbnNSZWxheUVycm9yKHJlc3BvbnNlKVxuICAgICAgfVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBGdW5jdGlvbnNIdHRwRXJyb3IocmVzcG9uc2UpXG4gICAgICB9XG5cbiAgICAgIGxldCByZXNwb25zZVR5cGUgPSAocmVzcG9uc2UuaGVhZGVycy5nZXQoJ0NvbnRlbnQtVHlwZScpID8/ICd0ZXh0L3BsYWluJykuc3BsaXQoJzsnKVswXS50cmltKClcbiAgICAgIGxldCBkYXRhOiBhbnlcbiAgICAgIGlmIChyZXNwb25zZVR5cGUgPT09ICdhcHBsaWNhdGlvbi9qc29uJykge1xuICAgICAgICBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlVHlwZSA9PT0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpIHtcbiAgICAgICAgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmJsb2IoKVxuICAgICAgfSBlbHNlIGlmIChyZXNwb25zZVR5cGUgPT09ICd0ZXh0L2V2ZW50LXN0cmVhbScpIHtcbiAgICAgICAgZGF0YSA9IHJlc3BvbnNlXG4gICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlVHlwZSA9PT0gJ211bHRpcGFydC9mb3JtLWRhdGEnKSB7XG4gICAgICAgIGRhdGEgPSBhd2FpdCByZXNwb25zZS5mb3JtRGF0YSgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWZhdWx0IHRvIHRleHRcbiAgICAgICAgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICB9XG4gIH1cbn1cbiIsImV4cG9ydCBjb25zdCByZXNvbHZlRmV0Y2ggPSAoY3VzdG9tRmV0Y2gpID0+IHtcbiAgICBsZXQgX2ZldGNoO1xuICAgIGlmIChjdXN0b21GZXRjaCkge1xuICAgICAgICBfZmV0Y2ggPSBjdXN0b21GZXRjaDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGZldGNoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBfZmV0Y2ggPSAoLi4uYXJncykgPT4gaW1wb3J0KCdAc3VwYWJhc2Uvbm9kZS1mZXRjaCcpLnRoZW4oKHsgZGVmYXVsdDogZmV0Y2ggfSkgPT4gZmV0Y2goLi4uYXJncykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgX2ZldGNoID0gZmV0Y2g7XG4gICAgfVxuICAgIHJldHVybiAoLi4uYXJncykgPT4gX2ZldGNoKC4uLmFyZ3MpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbHBlci5qcy5tYXAiLCJpbXBvcnQgeyBGZXRjaCB9IGZyb20gJy4vdHlwZXMnXG5cbmV4cG9ydCBjb25zdCByZXNvbHZlRmV0Y2ggPSAoY3VzdG9tRmV0Y2g/OiBGZXRjaCk6IEZldGNoID0+IHtcbiAgbGV0IF9mZXRjaDogRmV0Y2hcbiAgaWYgKGN1c3RvbUZldGNoKSB7XG4gICAgX2ZldGNoID0gY3VzdG9tRmV0Y2hcbiAgfSBlbHNlIGlmICh0eXBlb2YgZmV0Y2ggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgX2ZldGNoID0gKC4uLmFyZ3MpID0+XG4gICAgICBpbXBvcnQoJ0BzdXBhYmFzZS9ub2RlLWZldGNoJyBhcyBhbnkpLnRoZW4oKHsgZGVmYXVsdDogZmV0Y2ggfSkgPT4gZmV0Y2goLi4uYXJncykpXG4gIH0gZWxzZSB7XG4gICAgX2ZldGNoID0gZmV0Y2hcbiAgfVxuICByZXR1cm4gKC4uLmFyZ3MpID0+IF9mZXRjaCguLi5hcmdzKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSAocmVxdWlyZShcIi4vaGVscGVycy93b3JrZXIvanMtbG9hZGVyXCIpKHJlcXVpcmUoJy4vaGVscGVycy9idW5kbGUtdXJsJykuZ2V0QnVuZGxlVVJMKCdnTDlIUScpICsgXCIuLi8uLi9icm93c2VyLjcwYjI0MGE3LmpzXCIgKyBcIj9cIiArIERhdGUubm93KCkpLmNhdGNoKGVyciA9PiB7ZGVsZXRlIG1vZHVsZS5idW5kbGUuY2FjaGVbbW9kdWxlLmlkXTsgdGhyb3cgZXJyO30pKS50aGVuKCgpID0+IG1vZHVsZS5idW5kbGUucm9vdCgnMVlONDMnKSk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGdsb2JhbCBfX3BhcmNlbF9faW1wb3J0U2NyaXB0c19fOnJlYWRvbmx5Ki9cbnZhciBjYWNoZUxvYWRlciA9IHJlcXVpcmUoJy4uL2NhY2hlTG9hZGVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gY2FjaGVMb2FkZXIoZnVuY3Rpb24gKGJ1bmRsZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHRyeSB7XG4gICAgICBfX3BhcmNlbF9faW1wb3J0U2NyaXB0c19fKGJ1bmRsZSk7XG5cbiAgICAgIHJlc29sdmUoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZWplY3QoZSk7XG4gICAgfVxuICB9KTtcbn0pOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgY2FjaGVkQnVuZGxlcyA9IHt9O1xudmFyIGNhY2hlZFByZWxvYWRzID0ge307XG52YXIgY2FjaGVkUHJlZmV0Y2hlcyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDYWNoZSh0eXBlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3ByZWxvYWQnOlxuICAgICAgcmV0dXJuIGNhY2hlZFByZWxvYWRzO1xuXG4gICAgY2FzZSAncHJlZmV0Y2gnOlxuICAgICAgcmV0dXJuIGNhY2hlZFByZWZldGNoZXM7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGNhY2hlZEJ1bmRsZXM7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobG9hZGVyLCB0eXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYnVuZGxlKSB7XG4gICAgdmFyIGNhY2hlID0gZ2V0Q2FjaGUodHlwZSk7XG5cbiAgICBpZiAoY2FjaGVbYnVuZGxlXSkge1xuICAgICAgcmV0dXJuIGNhY2hlW2J1bmRsZV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhY2hlW2J1bmRsZV0gPSBsb2FkZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgICAgZGVsZXRlIGNhY2hlW2J1bmRsZV07XG4gICAgICB0aHJvdyBlO1xuICAgIH0pO1xuICB9O1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGJ1bmRsZVVSTCA9IHt9O1xuXG5mdW5jdGlvbiBnZXRCdW5kbGVVUkxDYWNoZWQoaWQpIHtcbiAgdmFyIHZhbHVlID0gYnVuZGxlVVJMW2lkXTtcblxuICBpZiAoIXZhbHVlKSB7XG4gICAgdmFsdWUgPSBnZXRCdW5kbGVVUkwoKTtcbiAgICBidW5kbGVVUkxbaWRdID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGdldEJ1bmRsZVVSTCgpIHtcbiAgdHJ5IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdmFyIG1hdGNoZXMgPSAoJycgKyBlcnIuc3RhY2spLm1hdGNoKC8oaHR0cHM/fGZpbGV8ZnRwfChjaHJvbWV8bW96fHNhZmFyaS13ZWIpLWV4dGVuc2lvbik6XFwvXFwvW14pXFxuXSsvZyk7XG5cbiAgICBpZiAobWF0Y2hlcykge1xuICAgICAgLy8gVGhlIGZpcnN0IHR3byBzdGFjayBmcmFtZXMgd2lsbCBiZSB0aGlzIGZ1bmN0aW9uIGFuZCBnZXRCdW5kbGVVUkxDYWNoZWQuXG4gICAgICAvLyBVc2UgdGhlIDNyZCBvbmUsIHdoaWNoIHdpbGwgYmUgYSBydW50aW1lIGluIHRoZSBvcmlnaW5hbCBidW5kbGUuXG4gICAgICByZXR1cm4gZ2V0QmFzZVVSTChtYXRjaGVzWzJdKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gJy8nO1xufVxuXG5mdW5jdGlvbiBnZXRCYXNlVVJMKHVybCkge1xuICByZXR1cm4gKCcnICsgdXJsKS5yZXBsYWNlKC9eKCg/Omh0dHBzP3xmaWxlfGZ0cHwoY2hyb21lfG1venxzYWZhcmktd2ViKS1leHRlbnNpb24pOlxcL1xcLy4rKVxcL1teL10rJC8sICckMScpICsgJy8nO1xufSAvLyBUT0RPOiBSZXBsYWNlIHVzZXMgd2l0aCBgbmV3IFVSTCh1cmwpLm9yaWdpbmAgd2hlbiBpZTExIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuXG5cblxuZnVuY3Rpb24gZ2V0T3JpZ2luKHVybCkge1xuICB2YXIgbWF0Y2hlcyA9ICgnJyArIHVybCkubWF0Y2goLyhodHRwcz98ZmlsZXxmdHB8KGNocm9tZXxtb3p8c2FmYXJpLXdlYiktZXh0ZW5zaW9uKTpcXC9cXC9bXi9dKy8pO1xuXG4gIGlmICghbWF0Y2hlcykge1xuICAgIHRocm93IG5ldyBFcnJvcignT3JpZ2luIG5vdCBmb3VuZCcpO1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoZXNbMF07XG59XG5cbmV4cG9ydHMuZ2V0QnVuZGxlVVJMID0gZ2V0QnVuZGxlVVJMQ2FjaGVkO1xuZXhwb3J0cy5nZXRCYXNlVVJMID0gZ2V0QmFzZVVSTDtcbmV4cG9ydHMuZ2V0T3JpZ2luID0gZ2V0T3JpZ2luOyIsImV4cG9ydCBjbGFzcyBGdW5jdGlvbnNFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBuYW1lID0gJ0Z1bmN0aW9uc0Vycm9yJywgY29udGV4dCkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRnVuY3Rpb25zRmV0Y2hFcnJvciBleHRlbmRzIEZ1bmN0aW9uc0Vycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKCdGYWlsZWQgdG8gc2VuZCBhIHJlcXVlc3QgdG8gdGhlIEVkZ2UgRnVuY3Rpb24nLCAnRnVuY3Rpb25zRmV0Y2hFcnJvcicsIGNvbnRleHQpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBGdW5jdGlvbnNSZWxheUVycm9yIGV4dGVuZHMgRnVuY3Rpb25zRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIoJ1JlbGF5IEVycm9yIGludm9raW5nIHRoZSBFZGdlIEZ1bmN0aW9uJywgJ0Z1bmN0aW9uc1JlbGF5RXJyb3InLCBjb250ZXh0KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRnVuY3Rpb25zSHR0cEVycm9yIGV4dGVuZHMgRnVuY3Rpb25zRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIoJ0VkZ2UgRnVuY3Rpb24gcmV0dXJuZWQgYSBub24tMnh4IHN0YXR1cyBjb2RlJywgJ0Z1bmN0aW9uc0h0dHBFcnJvcicsIGNvbnRleHQpO1xuICAgIH1cbn1cbi8vIERlZmluZSB0aGUgZW51bSBmb3IgdGhlICdyZWdpb24nIHByb3BlcnR5XG5leHBvcnQgdmFyIEZ1bmN0aW9uUmVnaW9uO1xuKGZ1bmN0aW9uIChGdW5jdGlvblJlZ2lvbikge1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiQW55XCJdID0gXCJhbnlcIjtcbiAgICBGdW5jdGlvblJlZ2lvbltcIkFwTm9ydGhlYXN0MVwiXSA9IFwiYXAtbm9ydGhlYXN0LTFcIjtcbiAgICBGdW5jdGlvblJlZ2lvbltcIkFwTm9ydGhlYXN0MlwiXSA9IFwiYXAtbm9ydGhlYXN0LTJcIjtcbiAgICBGdW5jdGlvblJlZ2lvbltcIkFwU291dGgxXCJdID0gXCJhcC1zb3V0aC0xXCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJBcFNvdXRoZWFzdDFcIl0gPSBcImFwLXNvdXRoZWFzdC0xXCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJBcFNvdXRoZWFzdDJcIl0gPSBcImFwLXNvdXRoZWFzdC0yXCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJDYUNlbnRyYWwxXCJdID0gXCJjYS1jZW50cmFsLTFcIjtcbiAgICBGdW5jdGlvblJlZ2lvbltcIkV1Q2VudHJhbDFcIl0gPSBcImV1LWNlbnRyYWwtMVwiO1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiRXVXZXN0MVwiXSA9IFwiZXUtd2VzdC0xXCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJFdVdlc3QyXCJdID0gXCJldS13ZXN0LTJcIjtcbiAgICBGdW5jdGlvblJlZ2lvbltcIkV1V2VzdDNcIl0gPSBcImV1LXdlc3QtM1wiO1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiU2FFYXN0MVwiXSA9IFwic2EtZWFzdC0xXCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJVc0Vhc3QxXCJdID0gXCJ1cy1lYXN0LTFcIjtcbiAgICBGdW5jdGlvblJlZ2lvbltcIlVzV2VzdDFcIl0gPSBcInVzLXdlc3QtMVwiO1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiVXNXZXN0MlwiXSA9IFwidXMtd2VzdC0yXCI7XG59KShGdW5jdGlvblJlZ2lvbiB8fCAoRnVuY3Rpb25SZWdpb24gPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIiwiZXhwb3J0IHR5cGUgRmV0Y2ggPSB0eXBlb2YgZmV0Y2hcblxuLyoqXG4gKiBSZXNwb25zZSBmb3JtYXRcbiAqXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb25zUmVzcG9uc2VTdWNjZXNzPFQ+IHtcbiAgZGF0YTogVFxuICBlcnJvcjogbnVsbFxufVxuZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvbnNSZXNwb25zZUZhaWx1cmUge1xuICBkYXRhOiBudWxsXG4gIGVycm9yOiBhbnlcbn1cbmV4cG9ydCB0eXBlIEZ1bmN0aW9uc1Jlc3BvbnNlPFQ+ID0gRnVuY3Rpb25zUmVzcG9uc2VTdWNjZXNzPFQ+IHwgRnVuY3Rpb25zUmVzcG9uc2VGYWlsdXJlXG5cbmV4cG9ydCBjbGFzcyBGdW5jdGlvbnNFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29udGV4dDogYW55XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgbmFtZSA9ICdGdW5jdGlvbnNFcnJvcicsIGNvbnRleHQ/OiBhbnkpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9IG5hbWVcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uc0ZldGNoRXJyb3IgZXh0ZW5kcyBGdW5jdGlvbnNFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQ6IGFueSkge1xuICAgIHN1cGVyKCdGYWlsZWQgdG8gc2VuZCBhIHJlcXVlc3QgdG8gdGhlIEVkZ2UgRnVuY3Rpb24nLCAnRnVuY3Rpb25zRmV0Y2hFcnJvcicsIGNvbnRleHQpXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uc1JlbGF5RXJyb3IgZXh0ZW5kcyBGdW5jdGlvbnNFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQ6IGFueSkge1xuICAgIHN1cGVyKCdSZWxheSBFcnJvciBpbnZva2luZyB0aGUgRWRnZSBGdW5jdGlvbicsICdGdW5jdGlvbnNSZWxheUVycm9yJywgY29udGV4dClcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRnVuY3Rpb25zSHR0cEVycm9yIGV4dGVuZHMgRnVuY3Rpb25zRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0OiBhbnkpIHtcbiAgICBzdXBlcignRWRnZSBGdW5jdGlvbiByZXR1cm5lZCBhIG5vbi0yeHggc3RhdHVzIGNvZGUnLCAnRnVuY3Rpb25zSHR0cEVycm9yJywgY29udGV4dClcbiAgfVxufVxuLy8gRGVmaW5lIHRoZSBlbnVtIGZvciB0aGUgJ3JlZ2lvbicgcHJvcGVydHlcbmV4cG9ydCBlbnVtIEZ1bmN0aW9uUmVnaW9uIHtcbiAgQW55ID0gJ2FueScsXG4gIEFwTm9ydGhlYXN0MSA9ICdhcC1ub3J0aGVhc3QtMScsXG4gIEFwTm9ydGhlYXN0MiA9ICdhcC1ub3J0aGVhc3QtMicsXG4gIEFwU291dGgxID0gJ2FwLXNvdXRoLTEnLFxuICBBcFNvdXRoZWFzdDEgPSAnYXAtc291dGhlYXN0LTEnLFxuICBBcFNvdXRoZWFzdDIgPSAnYXAtc291dGhlYXN0LTInLFxuICBDYUNlbnRyYWwxID0gJ2NhLWNlbnRyYWwtMScsXG4gIEV1Q2VudHJhbDEgPSAnZXUtY2VudHJhbC0xJyxcbiAgRXVXZXN0MSA9ICdldS13ZXN0LTEnLFxuICBFdVdlc3QyID0gJ2V1LXdlc3QtMicsXG4gIEV1V2VzdDMgPSAnZXUtd2VzdC0zJyxcbiAgU2FFYXN0MSA9ICdzYS1lYXN0LTEnLFxuICBVc0Vhc3QxID0gJ3VzLWVhc3QtMScsXG4gIFVzV2VzdDEgPSAndXMtd2VzdC0xJyxcbiAgVXNXZXN0MiA9ICd1cy13ZXN0LTInLFxufVxuXG5leHBvcnQgdHlwZSBGdW5jdGlvbkludm9rZU9wdGlvbnMgPSB7XG4gIC8qKlxuICAgKiBPYmplY3QgcmVwcmVzZW50aW5nIHRoZSBoZWFkZXJzIHRvIHNlbmQgd2l0aCB0aGUgcmVxdWVzdC5cbiAgICogKi9cbiAgaGVhZGVycz86IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH1cbiAgLyoqXG4gICAqIFRoZSBIVFRQIHZlcmIgb2YgdGhlIHJlcXVlc3RcbiAgICovXG4gIG1ldGhvZD86ICdQT1NUJyB8ICdHRVQnIHwgJ1BVVCcgfCAnUEFUQ0gnIHwgJ0RFTEVURSdcbiAgLyoqXG4gICAqIFRoZSBSZWdpb24gdG8gaW52b2tlIHRoZSBmdW5jdGlvbiBpbi5cbiAgICovXG4gIHJlZ2lvbj86IEZ1bmN0aW9uUmVnaW9uXG4gIC8qKlxuICAgKiBUaGUgYm9keSBvZiB0aGUgcmVxdWVzdC5cbiAgICovXG4gIGJvZHk/OlxuICAgIHwgRmlsZVxuICAgIHwgQmxvYlxuICAgIHwgQXJyYXlCdWZmZXJcbiAgICB8IEZvcm1EYXRhXG4gICAgfCBSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5PlxuICAgIHwgUmVjb3JkPHN0cmluZywgYW55PlxuICAgIHwgc3RyaW5nXG59XG4iLCJpbXBvcnQgaW5kZXggZnJvbSAnLi4vY2pzL2luZGV4LmpzJ1xuY29uc3Qge1xuICBQb3N0Z3Jlc3RDbGllbnQsXG4gIFBvc3RncmVzdFF1ZXJ5QnVpbGRlcixcbiAgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcixcbiAgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcixcbiAgUG9zdGdyZXN0QnVpbGRlcixcbn0gPSBpbmRleFxuXG5leHBvcnQge1xuICBQb3N0Z3Jlc3RCdWlsZGVyLFxuICBQb3N0Z3Jlc3RDbGllbnQsXG4gIFBvc3RncmVzdEZpbHRlckJ1aWxkZXIsXG4gIFBvc3RncmVzdFF1ZXJ5QnVpbGRlcixcbiAgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcixcbn1cblxuLy8gY29tcGF0aWJpbGl0eSB3aXRoIENKUyBvdXRwdXRcbmV4cG9ydCBkZWZhdWx0IHtcbiAgUG9zdGdyZXN0Q2xpZW50LFxuICBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIsXG4gIFBvc3RncmVzdEZpbHRlckJ1aWxkZXIsXG4gIFBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXIsXG4gIFBvc3RncmVzdEJ1aWxkZXIsXG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUG9zdGdyZXN0QnVpbGRlciA9IGV4cG9ydHMuUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlciA9IGV4cG9ydHMuUG9zdGdyZXN0RmlsdGVyQnVpbGRlciA9IGV4cG9ydHMuUG9zdGdyZXN0UXVlcnlCdWlsZGVyID0gZXhwb3J0cy5Qb3N0Z3Jlc3RDbGllbnQgPSB2b2lkIDA7XG4vLyBBbHdheXMgdXBkYXRlIHdyYXBwZXIubWpzIHdoZW4gdXBkYXRpbmcgdGhpcyBmaWxlLlxuY29uc3QgUG9zdGdyZXN0Q2xpZW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vUG9zdGdyZXN0Q2xpZW50XCIpKTtcbmV4cG9ydHMuUG9zdGdyZXN0Q2xpZW50ID0gUG9zdGdyZXN0Q2xpZW50XzEuZGVmYXVsdDtcbmNvbnN0IFBvc3RncmVzdFF1ZXJ5QnVpbGRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1Bvc3RncmVzdFF1ZXJ5QnVpbGRlclwiKSk7XG5leHBvcnRzLlBvc3RncmVzdFF1ZXJ5QnVpbGRlciA9IFBvc3RncmVzdFF1ZXJ5QnVpbGRlcl8xLmRlZmF1bHQ7XG5jb25zdCBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vUG9zdGdyZXN0RmlsdGVyQnVpbGRlclwiKSk7XG5leHBvcnRzLlBvc3RncmVzdEZpbHRlckJ1aWxkZXIgPSBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyXzEuZGVmYXVsdDtcbmNvbnN0IFBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9Qb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyXCIpKTtcbmV4cG9ydHMuUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlciA9IFBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXJfMS5kZWZhdWx0O1xuY29uc3QgUG9zdGdyZXN0QnVpbGRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1Bvc3RncmVzdEJ1aWxkZXJcIikpO1xuZXhwb3J0cy5Qb3N0Z3Jlc3RCdWlsZGVyID0gUG9zdGdyZXN0QnVpbGRlcl8xLmRlZmF1bHQ7XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gICAgUG9zdGdyZXN0Q2xpZW50OiBQb3N0Z3Jlc3RDbGllbnRfMS5kZWZhdWx0LFxuICAgIFBvc3RncmVzdFF1ZXJ5QnVpbGRlcjogUG9zdGdyZXN0UXVlcnlCdWlsZGVyXzEuZGVmYXVsdCxcbiAgICBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyOiBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyXzEuZGVmYXVsdCxcbiAgICBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyOiBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyXzEuZGVmYXVsdCxcbiAgICBQb3N0Z3Jlc3RCdWlsZGVyOiBQb3N0Z3Jlc3RCdWlsZGVyXzEuZGVmYXVsdCxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIvLyBBbHdheXMgdXBkYXRlIHdyYXBwZXIubWpzIHdoZW4gdXBkYXRpbmcgdGhpcyBmaWxlLlxuaW1wb3J0IFBvc3RncmVzdENsaWVudCBmcm9tICcuL1Bvc3RncmVzdENsaWVudCdcbmltcG9ydCBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIgZnJvbSAnLi9Qb3N0Z3Jlc3RRdWVyeUJ1aWxkZXInXG5pbXBvcnQgUG9zdGdyZXN0RmlsdGVyQnVpbGRlciBmcm9tICcuL1Bvc3RncmVzdEZpbHRlckJ1aWxkZXInXG5pbXBvcnQgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlciBmcm9tICcuL1Bvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXInXG5pbXBvcnQgUG9zdGdyZXN0QnVpbGRlciBmcm9tICcuL1Bvc3RncmVzdEJ1aWxkZXInXG5cbmV4cG9ydCB7XG4gIFBvc3RncmVzdENsaWVudCxcbiAgUG9zdGdyZXN0UXVlcnlCdWlsZGVyLFxuICBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyLFxuICBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyLFxuICBQb3N0Z3Jlc3RCdWlsZGVyLFxufVxuZXhwb3J0IGRlZmF1bHQge1xuICBQb3N0Z3Jlc3RDbGllbnQsXG4gIFBvc3RncmVzdFF1ZXJ5QnVpbGRlcixcbiAgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcixcbiAgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcixcbiAgUG9zdGdyZXN0QnVpbGRlcixcbn1cbmV4cG9ydCB0eXBlIHtcbiAgUG9zdGdyZXN0UmVzcG9uc2UsXG4gIFBvc3RncmVzdFJlc3BvbnNlRmFpbHVyZSxcbiAgUG9zdGdyZXN0UmVzcG9uc2VTdWNjZXNzLFxuICBQb3N0Z3Jlc3RTaW5nbGVSZXNwb25zZSxcbiAgUG9zdGdyZXN0TWF5YmVTaW5nbGVSZXNwb25zZSxcbiAgUG9zdGdyZXN0RXJyb3IsXG59IGZyb20gJy4vdHlwZXMnXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFBvc3RncmVzdFF1ZXJ5QnVpbGRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1Bvc3RncmVzdFF1ZXJ5QnVpbGRlclwiKSk7XG5jb25zdCBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vUG9zdGdyZXN0RmlsdGVyQnVpbGRlclwiKSk7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbi8qKlxuICogUG9zdGdSRVNUIGNsaWVudC5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGFiYXNlIC0gVHlwZXMgZm9yIHRoZSBzY2hlbWEgZnJvbSB0aGUgW3R5cGVcbiAqIGdlbmVyYXRvcl0oaHR0cHM6Ly9zdXBhYmFzZS5jb20vZG9jcy9yZWZlcmVuY2UvamF2YXNjcmlwdC9uZXh0L3R5cGVzY3JpcHQtc3VwcG9ydClcbiAqXG4gKiBAdHlwZVBhcmFtIFNjaGVtYU5hbWUgLSBQb3N0Z3JlcyBzY2hlbWEgdG8gc3dpdGNoIHRvLiBNdXN0IGJlIGEgc3RyaW5nXG4gKiBsaXRlcmFsLCB0aGUgc2FtZSBvbmUgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3Rvci4gSWYgdGhlIHNjaGVtYSBpcyBub3RcbiAqIGBcInB1YmxpY1wiYCwgdGhpcyBtdXN0IGJlIHN1cHBsaWVkIG1hbnVhbGx5LlxuICovXG5jbGFzcyBQb3N0Z3Jlc3RDbGllbnQge1xuICAgIC8vIFRPRE86IEFkZCBiYWNrIHNob3VsZFRocm93T25FcnJvciBvbmNlIHdlIGZpZ3VyZSBvdXQgdGhlIHR5cGluZ3NcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgUG9zdGdSRVNUIGNsaWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1cmwgLSBVUkwgb2YgdGhlIFBvc3RnUkVTVCBlbmRwb2ludFxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLmhlYWRlcnMgLSBDdXN0b20gaGVhZGVyc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLnNjaGVtYSAtIFBvc3RncmVzIHNjaGVtYSB0byBzd2l0Y2ggdG9cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5mZXRjaCAtIEN1c3RvbSBmZXRjaFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHVybCwgeyBoZWFkZXJzID0ge30sIHNjaGVtYSwgZmV0Y2gsIH0gPSB7fSkge1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb25zdGFudHNfMS5ERUZBVUxUX0hFQURFUlMpLCBoZWFkZXJzKTtcbiAgICAgICAgdGhpcy5zY2hlbWFOYW1lID0gc2NoZW1hO1xuICAgICAgICB0aGlzLmZldGNoID0gZmV0Y2g7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYSBxdWVyeSBvbiBhIHRhYmxlIG9yIGEgdmlldy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZWxhdGlvbiAtIFRoZSB0YWJsZSBvciB2aWV3IG5hbWUgdG8gcXVlcnlcbiAgICAgKi9cbiAgICBmcm9tKHJlbGF0aW9uKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYCR7dGhpcy51cmx9LyR7cmVsYXRpb259YCk7XG4gICAgICAgIHJldHVybiBuZXcgUG9zdGdyZXN0UXVlcnlCdWlsZGVyXzEuZGVmYXVsdCh1cmwsIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuaGVhZGVycyksXG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hTmFtZSxcbiAgICAgICAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VsZWN0IGEgc2NoZW1hIHRvIHF1ZXJ5IG9yIHBlcmZvcm0gYW4gZnVuY3Rpb24gKHJwYykgY2FsbC5cbiAgICAgKlxuICAgICAqIFRoZSBzY2hlbWEgbmVlZHMgdG8gYmUgb24gdGhlIGxpc3Qgb2YgZXhwb3NlZCBzY2hlbWFzIGluc2lkZSBTdXBhYmFzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzY2hlbWEgLSBUaGUgc2NoZW1hIHRvIHF1ZXJ5XG4gICAgICovXG4gICAgc2NoZW1hKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gbmV3IFBvc3RncmVzdENsaWVudCh0aGlzLnVybCwge1xuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGEgZnVuY3Rpb24gY2FsbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmbiAtIFRoZSBmdW5jdGlvbiBuYW1lIHRvIGNhbGxcbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgZnVuY3Rpb24gY2FsbFxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLmhlYWQgLSBXaGVuIHNldCB0byBgdHJ1ZWAsIGBkYXRhYCB3aWxsIG5vdCBiZSByZXR1cm5lZC5cbiAgICAgKiBVc2VmdWwgaWYgeW91IG9ubHkgbmVlZCB0aGUgY291bnQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZ2V0IC0gV2hlbiBzZXQgdG8gYHRydWVgLCB0aGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2l0aFxuICAgICAqIHJlYWQtb25seSBhY2Nlc3MgbW9kZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jb3VudCAtIENvdW50IGFsZ29yaXRobSB0byB1c2UgdG8gY291bnQgcm93cyByZXR1cm5lZCBieSB0aGVcbiAgICAgKiBmdW5jdGlvbi4gT25seSBhcHBsaWNhYmxlIGZvciBbc2V0LXJldHVybmluZ1xuICAgICAqIGZ1bmN0aW9uc10oaHR0cHM6Ly93d3cucG9zdGdyZXNxbC5vcmcvZG9jcy9jdXJyZW50L2Z1bmN0aW9ucy1zcmYuaHRtbCkuXG4gICAgICpcbiAgICAgKiBgXCJleGFjdFwiYDogRXhhY3QgYnV0IHNsb3cgY291bnQgYWxnb3JpdGhtLiBQZXJmb3JtcyBhIGBDT1VOVCgqKWAgdW5kZXIgdGhlXG4gICAgICogaG9vZC5cbiAgICAgKlxuICAgICAqIGBcInBsYW5uZWRcImA6IEFwcHJveGltYXRlZCBidXQgZmFzdCBjb3VudCBhbGdvcml0aG0uIFVzZXMgdGhlIFBvc3RncmVzXG4gICAgICogc3RhdGlzdGljcyB1bmRlciB0aGUgaG9vZC5cbiAgICAgKlxuICAgICAqIGBcImVzdGltYXRlZFwiYDogVXNlcyBleGFjdCBjb3VudCBmb3IgbG93IG51bWJlcnMgYW5kIHBsYW5uZWQgY291bnQgZm9yIGhpZ2hcbiAgICAgKiBudW1iZXJzLlxuICAgICAqL1xuICAgIHJwYyhmbiwgYXJncyA9IHt9LCB7IGhlYWQgPSBmYWxzZSwgZ2V0ID0gZmFsc2UsIGNvdW50LCB9ID0ge30pIHtcbiAgICAgICAgbGV0IG1ldGhvZDtcbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChgJHt0aGlzLnVybH0vcnBjLyR7Zm59YCk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAoaGVhZCB8fCBnZXQpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9IGhlYWQgPyAnSEVBRCcgOiAnR0VUJztcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGFyZ3MpXG4gICAgICAgICAgICAgICAgLy8gcGFyYW1zIHdpdGggdW5kZWZpbmVkIHZhbHVlIG5lZWRzIHRvIGJlIGZpbHRlcmVkIG91dCwgb3RoZXJ3aXNlIGl0J2xsXG4gICAgICAgICAgICAgICAgLy8gc2hvdyB1cCBhcyBgP3BhcmFtPXVuZGVmaW5lZGBcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChbXywgdmFsdWVdKSA9PiB2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIC8vIGFycmF5IHZhbHVlcyBuZWVkIHNwZWNpYWwgc3ludGF4XG4gICAgICAgICAgICAgICAgLm1hcCgoW25hbWUsIHZhbHVlXSkgPT4gW25hbWUsIEFycmF5LmlzQXJyYXkodmFsdWUpID8gYHske3ZhbHVlLmpvaW4oJywnKX19YCA6IGAke3ZhbHVlfWBdKVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKChbbmFtZSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgICAgICBib2R5ID0gYXJncztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5oZWFkZXJzKTtcbiAgICAgICAgaWYgKGNvdW50KSB7XG4gICAgICAgICAgICBoZWFkZXJzWydQcmVmZXInXSA9IGBjb3VudD0ke2NvdW50fWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyXzEuZGVmYXVsdCh7XG4gICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgc2NoZW1hOiB0aGlzLnNjaGVtYU5hbWUsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgICAgICAgICBhbGxvd0VtcHR5OiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gUG9zdGdyZXN0Q2xpZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UG9zdGdyZXN0Q2xpZW50LmpzLm1hcCIsImltcG9ydCBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIgZnJvbSAnLi9Qb3N0Z3Jlc3RRdWVyeUJ1aWxkZXInXG5pbXBvcnQgUG9zdGdyZXN0RmlsdGVyQnVpbGRlciBmcm9tICcuL1Bvc3RncmVzdEZpbHRlckJ1aWxkZXInXG5pbXBvcnQgUG9zdGdyZXN0QnVpbGRlciBmcm9tICcuL1Bvc3RncmVzdEJ1aWxkZXInXG5pbXBvcnQgeyBERUZBVUxUX0hFQURFUlMgfSBmcm9tICcuL2NvbnN0YW50cydcbmltcG9ydCB7IEZldGNoLCBHZW5lcmljU2NoZW1hIH0gZnJvbSAnLi90eXBlcydcblxuLyoqXG4gKiBQb3N0Z1JFU1QgY2xpZW50LlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0YWJhc2UgLSBUeXBlcyBmb3IgdGhlIHNjaGVtYSBmcm9tIHRoZSBbdHlwZVxuICogZ2VuZXJhdG9yXShodHRwczovL3N1cGFiYXNlLmNvbS9kb2NzL3JlZmVyZW5jZS9qYXZhc2NyaXB0L25leHQvdHlwZXNjcmlwdC1zdXBwb3J0KVxuICpcbiAqIEB0eXBlUGFyYW0gU2NoZW1hTmFtZSAtIFBvc3RncmVzIHNjaGVtYSB0byBzd2l0Y2ggdG8uIE11c3QgYmUgYSBzdHJpbmdcbiAqIGxpdGVyYWwsIHRoZSBzYW1lIG9uZSBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLiBJZiB0aGUgc2NoZW1hIGlzIG5vdFxuICogYFwicHVibGljXCJgLCB0aGlzIG11c3QgYmUgc3VwcGxpZWQgbWFudWFsbHkuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvc3RncmVzdENsaWVudDxcbiAgRGF0YWJhc2UgPSBhbnksXG4gIFNjaGVtYU5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBEYXRhYmFzZSA9ICdwdWJsaWMnIGV4dGVuZHMga2V5b2YgRGF0YWJhc2VcbiAgICA/ICdwdWJsaWMnXG4gICAgOiBzdHJpbmcgJiBrZXlvZiBEYXRhYmFzZSxcbiAgU2NoZW1hIGV4dGVuZHMgR2VuZXJpY1NjaGVtYSA9IERhdGFiYXNlW1NjaGVtYU5hbWVdIGV4dGVuZHMgR2VuZXJpY1NjaGVtYVxuICAgID8gRGF0YWJhc2VbU2NoZW1hTmFtZV1cbiAgICA6IGFueVxuPiB7XG4gIHVybDogc3RyaW5nXG4gIGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgc2NoZW1hTmFtZT86IFNjaGVtYU5hbWVcbiAgZmV0Y2g/OiBGZXRjaFxuXG4gIC8vIFRPRE86IEFkZCBiYWNrIHNob3VsZFRocm93T25FcnJvciBvbmNlIHdlIGZpZ3VyZSBvdXQgdGhlIHR5cGluZ3NcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBQb3N0Z1JFU1QgY2xpZW50LlxuICAgKlxuICAgKiBAcGFyYW0gdXJsIC0gVVJMIG9mIHRoZSBQb3N0Z1JFU1QgZW5kcG9pbnRcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSBvcHRpb25zLmhlYWRlcnMgLSBDdXN0b20gaGVhZGVyc1xuICAgKiBAcGFyYW0gb3B0aW9ucy5zY2hlbWEgLSBQb3N0Z3JlcyBzY2hlbWEgdG8gc3dpdGNoIHRvXG4gICAqIEBwYXJhbSBvcHRpb25zLmZldGNoIC0gQ3VzdG9tIGZldGNoXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICB1cmw6IHN0cmluZyxcbiAgICB7XG4gICAgICBoZWFkZXJzID0ge30sXG4gICAgICBzY2hlbWEsXG4gICAgICBmZXRjaCxcbiAgICB9OiB7XG4gICAgICBoZWFkZXJzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuICAgICAgc2NoZW1hPzogU2NoZW1hTmFtZVxuICAgICAgZmV0Y2g/OiBGZXRjaFxuICAgIH0gPSB7fVxuICApIHtcbiAgICB0aGlzLnVybCA9IHVybFxuICAgIHRoaXMuaGVhZGVycyA9IHsgLi4uREVGQVVMVF9IRUFERVJTLCAuLi5oZWFkZXJzIH1cbiAgICB0aGlzLnNjaGVtYU5hbWUgPSBzY2hlbWFcbiAgICB0aGlzLmZldGNoID0gZmV0Y2hcbiAgfVxuXG4gIGZyb208XG4gICAgVGFibGVOYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgU2NoZW1hWydUYWJsZXMnXSxcbiAgICBUYWJsZSBleHRlbmRzIFNjaGVtYVsnVGFibGVzJ11bVGFibGVOYW1lXVxuICA+KHJlbGF0aW9uOiBUYWJsZU5hbWUpOiBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXI8U2NoZW1hLCBUYWJsZSwgVGFibGVOYW1lPlxuICBmcm9tPFZpZXdOYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgU2NoZW1hWydWaWV3cyddLCBWaWV3IGV4dGVuZHMgU2NoZW1hWydWaWV3cyddW1ZpZXdOYW1lXT4oXG4gICAgcmVsYXRpb246IFZpZXdOYW1lXG4gICk6IFBvc3RncmVzdFF1ZXJ5QnVpbGRlcjxTY2hlbWEsIFZpZXcsIFZpZXdOYW1lPlxuICAvKipcbiAgICogUGVyZm9ybSBhIHF1ZXJ5IG9uIGEgdGFibGUgb3IgYSB2aWV3LlxuICAgKlxuICAgKiBAcGFyYW0gcmVsYXRpb24gLSBUaGUgdGFibGUgb3IgdmlldyBuYW1lIHRvIHF1ZXJ5XG4gICAqL1xuICBmcm9tKHJlbGF0aW9uOiBzdHJpbmcpOiBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXI8U2NoZW1hLCBhbnksIGFueT4ge1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYCR7dGhpcy51cmx9LyR7cmVsYXRpb259YClcbiAgICByZXR1cm4gbmV3IFBvc3RncmVzdFF1ZXJ5QnVpbGRlcih1cmwsIHtcbiAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzIH0sXG4gICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hTmFtZSxcbiAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogU2VsZWN0IGEgc2NoZW1hIHRvIHF1ZXJ5IG9yIHBlcmZvcm0gYW4gZnVuY3Rpb24gKHJwYykgY2FsbC5cbiAgICpcbiAgICogVGhlIHNjaGVtYSBuZWVkcyB0byBiZSBvbiB0aGUgbGlzdCBvZiBleHBvc2VkIHNjaGVtYXMgaW5zaWRlIFN1cGFiYXNlLlxuICAgKlxuICAgKiBAcGFyYW0gc2NoZW1hIC0gVGhlIHNjaGVtYSB0byBxdWVyeVxuICAgKi9cbiAgc2NoZW1hPER5bmFtaWNTY2hlbWEgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBEYXRhYmFzZT4oXG4gICAgc2NoZW1hOiBEeW5hbWljU2NoZW1hXG4gICk6IFBvc3RncmVzdENsaWVudDxcbiAgICBEYXRhYmFzZSxcbiAgICBEeW5hbWljU2NoZW1hLFxuICAgIERhdGFiYXNlW0R5bmFtaWNTY2hlbWFdIGV4dGVuZHMgR2VuZXJpY1NjaGVtYSA/IERhdGFiYXNlW0R5bmFtaWNTY2hlbWFdIDogYW55XG4gID4ge1xuICAgIHJldHVybiBuZXcgUG9zdGdyZXN0Q2xpZW50KHRoaXMudXJsLCB7XG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICBzY2hlbWEsXG4gICAgICBmZXRjaDogdGhpcy5mZXRjaCxcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gYSBmdW5jdGlvbiBjYWxsLlxuICAgKlxuICAgKiBAcGFyYW0gZm4gLSBUaGUgZnVuY3Rpb24gbmFtZSB0byBjYWxsXG4gICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBmdW5jdGlvbiBjYWxsXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0gb3B0aW9ucy5oZWFkIC0gV2hlbiBzZXQgdG8gYHRydWVgLCBgZGF0YWAgd2lsbCBub3QgYmUgcmV0dXJuZWQuXG4gICAqIFVzZWZ1bCBpZiB5b3Ugb25seSBuZWVkIHRoZSBjb3VudC5cbiAgICogQHBhcmFtIG9wdGlvbnMuZ2V0IC0gV2hlbiBzZXQgdG8gYHRydWVgLCB0aGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2l0aFxuICAgKiByZWFkLW9ubHkgYWNjZXNzIG1vZGUuXG4gICAqIEBwYXJhbSBvcHRpb25zLmNvdW50IC0gQ291bnQgYWxnb3JpdGhtIHRvIHVzZSB0byBjb3VudCByb3dzIHJldHVybmVkIGJ5IHRoZVxuICAgKiBmdW5jdGlvbi4gT25seSBhcHBsaWNhYmxlIGZvciBbc2V0LXJldHVybmluZ1xuICAgKiBmdW5jdGlvbnNdKGh0dHBzOi8vd3d3LnBvc3RncmVzcWwub3JnL2RvY3MvY3VycmVudC9mdW5jdGlvbnMtc3JmLmh0bWwpLlxuICAgKlxuICAgKiBgXCJleGFjdFwiYDogRXhhY3QgYnV0IHNsb3cgY291bnQgYWxnb3JpdGhtLiBQZXJmb3JtcyBhIGBDT1VOVCgqKWAgdW5kZXIgdGhlXG4gICAqIGhvb2QuXG4gICAqXG4gICAqIGBcInBsYW5uZWRcImA6IEFwcHJveGltYXRlZCBidXQgZmFzdCBjb3VudCBhbGdvcml0aG0uIFVzZXMgdGhlIFBvc3RncmVzXG4gICAqIHN0YXRpc3RpY3MgdW5kZXIgdGhlIGhvb2QuXG4gICAqXG4gICAqIGBcImVzdGltYXRlZFwiYDogVXNlcyBleGFjdCBjb3VudCBmb3IgbG93IG51bWJlcnMgYW5kIHBsYW5uZWQgY291bnQgZm9yIGhpZ2hcbiAgICogbnVtYmVycy5cbiAgICovXG4gIHJwYzxGbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBTY2hlbWFbJ0Z1bmN0aW9ucyddLCBGbiBleHRlbmRzIFNjaGVtYVsnRnVuY3Rpb25zJ11bRm5OYW1lXT4oXG4gICAgZm46IEZuTmFtZSxcbiAgICBhcmdzOiBGblsnQXJncyddID0ge30sXG4gICAge1xuICAgICAgaGVhZCA9IGZhbHNlLFxuICAgICAgZ2V0ID0gZmFsc2UsXG4gICAgICBjb3VudCxcbiAgICB9OiB7XG4gICAgICBoZWFkPzogYm9vbGVhblxuICAgICAgZ2V0PzogYm9vbGVhblxuICAgICAgY291bnQ/OiAnZXhhY3QnIHwgJ3BsYW5uZWQnIHwgJ2VzdGltYXRlZCdcbiAgICB9ID0ge31cbiAgKTogUG9zdGdyZXN0RmlsdGVyQnVpbGRlcjxcbiAgICBTY2hlbWEsXG4gICAgRm5bJ1JldHVybnMnXSBleHRlbmRzIGFueVtdXG4gICAgICA/IEZuWydSZXR1cm5zJ11bbnVtYmVyXSBleHRlbmRzIFJlY29yZDxzdHJpbmcsIHVua25vd24+XG4gICAgICAgID8gRm5bJ1JldHVybnMnXVtudW1iZXJdXG4gICAgICAgIDogbmV2ZXJcbiAgICAgIDogbmV2ZXIsXG4gICAgRm5bJ1JldHVybnMnXVxuICA+IHtcbiAgICBsZXQgbWV0aG9kOiAnSEVBRCcgfCAnR0VUJyB8ICdQT1NUJ1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYCR7dGhpcy51cmx9L3JwYy8ke2ZufWApXG4gICAgbGV0IGJvZHk6IHVua25vd24gfCB1bmRlZmluZWRcbiAgICBpZiAoaGVhZCB8fCBnZXQpIHtcbiAgICAgIG1ldGhvZCA9IGhlYWQgPyAnSEVBRCcgOiAnR0VUJ1xuICAgICAgT2JqZWN0LmVudHJpZXMoYXJncylcbiAgICAgICAgLy8gcGFyYW1zIHdpdGggdW5kZWZpbmVkIHZhbHVlIG5lZWRzIHRvIGJlIGZpbHRlcmVkIG91dCwgb3RoZXJ3aXNlIGl0J2xsXG4gICAgICAgIC8vIHNob3cgdXAgYXMgYD9wYXJhbT11bmRlZmluZWRgXG4gICAgICAgIC5maWx0ZXIoKFtfLCB2YWx1ZV0pID0+IHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgIC8vIGFycmF5IHZhbHVlcyBuZWVkIHNwZWNpYWwgc3ludGF4XG4gICAgICAgIC5tYXAoKFtuYW1lLCB2YWx1ZV0pID0+IFtuYW1lLCBBcnJheS5pc0FycmF5KHZhbHVlKSA/IGB7JHt2YWx1ZS5qb2luKCcsJyl9fWAgOiBgJHt2YWx1ZX1gXSlcbiAgICAgICAgLmZvckVhY2goKFtuYW1lLCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChuYW1lLCB2YWx1ZSlcbiAgICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgbWV0aG9kID0gJ1BPU1QnXG4gICAgICBib2R5ID0gYXJnc1xuICAgIH1cblxuICAgIGNvbnN0IGhlYWRlcnMgPSB7IC4uLnRoaXMuaGVhZGVycyB9XG4gICAgaWYgKGNvdW50KSB7XG4gICAgICBoZWFkZXJzWydQcmVmZXInXSA9IGBjb3VudD0ke2NvdW50fWBcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFBvc3RncmVzdEZpbHRlckJ1aWxkZXIoe1xuICAgICAgbWV0aG9kLFxuICAgICAgdXJsLFxuICAgICAgaGVhZGVycyxcbiAgICAgIHNjaGVtYTogdGhpcy5zY2hlbWFOYW1lLFxuICAgICAgYm9keSxcbiAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgICAgYWxsb3dFbXB0eTogZmFsc2UsXG4gICAgfSBhcyB1bmtub3duIGFzIFBvc3RncmVzdEJ1aWxkZXI8Rm5bJ1JldHVybnMnXT4pXG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1Bvc3RncmVzdEZpbHRlckJ1aWxkZXJcIikpO1xuY2xhc3MgUG9zdGdyZXN0UXVlcnlCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih1cmwsIHsgaGVhZGVycyA9IHt9LCBzY2hlbWEsIGZldGNoLCB9KSB7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgdGhpcy5mZXRjaCA9IGZldGNoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGEgU0VMRUNUIHF1ZXJ5IG9uIHRoZSB0YWJsZSBvciB2aWV3LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbnMgLSBUaGUgY29sdW1ucyB0byByZXRyaWV2ZSwgc2VwYXJhdGVkIGJ5IGNvbW1hcy4gQ29sdW1ucyBjYW4gYmUgcmVuYW1lZCB3aGVuIHJldHVybmVkIHdpdGggYGN1c3RvbU5hbWU6Y29sdW1uTmFtZWBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMuaGVhZCAtIFdoZW4gc2V0IHRvIGB0cnVlYCwgYGRhdGFgIHdpbGwgbm90IGJlIHJldHVybmVkLlxuICAgICAqIFVzZWZ1bCBpZiB5b3Ugb25seSBuZWVkIHRoZSBjb3VudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmNvdW50IC0gQ291bnQgYWxnb3JpdGhtIHRvIHVzZSB0byBjb3VudCByb3dzIGluIHRoZSB0YWJsZSBvciB2aWV3LlxuICAgICAqXG4gICAgICogYFwiZXhhY3RcImA6IEV4YWN0IGJ1dCBzbG93IGNvdW50IGFsZ29yaXRobS4gUGVyZm9ybXMgYSBgQ09VTlQoKilgIHVuZGVyIHRoZVxuICAgICAqIGhvb2QuXG4gICAgICpcbiAgICAgKiBgXCJwbGFubmVkXCJgOiBBcHByb3hpbWF0ZWQgYnV0IGZhc3QgY291bnQgYWxnb3JpdGhtLiBVc2VzIHRoZSBQb3N0Z3Jlc1xuICAgICAqIHN0YXRpc3RpY3MgdW5kZXIgdGhlIGhvb2QuXG4gICAgICpcbiAgICAgKiBgXCJlc3RpbWF0ZWRcImA6IFVzZXMgZXhhY3QgY291bnQgZm9yIGxvdyBudW1iZXJzIGFuZCBwbGFubmVkIGNvdW50IGZvciBoaWdoXG4gICAgICogbnVtYmVycy5cbiAgICAgKi9cbiAgICBzZWxlY3QoY29sdW1ucywgeyBoZWFkID0gZmFsc2UsIGNvdW50LCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gaGVhZCA/ICdIRUFEJyA6ICdHRVQnO1xuICAgICAgICAvLyBSZW1vdmUgd2hpdGVzcGFjZXMgZXhjZXB0IHdoZW4gcXVvdGVkXG4gICAgICAgIGxldCBxdW90ZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgY2xlYW5lZENvbHVtbnMgPSAoY29sdW1ucyAhPT0gbnVsbCAmJiBjb2x1bW5zICE9PSB2b2lkIDAgPyBjb2x1bW5zIDogJyonKVxuICAgICAgICAgICAgLnNwbGl0KCcnKVxuICAgICAgICAgICAgLm1hcCgoYykgPT4ge1xuICAgICAgICAgICAgaWYgKC9cXHMvLnRlc3QoYykgJiYgIXF1b3RlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjID09PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgcXVvdGVkID0gIXF1b3RlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oJycpO1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KCdzZWxlY3QnLCBjbGVhbmVkQ29sdW1ucyk7XG4gICAgICAgIGlmIChjb3VudCkge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzWydQcmVmZXInXSA9IGBjb3VudD0ke2NvdW50fWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyXzEuZGVmYXVsdCh7XG4gICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2NoZW1hOiB0aGlzLnNjaGVtYSxcbiAgICAgICAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgICAgICAgICAgYWxsb3dFbXB0eTogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGFuIElOU0VSVCBpbnRvIHRoZSB0YWJsZSBvciB2aWV3LlxuICAgICAqXG4gICAgICogQnkgZGVmYXVsdCwgaW5zZXJ0ZWQgcm93cyBhcmUgbm90IHJldHVybmVkLiBUbyByZXR1cm4gaXQsIGNoYWluIHRoZSBjYWxsXG4gICAgICogd2l0aCBgLnNlbGVjdCgpYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgdmFsdWVzIHRvIGluc2VydC4gUGFzcyBhbiBvYmplY3QgdG8gaW5zZXJ0IGEgc2luZ2xlIHJvd1xuICAgICAqIG9yIGFuIGFycmF5IHRvIGluc2VydCBtdWx0aXBsZSByb3dzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jb3VudCAtIENvdW50IGFsZ29yaXRobSB0byB1c2UgdG8gY291bnQgaW5zZXJ0ZWQgcm93cy5cbiAgICAgKlxuICAgICAqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcbiAgICAgKiBob29kLlxuICAgICAqXG4gICAgICogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcbiAgICAgKiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuICAgICAqXG4gICAgICogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuICAgICAqIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5kZWZhdWx0VG9OdWxsIC0gTWFrZSBtaXNzaW5nIGZpZWxkcyBkZWZhdWx0IHRvIGBudWxsYC5cbiAgICAgKiBPdGhlcndpc2UsIHVzZSB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIGNvbHVtbi4gT25seSBhcHBsaWVzIGZvciBidWxrXG4gICAgICogaW5zZXJ0cy5cbiAgICAgKi9cbiAgICBpbnNlcnQodmFsdWVzLCB7IGNvdW50LCBkZWZhdWx0VG9OdWxsID0gdHJ1ZSwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgY29uc3QgcHJlZmVyc0hlYWRlcnMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuaGVhZGVyc1snUHJlZmVyJ10pIHtcbiAgICAgICAgICAgIHByZWZlcnNIZWFkZXJzLnB1c2godGhpcy5oZWFkZXJzWydQcmVmZXInXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50KSB7XG4gICAgICAgICAgICBwcmVmZXJzSGVhZGVycy5wdXNoKGBjb3VudD0ke2NvdW50fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVmYXVsdFRvTnVsbCkge1xuICAgICAgICAgICAgcHJlZmVyc0hlYWRlcnMucHVzaCgnbWlzc2luZz1kZWZhdWx0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oZWFkZXJzWydQcmVmZXInXSA9IHByZWZlcnNIZWFkZXJzLmpvaW4oJywnKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICAgICAgY29uc3QgY29sdW1ucyA9IHZhbHVlcy5yZWR1Y2UoKGFjYywgeCkgPT4gYWNjLmNvbmNhdChPYmplY3Qua2V5cyh4KSksIFtdKTtcbiAgICAgICAgICAgIGlmIChjb2x1bW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1bmlxdWVDb2x1bW5zID0gWy4uLm5ldyBTZXQoY29sdW1ucyldLm1hcCgoY29sdW1uKSA9PiBgXCIke2NvbHVtbn1cImApO1xuICAgICAgICAgICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2NvbHVtbnMnLCB1bmlxdWVDb2x1bW5zLmpvaW4oJywnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyXzEuZGVmYXVsdCh7XG4gICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2NoZW1hOiB0aGlzLnNjaGVtYSxcbiAgICAgICAgICAgIGJvZHk6IHZhbHVlcyxcbiAgICAgICAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgICAgICAgICAgYWxsb3dFbXB0eTogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGFuIFVQU0VSVCBvbiB0aGUgdGFibGUgb3Igdmlldy4gRGVwZW5kaW5nIG9uIHRoZSBjb2x1bW4ocykgcGFzc2VkXG4gICAgICogdG8gYG9uQ29uZmxpY3RgLCBgLnVwc2VydCgpYCBhbGxvd3MgeW91IHRvIHBlcmZvcm0gdGhlIGVxdWl2YWxlbnQgb2ZcbiAgICAgKiBgLmluc2VydCgpYCBpZiBhIHJvdyB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIGBvbkNvbmZsaWN0YCBjb2x1bW5zIGRvZXNuJ3RcbiAgICAgKiBleGlzdCwgb3IgaWYgaXQgZG9lcyBleGlzdCwgcGVyZm9ybSBhbiBhbHRlcm5hdGl2ZSBhY3Rpb24gZGVwZW5kaW5nIG9uXG4gICAgICogYGlnbm9yZUR1cGxpY2F0ZXNgLlxuICAgICAqXG4gICAgICogQnkgZGVmYXVsdCwgdXBzZXJ0ZWQgcm93cyBhcmUgbm90IHJldHVybmVkLiBUbyByZXR1cm4gaXQsIGNoYWluIHRoZSBjYWxsXG4gICAgICogd2l0aCBgLnNlbGVjdCgpYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgdmFsdWVzIHRvIHVwc2VydCB3aXRoLiBQYXNzIGFuIG9iamVjdCB0byB1cHNlcnQgYVxuICAgICAqIHNpbmdsZSByb3cgb3IgYW4gYXJyYXkgdG8gdXBzZXJ0IG11bHRpcGxlIHJvd3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm9uQ29uZmxpY3QgLSBDb21tYS1zZXBhcmF0ZWQgVU5JUVVFIGNvbHVtbihzKSB0byBzcGVjaWZ5IGhvd1xuICAgICAqIGR1cGxpY2F0ZSByb3dzIGFyZSBkZXRlcm1pbmVkLiBUd28gcm93cyBhcmUgZHVwbGljYXRlcyBpZiBhbGwgdGhlXG4gICAgICogYG9uQ29uZmxpY3RgIGNvbHVtbnMgYXJlIGVxdWFsLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMuaWdub3JlRHVwbGljYXRlcyAtIElmIGB0cnVlYCwgZHVwbGljYXRlIHJvd3MgYXJlIGlnbm9yZWQuIElmXG4gICAgICogYGZhbHNlYCwgZHVwbGljYXRlIHJvd3MgYXJlIG1lcmdlZCB3aXRoIGV4aXN0aW5nIHJvd3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jb3VudCAtIENvdW50IGFsZ29yaXRobSB0byB1c2UgdG8gY291bnQgdXBzZXJ0ZWQgcm93cy5cbiAgICAgKlxuICAgICAqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcbiAgICAgKiBob29kLlxuICAgICAqXG4gICAgICogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcbiAgICAgKiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuICAgICAqXG4gICAgICogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuICAgICAqIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5kZWZhdWx0VG9OdWxsIC0gTWFrZSBtaXNzaW5nIGZpZWxkcyBkZWZhdWx0IHRvIGBudWxsYC5cbiAgICAgKiBPdGhlcndpc2UsIHVzZSB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIGNvbHVtbi4gVGhpcyBvbmx5IGFwcGxpZXMgd2hlblxuICAgICAqIGluc2VydGluZyBuZXcgcm93cywgbm90IHdoZW4gbWVyZ2luZyB3aXRoIGV4aXN0aW5nIHJvd3MgdW5kZXJcbiAgICAgKiBgaWdub3JlRHVwbGljYXRlczogZmFsc2VgLiBUaGlzIGFsc28gb25seSBhcHBsaWVzIHdoZW4gZG9pbmcgYnVsayB1cHNlcnRzLlxuICAgICAqL1xuICAgIHVwc2VydCh2YWx1ZXMsIHsgb25Db25mbGljdCwgaWdub3JlRHVwbGljYXRlcyA9IGZhbHNlLCBjb3VudCwgZGVmYXVsdFRvTnVsbCA9IHRydWUsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGNvbnN0IHByZWZlcnNIZWFkZXJzID0gW2ByZXNvbHV0aW9uPSR7aWdub3JlRHVwbGljYXRlcyA/ICdpZ25vcmUnIDogJ21lcmdlJ30tZHVwbGljYXRlc2BdO1xuICAgICAgICBpZiAob25Db25mbGljdCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldCgnb25fY29uZmxpY3QnLCBvbkNvbmZsaWN0KTtcbiAgICAgICAgaWYgKHRoaXMuaGVhZGVyc1snUHJlZmVyJ10pIHtcbiAgICAgICAgICAgIHByZWZlcnNIZWFkZXJzLnB1c2godGhpcy5oZWFkZXJzWydQcmVmZXInXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50KSB7XG4gICAgICAgICAgICBwcmVmZXJzSGVhZGVycy5wdXNoKGBjb3VudD0ke2NvdW50fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVmYXVsdFRvTnVsbCkge1xuICAgICAgICAgICAgcHJlZmVyc0hlYWRlcnMucHVzaCgnbWlzc2luZz1kZWZhdWx0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oZWFkZXJzWydQcmVmZXInXSA9IHByZWZlcnNIZWFkZXJzLmpvaW4oJywnKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICAgICAgY29uc3QgY29sdW1ucyA9IHZhbHVlcy5yZWR1Y2UoKGFjYywgeCkgPT4gYWNjLmNvbmNhdChPYmplY3Qua2V5cyh4KSksIFtdKTtcbiAgICAgICAgICAgIGlmIChjb2x1bW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1bmlxdWVDb2x1bW5zID0gWy4uLm5ldyBTZXQoY29sdW1ucyldLm1hcCgoY29sdW1uKSA9PiBgXCIke2NvbHVtbn1cImApO1xuICAgICAgICAgICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2NvbHVtbnMnLCB1bmlxdWVDb2x1bW5zLmpvaW4oJywnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyXzEuZGVmYXVsdCh7XG4gICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2NoZW1hOiB0aGlzLnNjaGVtYSxcbiAgICAgICAgICAgIGJvZHk6IHZhbHVlcyxcbiAgICAgICAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgICAgICAgICAgYWxsb3dFbXB0eTogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGFuIFVQREFURSBvbiB0aGUgdGFibGUgb3Igdmlldy5cbiAgICAgKlxuICAgICAqIEJ5IGRlZmF1bHQsIHVwZGF0ZWQgcm93cyBhcmUgbm90IHJldHVybmVkLiBUbyByZXR1cm4gaXQsIGNoYWluIHRoZSBjYWxsXG4gICAgICogd2l0aCBgLnNlbGVjdCgpYCBhZnRlciBmaWx0ZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlcyAtIFRoZSB2YWx1ZXMgdG8gdXBkYXRlIHdpdGhcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IHVwZGF0ZWQgcm93cy5cbiAgICAgKlxuICAgICAqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcbiAgICAgKiBob29kLlxuICAgICAqXG4gICAgICogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcbiAgICAgKiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuICAgICAqXG4gICAgICogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuICAgICAqIG51bWJlcnMuXG4gICAgICovXG4gICAgdXBkYXRlKHZhbHVlcywgeyBjb3VudCwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQQVRDSCc7XG4gICAgICAgIGNvbnN0IHByZWZlcnNIZWFkZXJzID0gW107XG4gICAgICAgIGlmICh0aGlzLmhlYWRlcnNbJ1ByZWZlciddKSB7XG4gICAgICAgICAgICBwcmVmZXJzSGVhZGVycy5wdXNoKHRoaXMuaGVhZGVyc1snUHJlZmVyJ10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3VudCkge1xuICAgICAgICAgICAgcHJlZmVyc0hlYWRlcnMucHVzaChgY291bnQ9JHtjb3VudH1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhlYWRlcnNbJ1ByZWZlciddID0gcHJlZmVyc0hlYWRlcnMuam9pbignLCcpO1xuICAgICAgICByZXR1cm4gbmV3IFBvc3RncmVzdEZpbHRlckJ1aWxkZXJfMS5kZWZhdWx0KHtcbiAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgICAgICAgYm9keTogdmFsdWVzLFxuICAgICAgICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgICAgICAgICBhbGxvd0VtcHR5OiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYSBERUxFVEUgb24gdGhlIHRhYmxlIG9yIHZpZXcuXG4gICAgICpcbiAgICAgKiBCeSBkZWZhdWx0LCBkZWxldGVkIHJvd3MgYXJlIG5vdCByZXR1cm5lZC4gVG8gcmV0dXJuIGl0LCBjaGFpbiB0aGUgY2FsbFxuICAgICAqIHdpdGggYC5zZWxlY3QoKWAgYWZ0ZXIgZmlsdGVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IGRlbGV0ZWQgcm93cy5cbiAgICAgKlxuICAgICAqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcbiAgICAgKiBob29kLlxuICAgICAqXG4gICAgICogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcbiAgICAgKiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuICAgICAqXG4gICAgICogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuICAgICAqIG51bWJlcnMuXG4gICAgICovXG4gICAgZGVsZXRlKHsgY291bnQsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBtZXRob2QgPSAnREVMRVRFJztcbiAgICAgICAgY29uc3QgcHJlZmVyc0hlYWRlcnMgPSBbXTtcbiAgICAgICAgaWYgKGNvdW50KSB7XG4gICAgICAgICAgICBwcmVmZXJzSGVhZGVycy5wdXNoKGBjb3VudD0ke2NvdW50fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhlYWRlcnNbJ1ByZWZlciddKSB7XG4gICAgICAgICAgICBwcmVmZXJzSGVhZGVycy51bnNoaWZ0KHRoaXMuaGVhZGVyc1snUHJlZmVyJ10pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGVhZGVyc1snUHJlZmVyJ10gPSBwcmVmZXJzSGVhZGVycy5qb2luKCcsJyk7XG4gICAgICAgIHJldHVybiBuZXcgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcl8xLmRlZmF1bHQoe1xuICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgdXJsOiB0aGlzLnVybCxcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNjaGVtYTogdGhpcy5zY2hlbWEsXG4gICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaCxcbiAgICAgICAgICAgIGFsbG93RW1wdHk6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIuanMubWFwIiwiaW1wb3J0IFBvc3RncmVzdEJ1aWxkZXIgZnJvbSAnLi9Qb3N0Z3Jlc3RCdWlsZGVyJ1xuaW1wb3J0IFBvc3RncmVzdEZpbHRlckJ1aWxkZXIgZnJvbSAnLi9Qb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyJ1xuaW1wb3J0IHsgR2V0UmVzdWx0IH0gZnJvbSAnLi9zZWxlY3QtcXVlcnktcGFyc2VyJ1xuaW1wb3J0IHsgRmV0Y2gsIEdlbmVyaWNTY2hlbWEsIEdlbmVyaWNUYWJsZSwgR2VuZXJpY1ZpZXcgfSBmcm9tICcuL3R5cGVzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXI8XG4gIFNjaGVtYSBleHRlbmRzIEdlbmVyaWNTY2hlbWEsXG4gIFJlbGF0aW9uIGV4dGVuZHMgR2VuZXJpY1RhYmxlIHwgR2VuZXJpY1ZpZXcsXG4gIFJlbGF0aW9uTmFtZSA9IHVua25vd24sXG4gIFJlbGF0aW9uc2hpcHMgPSBSZWxhdGlvbiBleHRlbmRzIHsgUmVsYXRpb25zaGlwczogaW5mZXIgUiB9ID8gUiA6IHVua25vd25cbj4ge1xuICB1cmw6IFVSTFxuICBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gIHNjaGVtYT86IHN0cmluZ1xuICBzaWduYWw/OiBBYm9ydFNpZ25hbFxuICBmZXRjaD86IEZldGNoXG5cbiAgY29uc3RydWN0b3IoXG4gICAgdXJsOiBVUkwsXG4gICAge1xuICAgICAgaGVhZGVycyA9IHt9LFxuICAgICAgc2NoZW1hLFxuICAgICAgZmV0Y2gsXG4gICAgfToge1xuICAgICAgaGVhZGVycz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgICAgIHNjaGVtYT86IHN0cmluZ1xuICAgICAgZmV0Y2g/OiBGZXRjaFxuICAgIH1cbiAgKSB7XG4gICAgdGhpcy51cmwgPSB1cmxcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzXG4gICAgdGhpcy5zY2hlbWEgPSBzY2hlbWFcbiAgICB0aGlzLmZldGNoID0gZmV0Y2hcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGEgU0VMRUNUIHF1ZXJ5IG9uIHRoZSB0YWJsZSBvciB2aWV3LlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1ucyAtIFRoZSBjb2x1bW5zIHRvIHJldHJpZXZlLCBzZXBhcmF0ZWQgYnkgY29tbWFzLiBDb2x1bW5zIGNhbiBiZSByZW5hbWVkIHdoZW4gcmV0dXJuZWQgd2l0aCBgY3VzdG9tTmFtZTpjb2x1bW5OYW1lYFxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMuaGVhZCAtIFdoZW4gc2V0IHRvIGB0cnVlYCwgYGRhdGFgIHdpbGwgbm90IGJlIHJldHVybmVkLlxuICAgKiBVc2VmdWwgaWYgeW91IG9ubHkgbmVlZCB0aGUgY291bnQuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLmNvdW50IC0gQ291bnQgYWxnb3JpdGhtIHRvIHVzZSB0byBjb3VudCByb3dzIGluIHRoZSB0YWJsZSBvciB2aWV3LlxuICAgKlxuICAgKiBgXCJleGFjdFwiYDogRXhhY3QgYnV0IHNsb3cgY291bnQgYWxnb3JpdGhtLiBQZXJmb3JtcyBhIGBDT1VOVCgqKWAgdW5kZXIgdGhlXG4gICAqIGhvb2QuXG4gICAqXG4gICAqIGBcInBsYW5uZWRcImA6IEFwcHJveGltYXRlZCBidXQgZmFzdCBjb3VudCBhbGdvcml0aG0uIFVzZXMgdGhlIFBvc3RncmVzXG4gICAqIHN0YXRpc3RpY3MgdW5kZXIgdGhlIGhvb2QuXG4gICAqXG4gICAqIGBcImVzdGltYXRlZFwiYDogVXNlcyBleGFjdCBjb3VudCBmb3IgbG93IG51bWJlcnMgYW5kIHBsYW5uZWQgY291bnQgZm9yIGhpZ2hcbiAgICogbnVtYmVycy5cbiAgICovXG4gIHNlbGVjdDxcbiAgICBRdWVyeSBleHRlbmRzIHN0cmluZyA9ICcqJyxcbiAgICBSZXN1bHRPbmUgPSBHZXRSZXN1bHQ8U2NoZW1hLCBSZWxhdGlvblsnUm93J10sIFJlbGF0aW9uTmFtZSwgUmVsYXRpb25zaGlwcywgUXVlcnk+XG4gID4oXG4gICAgY29sdW1ucz86IFF1ZXJ5LFxuICAgIHtcbiAgICAgIGhlYWQgPSBmYWxzZSxcbiAgICAgIGNvdW50LFxuICAgIH06IHtcbiAgICAgIGhlYWQ/OiBib29sZWFuXG4gICAgICBjb3VudD86ICdleGFjdCcgfCAncGxhbm5lZCcgfCAnZXN0aW1hdGVkJ1xuICAgIH0gPSB7fVxuICApOiBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyPFNjaGVtYSwgUmVsYXRpb25bJ1JvdyddLCBSZXN1bHRPbmVbXSwgUmVsYXRpb25OYW1lLCBSZWxhdGlvbnNoaXBzPiB7XG4gICAgY29uc3QgbWV0aG9kID0gaGVhZCA/ICdIRUFEJyA6ICdHRVQnXG4gICAgLy8gUmVtb3ZlIHdoaXRlc3BhY2VzIGV4Y2VwdCB3aGVuIHF1b3RlZFxuICAgIGxldCBxdW90ZWQgPSBmYWxzZVxuICAgIGNvbnN0IGNsZWFuZWRDb2x1bW5zID0gKGNvbHVtbnMgPz8gJyonKVxuICAgICAgLnNwbGl0KCcnKVxuICAgICAgLm1hcCgoYykgPT4ge1xuICAgICAgICBpZiAoL1xccy8udGVzdChjKSAmJiAhcXVvdGVkKSB7XG4gICAgICAgICAgcmV0dXJuICcnXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPT09ICdcIicpIHtcbiAgICAgICAgICBxdW90ZWQgPSAhcXVvdGVkXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNcbiAgICAgIH0pXG4gICAgICAuam9pbignJylcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KCdzZWxlY3QnLCBjbGVhbmVkQ29sdW1ucylcbiAgICBpZiAoY291bnQpIHtcbiAgICAgIHRoaXMuaGVhZGVyc1snUHJlZmVyJ10gPSBgY291bnQ9JHtjb3VudH1gXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyKHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgICBhbGxvd0VtcHR5OiBmYWxzZSxcbiAgICB9IGFzIHVua25vd24gYXMgUG9zdGdyZXN0QnVpbGRlcjxSZXN1bHRPbmVbXT4pXG4gIH1cblxuICAvLyBUT0RPKHYzKTogTWFrZSBgZGVmYXVsdFRvTnVsbGAgY29uc2lzdGVudCBmb3IgYm90aCBzaW5nbGUgJiBidWxrIGluc2VydHMuXG4gIGluc2VydDxSb3cgZXh0ZW5kcyBSZWxhdGlvbiBleHRlbmRzIHsgSW5zZXJ0OiB1bmtub3duIH0gPyBSZWxhdGlvblsnSW5zZXJ0J10gOiBuZXZlcj4oXG4gICAgdmFsdWVzOiBSb3csXG4gICAgb3B0aW9ucz86IHtcbiAgICAgIGNvdW50PzogJ2V4YWN0JyB8ICdwbGFubmVkJyB8ICdlc3RpbWF0ZWQnXG4gICAgfVxuICApOiBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyPFNjaGVtYSwgUmVsYXRpb25bJ1JvdyddLCBudWxsLCBSZWxhdGlvbk5hbWUsIFJlbGF0aW9uc2hpcHM+XG4gIGluc2VydDxSb3cgZXh0ZW5kcyBSZWxhdGlvbiBleHRlbmRzIHsgSW5zZXJ0OiB1bmtub3duIH0gPyBSZWxhdGlvblsnSW5zZXJ0J10gOiBuZXZlcj4oXG4gICAgdmFsdWVzOiBSb3dbXSxcbiAgICBvcHRpb25zPzoge1xuICAgICAgY291bnQ/OiAnZXhhY3QnIHwgJ3BsYW5uZWQnIHwgJ2VzdGltYXRlZCdcbiAgICAgIGRlZmF1bHRUb051bGw/OiBib29sZWFuXG4gICAgfVxuICApOiBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyPFNjaGVtYSwgUmVsYXRpb25bJ1JvdyddLCBudWxsLCBSZWxhdGlvbk5hbWUsIFJlbGF0aW9uc2hpcHM+XG4gIC8qKlxuICAgKiBQZXJmb3JtIGFuIElOU0VSVCBpbnRvIHRoZSB0YWJsZSBvciB2aWV3LlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBpbnNlcnRlZCByb3dzIGFyZSBub3QgcmV0dXJuZWQuIFRvIHJldHVybiBpdCwgY2hhaW4gdGhlIGNhbGxcbiAgICogd2l0aCBgLnNlbGVjdCgpYC5cbiAgICpcbiAgICogQHBhcmFtIHZhbHVlcyAtIFRoZSB2YWx1ZXMgdG8gaW5zZXJ0LiBQYXNzIGFuIG9iamVjdCB0byBpbnNlcnQgYSBzaW5nbGUgcm93XG4gICAqIG9yIGFuIGFycmF5IHRvIGluc2VydCBtdWx0aXBsZSByb3dzLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IGluc2VydGVkIHJvd3MuXG4gICAqXG4gICAqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcbiAgICogaG9vZC5cbiAgICpcbiAgICogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcbiAgICogc3RhdGlzdGljcyB1bmRlciB0aGUgaG9vZC5cbiAgICpcbiAgICogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuICAgKiBudW1iZXJzLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucy5kZWZhdWx0VG9OdWxsIC0gTWFrZSBtaXNzaW5nIGZpZWxkcyBkZWZhdWx0IHRvIGBudWxsYC5cbiAgICogT3RoZXJ3aXNlLCB1c2UgdGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBjb2x1bW4uIE9ubHkgYXBwbGllcyBmb3IgYnVsa1xuICAgKiBpbnNlcnRzLlxuICAgKi9cbiAgaW5zZXJ0PFJvdyBleHRlbmRzIFJlbGF0aW9uIGV4dGVuZHMgeyBJbnNlcnQ6IHVua25vd24gfSA/IFJlbGF0aW9uWydJbnNlcnQnXSA6IG5ldmVyPihcbiAgICB2YWx1ZXM6IFJvdyB8IFJvd1tdLFxuICAgIHtcbiAgICAgIGNvdW50LFxuICAgICAgZGVmYXVsdFRvTnVsbCA9IHRydWUsXG4gICAgfToge1xuICAgICAgY291bnQ/OiAnZXhhY3QnIHwgJ3BsYW5uZWQnIHwgJ2VzdGltYXRlZCdcbiAgICAgIGRlZmF1bHRUb051bGw/OiBib29sZWFuXG4gICAgfSA9IHt9XG4gICk6IFBvc3RncmVzdEZpbHRlckJ1aWxkZXI8U2NoZW1hLCBSZWxhdGlvblsnUm93J10sIG51bGwsIFJlbGF0aW9uTmFtZSwgUmVsYXRpb25zaGlwcz4ge1xuICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJ1xuXG4gICAgY29uc3QgcHJlZmVyc0hlYWRlcnMgPSBbXVxuICAgIGlmICh0aGlzLmhlYWRlcnNbJ1ByZWZlciddKSB7XG4gICAgICBwcmVmZXJzSGVhZGVycy5wdXNoKHRoaXMuaGVhZGVyc1snUHJlZmVyJ10pXG4gICAgfVxuICAgIGlmIChjb3VudCkge1xuICAgICAgcHJlZmVyc0hlYWRlcnMucHVzaChgY291bnQ9JHtjb3VudH1gKVxuICAgIH1cbiAgICBpZiAoIWRlZmF1bHRUb051bGwpIHtcbiAgICAgIHByZWZlcnNIZWFkZXJzLnB1c2goJ21pc3Npbmc9ZGVmYXVsdCcpXG4gICAgfVxuICAgIHRoaXMuaGVhZGVyc1snUHJlZmVyJ10gPSBwcmVmZXJzSGVhZGVycy5qb2luKCcsJylcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgIGNvbnN0IGNvbHVtbnMgPSB2YWx1ZXMucmVkdWNlKChhY2MsIHgpID0+IGFjYy5jb25jYXQoT2JqZWN0LmtleXMoeCkpLCBbXSBhcyBzdHJpbmdbXSlcbiAgICAgIGlmIChjb2x1bW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgdW5pcXVlQ29sdW1ucyA9IFsuLi5uZXcgU2V0KGNvbHVtbnMpXS5tYXAoKGNvbHVtbikgPT4gYFwiJHtjb2x1bW59XCJgKVxuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KCdjb2x1bW5zJywgdW5pcXVlQ29sdW1ucy5qb2luKCcsJykpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyKHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgYm9keTogdmFsdWVzLFxuICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgICBhbGxvd0VtcHR5OiBmYWxzZSxcbiAgICB9IGFzIHVua25vd24gYXMgUG9zdGdyZXN0QnVpbGRlcjxudWxsPilcbiAgfVxuXG4gIC8vIFRPRE8odjMpOiBNYWtlIGBkZWZhdWx0VG9OdWxsYCBjb25zaXN0ZW50IGZvciBib3RoIHNpbmdsZSAmIGJ1bGsgdXBzZXJ0cy5cbiAgdXBzZXJ0PFJvdyBleHRlbmRzIFJlbGF0aW9uIGV4dGVuZHMgeyBJbnNlcnQ6IHVua25vd24gfSA/IFJlbGF0aW9uWydJbnNlcnQnXSA6IG5ldmVyPihcbiAgICB2YWx1ZXM6IFJvdyxcbiAgICBvcHRpb25zPzoge1xuICAgICAgb25Db25mbGljdD86IHN0cmluZ1xuICAgICAgaWdub3JlRHVwbGljYXRlcz86IGJvb2xlYW5cbiAgICAgIGNvdW50PzogJ2V4YWN0JyB8ICdwbGFubmVkJyB8ICdlc3RpbWF0ZWQnXG4gICAgfVxuICApOiBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyPFNjaGVtYSwgUmVsYXRpb25bJ1JvdyddLCBudWxsLCBSZWxhdGlvbk5hbWUsIFJlbGF0aW9uc2hpcHM+XG4gIHVwc2VydDxSb3cgZXh0ZW5kcyBSZWxhdGlvbiBleHRlbmRzIHsgSW5zZXJ0OiB1bmtub3duIH0gPyBSZWxhdGlvblsnSW5zZXJ0J10gOiBuZXZlcj4oXG4gICAgdmFsdWVzOiBSb3dbXSxcbiAgICBvcHRpb25zPzoge1xuICAgICAgb25Db25mbGljdD86IHN0cmluZ1xuICAgICAgaWdub3JlRHVwbGljYXRlcz86IGJvb2xlYW5cbiAgICAgIGNvdW50PzogJ2V4YWN0JyB8ICdwbGFubmVkJyB8ICdlc3RpbWF0ZWQnXG4gICAgICBkZWZhdWx0VG9OdWxsPzogYm9vbGVhblxuICAgIH1cbiAgKTogUG9zdGdyZXN0RmlsdGVyQnVpbGRlcjxTY2hlbWEsIFJlbGF0aW9uWydSb3cnXSwgbnVsbCwgUmVsYXRpb25OYW1lLCBSZWxhdGlvbnNoaXBzPlxuICAvKipcbiAgICogUGVyZm9ybSBhbiBVUFNFUlQgb24gdGhlIHRhYmxlIG9yIHZpZXcuIERlcGVuZGluZyBvbiB0aGUgY29sdW1uKHMpIHBhc3NlZFxuICAgKiB0byBgb25Db25mbGljdGAsIGAudXBzZXJ0KClgIGFsbG93cyB5b3UgdG8gcGVyZm9ybSB0aGUgZXF1aXZhbGVudCBvZlxuICAgKiBgLmluc2VydCgpYCBpZiBhIHJvdyB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIGBvbkNvbmZsaWN0YCBjb2x1bW5zIGRvZXNuJ3RcbiAgICogZXhpc3QsIG9yIGlmIGl0IGRvZXMgZXhpc3QsIHBlcmZvcm0gYW4gYWx0ZXJuYXRpdmUgYWN0aW9uIGRlcGVuZGluZyBvblxuICAgKiBgaWdub3JlRHVwbGljYXRlc2AuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHVwc2VydGVkIHJvd3MgYXJlIG5vdCByZXR1cm5lZC4gVG8gcmV0dXJuIGl0LCBjaGFpbiB0aGUgY2FsbFxuICAgKiB3aXRoIGAuc2VsZWN0KClgLlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyB0byB1cHNlcnQgd2l0aC4gUGFzcyBhbiBvYmplY3QgdG8gdXBzZXJ0IGFcbiAgICogc2luZ2xlIHJvdyBvciBhbiBhcnJheSB0byB1cHNlcnQgbXVsdGlwbGUgcm93cy5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLm9uQ29uZmxpY3QgLSBDb21tYS1zZXBhcmF0ZWQgVU5JUVVFIGNvbHVtbihzKSB0byBzcGVjaWZ5IGhvd1xuICAgKiBkdXBsaWNhdGUgcm93cyBhcmUgZGV0ZXJtaW5lZC4gVHdvIHJvd3MgYXJlIGR1cGxpY2F0ZXMgaWYgYWxsIHRoZVxuICAgKiBgb25Db25mbGljdGAgY29sdW1ucyBhcmUgZXF1YWwuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLmlnbm9yZUR1cGxpY2F0ZXMgLSBJZiBgdHJ1ZWAsIGR1cGxpY2F0ZSByb3dzIGFyZSBpZ25vcmVkLiBJZlxuICAgKiBgZmFsc2VgLCBkdXBsaWNhdGUgcm93cyBhcmUgbWVyZ2VkIHdpdGggZXhpc3Rpbmcgcm93cy5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IHVwc2VydGVkIHJvd3MuXG4gICAqXG4gICAqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcbiAgICogaG9vZC5cbiAgICpcbiAgICogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcbiAgICogc3RhdGlzdGljcyB1bmRlciB0aGUgaG9vZC5cbiAgICpcbiAgICogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuICAgKiBudW1iZXJzLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucy5kZWZhdWx0VG9OdWxsIC0gTWFrZSBtaXNzaW5nIGZpZWxkcyBkZWZhdWx0IHRvIGBudWxsYC5cbiAgICogT3RoZXJ3aXNlLCB1c2UgdGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBjb2x1bW4uIFRoaXMgb25seSBhcHBsaWVzIHdoZW5cbiAgICogaW5zZXJ0aW5nIG5ldyByb3dzLCBub3Qgd2hlbiBtZXJnaW5nIHdpdGggZXhpc3Rpbmcgcm93cyB1bmRlclxuICAgKiBgaWdub3JlRHVwbGljYXRlczogZmFsc2VgLiBUaGlzIGFsc28gb25seSBhcHBsaWVzIHdoZW4gZG9pbmcgYnVsayB1cHNlcnRzLlxuICAgKi9cbiAgdXBzZXJ0PFJvdyBleHRlbmRzIFJlbGF0aW9uIGV4dGVuZHMgeyBJbnNlcnQ6IHVua25vd24gfSA/IFJlbGF0aW9uWydJbnNlcnQnXSA6IG5ldmVyPihcbiAgICB2YWx1ZXM6IFJvdyB8IFJvd1tdLFxuICAgIHtcbiAgICAgIG9uQ29uZmxpY3QsXG4gICAgICBpZ25vcmVEdXBsaWNhdGVzID0gZmFsc2UsXG4gICAgICBjb3VudCxcbiAgICAgIGRlZmF1bHRUb051bGwgPSB0cnVlLFxuICAgIH06IHtcbiAgICAgIG9uQ29uZmxpY3Q/OiBzdHJpbmdcbiAgICAgIGlnbm9yZUR1cGxpY2F0ZXM/OiBib29sZWFuXG4gICAgICBjb3VudD86ICdleGFjdCcgfCAncGxhbm5lZCcgfCAnZXN0aW1hdGVkJ1xuICAgICAgZGVmYXVsdFRvTnVsbD86IGJvb2xlYW5cbiAgICB9ID0ge31cbiAgKTogUG9zdGdyZXN0RmlsdGVyQnVpbGRlcjxTY2hlbWEsIFJlbGF0aW9uWydSb3cnXSwgbnVsbCwgUmVsYXRpb25OYW1lLCBSZWxhdGlvbnNoaXBzPiB7XG4gICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnXG5cbiAgICBjb25zdCBwcmVmZXJzSGVhZGVycyA9IFtgcmVzb2x1dGlvbj0ke2lnbm9yZUR1cGxpY2F0ZXMgPyAnaWdub3JlJyA6ICdtZXJnZSd9LWR1cGxpY2F0ZXNgXVxuXG4gICAgaWYgKG9uQ29uZmxpY3QgIT09IHVuZGVmaW5lZCkgdGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldCgnb25fY29uZmxpY3QnLCBvbkNvbmZsaWN0KVxuICAgIGlmICh0aGlzLmhlYWRlcnNbJ1ByZWZlciddKSB7XG4gICAgICBwcmVmZXJzSGVhZGVycy5wdXNoKHRoaXMuaGVhZGVyc1snUHJlZmVyJ10pXG4gICAgfVxuICAgIGlmIChjb3VudCkge1xuICAgICAgcHJlZmVyc0hlYWRlcnMucHVzaChgY291bnQ9JHtjb3VudH1gKVxuICAgIH1cbiAgICBpZiAoIWRlZmF1bHRUb051bGwpIHtcbiAgICAgIHByZWZlcnNIZWFkZXJzLnB1c2goJ21pc3Npbmc9ZGVmYXVsdCcpXG4gICAgfVxuICAgIHRoaXMuaGVhZGVyc1snUHJlZmVyJ10gPSBwcmVmZXJzSGVhZGVycy5qb2luKCcsJylcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgIGNvbnN0IGNvbHVtbnMgPSB2YWx1ZXMucmVkdWNlKChhY2MsIHgpID0+IGFjYy5jb25jYXQoT2JqZWN0LmtleXMoeCkpLCBbXSBhcyBzdHJpbmdbXSlcbiAgICAgIGlmIChjb2x1bW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgdW5pcXVlQ29sdW1ucyA9IFsuLi5uZXcgU2V0KGNvbHVtbnMpXS5tYXAoKGNvbHVtbikgPT4gYFwiJHtjb2x1bW59XCJgKVxuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KCdjb2x1bW5zJywgdW5pcXVlQ29sdW1ucy5qb2luKCcsJykpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyKHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgYm9keTogdmFsdWVzLFxuICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgICBhbGxvd0VtcHR5OiBmYWxzZSxcbiAgICB9IGFzIHVua25vd24gYXMgUG9zdGdyZXN0QnVpbGRlcjxudWxsPilcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGFuIFVQREFURSBvbiB0aGUgdGFibGUgb3Igdmlldy5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdXBkYXRlZCByb3dzIGFyZSBub3QgcmV0dXJuZWQuIFRvIHJldHVybiBpdCwgY2hhaW4gdGhlIGNhbGxcbiAgICogd2l0aCBgLnNlbGVjdCgpYCBhZnRlciBmaWx0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyB0byB1cGRhdGUgd2l0aFxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IHVwZGF0ZWQgcm93cy5cbiAgICpcbiAgICogYFwiZXhhY3RcImA6IEV4YWN0IGJ1dCBzbG93IGNvdW50IGFsZ29yaXRobS4gUGVyZm9ybXMgYSBgQ09VTlQoKilgIHVuZGVyIHRoZVxuICAgKiBob29kLlxuICAgKlxuICAgKiBgXCJwbGFubmVkXCJgOiBBcHByb3hpbWF0ZWQgYnV0IGZhc3QgY291bnQgYWxnb3JpdGhtLiBVc2VzIHRoZSBQb3N0Z3Jlc1xuICAgKiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuICAgKlxuICAgKiBgXCJlc3RpbWF0ZWRcImA6IFVzZXMgZXhhY3QgY291bnQgZm9yIGxvdyBudW1iZXJzIGFuZCBwbGFubmVkIGNvdW50IGZvciBoaWdoXG4gICAqIG51bWJlcnMuXG4gICAqL1xuICB1cGRhdGU8Um93IGV4dGVuZHMgUmVsYXRpb24gZXh0ZW5kcyB7IFVwZGF0ZTogdW5rbm93biB9ID8gUmVsYXRpb25bJ1VwZGF0ZSddIDogbmV2ZXI+KFxuICAgIHZhbHVlczogUm93LFxuICAgIHtcbiAgICAgIGNvdW50LFxuICAgIH06IHtcbiAgICAgIGNvdW50PzogJ2V4YWN0JyB8ICdwbGFubmVkJyB8ICdlc3RpbWF0ZWQnXG4gICAgfSA9IHt9XG4gICk6IFBvc3RncmVzdEZpbHRlckJ1aWxkZXI8U2NoZW1hLCBSZWxhdGlvblsnUm93J10sIG51bGwsIFJlbGF0aW9uTmFtZSwgUmVsYXRpb25zaGlwcz4ge1xuICAgIGNvbnN0IG1ldGhvZCA9ICdQQVRDSCdcbiAgICBjb25zdCBwcmVmZXJzSGVhZGVycyA9IFtdXG4gICAgaWYgKHRoaXMuaGVhZGVyc1snUHJlZmVyJ10pIHtcbiAgICAgIHByZWZlcnNIZWFkZXJzLnB1c2godGhpcy5oZWFkZXJzWydQcmVmZXInXSlcbiAgICB9XG4gICAgaWYgKGNvdW50KSB7XG4gICAgICBwcmVmZXJzSGVhZGVycy5wdXNoKGBjb3VudD0ke2NvdW50fWApXG4gICAgfVxuICAgIHRoaXMuaGVhZGVyc1snUHJlZmVyJ10gPSBwcmVmZXJzSGVhZGVycy5qb2luKCcsJylcblxuICAgIHJldHVybiBuZXcgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcih7XG4gICAgICBtZXRob2QsXG4gICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgc2NoZW1hOiB0aGlzLnNjaGVtYSxcbiAgICAgIGJvZHk6IHZhbHVlcyxcbiAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgICAgYWxsb3dFbXB0eTogZmFsc2UsXG4gICAgfSBhcyB1bmtub3duIGFzIFBvc3RncmVzdEJ1aWxkZXI8bnVsbD4pXG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybSBhIERFTEVURSBvbiB0aGUgdGFibGUgb3Igdmlldy5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgZGVsZXRlZCByb3dzIGFyZSBub3QgcmV0dXJuZWQuIFRvIHJldHVybiBpdCwgY2hhaW4gdGhlIGNhbGxcbiAgICogd2l0aCBgLnNlbGVjdCgpYCBhZnRlciBmaWx0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IGRlbGV0ZWQgcm93cy5cbiAgICpcbiAgICogYFwiZXhhY3RcImA6IEV4YWN0IGJ1dCBzbG93IGNvdW50IGFsZ29yaXRobS4gUGVyZm9ybXMgYSBgQ09VTlQoKilgIHVuZGVyIHRoZVxuICAgKiBob29kLlxuICAgKlxuICAgKiBgXCJwbGFubmVkXCJgOiBBcHByb3hpbWF0ZWQgYnV0IGZhc3QgY291bnQgYWxnb3JpdGhtLiBVc2VzIHRoZSBQb3N0Z3Jlc1xuICAgKiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuICAgKlxuICAgKiBgXCJlc3RpbWF0ZWRcImA6IFVzZXMgZXhhY3QgY291bnQgZm9yIGxvdyBudW1iZXJzIGFuZCBwbGFubmVkIGNvdW50IGZvciBoaWdoXG4gICAqIG51bWJlcnMuXG4gICAqL1xuICBkZWxldGUoe1xuICAgIGNvdW50LFxuICB9OiB7XG4gICAgY291bnQ/OiAnZXhhY3QnIHwgJ3BsYW5uZWQnIHwgJ2VzdGltYXRlZCdcbiAgfSA9IHt9KTogUG9zdGdyZXN0RmlsdGVyQnVpbGRlcjxTY2hlbWEsIFJlbGF0aW9uWydSb3cnXSwgbnVsbCwgUmVsYXRpb25OYW1lLCBSZWxhdGlvbnNoaXBzPiB7XG4gICAgY29uc3QgbWV0aG9kID0gJ0RFTEVURSdcbiAgICBjb25zdCBwcmVmZXJzSGVhZGVycyA9IFtdXG4gICAgaWYgKGNvdW50KSB7XG4gICAgICBwcmVmZXJzSGVhZGVycy5wdXNoKGBjb3VudD0ke2NvdW50fWApXG4gICAgfVxuICAgIGlmICh0aGlzLmhlYWRlcnNbJ1ByZWZlciddKSB7XG4gICAgICBwcmVmZXJzSGVhZGVycy51bnNoaWZ0KHRoaXMuaGVhZGVyc1snUHJlZmVyJ10pXG4gICAgfVxuICAgIHRoaXMuaGVhZGVyc1snUHJlZmVyJ10gPSBwcmVmZXJzSGVhZGVycy5qb2luKCcsJylcblxuICAgIHJldHVybiBuZXcgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcih7XG4gICAgICBtZXRob2QsXG4gICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgc2NoZW1hOiB0aGlzLnNjaGVtYSxcbiAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgICAgYWxsb3dFbXB0eTogZmFsc2UsXG4gICAgfSBhcyB1bmtub3duIGFzIFBvc3RncmVzdEJ1aWxkZXI8bnVsbD4pXG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1Bvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXJcIikpO1xuY2xhc3MgUG9zdGdyZXN0RmlsdGVyQnVpbGRlciBleHRlbmRzIFBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXJfMS5kZWZhdWx0IHtcbiAgICAvKipcbiAgICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgZXF1YWwgdG8gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIFRvIGNoZWNrIGlmIHRoZSB2YWx1ZSBvZiBgY29sdW1uYCBpcyBOVUxMLCB5b3Ugc2hvdWxkIHVzZSBgLmlzKClgIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcbiAgICAgKi9cbiAgICBlcShjb2x1bW4sIHZhbHVlKSB7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgZXEuJHt2YWx1ZX1gKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBpcyBub3QgZXF1YWwgdG8gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuICAgICAqL1xuICAgIG5lcShjb2x1bW4sIHZhbHVlKSB7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbmVxLiR7dmFsdWV9YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgZ3JlYXRlciB0aGFuIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcbiAgICAgKi9cbiAgICBndChjb2x1bW4sIHZhbHVlKSB7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgZ3QuJHt2YWx1ZX1gKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuICAgICAqL1xuICAgIGd0ZShjb2x1bW4sIHZhbHVlKSB7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgZ3RlLiR7dmFsdWV9YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgbGVzcyB0aGFuIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcbiAgICAgKi9cbiAgICBsdChjb2x1bW4sIHZhbHVlKSB7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbHQuJHt2YWx1ZX1gKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuICAgICAqL1xuICAgIGx0ZShjb2x1bW4sIHZhbHVlKSB7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbHRlLiR7dmFsdWV9YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgbWF0Y2hlcyBgcGF0dGVybmAgY2FzZS1zZW5zaXRpdmVseS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgICAqIEBwYXJhbSBwYXR0ZXJuIC0gVGhlIHBhdHRlcm4gdG8gbWF0Y2ggd2l0aFxuICAgICAqL1xuICAgIGxpa2UoY29sdW1uLCBwYXR0ZXJuKSB7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbGlrZS4ke3BhdHRlcm59YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgbWF0Y2hlcyBhbGwgb2YgYHBhdHRlcm5zYCBjYXNlLXNlbnNpdGl2ZWx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHBhdHRlcm5zIC0gVGhlIHBhdHRlcm5zIHRvIG1hdGNoIHdpdGhcbiAgICAgKi9cbiAgICBsaWtlQWxsT2YoY29sdW1uLCBwYXR0ZXJucykge1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGxpa2UoYWxsKS57JHtwYXR0ZXJucy5qb2luKCcsJyl9fWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIG1hdGNoZXMgYW55IG9mIGBwYXR0ZXJuc2AgY2FzZS1zZW5zaXRpdmVseS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgICAqIEBwYXJhbSBwYXR0ZXJucyAtIFRoZSBwYXR0ZXJucyB0byBtYXRjaCB3aXRoXG4gICAgICovXG4gICAgbGlrZUFueU9mKGNvbHVtbiwgcGF0dGVybnMpIHtcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBsaWtlKGFueSkueyR7cGF0dGVybnMuam9pbignLCcpfX1gKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBtYXRjaGVzIGBwYXR0ZXJuYCBjYXNlLWluc2Vuc2l0aXZlbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gcGF0dGVybiAtIFRoZSBwYXR0ZXJuIHRvIG1hdGNoIHdpdGhcbiAgICAgKi9cbiAgICBpbGlrZShjb2x1bW4sIHBhdHRlcm4pIHtcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBpbGlrZS4ke3BhdHRlcm59YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgbWF0Y2hlcyBhbGwgb2YgYHBhdHRlcm5zYCBjYXNlLWluc2Vuc2l0aXZlbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gcGF0dGVybnMgLSBUaGUgcGF0dGVybnMgdG8gbWF0Y2ggd2l0aFxuICAgICAqL1xuICAgIGlsaWtlQWxsT2YoY29sdW1uLCBwYXR0ZXJucykge1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGlsaWtlKGFsbCkueyR7cGF0dGVybnMuam9pbignLCcpfX1gKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBtYXRjaGVzIGFueSBvZiBgcGF0dGVybnNgIGNhc2UtaW5zZW5zaXRpdmVseS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgICAqIEBwYXJhbSBwYXR0ZXJucyAtIFRoZSBwYXR0ZXJucyB0byBtYXRjaCB3aXRoXG4gICAgICovXG4gICAgaWxpa2VBbnlPZihjb2x1bW4sIHBhdHRlcm5zKSB7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgaWxpa2UoYW55KS57JHtwYXR0ZXJucy5qb2luKCcsJyl9fWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIElTIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBGb3Igbm9uLWJvb2xlYW4gY29sdW1ucywgdGhpcyBpcyBvbmx5IHJlbGV2YW50IGZvciBjaGVja2luZyBpZiB0aGUgdmFsdWUgb2ZcbiAgICAgKiBgY29sdW1uYCBpcyBOVUxMIGJ5IHNldHRpbmcgYHZhbHVlYCB0byBgbnVsbGAuXG4gICAgICpcbiAgICAgKiBGb3IgYm9vbGVhbiBjb2x1bW5zLCB5b3UgY2FuIGFsc28gc2V0IGB2YWx1ZWAgdG8gYHRydWVgIG9yIGBmYWxzZWAgYW5kIGl0XG4gICAgICogd2lsbCBiZWhhdmUgdGhlIHNhbWUgd2F5IGFzIGAuZXEoKWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcbiAgICAgKi9cbiAgICBpcyhjb2x1bW4sIHZhbHVlKSB7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgaXMuJHt2YWx1ZX1gKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBpcyBpbmNsdWRlZCBpbiB0aGUgYHZhbHVlc2AgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyBhcnJheSB0byBmaWx0ZXIgd2l0aFxuICAgICAqL1xuICAgIGluKGNvbHVtbiwgdmFsdWVzKSB7XG4gICAgICAgIGNvbnN0IGNsZWFuZWRWYWx1ZXMgPSBBcnJheS5mcm9tKG5ldyBTZXQodmFsdWVzKSlcbiAgICAgICAgICAgIC5tYXAoKHMpID0+IHtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBwb3N0Z3Jlc3QgcmVzZXJ2ZWQgY2hhcmFjdGVyc1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9wb3N0Z3Jlc3Qub3JnL2VuL3Y3LjAuMC9hcGkuaHRtbCNyZXNlcnZlZC1jaGFyYWN0ZXJzXG4gICAgICAgICAgICBpZiAodHlwZW9mIHMgPT09ICdzdHJpbmcnICYmIG5ldyBSZWdFeHAoJ1ssKCldJykudGVzdChzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYFwiJHtzfVwiYDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7c31gO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oJywnKTtcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBpbi4oJHtjbGVhbmVkVmFsdWVzfSlgKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9ubHkgcmVsZXZhbnQgZm9yIGpzb25iLCBhcnJheSwgYW5kIHJhbmdlIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZVxuICAgICAqIGBjb2x1bW5gIGNvbnRhaW5zIGV2ZXJ5IGVsZW1lbnQgYXBwZWFyaW5nIGluIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGpzb25iLCBhcnJheSwgb3IgcmFuZ2UgY29sdW1uIHRvIGZpbHRlciBvblxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBqc29uYiwgYXJyYXksIG9yIHJhbmdlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAgICovXG4gICAgY29udGFpbnMoY29sdW1uLCB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gcmFuZ2UgdHlwZXMgY2FuIGJlIGluY2x1c2l2ZSAnWycsICddJyBvciBleGNsdXNpdmUgJygnLCAnKScgc28ganVzdFxuICAgICAgICAgICAgLy8ga2VlcCBpdCBzaW1wbGUgYW5kIGFjY2VwdCBhIHN0cmluZ1xuICAgICAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBjcy4ke3ZhbHVlfWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAvLyBhcnJheVxuICAgICAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBjcy57JHt2YWx1ZS5qb2luKCcsJyl9fWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8ganNvblxuICAgICAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBjcy4ke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogT25seSByZWxldmFudCBmb3IganNvbmIsIGFycmF5LCBhbmQgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlXG4gICAgICogZXZlcnkgZWxlbWVudCBhcHBlYXJpbmcgaW4gYGNvbHVtbmAgaXMgY29udGFpbmVkIGJ5IGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGpzb25iLCBhcnJheSwgb3IgcmFuZ2UgY29sdW1uIHRvIGZpbHRlciBvblxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBqc29uYiwgYXJyYXksIG9yIHJhbmdlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAgICovXG4gICAgY29udGFpbmVkQnkoY29sdW1uLCB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gcmFuZ2VcbiAgICAgICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgY2QuJHt2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgLy8gYXJyYXlcbiAgICAgICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgY2QueyR7dmFsdWUuam9pbignLCcpfX1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGpzb25cbiAgICAgICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgY2QuJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9ubHkgcmVsZXZhbnQgZm9yIHJhbmdlIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBldmVyeSBlbGVtZW50IGluXG4gICAgICogYGNvbHVtbmAgaXMgZ3JlYXRlciB0aGFuIGFueSBlbGVtZW50IGluIGByYW5nZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gcmFuZ2UgLSBUaGUgcmFuZ2UgdG8gZmlsdGVyIHdpdGhcbiAgICAgKi9cbiAgICByYW5nZUd0KGNvbHVtbiwgcmFuZ2UpIHtcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBzci4ke3JhbmdlfWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogT25seSByZWxldmFudCBmb3IgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlIGV2ZXJ5IGVsZW1lbnQgaW5cbiAgICAgKiBgY29sdW1uYCBpcyBlaXRoZXIgY29udGFpbmVkIGluIGByYW5nZWAgb3IgZ3JlYXRlciB0aGFuIGFueSBlbGVtZW50IGluXG4gICAgICogYHJhbmdlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgcmFuZ2UgY29sdW1uIHRvIGZpbHRlciBvblxuICAgICAqIEBwYXJhbSByYW5nZSAtIFRoZSByYW5nZSB0byBmaWx0ZXIgd2l0aFxuICAgICAqL1xuICAgIHJhbmdlR3RlKGNvbHVtbiwgcmFuZ2UpIHtcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBueGwuJHtyYW5nZX1gKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9ubHkgcmVsZXZhbnQgZm9yIHJhbmdlIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBldmVyeSBlbGVtZW50IGluXG4gICAgICogYGNvbHVtbmAgaXMgbGVzcyB0aGFuIGFueSBlbGVtZW50IGluIGByYW5nZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gcmFuZ2UgLSBUaGUgcmFuZ2UgdG8gZmlsdGVyIHdpdGhcbiAgICAgKi9cbiAgICByYW5nZUx0KGNvbHVtbiwgcmFuZ2UpIHtcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBzbC4ke3JhbmdlfWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogT25seSByZWxldmFudCBmb3IgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlIGV2ZXJ5IGVsZW1lbnQgaW5cbiAgICAgKiBgY29sdW1uYCBpcyBlaXRoZXIgY29udGFpbmVkIGluIGByYW5nZWAgb3IgbGVzcyB0aGFuIGFueSBlbGVtZW50IGluXG4gICAgICogYHJhbmdlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgcmFuZ2UgY29sdW1uIHRvIGZpbHRlciBvblxuICAgICAqIEBwYXJhbSByYW5nZSAtIFRoZSByYW5nZSB0byBmaWx0ZXIgd2l0aFxuICAgICAqL1xuICAgIHJhbmdlTHRlKGNvbHVtbiwgcmFuZ2UpIHtcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBueHIuJHtyYW5nZX1gKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9ubHkgcmVsZXZhbnQgZm9yIHJhbmdlIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBpc1xuICAgICAqIG11dHVhbGx5IGV4Y2x1c2l2ZSB0byBgcmFuZ2VgIGFuZCB0aGVyZSBjYW4gYmUgbm8gZWxlbWVudCBiZXR3ZWVuIHRoZSB0d29cbiAgICAgKiByYW5nZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gcmFuZ2UgLSBUaGUgcmFuZ2UgdG8gZmlsdGVyIHdpdGhcbiAgICAgKi9cbiAgICByYW5nZUFkamFjZW50KGNvbHVtbiwgcmFuZ2UpIHtcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBhZGouJHtyYW5nZX1gKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9ubHkgcmVsZXZhbnQgZm9yIGFycmF5IGFuZCByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmVcbiAgICAgKiBgY29sdW1uYCBhbmQgYHZhbHVlYCBoYXZlIGFuIGVsZW1lbnQgaW4gY29tbW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBhcnJheSBvciByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIGFycmF5IG9yIHJhbmdlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAgICovXG4gICAgb3ZlcmxhcHMoY29sdW1uLCB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gcmFuZ2VcbiAgICAgICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgb3YuJHt2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGFycmF5XG4gICAgICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG92Lnske3ZhbHVlLmpvaW4oJywnKX19YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9ubHkgcmVsZXZhbnQgZm9yIHRleHQgYW5kIHRzdmVjdG9yIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZVxuICAgICAqIGBjb2x1bW5gIG1hdGNoZXMgdGhlIHF1ZXJ5IHN0cmluZyBpbiBgcXVlcnlgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSB0ZXh0IG9yIHRzdmVjdG9yIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gcXVlcnkgLSBUaGUgcXVlcnkgdGV4dCB0byBtYXRjaCB3aXRoXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIG9wdGlvbnMuY29uZmlnIC0gVGhlIHRleHQgc2VhcmNoIGNvbmZpZ3VyYXRpb24gdG8gdXNlXG4gICAgICogQHBhcmFtIG9wdGlvbnMudHlwZSAtIENoYW5nZSBob3cgdGhlIGBxdWVyeWAgdGV4dCBpcyBpbnRlcnByZXRlZFxuICAgICAqL1xuICAgIHRleHRTZWFyY2goY29sdW1uLCBxdWVyeSwgeyBjb25maWcsIHR5cGUgfSA9IHt9KSB7XG4gICAgICAgIGxldCB0eXBlUGFydCA9ICcnO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3BsYWluJykge1xuICAgICAgICAgICAgdHlwZVBhcnQgPSAncGwnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdwaHJhc2UnKSB7XG4gICAgICAgICAgICB0eXBlUGFydCA9ICdwaCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ3dlYnNlYXJjaCcpIHtcbiAgICAgICAgICAgIHR5cGVQYXJ0ID0gJ3cnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbmZpZ1BhcnQgPSBjb25maWcgPT09IHVuZGVmaW5lZCA/ICcnIDogYCgke2NvbmZpZ30pYDtcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGAke3R5cGVQYXJ0fWZ0cyR7Y29uZmlnUGFydH0uJHtxdWVyeX1gKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBlYWNoIGNvbHVtbiBpbiBgcXVlcnlgIGtleXMgaXMgZXF1YWwgdG8gaXRzXG4gICAgICogYXNzb2NpYXRlZCB2YWx1ZS4gU2hvcnRoYW5kIGZvciBtdWx0aXBsZSBgLmVxKClgcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBxdWVyeSAtIFRoZSBvYmplY3QgdG8gZmlsdGVyIHdpdGgsIHdpdGggY29sdW1uIG5hbWVzIGFzIGtleXMgbWFwcGVkXG4gICAgICogdG8gdGhlaXIgZmlsdGVyIHZhbHVlc1xuICAgICAqL1xuICAgIG1hdGNoKHF1ZXJ5KSB7XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHF1ZXJ5KS5mb3JFYWNoKChbY29sdW1uLCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgZXEuJHt2YWx1ZX1gKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hpY2ggZG9lc24ndCBzYXRpc2Z5IHRoZSBmaWx0ZXIuXG4gICAgICpcbiAgICAgKiBVbmxpa2UgbW9zdCBmaWx0ZXJzLCBgb3BlYXJhdG9yYCBhbmQgYHZhbHVlYCBhcmUgdXNlZCBhcy1pcyBhbmQgbmVlZCB0b1xuICAgICAqIGZvbGxvdyBbUG9zdGdSRVNUXG4gICAgICogc3ludGF4XShodHRwczovL3Bvc3RncmVzdC5vcmcvZW4vc3RhYmxlL2FwaS5odG1sI29wZXJhdG9ycykuIFlvdSBhbHNvIG5lZWRcbiAgICAgKiB0byBtYWtlIHN1cmUgdGhleSBhcmUgcHJvcGVybHkgc2FuaXRpemVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIG9wZXJhdG9yIC0gVGhlIG9wZXJhdG9yIHRvIGJlIG5lZ2F0ZWQgdG8gZmlsdGVyIHdpdGgsIGZvbGxvd2luZ1xuICAgICAqIFBvc3RnUkVTVCBzeW50YXhcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGgsIGZvbGxvd2luZyBQb3N0Z1JFU1Qgc3ludGF4XG4gICAgICovXG4gICAgbm90KGNvbHVtbiwgb3BlcmF0b3IsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbm90LiR7b3BlcmF0b3J9LiR7dmFsdWV9YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hpY2ggc2F0aXNmeSBhdCBsZWFzdCBvbmUgb2YgdGhlIGZpbHRlcnMuXG4gICAgICpcbiAgICAgKiBVbmxpa2UgbW9zdCBmaWx0ZXJzLCBgZmlsdGVyc2AgaXMgdXNlZCBhcy1pcyBhbmQgbmVlZHMgdG8gZm9sbG93IFtQb3N0Z1JFU1RcbiAgICAgKiBzeW50YXhdKGh0dHBzOi8vcG9zdGdyZXN0Lm9yZy9lbi9zdGFibGUvYXBpLmh0bWwjb3BlcmF0b3JzKS4gWW91IGFsc28gbmVlZFxuICAgICAqIHRvIG1ha2Ugc3VyZSBpdCdzIHByb3Blcmx5IHNhbml0aXplZC5cbiAgICAgKlxuICAgICAqIEl0J3MgY3VycmVudGx5IG5vdCBwb3NzaWJsZSB0byBkbyBhbiBgLm9yKClgIGZpbHRlciBhY3Jvc3MgbXVsdGlwbGUgdGFibGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZpbHRlcnMgLSBUaGUgZmlsdGVycyB0byB1c2UsIGZvbGxvd2luZyBQb3N0Z1JFU1Qgc3ludGF4XG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIG9wdGlvbnMucmVmZXJlbmNlZFRhYmxlIC0gU2V0IHRoaXMgdG8gZmlsdGVyIG9uIHJlZmVyZW5jZWQgdGFibGVzXG4gICAgICogaW5zdGVhZCBvZiB0aGUgcGFyZW50IHRhYmxlXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZm9yZWlnblRhYmxlIC0gRGVwcmVjYXRlZCwgdXNlIGByZWZlcmVuY2VkVGFibGVgIGluc3RlYWRcbiAgICAgKi9cbiAgICBvcihmaWx0ZXJzLCB7IGZvcmVpZ25UYWJsZSwgcmVmZXJlbmNlZFRhYmxlID0gZm9yZWlnblRhYmxlLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3Qga2V5ID0gcmVmZXJlbmNlZFRhYmxlID8gYCR7cmVmZXJlbmNlZFRhYmxlfS5vcmAgOiAnb3InO1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgYCgke2ZpbHRlcnN9KWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWF0Y2ggb25seSByb3dzIHdoaWNoIHNhdGlzZnkgdGhlIGZpbHRlci4gVGhpcyBpcyBhbiBlc2NhcGUgaGF0Y2ggLSB5b3VcbiAgICAgKiBzaG91bGQgdXNlIHRoZSBzcGVjaWZpYyBmaWx0ZXIgbWV0aG9kcyB3aGVyZXZlciBwb3NzaWJsZS5cbiAgICAgKlxuICAgICAqIFVubGlrZSBtb3N0IGZpbHRlcnMsIGBvcGVhcmF0b3JgIGFuZCBgdmFsdWVgIGFyZSB1c2VkIGFzLWlzIGFuZCBuZWVkIHRvXG4gICAgICogZm9sbG93IFtQb3N0Z1JFU1RcbiAgICAgKiBzeW50YXhdKGh0dHBzOi8vcG9zdGdyZXN0Lm9yZy9lbi9zdGFibGUvYXBpLmh0bWwjb3BlcmF0b3JzKS4gWW91IGFsc28gbmVlZFxuICAgICAqIHRvIG1ha2Ugc3VyZSB0aGV5IGFyZSBwcm9wZXJseSBzYW5pdGl6ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gb3BlcmF0b3IgLSBUaGUgb3BlcmF0b3IgdG8gZmlsdGVyIHdpdGgsIGZvbGxvd2luZyBQb3N0Z1JFU1Qgc3ludGF4XG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoLCBmb2xsb3dpbmcgUG9zdGdSRVNUIHN5bnRheFxuICAgICAqL1xuICAgIGZpbHRlcihjb2x1bW4sIG9wZXJhdG9yLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYCR7b3BlcmF0b3J9LiR7dmFsdWV9YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFBvc3RncmVzdEZpbHRlckJ1aWxkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyLmpzLm1hcCIsImltcG9ydCBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyIGZyb20gJy4vUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcidcbmltcG9ydCB7IEdlbmVyaWNTY2hlbWEgfSBmcm9tICcuL3R5cGVzJ1xuXG50eXBlIEZpbHRlck9wZXJhdG9yID1cbiAgfCAnZXEnXG4gIHwgJ25lcSdcbiAgfCAnZ3QnXG4gIHwgJ2d0ZSdcbiAgfCAnbHQnXG4gIHwgJ2x0ZSdcbiAgfCAnbGlrZSdcbiAgfCAnaWxpa2UnXG4gIHwgJ2lzJ1xuICB8ICdpbidcbiAgfCAnY3MnXG4gIHwgJ2NkJ1xuICB8ICdzbCdcbiAgfCAnc3InXG4gIHwgJ254bCdcbiAgfCAnbnhyJ1xuICB8ICdhZGonXG4gIHwgJ292J1xuICB8ICdmdHMnXG4gIHwgJ3BsZnRzJ1xuICB8ICdwaGZ0cydcbiAgfCAnd2Z0cydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcjxcbiAgU2NoZW1hIGV4dGVuZHMgR2VuZXJpY1NjaGVtYSxcbiAgUm93IGV4dGVuZHMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gIFJlc3VsdCxcbiAgUmVsYXRpb25OYW1lID0gdW5rbm93bixcbiAgUmVsYXRpb25zaGlwcyA9IHVua25vd25cbj4gZXh0ZW5kcyBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyPFNjaGVtYSwgUm93LCBSZXN1bHQsIFJlbGF0aW9uTmFtZSwgUmVsYXRpb25zaGlwcz4ge1xuICBlcTxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93PihcbiAgICBjb2x1bW46IENvbHVtbk5hbWUsXG4gICAgdmFsdWU6IE5vbk51bGxhYmxlPFJvd1tDb2x1bW5OYW1lXT5cbiAgKTogdGhpc1xuICBlcTxWYWx1ZSBleHRlbmRzIHVua25vd24+KGNvbHVtbjogc3RyaW5nLCB2YWx1ZTogTm9uTnVsbGFibGU8VmFsdWU+KTogdGhpc1xuICAvKipcbiAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzIGVxdWFsIHRvIGB2YWx1ZWAuXG4gICAqXG4gICAqIFRvIGNoZWNrIGlmIHRoZSB2YWx1ZSBvZiBgY29sdW1uYCBpcyBOVUxMLCB5b3Ugc2hvdWxkIHVzZSBgLmlzKClgIGluc3RlYWQuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcbiAgICovXG4gIGVxKGNvbHVtbjogc3RyaW5nLCB2YWx1ZTogdW5rbm93bik6IHRoaXMge1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgZXEuJHt2YWx1ZX1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBuZXE8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oY29sdW1uOiBDb2x1bW5OYW1lLCB2YWx1ZTogUm93W0NvbHVtbk5hbWVdKTogdGhpc1xuICBuZXEoY29sdW1uOiBzdHJpbmcsIHZhbHVlOiB1bmtub3duKTogdGhpc1xuICAvKipcbiAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzIG5vdCBlcXVhbCB0byBgdmFsdWVgLlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAqL1xuICBuZXEoY29sdW1uOiBzdHJpbmcsIHZhbHVlOiB1bmtub3duKTogdGhpcyB7XG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBuZXEuJHt2YWx1ZX1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBndDxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93Pihjb2x1bW46IENvbHVtbk5hbWUsIHZhbHVlOiBSb3dbQ29sdW1uTmFtZV0pOiB0aGlzXG4gIGd0KGNvbHVtbjogc3RyaW5nLCB2YWx1ZTogdW5rbm93bik6IHRoaXNcbiAgLyoqXG4gICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBpcyBncmVhdGVyIHRoYW4gYHZhbHVlYC5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuICAgKi9cbiAgZ3QoY29sdW1uOiBzdHJpbmcsIHZhbHVlOiB1bmtub3duKTogdGhpcyB7XG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBndC4ke3ZhbHVlfWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGd0ZTxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93Pihjb2x1bW46IENvbHVtbk5hbWUsIHZhbHVlOiBSb3dbQ29sdW1uTmFtZV0pOiB0aGlzXG4gIGd0ZShjb2x1bW46IHN0cmluZywgdmFsdWU6IHVua25vd24pOiB0aGlzXG4gIC8qKlxuICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGB2YWx1ZWAuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcbiAgICovXG4gIGd0ZShjb2x1bW46IHN0cmluZywgdmFsdWU6IHVua25vd24pOiB0aGlzIHtcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGd0ZS4ke3ZhbHVlfWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGx0PENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KGNvbHVtbjogQ29sdW1uTmFtZSwgdmFsdWU6IFJvd1tDb2x1bW5OYW1lXSk6IHRoaXNcbiAgbHQoY29sdW1uOiBzdHJpbmcsIHZhbHVlOiB1bmtub3duKTogdGhpc1xuICAvKipcbiAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzIGxlc3MgdGhhbiBgdmFsdWVgLlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAqL1xuICBsdChjb2x1bW46IHN0cmluZywgdmFsdWU6IHVua25vd24pOiB0aGlzIHtcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGx0LiR7dmFsdWV9YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgbHRlPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KGNvbHVtbjogQ29sdW1uTmFtZSwgdmFsdWU6IFJvd1tDb2x1bW5OYW1lXSk6IHRoaXNcbiAgbHRlKGNvbHVtbjogc3RyaW5nLCB2YWx1ZTogdW5rbm93bik6IHRoaXNcbiAgLyoqXG4gICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYHZhbHVlYC5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuICAgKi9cbiAgbHRlKGNvbHVtbjogc3RyaW5nLCB2YWx1ZTogdW5rbm93bik6IHRoaXMge1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbHRlLiR7dmFsdWV9YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgbGlrZTxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93Pihjb2x1bW46IENvbHVtbk5hbWUsIHBhdHRlcm46IHN0cmluZyk6IHRoaXNcbiAgbGlrZShjb2x1bW46IHN0cmluZywgcGF0dGVybjogc3RyaW5nKTogdGhpc1xuICAvKipcbiAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIG1hdGNoZXMgYHBhdHRlcm5gIGNhc2Utc2Vuc2l0aXZlbHkuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gcGF0dGVybiAtIFRoZSBwYXR0ZXJuIHRvIG1hdGNoIHdpdGhcbiAgICovXG4gIGxpa2UoY29sdW1uOiBzdHJpbmcsIHBhdHRlcm46IHN0cmluZyk6IHRoaXMge1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbGlrZS4ke3BhdHRlcm59YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgbGlrZUFsbE9mPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KFxuICAgIGNvbHVtbjogQ29sdW1uTmFtZSxcbiAgICBwYXR0ZXJuczogcmVhZG9ubHkgc3RyaW5nW11cbiAgKTogdGhpc1xuICBsaWtlQWxsT2YoY29sdW1uOiBzdHJpbmcsIHBhdHRlcm5zOiByZWFkb25seSBzdHJpbmdbXSk6IHRoaXNcbiAgLyoqXG4gICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBtYXRjaGVzIGFsbCBvZiBgcGF0dGVybnNgIGNhc2Utc2Vuc2l0aXZlbHkuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gcGF0dGVybnMgLSBUaGUgcGF0dGVybnMgdG8gbWF0Y2ggd2l0aFxuICAgKi9cbiAgbGlrZUFsbE9mKGNvbHVtbjogc3RyaW5nLCBwYXR0ZXJuczogcmVhZG9ubHkgc3RyaW5nW10pOiB0aGlzIHtcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGxpa2UoYWxsKS57JHtwYXR0ZXJucy5qb2luKCcsJyl9fWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGxpa2VBbnlPZjxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93PihcbiAgICBjb2x1bW46IENvbHVtbk5hbWUsXG4gICAgcGF0dGVybnM6IHJlYWRvbmx5IHN0cmluZ1tdXG4gICk6IHRoaXNcbiAgbGlrZUFueU9mKGNvbHVtbjogc3RyaW5nLCBwYXR0ZXJuczogcmVhZG9ubHkgc3RyaW5nW10pOiB0aGlzXG4gIC8qKlxuICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgbWF0Y2hlcyBhbnkgb2YgYHBhdHRlcm5zYCBjYXNlLXNlbnNpdGl2ZWx5LlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHBhdHRlcm5zIC0gVGhlIHBhdHRlcm5zIHRvIG1hdGNoIHdpdGhcbiAgICovXG4gIGxpa2VBbnlPZihjb2x1bW46IHN0cmluZywgcGF0dGVybnM6IHJlYWRvbmx5IHN0cmluZ1tdKTogdGhpcyB7XG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBsaWtlKGFueSkueyR7cGF0dGVybnMuam9pbignLCcpfX1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBpbGlrZTxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93Pihjb2x1bW46IENvbHVtbk5hbWUsIHBhdHRlcm46IHN0cmluZyk6IHRoaXNcbiAgaWxpa2UoY29sdW1uOiBzdHJpbmcsIHBhdHRlcm46IHN0cmluZyk6IHRoaXNcbiAgLyoqXG4gICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBtYXRjaGVzIGBwYXR0ZXJuYCBjYXNlLWluc2Vuc2l0aXZlbHkuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gcGF0dGVybiAtIFRoZSBwYXR0ZXJuIHRvIG1hdGNoIHdpdGhcbiAgICovXG4gIGlsaWtlKGNvbHVtbjogc3RyaW5nLCBwYXR0ZXJuOiBzdHJpbmcpOiB0aGlzIHtcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGlsaWtlLiR7cGF0dGVybn1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBpbGlrZUFsbE9mPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KFxuICAgIGNvbHVtbjogQ29sdW1uTmFtZSxcbiAgICBwYXR0ZXJuczogcmVhZG9ubHkgc3RyaW5nW11cbiAgKTogdGhpc1xuICBpbGlrZUFsbE9mKGNvbHVtbjogc3RyaW5nLCBwYXR0ZXJuczogcmVhZG9ubHkgc3RyaW5nW10pOiB0aGlzXG4gIC8qKlxuICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgbWF0Y2hlcyBhbGwgb2YgYHBhdHRlcm5zYCBjYXNlLWluc2Vuc2l0aXZlbHkuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gcGF0dGVybnMgLSBUaGUgcGF0dGVybnMgdG8gbWF0Y2ggd2l0aFxuICAgKi9cbiAgaWxpa2VBbGxPZihjb2x1bW46IHN0cmluZywgcGF0dGVybnM6IHJlYWRvbmx5IHN0cmluZ1tdKTogdGhpcyB7XG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBpbGlrZShhbGwpLnske3BhdHRlcm5zLmpvaW4oJywnKX19YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgaWxpa2VBbnlPZjxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93PihcbiAgICBjb2x1bW46IENvbHVtbk5hbWUsXG4gICAgcGF0dGVybnM6IHJlYWRvbmx5IHN0cmluZ1tdXG4gICk6IHRoaXNcbiAgaWxpa2VBbnlPZihjb2x1bW46IHN0cmluZywgcGF0dGVybnM6IHJlYWRvbmx5IHN0cmluZ1tdKTogdGhpc1xuICAvKipcbiAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIG1hdGNoZXMgYW55IG9mIGBwYXR0ZXJuc2AgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHBhdHRlcm5zIC0gVGhlIHBhdHRlcm5zIHRvIG1hdGNoIHdpdGhcbiAgICovXG4gIGlsaWtlQW55T2YoY29sdW1uOiBzdHJpbmcsIHBhdHRlcm5zOiByZWFkb25seSBzdHJpbmdbXSk6IHRoaXMge1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgaWxpa2UoYW55KS57JHtwYXR0ZXJucy5qb2luKCcsJyl9fWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGlzPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KFxuICAgIGNvbHVtbjogQ29sdW1uTmFtZSxcbiAgICB2YWx1ZTogUm93W0NvbHVtbk5hbWVdICYgKGJvb2xlYW4gfCBudWxsKVxuICApOiB0aGlzXG4gIGlzKGNvbHVtbjogc3RyaW5nLCB2YWx1ZTogYm9vbGVhbiB8IG51bGwpOiB0aGlzXG4gIC8qKlxuICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgSVMgYHZhbHVlYC5cbiAgICpcbiAgICogRm9yIG5vbi1ib29sZWFuIGNvbHVtbnMsIHRoaXMgaXMgb25seSByZWxldmFudCBmb3IgY2hlY2tpbmcgaWYgdGhlIHZhbHVlIG9mXG4gICAqIGBjb2x1bW5gIGlzIE5VTEwgYnkgc2V0dGluZyBgdmFsdWVgIHRvIGBudWxsYC5cbiAgICpcbiAgICogRm9yIGJvb2xlYW4gY29sdW1ucywgeW91IGNhbiBhbHNvIHNldCBgdmFsdWVgIHRvIGB0cnVlYCBvciBgZmFsc2VgIGFuZCBpdFxuICAgKiB3aWxsIGJlaGF2ZSB0aGUgc2FtZSB3YXkgYXMgYC5lcSgpYC5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuICAgKi9cbiAgaXMoY29sdW1uOiBzdHJpbmcsIHZhbHVlOiBib29sZWFuIHwgbnVsbCk6IHRoaXMge1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgaXMuJHt2YWx1ZX1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBpbjxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93PihcbiAgICBjb2x1bW46IENvbHVtbk5hbWUsXG4gICAgdmFsdWVzOiBSZWFkb25seUFycmF5PFJvd1tDb2x1bW5OYW1lXT5cbiAgKTogdGhpc1xuICBpbihjb2x1bW46IHN0cmluZywgdmFsdWVzOiByZWFkb25seSB1bmtub3duW10pOiB0aGlzXG4gIC8qKlxuICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgaW5jbHVkZWQgaW4gdGhlIGB2YWx1ZXNgIGFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHZhbHVlcyAtIFRoZSB2YWx1ZXMgYXJyYXkgdG8gZmlsdGVyIHdpdGhcbiAgICovXG4gIGluKGNvbHVtbjogc3RyaW5nLCB2YWx1ZXM6IHJlYWRvbmx5IHVua25vd25bXSk6IHRoaXMge1xuICAgIGNvbnN0IGNsZWFuZWRWYWx1ZXMgPSBBcnJheS5mcm9tKG5ldyBTZXQodmFsdWVzKSlcbiAgICAgIC5tYXAoKHMpID0+IHtcbiAgICAgICAgLy8gaGFuZGxlIHBvc3RncmVzdCByZXNlcnZlZCBjaGFyYWN0ZXJzXG4gICAgICAgIC8vIGh0dHBzOi8vcG9zdGdyZXN0Lm9yZy9lbi92Ny4wLjAvYXBpLmh0bWwjcmVzZXJ2ZWQtY2hhcmFjdGVyc1xuICAgICAgICBpZiAodHlwZW9mIHMgPT09ICdzdHJpbmcnICYmIG5ldyBSZWdFeHAoJ1ssKCldJykudGVzdChzKSkgcmV0dXJuIGBcIiR7c31cImBcbiAgICAgICAgZWxzZSByZXR1cm4gYCR7c31gXG4gICAgICB9KVxuICAgICAgLmpvaW4oJywnKVxuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgaW4uKCR7Y2xlYW5lZFZhbHVlc30pYClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgY29udGFpbnM8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oXG4gICAgY29sdW1uOiBDb2x1bW5OYW1lLFxuICAgIHZhbHVlOiBzdHJpbmcgfCBSZWFkb25seUFycmF5PFJvd1tDb2x1bW5OYW1lXT4gfCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuICApOiB0aGlzXG4gIGNvbnRhaW5zKGNvbHVtbjogc3RyaW5nLCB2YWx1ZTogc3RyaW5nIHwgcmVhZG9ubHkgdW5rbm93bltdIHwgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiB0aGlzXG4gIC8qKlxuICAgKiBPbmx5IHJlbGV2YW50IGZvciBqc29uYiwgYXJyYXksIGFuZCByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmVcbiAgICogYGNvbHVtbmAgY29udGFpbnMgZXZlcnkgZWxlbWVudCBhcHBlYXJpbmcgaW4gYHZhbHVlYC5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBqc29uYiwgYXJyYXksIG9yIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHZhbHVlIC0gVGhlIGpzb25iLCBhcnJheSwgb3IgcmFuZ2UgdmFsdWUgdG8gZmlsdGVyIHdpdGhcbiAgICovXG4gIGNvbnRhaW5zKGNvbHVtbjogc3RyaW5nLCB2YWx1ZTogc3RyaW5nIHwgcmVhZG9ubHkgdW5rbm93bltdIHwgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiB0aGlzIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gcmFuZ2UgdHlwZXMgY2FuIGJlIGluY2x1c2l2ZSAnWycsICddJyBvciBleGNsdXNpdmUgJygnLCAnKScgc28ganVzdFxuICAgICAgLy8ga2VlcCBpdCBzaW1wbGUgYW5kIGFjY2VwdCBhIHN0cmluZ1xuICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBjcy4ke3ZhbHVlfWApXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgLy8gYXJyYXlcbiAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgY3MueyR7dmFsdWUuam9pbignLCcpfX1gKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBqc29uXG4gICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGNzLiR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfWApXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBjb250YWluZWRCeTxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93PihcbiAgICBjb2x1bW46IENvbHVtbk5hbWUsXG4gICAgdmFsdWU6IHN0cmluZyB8IFJlYWRvbmx5QXJyYXk8Um93W0NvbHVtbk5hbWVdPiB8IFJlY29yZDxzdHJpbmcsIHVua25vd24+XG4gICk6IHRoaXNcbiAgY29udGFpbmVkQnkoY29sdW1uOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgfCByZWFkb25seSB1bmtub3duW10gfCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IHRoaXNcbiAgLyoqXG4gICAqIE9ubHkgcmVsZXZhbnQgZm9yIGpzb25iLCBhcnJheSwgYW5kIHJhbmdlIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZVxuICAgKiBldmVyeSBlbGVtZW50IGFwcGVhcmluZyBpbiBgY29sdW1uYCBpcyBjb250YWluZWQgYnkgYHZhbHVlYC5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBqc29uYiwgYXJyYXksIG9yIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHZhbHVlIC0gVGhlIGpzb25iLCBhcnJheSwgb3IgcmFuZ2UgdmFsdWUgdG8gZmlsdGVyIHdpdGhcbiAgICovXG4gIGNvbnRhaW5lZEJ5KGNvbHVtbjogc3RyaW5nLCB2YWx1ZTogc3RyaW5nIHwgcmVhZG9ubHkgdW5rbm93bltdIHwgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiB0aGlzIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gcmFuZ2VcbiAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgY2QuJHt2YWx1ZX1gKVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIC8vIGFycmF5XG4gICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGNkLnske3ZhbHVlLmpvaW4oJywnKX19YClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8ganNvblxuICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBjZC4ke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gKVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcmFuZ2VHdDxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93Pihjb2x1bW46IENvbHVtbk5hbWUsIHJhbmdlOiBzdHJpbmcpOiB0aGlzXG4gIHJhbmdlR3QoY29sdW1uOiBzdHJpbmcsIHJhbmdlOiBzdHJpbmcpOiB0aGlzXG4gIC8qKlxuICAgKiBPbmx5IHJlbGV2YW50IGZvciByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgZXZlcnkgZWxlbWVudCBpblxuICAgKiBgY29sdW1uYCBpcyBncmVhdGVyIHRoYW4gYW55IGVsZW1lbnQgaW4gYHJhbmdlYC5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSByYW5nZSAtIFRoZSByYW5nZSB0byBmaWx0ZXIgd2l0aFxuICAgKi9cbiAgcmFuZ2VHdChjb2x1bW46IHN0cmluZywgcmFuZ2U6IHN0cmluZyk6IHRoaXMge1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgc3IuJHtyYW5nZX1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICByYW5nZUd0ZTxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93Pihjb2x1bW46IENvbHVtbk5hbWUsIHJhbmdlOiBzdHJpbmcpOiB0aGlzXG4gIHJhbmdlR3RlKGNvbHVtbjogc3RyaW5nLCByYW5nZTogc3RyaW5nKTogdGhpc1xuICAvKipcbiAgICogT25seSByZWxldmFudCBmb3IgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlIGV2ZXJ5IGVsZW1lbnQgaW5cbiAgICogYGNvbHVtbmAgaXMgZWl0aGVyIGNvbnRhaW5lZCBpbiBgcmFuZ2VgIG9yIGdyZWF0ZXIgdGhhbiBhbnkgZWxlbWVudCBpblxuICAgKiBgcmFuZ2VgLlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHJhbmdlIC0gVGhlIHJhbmdlIHRvIGZpbHRlciB3aXRoXG4gICAqL1xuICByYW5nZUd0ZShjb2x1bW46IHN0cmluZywgcmFuZ2U6IHN0cmluZyk6IHRoaXMge1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbnhsLiR7cmFuZ2V9YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcmFuZ2VMdDxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93Pihjb2x1bW46IENvbHVtbk5hbWUsIHJhbmdlOiBzdHJpbmcpOiB0aGlzXG4gIHJhbmdlTHQoY29sdW1uOiBzdHJpbmcsIHJhbmdlOiBzdHJpbmcpOiB0aGlzXG4gIC8qKlxuICAgKiBPbmx5IHJlbGV2YW50IGZvciByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgZXZlcnkgZWxlbWVudCBpblxuICAgKiBgY29sdW1uYCBpcyBsZXNzIHRoYW4gYW55IGVsZW1lbnQgaW4gYHJhbmdlYC5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSByYW5nZSAtIFRoZSByYW5nZSB0byBmaWx0ZXIgd2l0aFxuICAgKi9cbiAgcmFuZ2VMdChjb2x1bW46IHN0cmluZywgcmFuZ2U6IHN0cmluZyk6IHRoaXMge1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgc2wuJHtyYW5nZX1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICByYW5nZUx0ZTxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93Pihjb2x1bW46IENvbHVtbk5hbWUsIHJhbmdlOiBzdHJpbmcpOiB0aGlzXG4gIHJhbmdlTHRlKGNvbHVtbjogc3RyaW5nLCByYW5nZTogc3RyaW5nKTogdGhpc1xuICAvKipcbiAgICogT25seSByZWxldmFudCBmb3IgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlIGV2ZXJ5IGVsZW1lbnQgaW5cbiAgICogYGNvbHVtbmAgaXMgZWl0aGVyIGNvbnRhaW5lZCBpbiBgcmFuZ2VgIG9yIGxlc3MgdGhhbiBhbnkgZWxlbWVudCBpblxuICAgKiBgcmFuZ2VgLlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHJhbmdlIC0gVGhlIHJhbmdlIHRvIGZpbHRlciB3aXRoXG4gICAqL1xuICByYW5nZUx0ZShjb2x1bW46IHN0cmluZywgcmFuZ2U6IHN0cmluZyk6IHRoaXMge1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbnhyLiR7cmFuZ2V9YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcmFuZ2VBZGphY2VudDxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93Pihjb2x1bW46IENvbHVtbk5hbWUsIHJhbmdlOiBzdHJpbmcpOiB0aGlzXG4gIHJhbmdlQWRqYWNlbnQoY29sdW1uOiBzdHJpbmcsIHJhbmdlOiBzdHJpbmcpOiB0aGlzXG4gIC8qKlxuICAgKiBPbmx5IHJlbGV2YW50IGZvciByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXNcbiAgICogbXV0dWFsbHkgZXhjbHVzaXZlIHRvIGByYW5nZWAgYW5kIHRoZXJlIGNhbiBiZSBubyBlbGVtZW50IGJldHdlZW4gdGhlIHR3b1xuICAgKiByYW5nZXMuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgcmFuZ2UgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gcmFuZ2UgLSBUaGUgcmFuZ2UgdG8gZmlsdGVyIHdpdGhcbiAgICovXG4gIHJhbmdlQWRqYWNlbnQoY29sdW1uOiBzdHJpbmcsIHJhbmdlOiBzdHJpbmcpOiB0aGlzIHtcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGFkai4ke3JhbmdlfWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIG92ZXJsYXBzPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KFxuICAgIGNvbHVtbjogQ29sdW1uTmFtZSxcbiAgICB2YWx1ZTogc3RyaW5nIHwgUmVhZG9ubHlBcnJheTxSb3dbQ29sdW1uTmFtZV0+XG4gICk6IHRoaXNcbiAgb3ZlcmxhcHMoY29sdW1uOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgfCByZWFkb25seSB1bmtub3duW10pOiB0aGlzXG4gIC8qKlxuICAgKiBPbmx5IHJlbGV2YW50IGZvciBhcnJheSBhbmQgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlXG4gICAqIGBjb2x1bW5gIGFuZCBgdmFsdWVgIGhhdmUgYW4gZWxlbWVudCBpbiBjb21tb24uXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgYXJyYXkgb3IgcmFuZ2UgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgYXJyYXkgb3IgcmFuZ2UgdmFsdWUgdG8gZmlsdGVyIHdpdGhcbiAgICovXG4gIG92ZXJsYXBzKGNvbHVtbjogc3RyaW5nLCB2YWx1ZTogc3RyaW5nIHwgcmVhZG9ubHkgdW5rbm93bltdKTogdGhpcyB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIHJhbmdlXG4gICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG92LiR7dmFsdWV9YClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXJyYXlcbiAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgb3YueyR7dmFsdWUuam9pbignLCcpfX1gKVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgdGV4dFNlYXJjaDxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93PihcbiAgICBjb2x1bW46IENvbHVtbk5hbWUsXG4gICAgcXVlcnk6IHN0cmluZyxcbiAgICBvcHRpb25zPzogeyBjb25maWc/OiBzdHJpbmc7IHR5cGU/OiAncGxhaW4nIHwgJ3BocmFzZScgfCAnd2Vic2VhcmNoJyB9XG4gICk6IHRoaXNcbiAgdGV4dFNlYXJjaChcbiAgICBjb2x1bW46IHN0cmluZyxcbiAgICBxdWVyeTogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiB7IGNvbmZpZz86IHN0cmluZzsgdHlwZT86ICdwbGFpbicgfCAncGhyYXNlJyB8ICd3ZWJzZWFyY2gnIH1cbiAgKTogdGhpc1xuICAvKipcbiAgICogT25seSByZWxldmFudCBmb3IgdGV4dCBhbmQgdHN2ZWN0b3IgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlXG4gICAqIGBjb2x1bW5gIG1hdGNoZXMgdGhlIHF1ZXJ5IHN0cmluZyBpbiBgcXVlcnlgLlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIHRleHQgb3IgdHN2ZWN0b3IgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gcXVlcnkgLSBUaGUgcXVlcnkgdGV4dCB0byBtYXRjaCB3aXRoXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0gb3B0aW9ucy5jb25maWcgLSBUaGUgdGV4dCBzZWFyY2ggY29uZmlndXJhdGlvbiB0byB1c2VcbiAgICogQHBhcmFtIG9wdGlvbnMudHlwZSAtIENoYW5nZSBob3cgdGhlIGBxdWVyeWAgdGV4dCBpcyBpbnRlcnByZXRlZFxuICAgKi9cbiAgdGV4dFNlYXJjaChcbiAgICBjb2x1bW46IHN0cmluZyxcbiAgICBxdWVyeTogc3RyaW5nLFxuICAgIHsgY29uZmlnLCB0eXBlIH06IHsgY29uZmlnPzogc3RyaW5nOyB0eXBlPzogJ3BsYWluJyB8ICdwaHJhc2UnIHwgJ3dlYnNlYXJjaCcgfSA9IHt9XG4gICk6IHRoaXMge1xuICAgIGxldCB0eXBlUGFydCA9ICcnXG4gICAgaWYgKHR5cGUgPT09ICdwbGFpbicpIHtcbiAgICAgIHR5cGVQYXJ0ID0gJ3BsJ1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3BocmFzZScpIHtcbiAgICAgIHR5cGVQYXJ0ID0gJ3BoJ1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3dlYnNlYXJjaCcpIHtcbiAgICAgIHR5cGVQYXJ0ID0gJ3cnXG4gICAgfVxuICAgIGNvbnN0IGNvbmZpZ1BhcnQgPSBjb25maWcgPT09IHVuZGVmaW5lZCA/ICcnIDogYCgke2NvbmZpZ30pYFxuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgJHt0eXBlUGFydH1mdHMke2NvbmZpZ1BhcnR9LiR7cXVlcnl9YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgbWF0Y2g8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4ocXVlcnk6IFJlY29yZDxDb2x1bW5OYW1lLCBSb3dbQ29sdW1uTmFtZV0+KTogdGhpc1xuICBtYXRjaChxdWVyeTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiB0aGlzXG4gIC8qKlxuICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgZWFjaCBjb2x1bW4gaW4gYHF1ZXJ5YCBrZXlzIGlzIGVxdWFsIHRvIGl0c1xuICAgKiBhc3NvY2lhdGVkIHZhbHVlLiBTaG9ydGhhbmQgZm9yIG11bHRpcGxlIGAuZXEoKWBzLlxuICAgKlxuICAgKiBAcGFyYW0gcXVlcnkgLSBUaGUgb2JqZWN0IHRvIGZpbHRlciB3aXRoLCB3aXRoIGNvbHVtbiBuYW1lcyBhcyBrZXlzIG1hcHBlZFxuICAgKiB0byB0aGVpciBmaWx0ZXIgdmFsdWVzXG4gICAqL1xuICBtYXRjaChxdWVyeTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiB0aGlzIHtcbiAgICBPYmplY3QuZW50cmllcyhxdWVyeSkuZm9yRWFjaCgoW2NvbHVtbiwgdmFsdWVdKSA9PiB7XG4gICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGVxLiR7dmFsdWV9YClcbiAgICB9KVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBub3Q8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oXG4gICAgY29sdW1uOiBDb2x1bW5OYW1lLFxuICAgIG9wZXJhdG9yOiBGaWx0ZXJPcGVyYXRvcixcbiAgICB2YWx1ZTogUm93W0NvbHVtbk5hbWVdXG4gICk6IHRoaXNcbiAgbm90KGNvbHVtbjogc3RyaW5nLCBvcGVyYXRvcjogc3RyaW5nLCB2YWx1ZTogdW5rbm93bik6IHRoaXNcbiAgLyoqXG4gICAqIE1hdGNoIG9ubHkgcm93cyB3aGljaCBkb2Vzbid0IHNhdGlzZnkgdGhlIGZpbHRlci5cbiAgICpcbiAgICogVW5saWtlIG1vc3QgZmlsdGVycywgYG9wZWFyYXRvcmAgYW5kIGB2YWx1ZWAgYXJlIHVzZWQgYXMtaXMgYW5kIG5lZWQgdG9cbiAgICogZm9sbG93IFtQb3N0Z1JFU1RcbiAgICogc3ludGF4XShodHRwczovL3Bvc3RncmVzdC5vcmcvZW4vc3RhYmxlL2FwaS5odG1sI29wZXJhdG9ycykuIFlvdSBhbHNvIG5lZWRcbiAgICogdG8gbWFrZSBzdXJlIHRoZXkgYXJlIHByb3Blcmx5IHNhbml0aXplZC5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSBvcGVyYXRvciAtIFRoZSBvcGVyYXRvciB0byBiZSBuZWdhdGVkIHRvIGZpbHRlciB3aXRoLCBmb2xsb3dpbmdcbiAgICogUG9zdGdSRVNUIHN5bnRheFxuICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGgsIGZvbGxvd2luZyBQb3N0Z1JFU1Qgc3ludGF4XG4gICAqL1xuICBub3QoY29sdW1uOiBzdHJpbmcsIG9wZXJhdG9yOiBzdHJpbmcsIHZhbHVlOiB1bmtub3duKTogdGhpcyB7XG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBub3QuJHtvcGVyYXRvcn0uJHt2YWx1ZX1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogTWF0Y2ggb25seSByb3dzIHdoaWNoIHNhdGlzZnkgYXQgbGVhc3Qgb25lIG9mIHRoZSBmaWx0ZXJzLlxuICAgKlxuICAgKiBVbmxpa2UgbW9zdCBmaWx0ZXJzLCBgZmlsdGVyc2AgaXMgdXNlZCBhcy1pcyBhbmQgbmVlZHMgdG8gZm9sbG93IFtQb3N0Z1JFU1RcbiAgICogc3ludGF4XShodHRwczovL3Bvc3RncmVzdC5vcmcvZW4vc3RhYmxlL2FwaS5odG1sI29wZXJhdG9ycykuIFlvdSBhbHNvIG5lZWRcbiAgICogdG8gbWFrZSBzdXJlIGl0J3MgcHJvcGVybHkgc2FuaXRpemVkLlxuICAgKlxuICAgKiBJdCdzIGN1cnJlbnRseSBub3QgcG9zc2libGUgdG8gZG8gYW4gYC5vcigpYCBmaWx0ZXIgYWNyb3NzIG11bHRpcGxlIHRhYmxlcy5cbiAgICpcbiAgICogQHBhcmFtIGZpbHRlcnMgLSBUaGUgZmlsdGVycyB0byB1c2UsIGZvbGxvd2luZyBQb3N0Z1JFU1Qgc3ludGF4XG4gICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0gb3B0aW9ucy5yZWZlcmVuY2VkVGFibGUgLSBTZXQgdGhpcyB0byBmaWx0ZXIgb24gcmVmZXJlbmNlZCB0YWJsZXNcbiAgICogaW5zdGVhZCBvZiB0aGUgcGFyZW50IHRhYmxlXG4gICAqIEBwYXJhbSBvcHRpb25zLmZvcmVpZ25UYWJsZSAtIERlcHJlY2F0ZWQsIHVzZSBgcmVmZXJlbmNlZFRhYmxlYCBpbnN0ZWFkXG4gICAqL1xuICBvcihcbiAgICBmaWx0ZXJzOiBzdHJpbmcsXG4gICAge1xuICAgICAgZm9yZWlnblRhYmxlLFxuICAgICAgcmVmZXJlbmNlZFRhYmxlID0gZm9yZWlnblRhYmxlLFxuICAgIH06IHsgZm9yZWlnblRhYmxlPzogc3RyaW5nOyByZWZlcmVuY2VkVGFibGU/OiBzdHJpbmcgfSA9IHt9XG4gICk6IHRoaXMge1xuICAgIGNvbnN0IGtleSA9IHJlZmVyZW5jZWRUYWJsZSA/IGAke3JlZmVyZW5jZWRUYWJsZX0ub3JgIDogJ29yJ1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCBgKCR7ZmlsdGVyc30pYClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZmlsdGVyPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KFxuICAgIGNvbHVtbjogQ29sdW1uTmFtZSxcbiAgICBvcGVyYXRvcjogYCR7JycgfCAnbm90Lid9JHtGaWx0ZXJPcGVyYXRvcn1gLFxuICAgIHZhbHVlOiB1bmtub3duXG4gICk6IHRoaXNcbiAgZmlsdGVyKGNvbHVtbjogc3RyaW5nLCBvcGVyYXRvcjogc3RyaW5nLCB2YWx1ZTogdW5rbm93bik6IHRoaXNcbiAgLyoqXG4gICAqIE1hdGNoIG9ubHkgcm93cyB3aGljaCBzYXRpc2Z5IHRoZSBmaWx0ZXIuIFRoaXMgaXMgYW4gZXNjYXBlIGhhdGNoIC0geW91XG4gICAqIHNob3VsZCB1c2UgdGhlIHNwZWNpZmljIGZpbHRlciBtZXRob2RzIHdoZXJldmVyIHBvc3NpYmxlLlxuICAgKlxuICAgKiBVbmxpa2UgbW9zdCBmaWx0ZXJzLCBgb3BlYXJhdG9yYCBhbmQgYHZhbHVlYCBhcmUgdXNlZCBhcy1pcyBhbmQgbmVlZCB0b1xuICAgKiBmb2xsb3cgW1Bvc3RnUkVTVFxuICAgKiBzeW50YXhdKGh0dHBzOi8vcG9zdGdyZXN0Lm9yZy9lbi9zdGFibGUvYXBpLmh0bWwjb3BlcmF0b3JzKS4gWW91IGFsc28gbmVlZFxuICAgKiB0byBtYWtlIHN1cmUgdGhleSBhcmUgcHJvcGVybHkgc2FuaXRpemVkLlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIG9wZXJhdG9yIC0gVGhlIG9wZXJhdG9yIHRvIGZpbHRlciB3aXRoLCBmb2xsb3dpbmcgUG9zdGdSRVNUIHN5bnRheFxuICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGgsIGZvbGxvd2luZyBQb3N0Z1JFU1Qgc3ludGF4XG4gICAqL1xuICBmaWx0ZXIoY29sdW1uOiBzdHJpbmcsIG9wZXJhdG9yOiBzdHJpbmcsIHZhbHVlOiB1bmtub3duKTogdGhpcyB7XG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGAke29wZXJhdG9yfS4ke3ZhbHVlfWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBQb3N0Z3Jlc3RCdWlsZGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vUG9zdGdyZXN0QnVpbGRlclwiKSk7XG5jbGFzcyBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyIGV4dGVuZHMgUG9zdGdyZXN0QnVpbGRlcl8xLmRlZmF1bHQge1xuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYSBTRUxFQ1Qgb24gdGhlIHF1ZXJ5IHJlc3VsdC5cbiAgICAgKlxuICAgICAqIEJ5IGRlZmF1bHQsIGAuaW5zZXJ0KClgLCBgLnVwZGF0ZSgpYCwgYC51cHNlcnQoKWAsIGFuZCBgLmRlbGV0ZSgpYCBkbyBub3RcbiAgICAgKiByZXR1cm4gbW9kaWZpZWQgcm93cy4gQnkgY2FsbGluZyB0aGlzIG1ldGhvZCwgbW9kaWZpZWQgcm93cyBhcmUgcmV0dXJuZWQgaW5cbiAgICAgKiBgZGF0YWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1ucyAtIFRoZSBjb2x1bW5zIHRvIHJldHJpZXZlLCBzZXBhcmF0ZWQgYnkgY29tbWFzXG4gICAgICovXG4gICAgc2VsZWN0KGNvbHVtbnMpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHdoaXRlc3BhY2VzIGV4Y2VwdCB3aGVuIHF1b3RlZFxuICAgICAgICBsZXQgcXVvdGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGNsZWFuZWRDb2x1bW5zID0gKGNvbHVtbnMgIT09IG51bGwgJiYgY29sdW1ucyAhPT0gdm9pZCAwID8gY29sdW1ucyA6ICcqJylcbiAgICAgICAgICAgIC5zcGxpdCgnJylcbiAgICAgICAgICAgIC5tYXAoKGMpID0+IHtcbiAgICAgICAgICAgIGlmICgvXFxzLy50ZXN0KGMpICYmICFxdW90ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYyA9PT0gJ1wiJykge1xuICAgICAgICAgICAgICAgIHF1b3RlZCA9ICFxdW90ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCcnKTtcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldCgnc2VsZWN0JywgY2xlYW5lZENvbHVtbnMpO1xuICAgICAgICBpZiAodGhpcy5oZWFkZXJzWydQcmVmZXInXSkge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzWydQcmVmZXInXSArPSAnLCc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oZWFkZXJzWydQcmVmZXInXSArPSAncmV0dXJuPXJlcHJlc2VudGF0aW9uJztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9yZGVyIHRoZSBxdWVyeSByZXN1bHQgYnkgYGNvbHVtbmAuXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIGNhbGwgdGhpcyBtZXRob2QgbXVsdGlwbGUgdGltZXMgdG8gb3JkZXIgYnkgbXVsdGlwbGUgY29sdW1ucy5cbiAgICAgKlxuICAgICAqIFlvdSBjYW4gb3JkZXIgcmVmZXJlbmNlZCB0YWJsZXMsIGJ1dCBpdCBvbmx5IGFmZmVjdHMgdGhlIG9yZGVyaW5nIG9mIHRoZVxuICAgICAqIHBhcmVudCB0YWJsZSBpZiB5b3UgdXNlIGAhaW5uZXJgIGluIHRoZSBxdWVyeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIG9yZGVyIGJ5XG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYXNjZW5kaW5nIC0gSWYgYHRydWVgLCB0aGUgcmVzdWx0IHdpbGwgYmUgaW4gYXNjZW5kaW5nIG9yZGVyXG4gICAgICogQHBhcmFtIG9wdGlvbnMubnVsbHNGaXJzdCAtIElmIGB0cnVlYCwgYG51bGxgcyBhcHBlYXIgZmlyc3QuIElmIGBmYWxzZWAsXG4gICAgICogYG51bGxgcyBhcHBlYXIgbGFzdC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5yZWZlcmVuY2VkVGFibGUgLSBTZXQgdGhpcyB0byBvcmRlciBhIHJlZmVyZW5jZWQgdGFibGUgYnlcbiAgICAgKiBpdHMgY29sdW1uc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLmZvcmVpZ25UYWJsZSAtIERlcHJlY2F0ZWQsIHVzZSBgb3B0aW9ucy5yZWZlcmVuY2VkVGFibGVgXG4gICAgICogaW5zdGVhZFxuICAgICAqL1xuICAgIG9yZGVyKGNvbHVtbiwgeyBhc2NlbmRpbmcgPSB0cnVlLCBudWxsc0ZpcnN0LCBmb3JlaWduVGFibGUsIHJlZmVyZW5jZWRUYWJsZSA9IGZvcmVpZ25UYWJsZSwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHJlZmVyZW5jZWRUYWJsZSA/IGAke3JlZmVyZW5jZWRUYWJsZX0ub3JkZXJgIDogJ29yZGVyJztcbiAgICAgICAgY29uc3QgZXhpc3RpbmdPcmRlciA9IHRoaXMudXJsLnNlYXJjaFBhcmFtcy5nZXQoa2V5KTtcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldChrZXksIGAke2V4aXN0aW5nT3JkZXIgPyBgJHtleGlzdGluZ09yZGVyfSxgIDogJyd9JHtjb2x1bW59LiR7YXNjZW5kaW5nID8gJ2FzYycgOiAnZGVzYyd9JHtudWxsc0ZpcnN0ID09PSB1bmRlZmluZWQgPyAnJyA6IG51bGxzRmlyc3QgPyAnLm51bGxzZmlyc3QnIDogJy5udWxsc2xhc3QnfWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGltaXQgdGhlIHF1ZXJ5IHJlc3VsdCBieSBgY291bnRgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvdW50IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHJvd3MgdG8gcmV0dXJuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIG9wdGlvbnMucmVmZXJlbmNlZFRhYmxlIC0gU2V0IHRoaXMgdG8gbGltaXQgcm93cyBvZiByZWZlcmVuY2VkXG4gICAgICogdGFibGVzIGluc3RlYWQgb2YgdGhlIHBhcmVudCB0YWJsZVxuICAgICAqIEBwYXJhbSBvcHRpb25zLmZvcmVpZ25UYWJsZSAtIERlcHJlY2F0ZWQsIHVzZSBgb3B0aW9ucy5yZWZlcmVuY2VkVGFibGVgXG4gICAgICogaW5zdGVhZFxuICAgICAqL1xuICAgIGxpbWl0KGNvdW50LCB7IGZvcmVpZ25UYWJsZSwgcmVmZXJlbmNlZFRhYmxlID0gZm9yZWlnblRhYmxlLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdHlwZW9mIHJlZmVyZW5jZWRUYWJsZSA9PT0gJ3VuZGVmaW5lZCcgPyAnbGltaXQnIDogYCR7cmVmZXJlbmNlZFRhYmxlfS5saW1pdGA7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5zZXQoa2V5LCBgJHtjb3VudH1gKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpbWl0IHRoZSBxdWVyeSByZXN1bHQgYnkgc3RhcnRpbmcgYXQgYW4gb2Zmc2V0IGBmcm9tYCBhbmQgZW5kaW5nIGF0IHRoZSBvZmZzZXQgYHRvYC5cbiAgICAgKiBPbmx5IHJlY29yZHMgd2l0aGluIHRoaXMgcmFuZ2UgYXJlIHJldHVybmVkLlxuICAgICAqIFRoaXMgcmVzcGVjdHMgdGhlIHF1ZXJ5IG9yZGVyIGFuZCBpZiB0aGVyZSBpcyBubyBvcmRlciBjbGF1c2UgdGhlIHJhbmdlIGNvdWxkIGJlaGF2ZSB1bmV4cGVjdGVkbHkuXG4gICAgICogVGhlIGBmcm9tYCBhbmQgYHRvYCB2YWx1ZXMgYXJlIDAtYmFzZWQgYW5kIGluY2x1c2l2ZTogYHJhbmdlKDEsIDMpYCB3aWxsIGluY2x1ZGUgdGhlIHNlY29uZCwgdGhpcmRcbiAgICAgKiBhbmQgZm91cnRoIHJvd3Mgb2YgdGhlIHF1ZXJ5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGZyb20gLSBUaGUgc3RhcnRpbmcgaW5kZXggZnJvbSB3aGljaCB0byBsaW1pdCB0aGUgcmVzdWx0XG4gICAgICogQHBhcmFtIHRvIC0gVGhlIGxhc3QgaW5kZXggdG8gd2hpY2ggdG8gbGltaXQgdGhlIHJlc3VsdFxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLnJlZmVyZW5jZWRUYWJsZSAtIFNldCB0aGlzIHRvIGxpbWl0IHJvd3Mgb2YgcmVmZXJlbmNlZFxuICAgICAqIHRhYmxlcyBpbnN0ZWFkIG9mIHRoZSBwYXJlbnQgdGFibGVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5mb3JlaWduVGFibGUgLSBEZXByZWNhdGVkLCB1c2UgYG9wdGlvbnMucmVmZXJlbmNlZFRhYmxlYFxuICAgICAqIGluc3RlYWRcbiAgICAgKi9cbiAgICByYW5nZShmcm9tLCB0bywgeyBmb3JlaWduVGFibGUsIHJlZmVyZW5jZWRUYWJsZSA9IGZvcmVpZ25UYWJsZSwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGtleU9mZnNldCA9IHR5cGVvZiByZWZlcmVuY2VkVGFibGUgPT09ICd1bmRlZmluZWQnID8gJ29mZnNldCcgOiBgJHtyZWZlcmVuY2VkVGFibGV9Lm9mZnNldGA7XG4gICAgICAgIGNvbnN0IGtleUxpbWl0ID0gdHlwZW9mIHJlZmVyZW5jZWRUYWJsZSA9PT0gJ3VuZGVmaW5lZCcgPyAnbGltaXQnIDogYCR7cmVmZXJlbmNlZFRhYmxlfS5saW1pdGA7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5zZXQoa2V5T2Zmc2V0LCBgJHtmcm9tfWApO1xuICAgICAgICAvLyBSYW5nZSBpcyBpbmNsdXNpdmUsIHNvIGFkZCAxXG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5zZXQoa2V5TGltaXQsIGAke3RvIC0gZnJvbSArIDF9YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIEFib3J0U2lnbmFsIGZvciB0aGUgZmV0Y2ggcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzaWduYWwgLSBUaGUgQWJvcnRTaWduYWwgdG8gdXNlIGZvciB0aGUgZmV0Y2ggcmVxdWVzdFxuICAgICAqL1xuICAgIGFib3J0U2lnbmFsKHNpZ25hbCkge1xuICAgICAgICB0aGlzLnNpZ25hbCA9IHNpZ25hbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBgZGF0YWAgYXMgYSBzaW5nbGUgb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXkgb2Ygb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIFF1ZXJ5IHJlc3VsdCBtdXN0IGJlIG9uZSByb3cgKGUuZy4gdXNpbmcgYC5saW1pdCgxKWApLCBvdGhlcndpc2UgdGhpc1xuICAgICAqIHJldHVybnMgYW4gZXJyb3IuXG4gICAgICovXG4gICAgc2luZ2xlKCkge1xuICAgICAgICB0aGlzLmhlYWRlcnNbJ0FjY2VwdCddID0gJ2FwcGxpY2F0aW9uL3ZuZC5wZ3JzdC5vYmplY3QranNvbic7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYGRhdGFgIGFzIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5IG9mIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBRdWVyeSByZXN1bHQgbXVzdCBiZSB6ZXJvIG9yIG9uZSByb3cgKGUuZy4gdXNpbmcgYC5saW1pdCgxKWApLCBvdGhlcndpc2VcbiAgICAgKiB0aGlzIHJldHVybnMgYW4gZXJyb3IuXG4gICAgICovXG4gICAgbWF5YmVTaW5nbGUoKSB7XG4gICAgICAgIC8vIFRlbXBvcmFyeSBwYXJ0aWFsIGZpeCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL3N1cGFiYXNlL3Bvc3RncmVzdC1qcy9pc3N1ZXMvMzYxXG4gICAgICAgIC8vIElzc3VlIHBlcnNpc3RzIGUuZy4gZm9yIGAuaW5zZXJ0KFsuLi5dKS5zZWxlY3QoKS5tYXliZVNpbmdsZSgpYFxuICAgICAgICBpZiAodGhpcy5tZXRob2QgPT09ICdHRVQnKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlcnNbJ0FjY2VwdCddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzWydBY2NlcHQnXSA9ICdhcHBsaWNhdGlvbi92bmQucGdyc3Qub2JqZWN0K2pzb24nO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNNYXliZVNpbmdsZSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYGRhdGFgIGFzIGEgc3RyaW5nIGluIENTViBmb3JtYXQuXG4gICAgICovXG4gICAgY3N2KCkge1xuICAgICAgICB0aGlzLmhlYWRlcnNbJ0FjY2VwdCddID0gJ3RleHQvY3N2JztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBgZGF0YWAgYXMgYW4gb2JqZWN0IGluIFtHZW9KU09OXShodHRwczovL2dlb2pzb24ub3JnKSBmb3JtYXQuXG4gICAgICovXG4gICAgZ2VvanNvbigpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzWydBY2NlcHQnXSA9ICdhcHBsaWNhdGlvbi9nZW8ranNvbic7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYGRhdGFgIGFzIHRoZSBFWFBMQUlOIHBsYW4gZm9yIHRoZSBxdWVyeS5cbiAgICAgKlxuICAgICAqIFlvdSBuZWVkIHRvIGVuYWJsZSB0aGVcbiAgICAgKiBbZGJfcGxhbl9lbmFibGVkXShodHRwczovL3N1cGFiYXNlLmNvbS9kb2NzL2d1aWRlcy9kYXRhYmFzZS9kZWJ1Z2dpbmctcGVyZm9ybWFuY2UjZW5hYmxpbmctZXhwbGFpbilcbiAgICAgKiBzZXR0aW5nIGJlZm9yZSB1c2luZyB0aGlzIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYW5hbHl6ZSAtIElmIGB0cnVlYCwgdGhlIHF1ZXJ5IHdpbGwgYmUgZXhlY3V0ZWQgYW5kIHRoZVxuICAgICAqIGFjdHVhbCBydW4gdGltZSB3aWxsIGJlIHJldHVybmVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy52ZXJib3NlIC0gSWYgYHRydWVgLCB0aGUgcXVlcnkgaWRlbnRpZmllciB3aWxsIGJlIHJldHVybmVkXG4gICAgICogYW5kIGBkYXRhYCB3aWxsIGluY2x1ZGUgdGhlIG91dHB1dCBjb2x1bW5zIG9mIHRoZSBxdWVyeVxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc2V0dGluZ3MgLSBJZiBgdHJ1ZWAsIGluY2x1ZGUgaW5mb3JtYXRpb24gb24gY29uZmlndXJhdGlvblxuICAgICAqIHBhcmFtZXRlcnMgdGhhdCBhZmZlY3QgcXVlcnkgcGxhbm5pbmdcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmJ1ZmZlcnMgLSBJZiBgdHJ1ZWAsIGluY2x1ZGUgaW5mb3JtYXRpb24gb24gYnVmZmVyIHVzYWdlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy53YWwgLSBJZiBgdHJ1ZWAsIGluY2x1ZGUgaW5mb3JtYXRpb24gb24gV0FMIHJlY29yZCBnZW5lcmF0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5mb3JtYXQgLSBUaGUgZm9ybWF0IG9mIHRoZSBvdXRwdXQsIGNhbiBiZSBgXCJ0ZXh0XCJgIChkZWZhdWx0KVxuICAgICAqIG9yIGBcImpzb25cImBcbiAgICAgKi9cbiAgICBleHBsYWluKHsgYW5hbHl6ZSA9IGZhbHNlLCB2ZXJib3NlID0gZmFsc2UsIHNldHRpbmdzID0gZmFsc2UsIGJ1ZmZlcnMgPSBmYWxzZSwgd2FsID0gZmFsc2UsIGZvcm1hdCA9ICd0ZXh0JywgfSA9IHt9KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IFtcbiAgICAgICAgICAgIGFuYWx5emUgPyAnYW5hbHl6ZScgOiBudWxsLFxuICAgICAgICAgICAgdmVyYm9zZSA/ICd2ZXJib3NlJyA6IG51bGwsXG4gICAgICAgICAgICBzZXR0aW5ncyA/ICdzZXR0aW5ncycgOiBudWxsLFxuICAgICAgICAgICAgYnVmZmVycyA/ICdidWZmZXJzJyA6IG51bGwsXG4gICAgICAgICAgICB3YWwgPyAnd2FsJyA6IG51bGwsXG4gICAgICAgIF1cbiAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgICAgIC5qb2luKCd8Jyk7XG4gICAgICAgIC8vIEFuIEFjY2VwdCBoZWFkZXIgY2FuIGNhcnJ5IG11bHRpcGxlIG1lZGlhIHR5cGVzIGJ1dCBwb3N0Z3Jlc3QtanMgYWx3YXlzIHNlbmRzIG9uZVxuICAgICAgICBjb25zdCBmb3JNZWRpYXR5cGUgPSAoX2EgPSB0aGlzLmhlYWRlcnNbJ0FjY2VwdCddKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgIHRoaXMuaGVhZGVyc1snQWNjZXB0J10gPSBgYXBwbGljYXRpb24vdm5kLnBncnN0LnBsYW4rJHtmb3JtYXR9OyBmb3I9XCIke2Zvck1lZGlhdHlwZX1cIjsgb3B0aW9ucz0ke29wdGlvbnN9O2A7XG4gICAgICAgIGlmIChmb3JtYXQgPT09ICdqc29uJylcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUm9sbGJhY2sgdGhlIHF1ZXJ5LlxuICAgICAqXG4gICAgICogYGRhdGFgIHdpbGwgc3RpbGwgYmUgcmV0dXJuZWQsIGJ1dCB0aGUgcXVlcnkgaXMgbm90IGNvbW1pdHRlZC5cbiAgICAgKi9cbiAgICByb2xsYmFjaygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoKChfYSA9IHRoaXMuaGVhZGVyc1snUHJlZmVyJ10pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKS50cmltKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzWydQcmVmZXInXSArPSAnLHR4PXJvbGxiYWNrJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyc1snUHJlZmVyJ10gPSAndHg9cm9sbGJhY2snO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGUgdHlwZSBvZiB0aGUgcmV0dXJuZWQgYGRhdGFgLlxuICAgICAqXG4gICAgICogQHR5cGVQYXJhbSBOZXdSZXN1bHQgLSBUaGUgbmV3IHJlc3VsdCB0eXBlIHRvIG92ZXJyaWRlIHdpdGhcbiAgICAgKi9cbiAgICByZXR1cm5zKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlci5qcy5tYXAiLCJpbXBvcnQgUG9zdGdyZXN0QnVpbGRlciBmcm9tICcuL1Bvc3RncmVzdEJ1aWxkZXInXG5pbXBvcnQgeyBHZXRSZXN1bHQgfSBmcm9tICcuL3NlbGVjdC1xdWVyeS1wYXJzZXInXG5pbXBvcnQgeyBHZW5lcmljU2NoZW1hIH0gZnJvbSAnLi90eXBlcydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcjxcbiAgU2NoZW1hIGV4dGVuZHMgR2VuZXJpY1NjaGVtYSxcbiAgUm93IGV4dGVuZHMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gIFJlc3VsdCxcbiAgUmVsYXRpb25OYW1lID0gdW5rbm93bixcbiAgUmVsYXRpb25zaGlwcyA9IHVua25vd25cbj4gZXh0ZW5kcyBQb3N0Z3Jlc3RCdWlsZGVyPFJlc3VsdD4ge1xuICAvKipcbiAgICogUGVyZm9ybSBhIFNFTEVDVCBvbiB0aGUgcXVlcnkgcmVzdWx0LlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBgLmluc2VydCgpYCwgYC51cGRhdGUoKWAsIGAudXBzZXJ0KClgLCBhbmQgYC5kZWxldGUoKWAgZG8gbm90XG4gICAqIHJldHVybiBtb2RpZmllZCByb3dzLiBCeSBjYWxsaW5nIHRoaXMgbWV0aG9kLCBtb2RpZmllZCByb3dzIGFyZSByZXR1cm5lZCBpblxuICAgKiBgZGF0YWAuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW5zIC0gVGhlIGNvbHVtbnMgdG8gcmV0cmlldmUsIHNlcGFyYXRlZCBieSBjb21tYXNcbiAgICovXG4gIHNlbGVjdDxcbiAgICBRdWVyeSBleHRlbmRzIHN0cmluZyA9ICcqJyxcbiAgICBOZXdSZXN1bHRPbmUgPSBHZXRSZXN1bHQ8U2NoZW1hLCBSb3csIFJlbGF0aW9uTmFtZSwgUmVsYXRpb25zaGlwcywgUXVlcnk+XG4gID4oXG4gICAgY29sdW1ucz86IFF1ZXJ5XG4gICk6IFBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXI8U2NoZW1hLCBSb3csIE5ld1Jlc3VsdE9uZVtdLCBSZWxhdGlvbk5hbWUsIFJlbGF0aW9uc2hpcHM+IHtcbiAgICAvLyBSZW1vdmUgd2hpdGVzcGFjZXMgZXhjZXB0IHdoZW4gcXVvdGVkXG4gICAgbGV0IHF1b3RlZCA9IGZhbHNlXG4gICAgY29uc3QgY2xlYW5lZENvbHVtbnMgPSAoY29sdW1ucyA/PyAnKicpXG4gICAgICAuc3BsaXQoJycpXG4gICAgICAubWFwKChjKSA9PiB7XG4gICAgICAgIGlmICgvXFxzLy50ZXN0KGMpICYmICFxdW90ZWQpIHtcbiAgICAgICAgICByZXR1cm4gJydcbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA9PT0gJ1wiJykge1xuICAgICAgICAgIHF1b3RlZCA9ICFxdW90ZWRcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY1xuICAgICAgfSlcbiAgICAgIC5qb2luKCcnKVxuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3NlbGVjdCcsIGNsZWFuZWRDb2x1bW5zKVxuICAgIGlmICh0aGlzLmhlYWRlcnNbJ1ByZWZlciddKSB7XG4gICAgICB0aGlzLmhlYWRlcnNbJ1ByZWZlciddICs9ICcsJ1xuICAgIH1cbiAgICB0aGlzLmhlYWRlcnNbJ1ByZWZlciddICs9ICdyZXR1cm49cmVwcmVzZW50YXRpb24nXG4gICAgcmV0dXJuIHRoaXMgYXMgdW5rbm93biBhcyBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyPFxuICAgICAgU2NoZW1hLFxuICAgICAgUm93LFxuICAgICAgTmV3UmVzdWx0T25lW10sXG4gICAgICBSZWxhdGlvbk5hbWUsXG4gICAgICBSZWxhdGlvbnNoaXBzXG4gICAgPlxuICB9XG5cbiAgb3JkZXI8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oXG4gICAgY29sdW1uOiBDb2x1bW5OYW1lLFxuICAgIG9wdGlvbnM/OiB7IGFzY2VuZGluZz86IGJvb2xlYW47IG51bGxzRmlyc3Q/OiBib29sZWFuOyByZWZlcmVuY2VkVGFibGU/OiB1bmRlZmluZWQgfVxuICApOiB0aGlzXG4gIG9yZGVyKFxuICAgIGNvbHVtbjogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiB7IGFzY2VuZGluZz86IGJvb2xlYW47IG51bGxzRmlyc3Q/OiBib29sZWFuOyByZWZlcmVuY2VkVGFibGU/OiBzdHJpbmcgfVxuICApOiB0aGlzXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYG9wdGlvbnMucmVmZXJlbmNlZFRhYmxlYCBpbnN0ZWFkIG9mIGBvcHRpb25zLmZvcmVpZ25UYWJsZWBcbiAgICovXG4gIG9yZGVyPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KFxuICAgIGNvbHVtbjogQ29sdW1uTmFtZSxcbiAgICBvcHRpb25zPzogeyBhc2NlbmRpbmc/OiBib29sZWFuOyBudWxsc0ZpcnN0PzogYm9vbGVhbjsgZm9yZWlnblRhYmxlPzogdW5kZWZpbmVkIH1cbiAgKTogdGhpc1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGBvcHRpb25zLnJlZmVyZW5jZWRUYWJsZWAgaW5zdGVhZCBvZiBgb3B0aW9ucy5mb3JlaWduVGFibGVgXG4gICAqL1xuICBvcmRlcihcbiAgICBjb2x1bW46IHN0cmluZyxcbiAgICBvcHRpb25zPzogeyBhc2NlbmRpbmc/OiBib29sZWFuOyBudWxsc0ZpcnN0PzogYm9vbGVhbjsgZm9yZWlnblRhYmxlPzogc3RyaW5nIH1cbiAgKTogdGhpc1xuICAvKipcbiAgICogT3JkZXIgdGhlIHF1ZXJ5IHJlc3VsdCBieSBgY29sdW1uYC5cbiAgICpcbiAgICogWW91IGNhbiBjYWxsIHRoaXMgbWV0aG9kIG11bHRpcGxlIHRpbWVzIHRvIG9yZGVyIGJ5IG11bHRpcGxlIGNvbHVtbnMuXG4gICAqXG4gICAqIFlvdSBjYW4gb3JkZXIgcmVmZXJlbmNlZCB0YWJsZXMsIGJ1dCBpdCBvbmx5IGFmZmVjdHMgdGhlIG9yZGVyaW5nIG9mIHRoZVxuICAgKiBwYXJlbnQgdGFibGUgaWYgeW91IHVzZSBgIWlubmVyYCBpbiB0aGUgcXVlcnkuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIG9yZGVyIGJ5XG4gICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0gb3B0aW9ucy5hc2NlbmRpbmcgLSBJZiBgdHJ1ZWAsIHRoZSByZXN1bHQgd2lsbCBiZSBpbiBhc2NlbmRpbmcgb3JkZXJcbiAgICogQHBhcmFtIG9wdGlvbnMubnVsbHNGaXJzdCAtIElmIGB0cnVlYCwgYG51bGxgcyBhcHBlYXIgZmlyc3QuIElmIGBmYWxzZWAsXG4gICAqIGBudWxsYHMgYXBwZWFyIGxhc3QuXG4gICAqIEBwYXJhbSBvcHRpb25zLnJlZmVyZW5jZWRUYWJsZSAtIFNldCB0aGlzIHRvIG9yZGVyIGEgcmVmZXJlbmNlZCB0YWJsZSBieVxuICAgKiBpdHMgY29sdW1uc1xuICAgKiBAcGFyYW0gb3B0aW9ucy5mb3JlaWduVGFibGUgLSBEZXByZWNhdGVkLCB1c2UgYG9wdGlvbnMucmVmZXJlbmNlZFRhYmxlYFxuICAgKiBpbnN0ZWFkXG4gICAqL1xuICBvcmRlcihcbiAgICBjb2x1bW46IHN0cmluZyxcbiAgICB7XG4gICAgICBhc2NlbmRpbmcgPSB0cnVlLFxuICAgICAgbnVsbHNGaXJzdCxcbiAgICAgIGZvcmVpZ25UYWJsZSxcbiAgICAgIHJlZmVyZW5jZWRUYWJsZSA9IGZvcmVpZ25UYWJsZSxcbiAgICB9OiB7XG4gICAgICBhc2NlbmRpbmc/OiBib29sZWFuXG4gICAgICBudWxsc0ZpcnN0PzogYm9vbGVhblxuICAgICAgZm9yZWlnblRhYmxlPzogc3RyaW5nXG4gICAgICByZWZlcmVuY2VkVGFibGU/OiBzdHJpbmdcbiAgICB9ID0ge31cbiAgKTogdGhpcyB7XG4gICAgY29uc3Qga2V5ID0gcmVmZXJlbmNlZFRhYmxlID8gYCR7cmVmZXJlbmNlZFRhYmxlfS5vcmRlcmAgOiAnb3JkZXInXG4gICAgY29uc3QgZXhpc3RpbmdPcmRlciA9IHRoaXMudXJsLnNlYXJjaFBhcmFtcy5nZXQoa2V5KVxuXG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldChcbiAgICAgIGtleSxcbiAgICAgIGAke2V4aXN0aW5nT3JkZXIgPyBgJHtleGlzdGluZ09yZGVyfSxgIDogJyd9JHtjb2x1bW59LiR7YXNjZW5kaW5nID8gJ2FzYycgOiAnZGVzYyd9JHtcbiAgICAgICAgbnVsbHNGaXJzdCA9PT0gdW5kZWZpbmVkID8gJycgOiBudWxsc0ZpcnN0ID8gJy5udWxsc2ZpcnN0JyA6ICcubnVsbHNsYXN0J1xuICAgICAgfWBcbiAgICApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBMaW1pdCB0aGUgcXVlcnkgcmVzdWx0IGJ5IGBjb3VudGAuXG4gICAqXG4gICAqIEBwYXJhbSBjb3VudCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiByb3dzIHRvIHJldHVyblxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIG9wdGlvbnMucmVmZXJlbmNlZFRhYmxlIC0gU2V0IHRoaXMgdG8gbGltaXQgcm93cyBvZiByZWZlcmVuY2VkXG4gICAqIHRhYmxlcyBpbnN0ZWFkIG9mIHRoZSBwYXJlbnQgdGFibGVcbiAgICogQHBhcmFtIG9wdGlvbnMuZm9yZWlnblRhYmxlIC0gRGVwcmVjYXRlZCwgdXNlIGBvcHRpb25zLnJlZmVyZW5jZWRUYWJsZWBcbiAgICogaW5zdGVhZFxuICAgKi9cbiAgbGltaXQoXG4gICAgY291bnQ6IG51bWJlcixcbiAgICB7XG4gICAgICBmb3JlaWduVGFibGUsXG4gICAgICByZWZlcmVuY2VkVGFibGUgPSBmb3JlaWduVGFibGUsXG4gICAgfTogeyBmb3JlaWduVGFibGU/OiBzdHJpbmc7IHJlZmVyZW5jZWRUYWJsZT86IHN0cmluZyB9ID0ge31cbiAgKTogdGhpcyB7XG4gICAgY29uc3Qga2V5ID0gdHlwZW9mIHJlZmVyZW5jZWRUYWJsZSA9PT0gJ3VuZGVmaW5lZCcgPyAnbGltaXQnIDogYCR7cmVmZXJlbmNlZFRhYmxlfS5saW1pdGBcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KGtleSwgYCR7Y291bnR9YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIExpbWl0IHRoZSBxdWVyeSByZXN1bHQgYnkgc3RhcnRpbmcgYXQgYW4gb2Zmc2V0IGBmcm9tYCBhbmQgZW5kaW5nIGF0IHRoZSBvZmZzZXQgYHRvYC5cbiAgICogT25seSByZWNvcmRzIHdpdGhpbiB0aGlzIHJhbmdlIGFyZSByZXR1cm5lZC5cbiAgICogVGhpcyByZXNwZWN0cyB0aGUgcXVlcnkgb3JkZXIgYW5kIGlmIHRoZXJlIGlzIG5vIG9yZGVyIGNsYXVzZSB0aGUgcmFuZ2UgY291bGQgYmVoYXZlIHVuZXhwZWN0ZWRseS5cbiAgICogVGhlIGBmcm9tYCBhbmQgYHRvYCB2YWx1ZXMgYXJlIDAtYmFzZWQgYW5kIGluY2x1c2l2ZTogYHJhbmdlKDEsIDMpYCB3aWxsIGluY2x1ZGUgdGhlIHNlY29uZCwgdGhpcmRcbiAgICogYW5kIGZvdXJ0aCByb3dzIG9mIHRoZSBxdWVyeS5cbiAgICpcbiAgICogQHBhcmFtIGZyb20gLSBUaGUgc3RhcnRpbmcgaW5kZXggZnJvbSB3aGljaCB0byBsaW1pdCB0aGUgcmVzdWx0XG4gICAqIEBwYXJhbSB0byAtIFRoZSBsYXN0IGluZGV4IHRvIHdoaWNoIHRvIGxpbWl0IHRoZSByZXN1bHRcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSBvcHRpb25zLnJlZmVyZW5jZWRUYWJsZSAtIFNldCB0aGlzIHRvIGxpbWl0IHJvd3Mgb2YgcmVmZXJlbmNlZFxuICAgKiB0YWJsZXMgaW5zdGVhZCBvZiB0aGUgcGFyZW50IHRhYmxlXG4gICAqIEBwYXJhbSBvcHRpb25zLmZvcmVpZ25UYWJsZSAtIERlcHJlY2F0ZWQsIHVzZSBgb3B0aW9ucy5yZWZlcmVuY2VkVGFibGVgXG4gICAqIGluc3RlYWRcbiAgICovXG4gIHJhbmdlKFxuICAgIGZyb206IG51bWJlcixcbiAgICB0bzogbnVtYmVyLFxuICAgIHtcbiAgICAgIGZvcmVpZ25UYWJsZSxcbiAgICAgIHJlZmVyZW5jZWRUYWJsZSA9IGZvcmVpZ25UYWJsZSxcbiAgICB9OiB7IGZvcmVpZ25UYWJsZT86IHN0cmluZzsgcmVmZXJlbmNlZFRhYmxlPzogc3RyaW5nIH0gPSB7fVxuICApOiB0aGlzIHtcbiAgICBjb25zdCBrZXlPZmZzZXQgPVxuICAgICAgdHlwZW9mIHJlZmVyZW5jZWRUYWJsZSA9PT0gJ3VuZGVmaW5lZCcgPyAnb2Zmc2V0JyA6IGAke3JlZmVyZW5jZWRUYWJsZX0ub2Zmc2V0YFxuICAgIGNvbnN0IGtleUxpbWl0ID0gdHlwZW9mIHJlZmVyZW5jZWRUYWJsZSA9PT0gJ3VuZGVmaW5lZCcgPyAnbGltaXQnIDogYCR7cmVmZXJlbmNlZFRhYmxlfS5saW1pdGBcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KGtleU9mZnNldCwgYCR7ZnJvbX1gKVxuICAgIC8vIFJhbmdlIGlzIGluY2x1c2l2ZSwgc28gYWRkIDFcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KGtleUxpbWl0LCBgJHt0byAtIGZyb20gKyAxfWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIEFib3J0U2lnbmFsIGZvciB0aGUgZmV0Y2ggcmVxdWVzdC5cbiAgICpcbiAgICogQHBhcmFtIHNpZ25hbCAtIFRoZSBBYm9ydFNpZ25hbCB0byB1c2UgZm9yIHRoZSBmZXRjaCByZXF1ZXN0XG4gICAqL1xuICBhYm9ydFNpZ25hbChzaWduYWw6IEFib3J0U2lnbmFsKTogdGhpcyB7XG4gICAgdGhpcy5zaWduYWwgPSBzaWduYWxcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBgZGF0YWAgYXMgYSBzaW5nbGUgb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXkgb2Ygb2JqZWN0cy5cbiAgICpcbiAgICogUXVlcnkgcmVzdWx0IG11c3QgYmUgb25lIHJvdyAoZS5nLiB1c2luZyBgLmxpbWl0KDEpYCksIG90aGVyd2lzZSB0aGlzXG4gICAqIHJldHVybnMgYW4gZXJyb3IuXG4gICAqL1xuICBzaW5nbGU8XG4gICAgUmVzdWx0T25lID0gUmVzdWx0IGV4dGVuZHMgKGluZmVyIFJlc3VsdE9uZSlbXSA/IFJlc3VsdE9uZSA6IG5ldmVyXG4gID4oKTogUG9zdGdyZXN0QnVpbGRlcjxSZXN1bHRPbmU+IHtcbiAgICB0aGlzLmhlYWRlcnNbJ0FjY2VwdCddID0gJ2FwcGxpY2F0aW9uL3ZuZC5wZ3JzdC5vYmplY3QranNvbidcbiAgICByZXR1cm4gdGhpcyBhcyBQb3N0Z3Jlc3RCdWlsZGVyPFJlc3VsdE9uZT5cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYGRhdGFgIGFzIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5IG9mIG9iamVjdHMuXG4gICAqXG4gICAqIFF1ZXJ5IHJlc3VsdCBtdXN0IGJlIHplcm8gb3Igb25lIHJvdyAoZS5nLiB1c2luZyBgLmxpbWl0KDEpYCksIG90aGVyd2lzZVxuICAgKiB0aGlzIHJldHVybnMgYW4gZXJyb3IuXG4gICAqL1xuICBtYXliZVNpbmdsZTxcbiAgICBSZXN1bHRPbmUgPSBSZXN1bHQgZXh0ZW5kcyAoaW5mZXIgUmVzdWx0T25lKVtdID8gUmVzdWx0T25lIDogbmV2ZXJcbiAgPigpOiBQb3N0Z3Jlc3RCdWlsZGVyPFJlc3VsdE9uZSB8IG51bGw+IHtcbiAgICAvLyBUZW1wb3JhcnkgcGFydGlhbCBmaXggZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9zdXBhYmFzZS9wb3N0Z3Jlc3QtanMvaXNzdWVzLzM2MVxuICAgIC8vIElzc3VlIHBlcnNpc3RzIGUuZy4gZm9yIGAuaW5zZXJ0KFsuLi5dKS5zZWxlY3QoKS5tYXliZVNpbmdsZSgpYFxuICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAgIHRoaXMuaGVhZGVyc1snQWNjZXB0J10gPSAnYXBwbGljYXRpb24vanNvbidcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oZWFkZXJzWydBY2NlcHQnXSA9ICdhcHBsaWNhdGlvbi92bmQucGdyc3Qub2JqZWN0K2pzb24nXG4gICAgfVxuICAgIHRoaXMuaXNNYXliZVNpbmdsZSA9IHRydWVcbiAgICByZXR1cm4gdGhpcyBhcyBQb3N0Z3Jlc3RCdWlsZGVyPFJlc3VsdE9uZSB8IG51bGw+XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGBkYXRhYCBhcyBhIHN0cmluZyBpbiBDU1YgZm9ybWF0LlxuICAgKi9cbiAgY3N2KCk6IFBvc3RncmVzdEJ1aWxkZXI8c3RyaW5nPiB7XG4gICAgdGhpcy5oZWFkZXJzWydBY2NlcHQnXSA9ICd0ZXh0L2NzdidcbiAgICByZXR1cm4gdGhpcyBhcyBQb3N0Z3Jlc3RCdWlsZGVyPHN0cmluZz5cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYGRhdGFgIGFzIGFuIG9iamVjdCBpbiBbR2VvSlNPTl0oaHR0cHM6Ly9nZW9qc29uLm9yZykgZm9ybWF0LlxuICAgKi9cbiAgZ2VvanNvbigpOiBQb3N0Z3Jlc3RCdWlsZGVyPFJlY29yZDxzdHJpbmcsIHVua25vd24+PiB7XG4gICAgdGhpcy5oZWFkZXJzWydBY2NlcHQnXSA9ICdhcHBsaWNhdGlvbi9nZW8ranNvbidcbiAgICByZXR1cm4gdGhpcyBhcyBQb3N0Z3Jlc3RCdWlsZGVyPFJlY29yZDxzdHJpbmcsIHVua25vd24+PlxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBgZGF0YWAgYXMgdGhlIEVYUExBSU4gcGxhbiBmb3IgdGhlIHF1ZXJ5LlxuICAgKlxuICAgKiBZb3UgbmVlZCB0byBlbmFibGUgdGhlXG4gICAqIFtkYl9wbGFuX2VuYWJsZWRdKGh0dHBzOi8vc3VwYWJhc2UuY29tL2RvY3MvZ3VpZGVzL2RhdGFiYXNlL2RlYnVnZ2luZy1wZXJmb3JtYW5jZSNlbmFibGluZy1leHBsYWluKVxuICAgKiBzZXR0aW5nIGJlZm9yZSB1c2luZyB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLmFuYWx5emUgLSBJZiBgdHJ1ZWAsIHRoZSBxdWVyeSB3aWxsIGJlIGV4ZWN1dGVkIGFuZCB0aGVcbiAgICogYWN0dWFsIHJ1biB0aW1lIHdpbGwgYmUgcmV0dXJuZWRcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMudmVyYm9zZSAtIElmIGB0cnVlYCwgdGhlIHF1ZXJ5IGlkZW50aWZpZXIgd2lsbCBiZSByZXR1cm5lZFxuICAgKiBhbmQgYGRhdGFgIHdpbGwgaW5jbHVkZSB0aGUgb3V0cHV0IGNvbHVtbnMgb2YgdGhlIHF1ZXJ5XG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLnNldHRpbmdzIC0gSWYgYHRydWVgLCBpbmNsdWRlIGluZm9ybWF0aW9uIG9uIGNvbmZpZ3VyYXRpb25cbiAgICogcGFyYW1ldGVycyB0aGF0IGFmZmVjdCBxdWVyeSBwbGFubmluZ1xuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucy5idWZmZXJzIC0gSWYgYHRydWVgLCBpbmNsdWRlIGluZm9ybWF0aW9uIG9uIGJ1ZmZlciB1c2FnZVxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucy53YWwgLSBJZiBgdHJ1ZWAsIGluY2x1ZGUgaW5mb3JtYXRpb24gb24gV0FMIHJlY29yZCBnZW5lcmF0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLmZvcm1hdCAtIFRoZSBmb3JtYXQgb2YgdGhlIG91dHB1dCwgY2FuIGJlIGBcInRleHRcImAgKGRlZmF1bHQpXG4gICAqIG9yIGBcImpzb25cImBcbiAgICovXG4gIGV4cGxhaW4oe1xuICAgIGFuYWx5emUgPSBmYWxzZSxcbiAgICB2ZXJib3NlID0gZmFsc2UsXG4gICAgc2V0dGluZ3MgPSBmYWxzZSxcbiAgICBidWZmZXJzID0gZmFsc2UsXG4gICAgd2FsID0gZmFsc2UsXG4gICAgZm9ybWF0ID0gJ3RleHQnLFxuICB9OiB7XG4gICAgYW5hbHl6ZT86IGJvb2xlYW5cbiAgICB2ZXJib3NlPzogYm9vbGVhblxuICAgIHNldHRpbmdzPzogYm9vbGVhblxuICAgIGJ1ZmZlcnM/OiBib29sZWFuXG4gICAgd2FsPzogYm9vbGVhblxuICAgIGZvcm1hdD86ICdqc29uJyB8ICd0ZXh0J1xuICB9ID0ge30pOiBQb3N0Z3Jlc3RCdWlsZGVyPFJlY29yZDxzdHJpbmcsIHVua25vd24+W10+IHwgUG9zdGdyZXN0QnVpbGRlcjxzdHJpbmc+IHtcbiAgICBjb25zdCBvcHRpb25zID0gW1xuICAgICAgYW5hbHl6ZSA/ICdhbmFseXplJyA6IG51bGwsXG4gICAgICB2ZXJib3NlID8gJ3ZlcmJvc2UnIDogbnVsbCxcbiAgICAgIHNldHRpbmdzID8gJ3NldHRpbmdzJyA6IG51bGwsXG4gICAgICBidWZmZXJzID8gJ2J1ZmZlcnMnIDogbnVsbCxcbiAgICAgIHdhbCA/ICd3YWwnIDogbnVsbCxcbiAgICBdXG4gICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAuam9pbignfCcpXG4gICAgLy8gQW4gQWNjZXB0IGhlYWRlciBjYW4gY2FycnkgbXVsdGlwbGUgbWVkaWEgdHlwZXMgYnV0IHBvc3RncmVzdC1qcyBhbHdheXMgc2VuZHMgb25lXG4gICAgY29uc3QgZm9yTWVkaWF0eXBlID0gdGhpcy5oZWFkZXJzWydBY2NlcHQnXSA/PyAnYXBwbGljYXRpb24vanNvbidcbiAgICB0aGlzLmhlYWRlcnNbXG4gICAgICAnQWNjZXB0J1xuICAgIF0gPSBgYXBwbGljYXRpb24vdm5kLnBncnN0LnBsYW4rJHtmb3JtYXR9OyBmb3I9XCIke2Zvck1lZGlhdHlwZX1cIjsgb3B0aW9ucz0ke29wdGlvbnN9O2BcbiAgICBpZiAoZm9ybWF0ID09PSAnanNvbicpIHJldHVybiB0aGlzIGFzIFBvc3RncmVzdEJ1aWxkZXI8UmVjb3JkPHN0cmluZywgdW5rbm93bj5bXT5cbiAgICBlbHNlIHJldHVybiB0aGlzIGFzIFBvc3RncmVzdEJ1aWxkZXI8c3RyaW5nPlxuICB9XG5cbiAgLyoqXG4gICAqIFJvbGxiYWNrIHRoZSBxdWVyeS5cbiAgICpcbiAgICogYGRhdGFgIHdpbGwgc3RpbGwgYmUgcmV0dXJuZWQsIGJ1dCB0aGUgcXVlcnkgaXMgbm90IGNvbW1pdHRlZC5cbiAgICovXG4gIHJvbGxiYWNrKCk6IHRoaXMge1xuICAgIGlmICgodGhpcy5oZWFkZXJzWydQcmVmZXInXSA/PyAnJykudHJpbSgpLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuaGVhZGVyc1snUHJlZmVyJ10gKz0gJyx0eD1yb2xsYmFjaydcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oZWFkZXJzWydQcmVmZXInXSA9ICd0eD1yb2xsYmFjaydcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGUgdHlwZSBvZiB0aGUgcmV0dXJuZWQgYGRhdGFgLlxuICAgKlxuICAgKiBAdHlwZVBhcmFtIE5ld1Jlc3VsdCAtIFRoZSBuZXcgcmVzdWx0IHR5cGUgdG8gb3ZlcnJpZGUgd2l0aFxuICAgKi9cbiAgcmV0dXJuczxOZXdSZXN1bHQ+KCk6IFBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXI8XG4gICAgU2NoZW1hLFxuICAgIFJvdyxcbiAgICBOZXdSZXN1bHQsXG4gICAgUmVsYXRpb25OYW1lLFxuICAgIFJlbGF0aW9uc2hpcHNcbiAgPiB7XG4gICAgcmV0dXJuIHRoaXMgYXMgdW5rbm93biBhcyBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyPFxuICAgICAgU2NoZW1hLFxuICAgICAgUm93LFxuICAgICAgTmV3UmVzdWx0LFxuICAgICAgUmVsYXRpb25OYW1lLFxuICAgICAgUmVsYXRpb25zaGlwc1xuICAgID5cbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBAdHMtaWdub3JlXG5jb25zdCBub2RlX2ZldGNoXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBzdXBhYmFzZS9ub2RlLWZldGNoXCIpKTtcbmNvbnN0IFBvc3RncmVzdEVycm9yXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vUG9zdGdyZXN0RXJyb3JcIikpO1xuY2xhc3MgUG9zdGdyZXN0QnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoYnVpbGRlcikge1xuICAgICAgICB0aGlzLnNob3VsZFRocm93T25FcnJvciA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IGJ1aWxkZXIubWV0aG9kO1xuICAgICAgICB0aGlzLnVybCA9IGJ1aWxkZXIudXJsO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBidWlsZGVyLmhlYWRlcnM7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gYnVpbGRlci5zY2hlbWE7XG4gICAgICAgIHRoaXMuYm9keSA9IGJ1aWxkZXIuYm9keTtcbiAgICAgICAgdGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSBidWlsZGVyLnNob3VsZFRocm93T25FcnJvcjtcbiAgICAgICAgdGhpcy5zaWduYWwgPSBidWlsZGVyLnNpZ25hbDtcbiAgICAgICAgdGhpcy5pc01heWJlU2luZ2xlID0gYnVpbGRlci5pc01heWJlU2luZ2xlO1xuICAgICAgICBpZiAoYnVpbGRlci5mZXRjaCkge1xuICAgICAgICAgICAgdGhpcy5mZXRjaCA9IGJ1aWxkZXIuZmV0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGZldGNoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5mZXRjaCA9IG5vZGVfZmV0Y2hfMS5kZWZhdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mZXRjaCA9IGZldGNoO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHRoZXJlJ3MgYW4gZXJyb3Igd2l0aCB0aGUgcXVlcnksIHRocm93T25FcnJvciB3aWxsIHJlamVjdCB0aGUgcHJvbWlzZSBieVxuICAgICAqIHRocm93aW5nIHRoZSBlcnJvciBpbnN0ZWFkIG9mIHJldHVybmluZyBpdCBhcyBwYXJ0IG9mIGEgc3VjY2Vzc2Z1bCByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vc3VwYWJhc2Uvc3VwYWJhc2UtanMvaXNzdWVzLzkyfVxuICAgICAqL1xuICAgIHRocm93T25FcnJvcigpIHtcbiAgICAgICAgdGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhlbihvbmZ1bGZpbGxlZCwgb25yZWplY3RlZCkge1xuICAgICAgICAvLyBodHRwczovL3Bvc3RncmVzdC5vcmcvZW4vc3RhYmxlL2FwaS5odG1sI3N3aXRjaGluZy1zY2hlbWFzXG4gICAgICAgIGlmICh0aGlzLnNjaGVtYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBza2lwXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoWydHRVQnLCAnSEVBRCddLmluY2x1ZGVzKHRoaXMubWV0aG9kKSkge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzWydBY2NlcHQtUHJvZmlsZSddID0gdGhpcy5zY2hlbWE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlcnNbJ0NvbnRlbnQtUHJvZmlsZSddID0gdGhpcy5zY2hlbWE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWV0aG9kICE9PSAnR0VUJyAmJiB0aGlzLm1ldGhvZCAhPT0gJ0hFQUQnKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5PVEU6IEludm9rZSB3L28gYHRoaXNgIHRvIGF2b2lkIGlsbGVnYWwgaW52b2NhdGlvbiBlcnJvci5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3N1cGFiYXNlL3Bvc3RncmVzdC1qcy9wdWxsLzI0N1xuICAgICAgICBjb25zdCBfZmV0Y2ggPSB0aGlzLmZldGNoO1xuICAgICAgICBsZXQgcmVzID0gX2ZldGNoKHRoaXMudXJsLnRvU3RyaW5nKCksIHtcbiAgICAgICAgICAgIG1ldGhvZDogdGhpcy5tZXRob2QsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh0aGlzLmJvZHkpLFxuICAgICAgICAgICAgc2lnbmFsOiB0aGlzLnNpZ25hbCxcbiAgICAgICAgfSkudGhlbihhc3luYyAocmVzKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IG51bGw7XG4gICAgICAgICAgICBsZXQgY291bnQgPSBudWxsO1xuICAgICAgICAgICAgbGV0IHN0YXR1cyA9IHJlcy5zdGF0dXM7XG4gICAgICAgICAgICBsZXQgc3RhdHVzVGV4dCA9IHJlcy5zdGF0dXNUZXh0O1xuICAgICAgICAgICAgaWYgKHJlcy5vaykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1ldGhvZCAhPT0gJ0hFQUQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYm9keSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByZWZlcjogcmV0dXJuPW1pbmltYWxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmhlYWRlcnNbJ0FjY2VwdCddID09PSAndGV4dC9jc3YnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gYm9keTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmhlYWRlcnNbJ0FjY2VwdCddICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhlYWRlcnNbJ0FjY2VwdCddLmluY2x1ZGVzKCdhcHBsaWNhdGlvbi92bmQucGdyc3QucGxhbit0ZXh0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBib2R5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoYm9keSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY291bnRIZWFkZXIgPSAoX2EgPSB0aGlzLmhlYWRlcnNbJ1ByZWZlciddKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWF0Y2goL2NvdW50PShleGFjdHxwbGFubmVkfGVzdGltYXRlZCkvKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50UmFuZ2UgPSAoX2IgPSByZXMuaGVhZGVycy5nZXQoJ2NvbnRlbnQtcmFuZ2UnKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNwbGl0KCcvJyk7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50SGVhZGVyICYmIGNvbnRlbnRSYW5nZSAmJiBjb250ZW50UmFuZ2UubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb3VudCA9IHBhcnNlSW50KGNvbnRlbnRSYW5nZVsxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRlbXBvcmFyeSBwYXJ0aWFsIGZpeCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL3N1cGFiYXNlL3Bvc3RncmVzdC1qcy9pc3N1ZXMvMzYxXG4gICAgICAgICAgICAgICAgLy8gSXNzdWUgcGVyc2lzdHMgZS5nLiBmb3IgYC5pbnNlcnQoWy4uLl0pLnNlbGVjdCgpLm1heWJlU2luZ2xlKClgXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNNYXliZVNpbmdsZSAmJiB0aGlzLm1ldGhvZCA9PT0gJ0dFVCcgJiYgQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vUG9zdGdSRVNUL3Bvc3RncmVzdC9ibG9iL2E4NjdkNzljNDI0MTlhZjE2YzE4YzNmYjAxOWViYThkZjk5MjYyNmYvc3JjL1Bvc3RnUkVTVC9FcnJvci5ocyNMNTUzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogJ1BHUlNUMTE2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgUmVzdWx0cyBjb250YWluICR7ZGF0YS5sZW5ndGh9IHJvd3MsIGFwcGxpY2F0aW9uL3ZuZC5wZ3JzdC5vYmplY3QranNvbiByZXF1aXJlcyAxIHJvd2AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGludDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnSlNPTiBvYmplY3QgcmVxdWVzdGVkLCBtdWx0aXBsZSAob3Igbm8pIHJvd3MgcmV0dXJuZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gNDA2O1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dCA9ICdOb3QgQWNjZXB0YWJsZSc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGF0YS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBib2R5ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IEpTT04ucGFyc2UoYm9keSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9zdXBhYmFzZS9wb3N0Z3Jlc3QtanMvaXNzdWVzLzI5NVxuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlcnJvcikgJiYgcmVzLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSAyMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0ID0gJ09LJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoX2QpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL3N1cGFiYXNlL3Bvc3RncmVzdC1qcy9pc3N1ZXMvMjk1XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXMuc3RhdHVzID09PSA0MDQgJiYgYm9keSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IDIwNDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQgPSAnTm8gQ29udGVudCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBib2R5LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgJiYgdGhpcy5pc01heWJlU2luZ2xlICYmICgoX2MgPSBlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IuZGV0YWlscykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmluY2x1ZGVzKCcwIHJvd3MnKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSAyMDA7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQgPSAnT0snO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgJiYgdGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFBvc3RncmVzdEVycm9yXzEuZGVmYXVsdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcG9zdGdyZXN0UmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICBjb3VudCxcbiAgICAgICAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgICAgICAgc3RhdHVzVGV4dCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gcG9zdGdyZXN0UmVzcG9uc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXRoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB7XG4gICAgICAgICAgICByZXMgPSByZXMuY2F0Y2goKGZldGNoRXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgICAgICByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGAkeyhfYSA9IGZldGNoRXJyb3IgPT09IG51bGwgfHwgZmV0Y2hFcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmV0Y2hFcnJvci5uYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnRmV0Y2hFcnJvcid9OiAke2ZldGNoRXJyb3IgPT09IG51bGwgfHwgZmV0Y2hFcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmV0Y2hFcnJvci5tZXNzYWdlfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgJHsoX2IgPSBmZXRjaEVycm9yID09PSBudWxsIHx8IGZldGNoRXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZldGNoRXJyb3Iuc3RhY2spICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICBoaW50OiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGAkeyhfYyA9IGZldGNoRXJyb3IgPT09IG51bGwgfHwgZmV0Y2hFcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmV0Y2hFcnJvci5jb2RlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAnJ31gLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBjb3VudDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiAwLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiAnJyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXMudGhlbihvbmZ1bGZpbGxlZCwgb25yZWplY3RlZCk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gUG9zdGdyZXN0QnVpbGRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBvc3RncmVzdEJ1aWxkZXIuanMubWFwIiwiLy8gQHRzLWlnbm9yZVxuaW1wb3J0IG5vZGVGZXRjaCBmcm9tICdAc3VwYWJhc2Uvbm9kZS1mZXRjaCdcblxuaW1wb3J0IHR5cGUgeyBGZXRjaCwgUG9zdGdyZXN0U2luZ2xlUmVzcG9uc2UgfSBmcm9tICcuL3R5cGVzJ1xuaW1wb3J0IFBvc3RncmVzdEVycm9yIGZyb20gJy4vUG9zdGdyZXN0RXJyb3InXG5cbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFBvc3RncmVzdEJ1aWxkZXI8UmVzdWx0PlxuICBpbXBsZW1lbnRzIFByb21pc2VMaWtlPFBvc3RncmVzdFNpbmdsZVJlc3BvbnNlPFJlc3VsdD4+XG57XG4gIHByb3RlY3RlZCBtZXRob2Q6ICdHRVQnIHwgJ0hFQUQnIHwgJ1BPU1QnIHwgJ1BBVENIJyB8ICdERUxFVEUnXG4gIHByb3RlY3RlZCB1cmw6IFVSTFxuICBwcm90ZWN0ZWQgaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuICBwcm90ZWN0ZWQgc2NoZW1hPzogc3RyaW5nXG4gIHByb3RlY3RlZCBib2R5PzogdW5rbm93blxuICBwcm90ZWN0ZWQgc2hvdWxkVGhyb3dPbkVycm9yID0gZmFsc2VcbiAgcHJvdGVjdGVkIHNpZ25hbD86IEFib3J0U2lnbmFsXG4gIHByb3RlY3RlZCBmZXRjaDogRmV0Y2hcbiAgcHJvdGVjdGVkIGlzTWF5YmVTaW5nbGU6IGJvb2xlYW5cblxuICBjb25zdHJ1Y3RvcihidWlsZGVyOiBQb3N0Z3Jlc3RCdWlsZGVyPFJlc3VsdD4pIHtcbiAgICB0aGlzLm1ldGhvZCA9IGJ1aWxkZXIubWV0aG9kXG4gICAgdGhpcy51cmwgPSBidWlsZGVyLnVybFxuICAgIHRoaXMuaGVhZGVycyA9IGJ1aWxkZXIuaGVhZGVyc1xuICAgIHRoaXMuc2NoZW1hID0gYnVpbGRlci5zY2hlbWFcbiAgICB0aGlzLmJvZHkgPSBidWlsZGVyLmJvZHlcbiAgICB0aGlzLnNob3VsZFRocm93T25FcnJvciA9IGJ1aWxkZXIuc2hvdWxkVGhyb3dPbkVycm9yXG4gICAgdGhpcy5zaWduYWwgPSBidWlsZGVyLnNpZ25hbFxuICAgIHRoaXMuaXNNYXliZVNpbmdsZSA9IGJ1aWxkZXIuaXNNYXliZVNpbmdsZVxuXG4gICAgaWYgKGJ1aWxkZXIuZmV0Y2gpIHtcbiAgICAgIHRoaXMuZmV0Y2ggPSBidWlsZGVyLmZldGNoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZmV0Y2ggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLmZldGNoID0gbm9kZUZldGNoXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZmV0Y2ggPSBmZXRjaFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0aGVyZSdzIGFuIGVycm9yIHdpdGggdGhlIHF1ZXJ5LCB0aHJvd09uRXJyb3Igd2lsbCByZWplY3QgdGhlIHByb21pc2UgYnlcbiAgICogdGhyb3dpbmcgdGhlIGVycm9yIGluc3RlYWQgb2YgcmV0dXJuaW5nIGl0IGFzIHBhcnQgb2YgYSBzdWNjZXNzZnVsIHJlc3BvbnNlLlxuICAgKlxuICAgKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3N1cGFiYXNlL3N1cGFiYXNlLWpzL2lzc3Vlcy85Mn1cbiAgICovXG4gIHRocm93T25FcnJvcigpOiB0aGlzIHtcbiAgICB0aGlzLnNob3VsZFRocm93T25FcnJvciA9IHRydWVcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgdGhlbjxUUmVzdWx0MSA9IFBvc3RncmVzdFNpbmdsZVJlc3BvbnNlPFJlc3VsdD4sIFRSZXN1bHQyID0gbmV2ZXI+KFxuICAgIG9uZnVsZmlsbGVkPzpcbiAgICAgIHwgKCh2YWx1ZTogUG9zdGdyZXN0U2luZ2xlUmVzcG9uc2U8UmVzdWx0PikgPT4gVFJlc3VsdDEgfCBQcm9taXNlTGlrZTxUUmVzdWx0MT4pXG4gICAgICB8IHVuZGVmaW5lZFxuICAgICAgfCBudWxsLFxuICAgIG9ucmVqZWN0ZWQ/OiAoKHJlYXNvbjogYW55KSA9PiBUUmVzdWx0MiB8IFByb21pc2VMaWtlPFRSZXN1bHQyPikgfCB1bmRlZmluZWQgfCBudWxsXG4gICk6IFByb21pc2VMaWtlPFRSZXN1bHQxIHwgVFJlc3VsdDI+IHtcbiAgICAvLyBodHRwczovL3Bvc3RncmVzdC5vcmcvZW4vc3RhYmxlL2FwaS5odG1sI3N3aXRjaGluZy1zY2hlbWFzXG4gICAgaWYgKHRoaXMuc2NoZW1hID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHNraXBcbiAgICB9IGVsc2UgaWYgKFsnR0VUJywgJ0hFQUQnXS5pbmNsdWRlcyh0aGlzLm1ldGhvZCkpIHtcbiAgICAgIHRoaXMuaGVhZGVyc1snQWNjZXB0LVByb2ZpbGUnXSA9IHRoaXMuc2NoZW1hXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVhZGVyc1snQ29udGVudC1Qcm9maWxlJ10gPSB0aGlzLnNjaGVtYVxuICAgIH1cbiAgICBpZiAodGhpcy5tZXRob2QgIT09ICdHRVQnICYmIHRoaXMubWV0aG9kICE9PSAnSEVBRCcpIHtcbiAgICAgIHRoaXMuaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbidcbiAgICB9XG5cbiAgICAvLyBOT1RFOiBJbnZva2Ugdy9vIGB0aGlzYCB0byBhdm9pZCBpbGxlZ2FsIGludm9jYXRpb24gZXJyb3IuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3N1cGFiYXNlL3Bvc3RncmVzdC1qcy9wdWxsLzI0N1xuICAgIGNvbnN0IF9mZXRjaCA9IHRoaXMuZmV0Y2hcbiAgICBsZXQgcmVzID0gX2ZldGNoKHRoaXMudXJsLnRvU3RyaW5nKCksIHtcbiAgICAgIG1ldGhvZDogdGhpcy5tZXRob2QsXG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh0aGlzLmJvZHkpLFxuICAgICAgc2lnbmFsOiB0aGlzLnNpZ25hbCxcbiAgICB9KS50aGVuKGFzeW5jIChyZXMpID0+IHtcbiAgICAgIGxldCBlcnJvciA9IG51bGxcbiAgICAgIGxldCBkYXRhID0gbnVsbFxuICAgICAgbGV0IGNvdW50OiBudW1iZXIgfCBudWxsID0gbnVsbFxuICAgICAgbGV0IHN0YXR1cyA9IHJlcy5zdGF0dXNcbiAgICAgIGxldCBzdGF0dXNUZXh0ID0gcmVzLnN0YXR1c1RleHRcblxuICAgICAgaWYgKHJlcy5vaykge1xuICAgICAgICBpZiAodGhpcy5tZXRob2QgIT09ICdIRUFEJykge1xuICAgICAgICAgIGNvbnN0IGJvZHkgPSBhd2FpdCByZXMudGV4dCgpXG4gICAgICAgICAgaWYgKGJvZHkgPT09ICcnKSB7XG4gICAgICAgICAgICAvLyBQcmVmZXI6IHJldHVybj1taW5pbWFsXG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmhlYWRlcnNbJ0FjY2VwdCddID09PSAndGV4dC9jc3YnKSB7XG4gICAgICAgICAgICBkYXRhID0gYm9keVxuICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICB0aGlzLmhlYWRlcnNbJ0FjY2VwdCddICYmXG4gICAgICAgICAgICB0aGlzLmhlYWRlcnNbJ0FjY2VwdCddLmluY2x1ZGVzKCdhcHBsaWNhdGlvbi92bmQucGdyc3QucGxhbit0ZXh0JylcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGRhdGEgPSBib2R5XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGJvZHkpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY291bnRIZWFkZXIgPSB0aGlzLmhlYWRlcnNbJ1ByZWZlciddPy5tYXRjaCgvY291bnQ9KGV4YWN0fHBsYW5uZWR8ZXN0aW1hdGVkKS8pXG4gICAgICAgIGNvbnN0IGNvbnRlbnRSYW5nZSA9IHJlcy5oZWFkZXJzLmdldCgnY29udGVudC1yYW5nZScpPy5zcGxpdCgnLycpXG4gICAgICAgIGlmIChjb3VudEhlYWRlciAmJiBjb250ZW50UmFuZ2UgJiYgY29udGVudFJhbmdlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBjb3VudCA9IHBhcnNlSW50KGNvbnRlbnRSYW5nZVsxXSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRlbXBvcmFyeSBwYXJ0aWFsIGZpeCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL3N1cGFiYXNlL3Bvc3RncmVzdC1qcy9pc3N1ZXMvMzYxXG4gICAgICAgIC8vIElzc3VlIHBlcnNpc3RzIGUuZy4gZm9yIGAuaW5zZXJ0KFsuLi5dKS5zZWxlY3QoKS5tYXliZVNpbmdsZSgpYFxuICAgICAgICBpZiAodGhpcy5pc01heWJlU2luZ2xlICYmIHRoaXMubWV0aG9kID09PSAnR0VUJyAmJiBBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgaWYgKGRhdGEubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgZXJyb3IgPSB7XG4gICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9Qb3N0Z1JFU1QvcG9zdGdyZXN0L2Jsb2IvYTg2N2Q3OWM0MjQxOWFmMTZjMThjM2ZiMDE5ZWJhOGRmOTkyNjI2Zi9zcmMvUG9zdGdSRVNUL0Vycm9yLmhzI0w1NTNcbiAgICAgICAgICAgICAgY29kZTogJ1BHUlNUMTE2JyxcbiAgICAgICAgICAgICAgZGV0YWlsczogYFJlc3VsdHMgY29udGFpbiAke2RhdGEubGVuZ3RofSByb3dzLCBhcHBsaWNhdGlvbi92bmQucGdyc3Qub2JqZWN0K2pzb24gcmVxdWlyZXMgMSByb3dgLFxuICAgICAgICAgICAgICBoaW50OiBudWxsLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAnSlNPTiBvYmplY3QgcmVxdWVzdGVkLCBtdWx0aXBsZSAob3Igbm8pIHJvd3MgcmV0dXJuZWQnLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YSA9IG51bGxcbiAgICAgICAgICAgIGNvdW50ID0gbnVsbFxuICAgICAgICAgICAgc3RhdHVzID0gNDA2XG4gICAgICAgICAgICBzdGF0dXNUZXh0ID0gJ05vdCBBY2NlcHRhYmxlJ1xuICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGRhdGEgPSBkYXRhWzBdXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSBudWxsXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBib2R5ID0gYXdhaXQgcmVzLnRleHQoKVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZXJyb3IgPSBKU09OLnBhcnNlKGJvZHkpXG5cbiAgICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vc3VwYWJhc2UvcG9zdGdyZXN0LWpzL2lzc3Vlcy8yOTVcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlcnJvcikgJiYgcmVzLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgICBkYXRhID0gW11cbiAgICAgICAgICAgIGVycm9yID0gbnVsbFxuICAgICAgICAgICAgc3RhdHVzID0gMjAwXG4gICAgICAgICAgICBzdGF0dXNUZXh0ID0gJ09LJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL3N1cGFiYXNlL3Bvc3RncmVzdC1qcy9pc3N1ZXMvMjk1XG4gICAgICAgICAgaWYgKHJlcy5zdGF0dXMgPT09IDQwNCAmJiBib2R5ID09PSAnJykge1xuICAgICAgICAgICAgc3RhdHVzID0gMjA0XG4gICAgICAgICAgICBzdGF0dXNUZXh0ID0gJ05vIENvbnRlbnQnXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yID0ge1xuICAgICAgICAgICAgICBtZXNzYWdlOiBib2R5LFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciAmJiB0aGlzLmlzTWF5YmVTaW5nbGUgJiYgZXJyb3I/LmRldGFpbHM/LmluY2x1ZGVzKCcwIHJvd3MnKSkge1xuICAgICAgICAgIGVycm9yID0gbnVsbFxuICAgICAgICAgIHN0YXR1cyA9IDIwMFxuICAgICAgICAgIHN0YXR1c1RleHQgPSAnT0snXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IgJiYgdGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUG9zdGdyZXN0RXJyb3IoZXJyb3IpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgcG9zdGdyZXN0UmVzcG9uc2UgPSB7XG4gICAgICAgIGVycm9yLFxuICAgICAgICBkYXRhLFxuICAgICAgICBjb3VudCxcbiAgICAgICAgc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0LFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcG9zdGdyZXN0UmVzcG9uc2VcbiAgICB9KVxuICAgIGlmICghdGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHtcbiAgICAgIHJlcyA9IHJlcy5jYXRjaCgoZmV0Y2hFcnJvcikgPT4gKHtcbiAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICBtZXNzYWdlOiBgJHtmZXRjaEVycm9yPy5uYW1lID8/ICdGZXRjaEVycm9yJ306ICR7ZmV0Y2hFcnJvcj8ubWVzc2FnZX1gLFxuICAgICAgICAgIGRldGFpbHM6IGAke2ZldGNoRXJyb3I/LnN0YWNrID8/ICcnfWAsXG4gICAgICAgICAgaGludDogJycsXG4gICAgICAgICAgY29kZTogYCR7ZmV0Y2hFcnJvcj8uY29kZSA/PyAnJ31gLFxuICAgICAgICB9LFxuICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICBjb3VudDogbnVsbCxcbiAgICAgICAgc3RhdHVzOiAwLFxuICAgICAgICBzdGF0dXNUZXh0OiAnJyxcbiAgICAgIH0pKVxuICAgIH1cblxuICAgIHJldHVybiByZXMudGhlbihvbmZ1bGZpbGxlZCwgb25yZWplY3RlZClcbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIHJlZjogaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtZ2xvYmFsXG52YXIgZ2V0R2xvYmFsID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gdGhlIG9ubHkgcmVsaWFibGUgbWVhbnMgdG8gZ2V0IHRoZSBnbG9iYWwgb2JqZWN0IGlzXG4gICAgLy8gYEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKClgXG4gICAgLy8gSG93ZXZlciwgdGhpcyBjYXVzZXMgQ1NQIHZpb2xhdGlvbnMgaW4gQ2hyb21lIGFwcHMuXG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykgeyByZXR1cm4gc2VsZjsgfVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgeyByZXR1cm4gd2luZG93OyB9XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBnbG9iYWw7IH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuYWJsZSB0byBsb2NhdGUgZ2xvYmFsIG9iamVjdCcpO1xufVxuXG52YXIgZ2xvYmFsT2JqZWN0ID0gZ2V0R2xvYmFsKCk7XG5cbmV4cG9ydCBjb25zdCBmZXRjaCA9IGdsb2JhbE9iamVjdC5mZXRjaDtcblxuZXhwb3J0IGRlZmF1bHQgZ2xvYmFsT2JqZWN0LmZldGNoLmJpbmQoZ2xvYmFsT2JqZWN0KTtcblxuZXhwb3J0IGNvbnN0IEhlYWRlcnMgPSBnbG9iYWxPYmplY3QuSGVhZGVycztcbmV4cG9ydCBjb25zdCBSZXF1ZXN0ID0gZ2xvYmFsT2JqZWN0LlJlcXVlc3Q7XG5leHBvcnQgY29uc3QgUmVzcG9uc2UgPSBnbG9iYWxPYmplY3QuUmVzcG9uc2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIFBvc3RncmVzdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIoY29udGV4dC5tZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1Bvc3RncmVzdEVycm9yJztcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gY29udGV4dC5kZXRhaWxzO1xuICAgICAgICB0aGlzLmhpbnQgPSBjb250ZXh0LmhpbnQ7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvbnRleHQuY29kZTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBQb3N0Z3Jlc3RFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBvc3RncmVzdEVycm9yLmpzLm1hcCIsImltcG9ydCB0eXBlIHsgUG9zdGdyZXN0RXJyb3IgYXMgSVBvc3RncmVzdEVycm9yIH0gZnJvbSAnLi90eXBlcydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9zdGdyZXN0RXJyb3IgZXh0ZW5kcyBFcnJvciBpbXBsZW1lbnRzIElQb3N0Z3Jlc3RFcnJvciB7XG4gIGRldGFpbHM6IHN0cmluZ1xuICBoaW50OiBzdHJpbmdcbiAgY29kZTogc3RyaW5nXG5cbiAgY29uc3RydWN0b3IoY29udGV4dDogSVBvc3RncmVzdEVycm9yKSB7XG4gICAgc3VwZXIoY29udGV4dC5tZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdQb3N0Z3Jlc3RFcnJvcidcbiAgICB0aGlzLmRldGFpbHMgPSBjb250ZXh0LmRldGFpbHNcbiAgICB0aGlzLmhpbnQgPSBjb250ZXh0LmhpbnRcbiAgICB0aGlzLmNvZGUgPSBjb250ZXh0LmNvZGVcbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRFRkFVTFRfSEVBREVSUyA9IHZvaWQgMDtcbmNvbnN0IHZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL3ZlcnNpb25cIik7XG5leHBvcnRzLkRFRkFVTFRfSEVBREVSUyA9IHsgJ1gtQ2xpZW50LUluZm8nOiBgcG9zdGdyZXN0LWpzLyR7dmVyc2lvbl8xLnZlcnNpb259YCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCIsImltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24nXG5leHBvcnQgY29uc3QgREVGQVVMVF9IRUFERVJTID0geyAnWC1DbGllbnQtSW5mbyc6IGBwb3N0Z3Jlc3QtanMvJHt2ZXJzaW9ufWAgfVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZlcnNpb24gPSB2b2lkIDA7XG5leHBvcnRzLnZlcnNpb24gPSAnMC4wLjAtYXV0b21hdGVkJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb24uanMubWFwIiwiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSAnMS4xNS44J1xuIiwiaW1wb3J0IFJlYWx0aW1lQ2xpZW50IGZyb20gJy4vUmVhbHRpbWVDbGllbnQnO1xuaW1wb3J0IFJlYWx0aW1lQ2hhbm5lbCwgeyBSRUFMVElNRV9MSVNURU5fVFlQRVMsIFJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5ULCBSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTLCBSRUFMVElNRV9DSEFOTkVMX1NUQVRFUywgfSBmcm9tICcuL1JlYWx0aW1lQ2hhbm5lbCc7XG5pbXBvcnQgUmVhbHRpbWVQcmVzZW5jZSwgeyBSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTLCB9IGZyb20gJy4vUmVhbHRpbWVQcmVzZW5jZSc7XG5leHBvcnQgeyBSZWFsdGltZVByZXNlbmNlLCBSZWFsdGltZUNoYW5uZWwsIFJlYWx0aW1lQ2xpZW50LCBSRUFMVElNRV9MSVNURU5fVFlQRVMsIFJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5ULCBSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTLCBSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTLCBSRUFMVElNRV9DSEFOTkVMX1NUQVRFUywgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImltcG9ydCBSZWFsdGltZUNsaWVudCwge1xuICBSZWFsdGltZUNsaWVudE9wdGlvbnMsXG4gIFJlYWx0aW1lTWVzc2FnZSxcbiAgUmVhbHRpbWVSZW1vdmVDaGFubmVsUmVzcG9uc2UsXG59IGZyb20gJy4vUmVhbHRpbWVDbGllbnQnXG5pbXBvcnQgUmVhbHRpbWVDaGFubmVsLCB7XG4gIFJlYWx0aW1lQ2hhbm5lbE9wdGlvbnMsXG4gIFJlYWx0aW1lQ2hhbm5lbFNlbmRSZXNwb25zZSxcbiAgUmVhbHRpbWVQb3N0Z3Jlc0NoYW5nZXNGaWx0ZXIsXG4gIFJlYWx0aW1lUG9zdGdyZXNDaGFuZ2VzUGF5bG9hZCxcbiAgUmVhbHRpbWVQb3N0Z3Jlc0luc2VydFBheWxvYWQsXG4gIFJlYWx0aW1lUG9zdGdyZXNVcGRhdGVQYXlsb2FkLFxuICBSZWFsdGltZVBvc3RncmVzRGVsZXRlUGF5bG9hZCxcbiAgUkVBTFRJTUVfTElTVEVOX1RZUEVTLFxuICBSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVCxcbiAgUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUyxcbiAgUkVBTFRJTUVfQ0hBTk5FTF9TVEFURVMsXG59IGZyb20gJy4vUmVhbHRpbWVDaGFubmVsJ1xuaW1wb3J0IFJlYWx0aW1lUHJlc2VuY2UsIHtcbiAgUmVhbHRpbWVQcmVzZW5jZVN0YXRlLFxuICBSZWFsdGltZVByZXNlbmNlSm9pblBheWxvYWQsXG4gIFJlYWx0aW1lUHJlc2VuY2VMZWF2ZVBheWxvYWQsXG4gIFJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFMsXG59IGZyb20gJy4vUmVhbHRpbWVQcmVzZW5jZSdcblxuZXhwb3J0IHtcbiAgUmVhbHRpbWVQcmVzZW5jZSxcbiAgUmVhbHRpbWVDaGFubmVsLFxuICBSZWFsdGltZUNoYW5uZWxPcHRpb25zLFxuICBSZWFsdGltZUNoYW5uZWxTZW5kUmVzcG9uc2UsXG4gIFJlYWx0aW1lQ2xpZW50LFxuICBSZWFsdGltZUNsaWVudE9wdGlvbnMsXG4gIFJlYWx0aW1lTWVzc2FnZSxcbiAgUmVhbHRpbWVQb3N0Z3Jlc0NoYW5nZXNGaWx0ZXIsXG4gIFJlYWx0aW1lUG9zdGdyZXNDaGFuZ2VzUGF5bG9hZCxcbiAgUmVhbHRpbWVQb3N0Z3Jlc0luc2VydFBheWxvYWQsXG4gIFJlYWx0aW1lUG9zdGdyZXNVcGRhdGVQYXlsb2FkLFxuICBSZWFsdGltZVBvc3RncmVzRGVsZXRlUGF5bG9hZCxcbiAgUmVhbHRpbWVQcmVzZW5jZUpvaW5QYXlsb2FkLFxuICBSZWFsdGltZVByZXNlbmNlTGVhdmVQYXlsb2FkLFxuICBSZWFsdGltZVByZXNlbmNlU3RhdGUsXG4gIFJlYWx0aW1lUmVtb3ZlQ2hhbm5lbFJlc3BvbnNlLFxuICBSRUFMVElNRV9MSVNURU5fVFlQRVMsXG4gIFJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5ULFxuICBSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTLFxuICBSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTLFxuICBSRUFMVElNRV9DSEFOTkVMX1NUQVRFUyxcbn1cbiIsImltcG9ydCB7IENIQU5ORUxfRVZFTlRTLCBDT05ORUNUSU9OX1NUQVRFLCBERUZBVUxUX0hFQURFUlMsIERFRkFVTFRfVElNRU9VVCwgU09DS0VUX1NUQVRFUywgVFJBTlNQT1JUUywgVlNOLCBXU19DTE9TRV9OT1JNQUwsIH0gZnJvbSAnLi9saWIvY29uc3RhbnRzJztcbmltcG9ydCBTZXJpYWxpemVyIGZyb20gJy4vbGliL3NlcmlhbGl6ZXInO1xuaW1wb3J0IFRpbWVyIGZyb20gJy4vbGliL3RpbWVyJztcbmltcG9ydCB7IGh0dHBFbmRwb2ludFVSTCB9IGZyb20gJy4vbGliL3RyYW5zZm9ybWVycyc7XG5pbXBvcnQgUmVhbHRpbWVDaGFubmVsIGZyb20gJy4vUmVhbHRpbWVDaGFubmVsJztcbmNvbnN0IG5vb3AgPSAoKSA9PiB7IH07XG5jb25zdCBOQVRJVkVfV0VCU09DS0VUX0FWQUlMQUJMRSA9IHR5cGVvZiBXZWJTb2NrZXQgIT09ICd1bmRlZmluZWQnO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVhbHRpbWVDbGllbnQge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBTb2NrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW5kUG9pbnQgVGhlIHN0cmluZyBXZWJTb2NrZXQgZW5kcG9pbnQsIGllLCBcIndzOi8vZXhhbXBsZS5jb20vc29ja2V0XCIsIFwid3NzOi8vZXhhbXBsZS5jb21cIiwgXCIvc29ja2V0XCIgKGluaGVyaXRlZCBob3N0ICYgcHJvdG9jb2wpXG4gICAgICogQHBhcmFtIGh0dHBFbmRwb2ludCBUaGUgc3RyaW5nIEhUVFAgZW5kcG9pbnQsIGllLCBcImh0dHBzOi8vZXhhbXBsZS5jb21cIiwgXCIvXCIgKGluaGVyaXRlZCBob3N0ICYgcHJvdG9jb2wpXG4gICAgICogQHBhcmFtIG9wdGlvbnMudHJhbnNwb3J0IFRoZSBXZWJzb2NrZXQgVHJhbnNwb3J0LCBmb3IgZXhhbXBsZSBXZWJTb2NrZXQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMudGltZW91dCBUaGUgZGVmYXVsdCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyB0byB0cmlnZ2VyIHB1c2ggdGltZW91dHMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucGFyYW1zIFRoZSBvcHRpb25hbCBwYXJhbXMgdG8gcGFzcyB3aGVuIGNvbm5lY3RpbmcuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuaGVhZGVycyBUaGUgb3B0aW9uYWwgaGVhZGVycyB0byBwYXNzIHdoZW4gY29ubmVjdGluZy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5oZWFydGJlYXRJbnRlcnZhbE1zIFRoZSBtaWxsaXNlYyBpbnRlcnZhbCB0byBzZW5kIGEgaGVhcnRiZWF0IG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIG9wdGlvbnMubG9nZ2VyIFRoZSBvcHRpb25hbCBmdW5jdGlvbiBmb3Igc3BlY2lhbGl6ZWQgbG9nZ2luZywgaWU6IGxvZ2dlcjogKGtpbmQsIG1zZywgZGF0YSkgPT4geyBjb25zb2xlLmxvZyhgJHtraW5kfTogJHttc2d9YCwgZGF0YSkgfVxuICAgICAqIEBwYXJhbSBvcHRpb25zLmVuY29kZSBUaGUgZnVuY3Rpb24gdG8gZW5jb2RlIG91dGdvaW5nIG1lc3NhZ2VzLiBEZWZhdWx0cyB0byBKU09OOiAocGF5bG9hZCwgY2FsbGJhY2spID0+IGNhbGxiYWNrKEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKVxuICAgICAqIEBwYXJhbSBvcHRpb25zLmRlY29kZSBUaGUgZnVuY3Rpb24gdG8gZGVjb2RlIGluY29taW5nIG1lc3NhZ2VzLiBEZWZhdWx0cyB0byBTZXJpYWxpemVyJ3MgZGVjb2RlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnJlY29ubmVjdEFmdGVyTXMgaGUgb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBtaWxsc2VjIHJlY29ubmVjdCBpbnRlcnZhbC4gRGVmYXVsdHMgdG8gc3RlcHBlZCBiYWNrb2ZmIG9mZi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbmRQb2ludCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuYWNjZXNzVG9rZW4gPSBudWxsO1xuICAgICAgICB0aGlzLmFwaUtleSA9IG51bGw7XG4gICAgICAgIHRoaXMuY2hhbm5lbHMgPSBbXTtcbiAgICAgICAgdGhpcy5lbmRQb2ludCA9ICcnO1xuICAgICAgICB0aGlzLmh0dHBFbmRwb2ludCA9ICcnO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBERUZBVUxUX0hFQURFUlM7XG4gICAgICAgIHRoaXMucGFyYW1zID0ge307XG4gICAgICAgIHRoaXMudGltZW91dCA9IERFRkFVTFRfVElNRU9VVDtcbiAgICAgICAgdGhpcy5oZWFydGJlYXRJbnRlcnZhbE1zID0gMzAwMDA7XG4gICAgICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGw7XG4gICAgICAgIHRoaXMucmVmID0gMDtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBub29wO1xuICAgICAgICB0aGlzLmNvbm4gPSBudWxsO1xuICAgICAgICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gbmV3IFNlcmlhbGl6ZXIoKTtcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcyA9IHtcbiAgICAgICAgICAgIG9wZW46IFtdLFxuICAgICAgICAgICAgY2xvc2U6IFtdLFxuICAgICAgICAgICAgZXJyb3I6IFtdLFxuICAgICAgICAgICAgbWVzc2FnZTogW10sXG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2UgZWl0aGVyIGN1c3RvbSBmZXRjaCwgaWYgcHJvdmlkZWQsIG9yIGRlZmF1bHQgZmV0Y2ggdG8gbWFrZSBIVFRQIHJlcXVlc3RzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcmVzb2x2ZUZldGNoID0gKGN1c3RvbUZldGNoKSA9PiB7XG4gICAgICAgICAgICBsZXQgX2ZldGNoO1xuICAgICAgICAgICAgaWYgKGN1c3RvbUZldGNoKSB7XG4gICAgICAgICAgICAgICAgX2ZldGNoID0gY3VzdG9tRmV0Y2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZmV0Y2ggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgX2ZldGNoID0gKC4uLmFyZ3MpID0+IGltcG9ydCgnQHN1cGFiYXNlL25vZGUtZmV0Y2gnKS50aGVuKCh7IGRlZmF1bHQ6IGZldGNoIH0pID0+IGZldGNoKC4uLmFyZ3MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF9mZXRjaCA9IGZldGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiBfZmV0Y2goLi4uYXJncyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZW5kUG9pbnQgPSBgJHtlbmRQb2ludH0vJHtUUkFOU1BPUlRTLndlYnNvY2tldH1gO1xuICAgICAgICB0aGlzLmh0dHBFbmRwb2ludCA9IGh0dHBFbmRwb2ludFVSTChlbmRQb2ludCk7XG4gICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhbnNwb3J0KSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IG9wdGlvbnMudHJhbnNwb3J0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucGFyYW1zKVxuICAgICAgICAgICAgdGhpcy5wYXJhbXMgPSBvcHRpb25zLnBhcmFtcztcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5oZWFkZXJzKVxuICAgICAgICAgICAgdGhpcy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmhlYWRlcnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRpbWVvdXQpXG4gICAgICAgICAgICB0aGlzLnRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQ7XG4gICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubG9nZ2VyKVxuICAgICAgICAgICAgdGhpcy5sb2dnZXIgPSBvcHRpb25zLmxvZ2dlcjtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5oZWFydGJlYXRJbnRlcnZhbE1zKVxuICAgICAgICAgICAgdGhpcy5oZWFydGJlYXRJbnRlcnZhbE1zID0gb3B0aW9ucy5oZWFydGJlYXRJbnRlcnZhbE1zO1xuICAgICAgICBjb25zdCBhY2Nlc3NUb2tlbiA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wYXJhbXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hcGlrZXk7XG4gICAgICAgIGlmIChhY2Nlc3NUb2tlbikge1xuICAgICAgICAgICAgdGhpcy5hY2Nlc3NUb2tlbiA9IGFjY2Vzc1Rva2VuO1xuICAgICAgICAgICAgdGhpcy5hcGlLZXkgPSBhY2Nlc3NUb2tlbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlY29ubmVjdEFmdGVyTXMgPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJlY29ubmVjdEFmdGVyTXMpXG4gICAgICAgICAgICA/IG9wdGlvbnMucmVjb25uZWN0QWZ0ZXJNc1xuICAgICAgICAgICAgOiAodHJpZXMpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzEwMDAsIDIwMDAsIDUwMDAsIDEwMDAwXVt0cmllcyAtIDFdIHx8IDEwMDAwO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lbmNvZGUgPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmVuY29kZSlcbiAgICAgICAgICAgID8gb3B0aW9ucy5lbmNvZGVcbiAgICAgICAgICAgIDogKHBheWxvYWQsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIHRoaXMuZGVjb2RlID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kZWNvZGUpXG4gICAgICAgICAgICA/IG9wdGlvbnMuZGVjb2RlXG4gICAgICAgICAgICA6IHRoaXMuc2VyaWFsaXplci5kZWNvZGUuYmluZCh0aGlzLnNlcmlhbGl6ZXIpO1xuICAgICAgICB0aGlzLnJlY29ubmVjdFRpbWVyID0gbmV3IFRpbWVyKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgIH0sIHRoaXMucmVjb25uZWN0QWZ0ZXJNcyk7XG4gICAgICAgIHRoaXMuZmV0Y2ggPSB0aGlzLl9yZXNvbHZlRmV0Y2gob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmZldGNoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29ubmVjdHMgdGhlIHNvY2tldCwgdW5sZXNzIGFscmVhZHkgY29ubmVjdGVkLlxuICAgICAqL1xuICAgIGNvbm5lY3QoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbm4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50cmFuc3BvcnQpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubiA9IG5ldyB0aGlzLnRyYW5zcG9ydCh0aGlzLl9lbmRQb2ludFVSTCgpLCB1bmRlZmluZWQsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTkFUSVZFX1dFQlNPQ0tFVF9BVkFJTEFCTEUpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubiA9IG5ldyBXZWJTb2NrZXQodGhpcy5fZW5kUG9pbnRVUkwoKSk7XG4gICAgICAgICAgICB0aGlzLnNldHVwQ29ubmVjdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29ubiA9IG5ldyBXU1dlYlNvY2tldER1bW15KHRoaXMuX2VuZFBvaW50VVJMKCksIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgY2xvc2U6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm4gPSBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGltcG9ydCgnd3MnKS50aGVuKCh7IGRlZmF1bHQ6IFdTIH0pID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29ubiA9IG5ldyBXUyh0aGlzLl9lbmRQb2ludFVSTCgpLCB1bmRlZmluZWQsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc2V0dXBDb25uZWN0aW9uKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0cyB0aGUgc29ja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvZGUgQSBudW1lcmljIHN0YXR1cyBjb2RlIHRvIHNlbmQgb24gZGlzY29ubmVjdC5cbiAgICAgKiBAcGFyYW0gcmVhc29uIEEgY3VzdG9tIHJlYXNvbiBmb3IgdGhlIGRpc2Nvbm5lY3QuXG4gICAgICovXG4gICAgZGlzY29ubmVjdChjb2RlLCByZWFzb24pIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubikge1xuICAgICAgICAgICAgdGhpcy5jb25uLm9uY2xvc2UgPSBmdW5jdGlvbiAoKSB7IH07IC8vIG5vb3BcbiAgICAgICAgICAgIGlmIChjb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uLmNsb3NlKGNvZGUsIHJlYXNvbiAhPT0gbnVsbCAmJiByZWFzb24gIT09IHZvaWQgMCA/IHJlYXNvbiA6ICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubi5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb25uID0gbnVsbDtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBvcGVuIGhhbmRsZXNcbiAgICAgICAgICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgJiYgY2xlYXJJbnRlcnZhbCh0aGlzLmhlYXJ0YmVhdFRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMucmVjb25uZWN0VGltZXIucmVzZXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBjcmVhdGVkIGNoYW5uZWxzXG4gICAgICovXG4gICAgZ2V0Q2hhbm5lbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbnN1YnNjcmliZXMgYW5kIHJlbW92ZXMgYSBzaW5nbGUgY2hhbm5lbFxuICAgICAqIEBwYXJhbSBjaGFubmVsIEEgUmVhbHRpbWVDaGFubmVsIGluc3RhbmNlXG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlQ2hhbm5lbChjaGFubmVsKSB7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IGF3YWl0IGNoYW5uZWwudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdHVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbnN1YnNjcmliZXMgYW5kIHJlbW92ZXMgYWxsIGNoYW5uZWxzXG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlQWxsQ2hhbm5lbHMoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlc18xID0gYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5jaGFubmVscy5tYXAoKGNoYW5uZWwpID0+IGNoYW5uZWwudW5zdWJzY3JpYmUoKSkpO1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlc18xO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIHRoZSBtZXNzYWdlLlxuICAgICAqXG4gICAgICogRm9yIGN1c3RvbWl6ZWQgbG9nZ2luZywgYHRoaXMubG9nZ2VyYCBjYW4gYmUgb3ZlcnJpZGRlbi5cbiAgICAgKi9cbiAgICBsb2coa2luZCwgbXNnLCBkYXRhKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyKGtpbmQsIG1zZywgZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHNvY2tldC5cbiAgICAgKi9cbiAgICBjb25uZWN0aW9uU3RhdGUoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5jb25uICYmIHRoaXMuY29ubi5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIFNPQ0tFVF9TVEFURVMuY29ubmVjdGluZzpcbiAgICAgICAgICAgICAgICByZXR1cm4gQ09OTkVDVElPTl9TVEFURS5Db25uZWN0aW5nO1xuICAgICAgICAgICAgY2FzZSBTT0NLRVRfU1RBVEVTLm9wZW46XG4gICAgICAgICAgICAgICAgcmV0dXJuIENPTk5FQ1RJT05fU1RBVEUuT3BlbjtcbiAgICAgICAgICAgIGNhc2UgU09DS0VUX1NUQVRFUy5jbG9zaW5nOlxuICAgICAgICAgICAgICAgIHJldHVybiBDT05ORUNUSU9OX1NUQVRFLkNsb3Npbmc7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBDT05ORUNUSU9OX1NUQVRFLkNsb3NlZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpcyB0aGUgY29ubmVjdGlvbiBpcyBvcGVuLlxuICAgICAqL1xuICAgIGlzQ29ubmVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uU3RhdGUoKSA9PT0gQ09OTkVDVElPTl9TVEFURS5PcGVuO1xuICAgIH1cbiAgICBjaGFubmVsKHRvcGljLCBwYXJhbXMgPSB7IGNvbmZpZzoge30gfSkge1xuICAgICAgICBjb25zdCBjaGFuID0gbmV3IFJlYWx0aW1lQ2hhbm5lbChgcmVhbHRpbWU6JHt0b3BpY31gLCBwYXJhbXMsIHRoaXMpO1xuICAgICAgICB0aGlzLmNoYW5uZWxzLnB1c2goY2hhbik7XG4gICAgICAgIHJldHVybiBjaGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdXNoIG91dCBhIG1lc3NhZ2UgaWYgdGhlIHNvY2tldCBpcyBjb25uZWN0ZWQuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgc29ja2V0IGlzIG5vdCBjb25uZWN0ZWQsIHRoZSBtZXNzYWdlIGdldHMgZW5xdWV1ZWQgd2l0aGluIGEgbG9jYWwgYnVmZmVyLCBhbmQgc2VudCBvdXQgd2hlbiBhIGNvbm5lY3Rpb24gaXMgbmV4dCBlc3RhYmxpc2hlZC5cbiAgICAgKi9cbiAgICBwdXNoKGRhdGEpIHtcbiAgICAgICAgY29uc3QgeyB0b3BpYywgZXZlbnQsIHBheWxvYWQsIHJlZiB9ID0gZGF0YTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVuY29kZShkYXRhLCAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuY29ubikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNlbmQocmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxvZygncHVzaCcsIGAke3RvcGljfSAke2V2ZW50fSAoJHtyZWZ9KWAsIHBheWxvYWQpO1xuICAgICAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZW5kQnVmZmVyLnB1c2goY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIEpXVCBhY2Nlc3MgdG9rZW4gdXNlZCBmb3IgY2hhbm5lbCBzdWJzY3JpcHRpb24gYXV0aG9yaXphdGlvbiBhbmQgUmVhbHRpbWUgUkxTLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRva2VuIEEgSldUIHN0cmluZy5cbiAgICAgKi9cbiAgICBzZXRBdXRoKHRva2VuKSB7XG4gICAgICAgIHRoaXMuYWNjZXNzVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5jaGFubmVscy5mb3JFYWNoKChjaGFubmVsKSA9PiB7XG4gICAgICAgICAgICB0b2tlbiAmJiBjaGFubmVsLnVwZGF0ZUpvaW5QYXlsb2FkKHsgYWNjZXNzX3Rva2VuOiB0b2tlbiB9KTtcbiAgICAgICAgICAgIGlmIChjaGFubmVsLmpvaW5lZE9uY2UgJiYgY2hhbm5lbC5faXNKb2luZWQoKSkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuX3B1c2goQ0hBTk5FTF9FVkVOVFMuYWNjZXNzX3Rva2VuLCB7IGFjY2Vzc190b2tlbjogdG9rZW4gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG5leHQgbWVzc2FnZSByZWYsIGFjY291bnRpbmcgZm9yIG92ZXJmbG93c1xuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX21ha2VSZWYoKSB7XG4gICAgICAgIGxldCBuZXdSZWYgPSB0aGlzLnJlZiArIDE7XG4gICAgICAgIGlmIChuZXdSZWYgPT09IHRoaXMucmVmKSB7XG4gICAgICAgICAgICB0aGlzLnJlZiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlZiA9IG5ld1JlZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZWYudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmUgZnJvbSBjaGFubmVscyB3aXRoIHRoZSBzcGVjaWZpZWQgdG9waWMuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfbGVhdmVPcGVuVG9waWModG9waWMpIHtcbiAgICAgICAgbGV0IGR1cENoYW5uZWwgPSB0aGlzLmNoYW5uZWxzLmZpbmQoKGMpID0+IGMudG9waWMgPT09IHRvcGljICYmIChjLl9pc0pvaW5lZCgpIHx8IGMuX2lzSm9pbmluZygpKSk7XG4gICAgICAgIGlmIChkdXBDaGFubmVsKSB7XG4gICAgICAgICAgICB0aGlzLmxvZygndHJhbnNwb3J0JywgYGxlYXZpbmcgZHVwbGljYXRlIHRvcGljIFwiJHt0b3BpY31cImApO1xuICAgICAgICAgICAgZHVwQ2hhbm5lbC51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBzdWJzY3JpcHRpb24gZnJvbSB0aGUgc29ja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNoYW5uZWwgQW4gb3BlbiBzdWJzY3JpcHRpb24uXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfcmVtb3ZlKGNoYW5uZWwpIHtcbiAgICAgICAgdGhpcy5jaGFubmVscyA9IHRoaXMuY2hhbm5lbHMuZmlsdGVyKChjKSA9PiBjLl9qb2luUmVmKCkgIT09IGNoYW5uZWwuX2pvaW5SZWYoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgY29ubmVjdGlvbiBoYW5kbGVycy5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHNldHVwQ29ubmVjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubikge1xuICAgICAgICAgICAgdGhpcy5jb25uLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICAgICAgdGhpcy5jb25uLm9ub3BlbiA9ICgpID0+IHRoaXMuX29uQ29ubk9wZW4oKTtcbiAgICAgICAgICAgIHRoaXMuY29ubi5vbmVycm9yID0gKGVycm9yKSA9PiB0aGlzLl9vbkNvbm5FcnJvcihlcnJvcik7XG4gICAgICAgICAgICB0aGlzLmNvbm4ub25tZXNzYWdlID0gKGV2ZW50KSA9PiB0aGlzLl9vbkNvbm5NZXNzYWdlKGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuY29ubi5vbmNsb3NlID0gKGV2ZW50KSA9PiB0aGlzLl9vbkNvbm5DbG9zZShldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgVVJMIG9mIHRoZSB3ZWJzb2NrZXQuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfZW5kUG9pbnRVUkwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBlbmRQYXJhbXModGhpcy5lbmRQb2ludCwgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wYXJhbXMsIHsgdnNuOiBWU04gfSkpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX29uQ29ubk1lc3NhZ2UocmF3TWVzc2FnZSkge1xuICAgICAgICB0aGlzLmRlY29kZShyYXdNZXNzYWdlLmRhdGEsIChtc2cpID0+IHtcbiAgICAgICAgICAgIGxldCB7IHRvcGljLCBldmVudCwgcGF5bG9hZCwgcmVmIH0gPSBtc2c7XG4gICAgICAgICAgICBpZiAoKHJlZiAmJiByZWYgPT09IHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZikgfHxcbiAgICAgICAgICAgICAgICBldmVudCA9PT0gKHBheWxvYWQgPT09IG51bGwgfHwgcGF5bG9hZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGF5bG9hZC50eXBlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxvZygncmVjZWl2ZScsIGAke3BheWxvYWQuc3RhdHVzIHx8ICcnfSAke3RvcGljfSAke2V2ZW50fSAkeyhyZWYgJiYgJygnICsgcmVmICsgJyknKSB8fCAnJ31gLCBwYXlsb2FkKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChjaGFubmVsKSA9PiBjaGFubmVsLl9pc01lbWJlcih0b3BpYykpXG4gICAgICAgICAgICAgICAgLmZvckVhY2goKGNoYW5uZWwpID0+IGNoYW5uZWwuX3RyaWdnZXIoZXZlbnQsIHBheWxvYWQsIHJlZikpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5tZXNzYWdlLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjayhtc2cpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfb25Db25uT3BlbigpIHtcbiAgICAgICAgdGhpcy5sb2coJ3RyYW5zcG9ydCcsIGBjb25uZWN0ZWQgdG8gJHt0aGlzLl9lbmRQb2ludFVSTCgpfWApO1xuICAgICAgICB0aGlzLl9mbHVzaFNlbmRCdWZmZXIoKTtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lci5yZXNldCgpO1xuICAgICAgICB0aGlzLmhlYXJ0YmVhdFRpbWVyICYmIGNsZWFySW50ZXJ2YWwodGhpcy5oZWFydGJlYXRUaW1lcik7XG4gICAgICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLl9zZW5kSGVhcnRiZWF0KCksIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcyk7XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3Mub3Blbi5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2soKSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfb25Db25uQ2xvc2UoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5sb2coJ3RyYW5zcG9ydCcsICdjbG9zZScsIGV2ZW50KTtcbiAgICAgICAgdGhpcy5fdHJpZ2dlckNoYW5FcnJvcigpO1xuICAgICAgICB0aGlzLmhlYXJ0YmVhdFRpbWVyICYmIGNsZWFySW50ZXJ2YWwodGhpcy5oZWFydGJlYXRUaW1lcik7XG4gICAgICAgIHRoaXMucmVjb25uZWN0VGltZXIuc2NoZWR1bGVUaW1lb3V0KCk7XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MuY2xvc2UuZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKGV2ZW50KSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfb25Db25uRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5sb2coJ3RyYW5zcG9ydCcsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB0aGlzLl90cmlnZ2VyQ2hhbkVycm9yKCk7XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MuZXJyb3IuZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKGVycm9yKSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfdHJpZ2dlckNoYW5FcnJvcigpIHtcbiAgICAgICAgdGhpcy5jaGFubmVscy5mb3JFYWNoKChjaGFubmVsKSA9PiBjaGFubmVsLl90cmlnZ2VyKENIQU5ORUxfRVZFTlRTLmVycm9yKSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfYXBwZW5kUGFyYW1zKHVybCwgcGFyYW1zKSB7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhwYXJhbXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmVmaXggPSB1cmwubWF0Y2goL1xcPy8pID8gJyYnIDogJz8nO1xuICAgICAgICBjb25zdCBxdWVyeSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIGAke3VybH0ke3ByZWZpeH0ke3F1ZXJ5fWA7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfZmx1c2hTZW5kQnVmZmVyKCkge1xuICAgICAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCgpICYmIHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRCdWZmZXIuZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKCkpO1xuICAgICAgICAgICAgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9zZW5kSGVhcnRiZWF0KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZikge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubG9nKCd0cmFuc3BvcnQnLCAnaGVhcnRiZWF0IHRpbWVvdXQuIEF0dGVtcHRpbmcgdG8gcmUtZXN0YWJsaXNoIGNvbm5lY3Rpb24nKTtcbiAgICAgICAgICAgIChfYSA9IHRoaXMuY29ubikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsb3NlKFdTX0NMT1NFX05PUk1BTCwgJ2hlYXJiZWF0IHRpbWVvdXQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSB0aGlzLl9tYWtlUmVmKCk7XG4gICAgICAgIHRoaXMucHVzaCh7XG4gICAgICAgICAgICB0b3BpYzogJ3Bob2VuaXgnLFxuICAgICAgICAgICAgZXZlbnQ6ICdoZWFydGJlYXQnLFxuICAgICAgICAgICAgcGF5bG9hZDoge30sXG4gICAgICAgICAgICByZWY6IHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZixcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0QXV0aCh0aGlzLmFjY2Vzc1Rva2VuKTtcbiAgICB9XG59XG5jbGFzcyBXU1dlYlNvY2tldER1bW15IHtcbiAgICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBfcHJvdG9jb2xzLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgIHRoaXMub25jbG9zZSA9ICgpID0+IHsgfTtcbiAgICAgICAgdGhpcy5vbmVycm9yID0gKCkgPT4geyB9O1xuICAgICAgICB0aGlzLm9ubWVzc2FnZSA9ICgpID0+IHsgfTtcbiAgICAgICAgdGhpcy5vbm9wZW4gPSAoKSA9PiB7IH07XG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFNPQ0tFVF9TVEFURVMuY29ubmVjdGluZztcbiAgICAgICAgdGhpcy5zZW5kID0gKCkgPT4geyB9O1xuICAgICAgICB0aGlzLnVybCA9IG51bGw7XG4gICAgICAgIHRoaXMudXJsID0gYWRkcmVzcztcbiAgICAgICAgdGhpcy5jbG9zZSA9IG9wdGlvbnMuY2xvc2U7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVhbHRpbWVDbGllbnQuanMubWFwIiwiaW1wb3J0IHR5cGUgeyBXZWJTb2NrZXQgYXMgV1NXZWJTb2NrZXQgfSBmcm9tICd3cydcblxuaW1wb3J0IHtcbiAgQ0hBTk5FTF9FVkVOVFMsXG4gIENPTk5FQ1RJT05fU1RBVEUsXG4gIERFRkFVTFRfSEVBREVSUyxcbiAgREVGQVVMVF9USU1FT1VULFxuICBTT0NLRVRfU1RBVEVTLFxuICBUUkFOU1BPUlRTLFxuICBWU04sXG4gIFdTX0NMT1NFX05PUk1BTCxcbn0gZnJvbSAnLi9saWIvY29uc3RhbnRzJ1xuaW1wb3J0IFNlcmlhbGl6ZXIgZnJvbSAnLi9saWIvc2VyaWFsaXplcidcbmltcG9ydCBUaW1lciBmcm9tICcuL2xpYi90aW1lcidcblxuaW1wb3J0IHsgaHR0cEVuZHBvaW50VVJMIH0gZnJvbSAnLi9saWIvdHJhbnNmb3JtZXJzJ1xuaW1wb3J0IFJlYWx0aW1lQ2hhbm5lbCBmcm9tICcuL1JlYWx0aW1lQ2hhbm5lbCdcbmltcG9ydCB0eXBlIHsgUmVhbHRpbWVDaGFubmVsT3B0aW9ucyB9IGZyb20gJy4vUmVhbHRpbWVDaGFubmVsJ1xuXG50eXBlIEZldGNoID0gdHlwZW9mIGZldGNoXG5cbmV4cG9ydCB0eXBlIENoYW5uZWwgPSB7XG4gIG5hbWU6IHN0cmluZ1xuICBpbnNlcnRlZF9hdDogc3RyaW5nXG4gIHVwZGF0ZWRfYXQ6IHN0cmluZ1xuICBpZDogbnVtYmVyXG59XG5cbmV4cG9ydCB0eXBlIFJlYWx0aW1lQ2xpZW50T3B0aW9ucyA9IHtcbiAgdHJhbnNwb3J0PzogV2ViU29ja2V0TGlrZUNvbnN0cnVjdG9yXG4gIHRpbWVvdXQ/OiBudW1iZXJcbiAgaGVhcnRiZWF0SW50ZXJ2YWxNcz86IG51bWJlclxuICBsb2dnZXI/OiBGdW5jdGlvblxuICBlbmNvZGU/OiBGdW5jdGlvblxuICBkZWNvZGU/OiBGdW5jdGlvblxuICByZWNvbm5lY3RBZnRlck1zPzogRnVuY3Rpb25cbiAgaGVhZGVycz86IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH1cbiAgcGFyYW1zPzogeyBba2V5OiBzdHJpbmddOiBhbnkgfVxuICBsb2dfbGV2ZWw/OiAnaW5mbycgfCAnZGVidWcnIHwgJ3dhcm4nIHwgJ2Vycm9yJ1xuICBmZXRjaD86IEZldGNoXG59XG5cbmV4cG9ydCB0eXBlIFJlYWx0aW1lTWVzc2FnZSA9IHtcbiAgdG9waWM6IHN0cmluZ1xuICBldmVudDogc3RyaW5nXG4gIHBheWxvYWQ6IGFueVxuICByZWY6IHN0cmluZ1xuICBqb2luX3JlZj86IHN0cmluZ1xufVxuXG5leHBvcnQgdHlwZSBSZWFsdGltZVJlbW92ZUNoYW5uZWxSZXNwb25zZSA9ICdvaycgfCAndGltZWQgb3V0JyB8ICdlcnJvcidcblxuY29uc3Qgbm9vcCA9ICgpID0+IHt9XG5cbmludGVyZmFjZSBXZWJTb2NrZXRMaWtlQ29uc3RydWN0b3Ige1xuICBuZXcgKFxuICAgIGFkZHJlc3M6IHN0cmluZyB8IFVSTCxcbiAgICBfaWdub3JlZD86IGFueSxcbiAgICBvcHRpb25zPzogeyBoZWFkZXJzOiBPYmplY3QgfCB1bmRlZmluZWQgfVxuICApOiBXZWJTb2NrZXRMaWtlXG59XG5cbnR5cGUgV2ViU29ja2V0TGlrZSA9IFdlYlNvY2tldCB8IFdTV2ViU29ja2V0IHwgV1NXZWJTb2NrZXREdW1teVxuXG5pbnRlcmZhY2UgV2ViU29ja2V0TGlrZUVycm9yIHtcbiAgZXJyb3I6IGFueVxuICBtZXNzYWdlOiBzdHJpbmdcbiAgdHlwZTogc3RyaW5nXG59XG5cbmNvbnN0IE5BVElWRV9XRUJTT0NLRVRfQVZBSUxBQkxFID0gdHlwZW9mIFdlYlNvY2tldCAhPT0gJ3VuZGVmaW5lZCdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVhbHRpbWVDbGllbnQge1xuICBhY2Nlc3NUb2tlbjogc3RyaW5nIHwgbnVsbCA9IG51bGxcbiAgYXBpS2V5OiBzdHJpbmcgfCBudWxsID0gbnVsbFxuICBjaGFubmVsczogUmVhbHRpbWVDaGFubmVsW10gPSBbXVxuICBlbmRQb2ludDogc3RyaW5nID0gJydcbiAgaHR0cEVuZHBvaW50OiBzdHJpbmcgPSAnJ1xuICBoZWFkZXJzPzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IERFRkFVTFRfSEVBREVSU1xuICBwYXJhbXM/OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge31cbiAgdGltZW91dDogbnVtYmVyID0gREVGQVVMVF9USU1FT1VUXG4gIHRyYW5zcG9ydDogV2ViU29ja2V0TGlrZUNvbnN0cnVjdG9yIHwgbnVsbFxuICBoZWFydGJlYXRJbnRlcnZhbE1zOiBudW1iZXIgPSAzMDAwMFxuICBoZWFydGJlYXRUaW1lcjogUmV0dXJuVHlwZTx0eXBlb2Ygc2V0SW50ZXJ2YWw+IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkXG4gIHBlbmRpbmdIZWFydGJlYXRSZWY6IHN0cmluZyB8IG51bGwgPSBudWxsXG4gIHJlZjogbnVtYmVyID0gMFxuICByZWNvbm5lY3RUaW1lcjogVGltZXJcbiAgbG9nZ2VyOiBGdW5jdGlvbiA9IG5vb3BcbiAgZW5jb2RlOiBGdW5jdGlvblxuICBkZWNvZGU6IEZ1bmN0aW9uXG4gIHJlY29ubmVjdEFmdGVyTXM6IEZ1bmN0aW9uXG4gIGNvbm46IFdlYlNvY2tldExpa2UgfCBudWxsID0gbnVsbFxuICBzZW5kQnVmZmVyOiBGdW5jdGlvbltdID0gW11cbiAgc2VyaWFsaXplcjogU2VyaWFsaXplciA9IG5ldyBTZXJpYWxpemVyKClcbiAgc3RhdGVDaGFuZ2VDYWxsYmFja3M6IHtcbiAgICBvcGVuOiBGdW5jdGlvbltdXG4gICAgY2xvc2U6IEZ1bmN0aW9uW11cbiAgICBlcnJvcjogRnVuY3Rpb25bXVxuICAgIG1lc3NhZ2U6IEZ1bmN0aW9uW11cbiAgfSA9IHtcbiAgICBvcGVuOiBbXSxcbiAgICBjbG9zZTogW10sXG4gICAgZXJyb3I6IFtdLFxuICAgIG1lc3NhZ2U6IFtdLFxuICB9XG4gIGZldGNoOiBGZXRjaFxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgU29ja2V0LlxuICAgKlxuICAgKiBAcGFyYW0gZW5kUG9pbnQgVGhlIHN0cmluZyBXZWJTb2NrZXQgZW5kcG9pbnQsIGllLCBcIndzOi8vZXhhbXBsZS5jb20vc29ja2V0XCIsIFwid3NzOi8vZXhhbXBsZS5jb21cIiwgXCIvc29ja2V0XCIgKGluaGVyaXRlZCBob3N0ICYgcHJvdG9jb2wpXG4gICAqIEBwYXJhbSBodHRwRW5kcG9pbnQgVGhlIHN0cmluZyBIVFRQIGVuZHBvaW50LCBpZSwgXCJodHRwczovL2V4YW1wbGUuY29tXCIsIFwiL1wiIChpbmhlcml0ZWQgaG9zdCAmIHByb3RvY29sKVxuICAgKiBAcGFyYW0gb3B0aW9ucy50cmFuc3BvcnQgVGhlIFdlYnNvY2tldCBUcmFuc3BvcnQsIGZvciBleGFtcGxlIFdlYlNvY2tldC5cbiAgICogQHBhcmFtIG9wdGlvbnMudGltZW91dCBUaGUgZGVmYXVsdCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyB0byB0cmlnZ2VyIHB1c2ggdGltZW91dHMuXG4gICAqIEBwYXJhbSBvcHRpb25zLnBhcmFtcyBUaGUgb3B0aW9uYWwgcGFyYW1zIHRvIHBhc3Mgd2hlbiBjb25uZWN0aW5nLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5oZWFkZXJzIFRoZSBvcHRpb25hbCBoZWFkZXJzIHRvIHBhc3Mgd2hlbiBjb25uZWN0aW5nLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5oZWFydGJlYXRJbnRlcnZhbE1zIFRoZSBtaWxsaXNlYyBpbnRlcnZhbCB0byBzZW5kIGEgaGVhcnRiZWF0IG1lc3NhZ2UuXG4gICAqIEBwYXJhbSBvcHRpb25zLmxvZ2dlciBUaGUgb3B0aW9uYWwgZnVuY3Rpb24gZm9yIHNwZWNpYWxpemVkIGxvZ2dpbmcsIGllOiBsb2dnZXI6IChraW5kLCBtc2csIGRhdGEpID0+IHsgY29uc29sZS5sb2coYCR7a2luZH06ICR7bXNnfWAsIGRhdGEpIH1cbiAgICogQHBhcmFtIG9wdGlvbnMuZW5jb2RlIFRoZSBmdW5jdGlvbiB0byBlbmNvZGUgb3V0Z29pbmcgbWVzc2FnZXMuIERlZmF1bHRzIHRvIEpTT046IChwYXlsb2FkLCBjYWxsYmFjaykgPT4gY2FsbGJhY2soSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpXG4gICAqIEBwYXJhbSBvcHRpb25zLmRlY29kZSBUaGUgZnVuY3Rpb24gdG8gZGVjb2RlIGluY29taW5nIG1lc3NhZ2VzLiBEZWZhdWx0cyB0byBTZXJpYWxpemVyJ3MgZGVjb2RlLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5yZWNvbm5lY3RBZnRlck1zIGhlIG9wdGlvbmFsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbWlsbHNlYyByZWNvbm5lY3QgaW50ZXJ2YWwuIERlZmF1bHRzIHRvIHN0ZXBwZWQgYmFja29mZiBvZmYuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbmRQb2ludDogc3RyaW5nLCBvcHRpb25zPzogUmVhbHRpbWVDbGllbnRPcHRpb25zKSB7XG4gICAgdGhpcy5lbmRQb2ludCA9IGAke2VuZFBvaW50fS8ke1RSQU5TUE9SVFMud2Vic29ja2V0fWBcbiAgICB0aGlzLmh0dHBFbmRwb2ludCA9IGh0dHBFbmRwb2ludFVSTChlbmRQb2ludClcbiAgICBpZiAob3B0aW9ucz8udHJhbnNwb3J0KSB7XG4gICAgICB0aGlzLnRyYW5zcG9ydCA9IG9wdGlvbnMudHJhbnNwb3J0XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudHJhbnNwb3J0ID0gbnVsbFxuICAgIH1cbiAgICBpZiAob3B0aW9ucz8ucGFyYW1zKSB0aGlzLnBhcmFtcyA9IG9wdGlvbnMucGFyYW1zXG4gICAgaWYgKG9wdGlvbnM/LmhlYWRlcnMpIHRoaXMuaGVhZGVycyA9IHsgLi4udGhpcy5oZWFkZXJzLCAuLi5vcHRpb25zLmhlYWRlcnMgfVxuICAgIGlmIChvcHRpb25zPy50aW1lb3V0KSB0aGlzLnRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXRcbiAgICBpZiAob3B0aW9ucz8ubG9nZ2VyKSB0aGlzLmxvZ2dlciA9IG9wdGlvbnMubG9nZ2VyXG4gICAgaWYgKG9wdGlvbnM/LmhlYXJ0YmVhdEludGVydmFsTXMpXG4gICAgICB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMgPSBvcHRpb25zLmhlYXJ0YmVhdEludGVydmFsTXNcblxuICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gb3B0aW9ucz8ucGFyYW1zPy5hcGlrZXlcbiAgICBpZiAoYWNjZXNzVG9rZW4pIHtcbiAgICAgIHRoaXMuYWNjZXNzVG9rZW4gPSBhY2Nlc3NUb2tlblxuICAgICAgdGhpcy5hcGlLZXkgPSBhY2Nlc3NUb2tlblxuICAgIH1cblxuICAgIHRoaXMucmVjb25uZWN0QWZ0ZXJNcyA9IG9wdGlvbnM/LnJlY29ubmVjdEFmdGVyTXNcbiAgICAgID8gb3B0aW9ucy5yZWNvbm5lY3RBZnRlck1zXG4gICAgICA6ICh0cmllczogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIFsxMDAwLCAyMDAwLCA1MDAwLCAxMDAwMF1bdHJpZXMgLSAxXSB8fCAxMDAwMFxuICAgICAgICB9XG4gICAgdGhpcy5lbmNvZGUgPSBvcHRpb25zPy5lbmNvZGVcbiAgICAgID8gb3B0aW9ucy5lbmNvZGVcbiAgICAgIDogKHBheWxvYWQ6IEpTT04sIGNhbGxiYWNrOiBGdW5jdGlvbikgPT4ge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhKU09OLnN0cmluZ2lmeShwYXlsb2FkKSlcbiAgICAgICAgfVxuICAgIHRoaXMuZGVjb2RlID0gb3B0aW9ucz8uZGVjb2RlXG4gICAgICA/IG9wdGlvbnMuZGVjb2RlXG4gICAgICA6IHRoaXMuc2VyaWFsaXplci5kZWNvZGUuYmluZCh0aGlzLnNlcmlhbGl6ZXIpXG4gICAgdGhpcy5yZWNvbm5lY3RUaW1lciA9IG5ldyBUaW1lcihhc3luYyAoKSA9PiB7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKVxuICAgICAgdGhpcy5jb25uZWN0KClcbiAgICB9LCB0aGlzLnJlY29ubmVjdEFmdGVyTXMpXG5cbiAgICB0aGlzLmZldGNoID0gdGhpcy5fcmVzb2x2ZUZldGNoKG9wdGlvbnM/LmZldGNoKVxuICB9XG5cbiAgLyoqXG4gICAqIENvbm5lY3RzIHRoZSBzb2NrZXQsIHVubGVzcyBhbHJlYWR5IGNvbm5lY3RlZC5cbiAgICovXG4gIGNvbm5lY3QoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY29ubikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHRoaXMudHJhbnNwb3J0KSB7XG4gICAgICB0aGlzLmNvbm4gPSBuZXcgdGhpcy50cmFuc3BvcnQodGhpcy5fZW5kUG9pbnRVUkwoKSwgdW5kZWZpbmVkLCB7XG4gICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgIH0pXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoTkFUSVZFX1dFQlNPQ0tFVF9BVkFJTEFCTEUpIHtcbiAgICAgIHRoaXMuY29ubiA9IG5ldyBXZWJTb2NrZXQodGhpcy5fZW5kUG9pbnRVUkwoKSlcbiAgICAgIHRoaXMuc2V0dXBDb25uZWN0aW9uKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuY29ubiA9IG5ldyBXU1dlYlNvY2tldER1bW15KHRoaXMuX2VuZFBvaW50VVJMKCksIHVuZGVmaW5lZCwge1xuICAgICAgY2xvc2U6ICgpID0+IHtcbiAgICAgICAgdGhpcy5jb25uID0gbnVsbFxuICAgICAgfSxcbiAgICB9KVxuXG4gICAgaW1wb3J0KCd3cycpLnRoZW4oKHsgZGVmYXVsdDogV1MgfSkgPT4ge1xuICAgICAgdGhpcy5jb25uID0gbmV3IFdTKHRoaXMuX2VuZFBvaW50VVJMKCksIHVuZGVmaW5lZCwge1xuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICB9KVxuICAgICAgdGhpcy5zZXR1cENvbm5lY3Rpb24oKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogRGlzY29ubmVjdHMgdGhlIHNvY2tldC5cbiAgICpcbiAgICogQHBhcmFtIGNvZGUgQSBudW1lcmljIHN0YXR1cyBjb2RlIHRvIHNlbmQgb24gZGlzY29ubmVjdC5cbiAgICogQHBhcmFtIHJlYXNvbiBBIGN1c3RvbSByZWFzb24gZm9yIHRoZSBkaXNjb25uZWN0LlxuICAgKi9cbiAgZGlzY29ubmVjdChjb2RlPzogbnVtYmVyLCByZWFzb24/OiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5jb25uKSB7XG4gICAgICB0aGlzLmNvbm4ub25jbG9zZSA9IGZ1bmN0aW9uICgpIHt9IC8vIG5vb3BcbiAgICAgIGlmIChjb2RlKSB7XG4gICAgICAgIHRoaXMuY29ubi5jbG9zZShjb2RlLCByZWFzb24gPz8gJycpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbm4uY2xvc2UoKVxuICAgICAgfVxuICAgICAgdGhpcy5jb25uID0gbnVsbFxuICAgICAgLy8gcmVtb3ZlIG9wZW4gaGFuZGxlc1xuICAgICAgdGhpcy5oZWFydGJlYXRUaW1lciAmJiBjbGVhckludGVydmFsKHRoaXMuaGVhcnRiZWF0VGltZXIpXG4gICAgICB0aGlzLnJlY29ubmVjdFRpbWVyLnJlc2V0KClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgY3JlYXRlZCBjaGFubmVsc1xuICAgKi9cbiAgZ2V0Q2hhbm5lbHMoKTogUmVhbHRpbWVDaGFubmVsW10ge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWxzXG4gIH1cblxuICAvKipcbiAgICogVW5zdWJzY3JpYmVzIGFuZCByZW1vdmVzIGEgc2luZ2xlIGNoYW5uZWxcbiAgICogQHBhcmFtIGNoYW5uZWwgQSBSZWFsdGltZUNoYW5uZWwgaW5zdGFuY2VcbiAgICovXG4gIGFzeW5jIHJlbW92ZUNoYW5uZWwoXG4gICAgY2hhbm5lbDogUmVhbHRpbWVDaGFubmVsXG4gICk6IFByb21pc2U8UmVhbHRpbWVSZW1vdmVDaGFubmVsUmVzcG9uc2U+IHtcbiAgICBjb25zdCBzdGF0dXMgPSBhd2FpdCBjaGFubmVsLnVuc3Vic2NyaWJlKClcbiAgICBpZiAodGhpcy5jaGFubmVscy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuZGlzY29ubmVjdCgpXG4gICAgfVxuICAgIHJldHVybiBzdGF0dXNcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnN1YnNjcmliZXMgYW5kIHJlbW92ZXMgYWxsIGNoYW5uZWxzXG4gICAqL1xuICBhc3luYyByZW1vdmVBbGxDaGFubmVscygpOiBQcm9taXNlPFJlYWx0aW1lUmVtb3ZlQ2hhbm5lbFJlc3BvbnNlW10+IHtcbiAgICBjb25zdCB2YWx1ZXNfMSA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgdGhpcy5jaGFubmVscy5tYXAoKGNoYW5uZWwpID0+IGNoYW5uZWwudW5zdWJzY3JpYmUoKSlcbiAgICApXG4gICAgdGhpcy5kaXNjb25uZWN0KClcbiAgICByZXR1cm4gdmFsdWVzXzFcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIHRoZSBtZXNzYWdlLlxuICAgKlxuICAgKiBGb3IgY3VzdG9taXplZCBsb2dnaW5nLCBgdGhpcy5sb2dnZXJgIGNhbiBiZSBvdmVycmlkZGVuLlxuICAgKi9cbiAgbG9nKGtpbmQ6IHN0cmluZywgbXNnOiBzdHJpbmcsIGRhdGE/OiBhbnkpIHtcbiAgICB0aGlzLmxvZ2dlcihraW5kLCBtc2csIGRhdGEpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgc29ja2V0LlxuICAgKi9cbiAgY29ubmVjdGlvblN0YXRlKCk6IENPTk5FQ1RJT05fU1RBVEUge1xuICAgIHN3aXRjaCAodGhpcy5jb25uICYmIHRoaXMuY29ubi5yZWFkeVN0YXRlKSB7XG4gICAgICBjYXNlIFNPQ0tFVF9TVEFURVMuY29ubmVjdGluZzpcbiAgICAgICAgcmV0dXJuIENPTk5FQ1RJT05fU1RBVEUuQ29ubmVjdGluZ1xuICAgICAgY2FzZSBTT0NLRVRfU1RBVEVTLm9wZW46XG4gICAgICAgIHJldHVybiBDT05ORUNUSU9OX1NUQVRFLk9wZW5cbiAgICAgIGNhc2UgU09DS0VUX1NUQVRFUy5jbG9zaW5nOlxuICAgICAgICByZXR1cm4gQ09OTkVDVElPTl9TVEFURS5DbG9zaW5nXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gQ09OTkVDVElPTl9TVEFURS5DbG9zZWRcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBgdHJ1ZWAgaXMgdGhlIGNvbm5lY3Rpb24gaXMgb3Blbi5cbiAgICovXG4gIGlzQ29ubmVjdGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25TdGF0ZSgpID09PSBDT05ORUNUSU9OX1NUQVRFLk9wZW5cbiAgfVxuXG4gIGNoYW5uZWwoXG4gICAgdG9waWM6IHN0cmluZyxcbiAgICBwYXJhbXM6IFJlYWx0aW1lQ2hhbm5lbE9wdGlvbnMgPSB7IGNvbmZpZzoge30gfVxuICApOiBSZWFsdGltZUNoYW5uZWwge1xuICAgIGNvbnN0IGNoYW4gPSBuZXcgUmVhbHRpbWVDaGFubmVsKGByZWFsdGltZToke3RvcGljfWAsIHBhcmFtcywgdGhpcylcbiAgICB0aGlzLmNoYW5uZWxzLnB1c2goY2hhbilcbiAgICByZXR1cm4gY2hhblxuICB9XG5cbiAgLyoqXG4gICAqIFB1c2ggb3V0IGEgbWVzc2FnZSBpZiB0aGUgc29ja2V0IGlzIGNvbm5lY3RlZC5cbiAgICpcbiAgICogSWYgdGhlIHNvY2tldCBpcyBub3QgY29ubmVjdGVkLCB0aGUgbWVzc2FnZSBnZXRzIGVucXVldWVkIHdpdGhpbiBhIGxvY2FsIGJ1ZmZlciwgYW5kIHNlbnQgb3V0IHdoZW4gYSBjb25uZWN0aW9uIGlzIG5leHQgZXN0YWJsaXNoZWQuXG4gICAqL1xuICBwdXNoKGRhdGE6IFJlYWx0aW1lTWVzc2FnZSk6IHZvaWQge1xuICAgIGNvbnN0IHsgdG9waWMsIGV2ZW50LCBwYXlsb2FkLCByZWYgfSA9IGRhdGFcbiAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIHRoaXMuZW5jb2RlKGRhdGEsIChyZXN1bHQ6IGFueSkgPT4ge1xuICAgICAgICB0aGlzLmNvbm4/LnNlbmQocmVzdWx0KVxuICAgICAgfSlcbiAgICB9XG4gICAgdGhpcy5sb2coJ3B1c2gnLCBgJHt0b3BpY30gJHtldmVudH0gKCR7cmVmfSlgLCBwYXlsb2FkKVxuICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZW5kQnVmZmVyLnB1c2goY2FsbGJhY2spXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIEpXVCBhY2Nlc3MgdG9rZW4gdXNlZCBmb3IgY2hhbm5lbCBzdWJzY3JpcHRpb24gYXV0aG9yaXphdGlvbiBhbmQgUmVhbHRpbWUgUkxTLlxuICAgKlxuICAgKiBAcGFyYW0gdG9rZW4gQSBKV1Qgc3RyaW5nLlxuICAgKi9cbiAgc2V0QXV0aCh0b2tlbjogc3RyaW5nIHwgbnVsbCk6IHZvaWQge1xuICAgIHRoaXMuYWNjZXNzVG9rZW4gPSB0b2tlblxuXG4gICAgdGhpcy5jaGFubmVscy5mb3JFYWNoKChjaGFubmVsKSA9PiB7XG4gICAgICB0b2tlbiAmJiBjaGFubmVsLnVwZGF0ZUpvaW5QYXlsb2FkKHsgYWNjZXNzX3Rva2VuOiB0b2tlbiB9KVxuXG4gICAgICBpZiAoY2hhbm5lbC5qb2luZWRPbmNlICYmIGNoYW5uZWwuX2lzSm9pbmVkKCkpIHtcbiAgICAgICAgY2hhbm5lbC5fcHVzaChDSEFOTkVMX0VWRU5UUy5hY2Nlc3NfdG9rZW4sIHsgYWNjZXNzX3Rva2VuOiB0b2tlbiB9KVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogVXNlIGVpdGhlciBjdXN0b20gZmV0Y2gsIGlmIHByb3ZpZGVkLCBvciBkZWZhdWx0IGZldGNoIHRvIG1ha2UgSFRUUCByZXF1ZXN0c1xuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9yZXNvbHZlRmV0Y2ggPSAoY3VzdG9tRmV0Y2g/OiBGZXRjaCk6IEZldGNoID0+IHtcbiAgICBsZXQgX2ZldGNoOiBGZXRjaFxuICAgIGlmIChjdXN0b21GZXRjaCkge1xuICAgICAgX2ZldGNoID0gY3VzdG9tRmV0Y2hcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBmZXRjaCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIF9mZXRjaCA9ICguLi5hcmdzKSA9PlxuICAgICAgICBpbXBvcnQoJ0BzdXBhYmFzZS9ub2RlLWZldGNoJyBhcyBhbnkpLnRoZW4oKHsgZGVmYXVsdDogZmV0Y2ggfSkgPT5cbiAgICAgICAgICBmZXRjaCguLi5hcmdzKVxuICAgICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIF9mZXRjaCA9IGZldGNoXG4gICAgfVxuICAgIHJldHVybiAoLi4uYXJncykgPT4gX2ZldGNoKC4uLmFyZ3MpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBuZXh0IG1lc3NhZ2UgcmVmLCBhY2NvdW50aW5nIGZvciBvdmVyZmxvd3NcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfbWFrZVJlZigpOiBzdHJpbmcge1xuICAgIGxldCBuZXdSZWYgPSB0aGlzLnJlZiArIDFcbiAgICBpZiAobmV3UmVmID09PSB0aGlzLnJlZikge1xuICAgICAgdGhpcy5yZWYgPSAwXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVmID0gbmV3UmVmXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucmVmLnRvU3RyaW5nKClcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnN1YnNjcmliZSBmcm9tIGNoYW5uZWxzIHdpdGggdGhlIHNwZWNpZmllZCB0b3BpYy5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfbGVhdmVPcGVuVG9waWModG9waWM6IHN0cmluZyk6IHZvaWQge1xuICAgIGxldCBkdXBDaGFubmVsID0gdGhpcy5jaGFubmVscy5maW5kKFxuICAgICAgKGMpID0+IGMudG9waWMgPT09IHRvcGljICYmIChjLl9pc0pvaW5lZCgpIHx8IGMuX2lzSm9pbmluZygpKVxuICAgIClcbiAgICBpZiAoZHVwQ2hhbm5lbCkge1xuICAgICAgdGhpcy5sb2coJ3RyYW5zcG9ydCcsIGBsZWF2aW5nIGR1cGxpY2F0ZSB0b3BpYyBcIiR7dG9waWN9XCJgKVxuICAgICAgZHVwQ2hhbm5lbC51bnN1YnNjcmliZSgpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBzdWJzY3JpcHRpb24gZnJvbSB0aGUgc29ja2V0LlxuICAgKlxuICAgKiBAcGFyYW0gY2hhbm5lbCBBbiBvcGVuIHN1YnNjcmlwdGlvbi5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfcmVtb3ZlKGNoYW5uZWw6IFJlYWx0aW1lQ2hhbm5lbCkge1xuICAgIHRoaXMuY2hhbm5lbHMgPSB0aGlzLmNoYW5uZWxzLmZpbHRlcihcbiAgICAgIChjOiBSZWFsdGltZUNoYW5uZWwpID0+IGMuX2pvaW5SZWYoKSAhPT0gY2hhbm5lbC5fam9pblJlZigpXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdXAgY29ubmVjdGlvbiBoYW5kbGVycy5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcml2YXRlIHNldHVwQ29ubmVjdGlvbigpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5jb25uKSB7XG4gICAgICB0aGlzLmNvbm4uYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcidcbiAgICAgIHRoaXMuY29ubi5vbm9wZW4gPSAoKSA9PiB0aGlzLl9vbkNvbm5PcGVuKClcbiAgICAgIHRoaXMuY29ubi5vbmVycm9yID0gKGVycm9yOiBXZWJTb2NrZXRMaWtlRXJyb3IpID0+XG4gICAgICAgIHRoaXMuX29uQ29ubkVycm9yKGVycm9yIGFzIFdlYlNvY2tldExpa2VFcnJvcilcbiAgICAgIHRoaXMuY29ubi5vbm1lc3NhZ2UgPSAoZXZlbnQ6IGFueSkgPT4gdGhpcy5fb25Db25uTWVzc2FnZShldmVudClcbiAgICAgIHRoaXMuY29ubi5vbmNsb3NlID0gKGV2ZW50OiBhbnkpID0+IHRoaXMuX29uQ29ubkNsb3NlKGV2ZW50KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBVUkwgb2YgdGhlIHdlYnNvY2tldC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcml2YXRlIF9lbmRQb2ludFVSTCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9hcHBlbmRQYXJhbXMoXG4gICAgICB0aGlzLmVuZFBvaW50LFxuICAgICAgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wYXJhbXMsIHsgdnNuOiBWU04gfSlcbiAgICApXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgX29uQ29ubk1lc3NhZ2UocmF3TWVzc2FnZTogeyBkYXRhOiBhbnkgfSkge1xuICAgIHRoaXMuZGVjb2RlKHJhd01lc3NhZ2UuZGF0YSwgKG1zZzogUmVhbHRpbWVNZXNzYWdlKSA9PiB7XG4gICAgICBsZXQgeyB0b3BpYywgZXZlbnQsIHBheWxvYWQsIHJlZiB9ID0gbXNnXG5cbiAgICAgIGlmIChcbiAgICAgICAgKHJlZiAmJiByZWYgPT09IHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZikgfHxcbiAgICAgICAgZXZlbnQgPT09IHBheWxvYWQ/LnR5cGVcbiAgICAgICkge1xuICAgICAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSBudWxsXG4gICAgICB9XG5cbiAgICAgIHRoaXMubG9nKFxuICAgICAgICAncmVjZWl2ZScsXG4gICAgICAgIGAke3BheWxvYWQuc3RhdHVzIHx8ICcnfSAke3RvcGljfSAke2V2ZW50fSAke1xuICAgICAgICAgIChyZWYgJiYgJygnICsgcmVmICsgJyknKSB8fCAnJ1xuICAgICAgICB9YCxcbiAgICAgICAgcGF5bG9hZFxuICAgICAgKVxuICAgICAgdGhpcy5jaGFubmVsc1xuICAgICAgICAuZmlsdGVyKChjaGFubmVsOiBSZWFsdGltZUNoYW5uZWwpID0+IGNoYW5uZWwuX2lzTWVtYmVyKHRvcGljKSlcbiAgICAgICAgLmZvckVhY2goKGNoYW5uZWw6IFJlYWx0aW1lQ2hhbm5lbCkgPT5cbiAgICAgICAgICBjaGFubmVsLl90cmlnZ2VyKGV2ZW50LCBwYXlsb2FkLCByZWYpXG4gICAgICAgIClcbiAgICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MubWVzc2FnZS5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2sobXNnKSlcbiAgICB9KVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIF9vbkNvbm5PcGVuKCkge1xuICAgIHRoaXMubG9nKCd0cmFuc3BvcnQnLCBgY29ubmVjdGVkIHRvICR7dGhpcy5fZW5kUG9pbnRVUkwoKX1gKVxuICAgIHRoaXMuX2ZsdXNoU2VuZEJ1ZmZlcigpXG4gICAgdGhpcy5yZWNvbm5lY3RUaW1lci5yZXNldCgpXG4gICAgdGhpcy5oZWFydGJlYXRUaW1lciAmJiBjbGVhckludGVydmFsKHRoaXMuaGVhcnRiZWF0VGltZXIpXG4gICAgdGhpcy5oZWFydGJlYXRUaW1lciA9IHNldEludGVydmFsKFxuICAgICAgKCkgPT4gdGhpcy5fc2VuZEhlYXJ0YmVhdCgpLFxuICAgICAgdGhpcy5oZWFydGJlYXRJbnRlcnZhbE1zXG4gICAgKVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3Mub3Blbi5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2soKSkhXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgX29uQ29ubkNsb3NlKGV2ZW50OiBhbnkpIHtcbiAgICB0aGlzLmxvZygndHJhbnNwb3J0JywgJ2Nsb3NlJywgZXZlbnQpXG4gICAgdGhpcy5fdHJpZ2dlckNoYW5FcnJvcigpXG4gICAgdGhpcy5oZWFydGJlYXRUaW1lciAmJiBjbGVhckludGVydmFsKHRoaXMuaGVhcnRiZWF0VGltZXIpXG4gICAgdGhpcy5yZWNvbm5lY3RUaW1lci5zY2hlZHVsZVRpbWVvdXQoKVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MuY2xvc2UuZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKGV2ZW50KSlcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBfb25Db25uRXJyb3IoZXJyb3I6IFdlYlNvY2tldExpa2VFcnJvcikge1xuICAgIHRoaXMubG9nKCd0cmFuc3BvcnQnLCBlcnJvci5tZXNzYWdlKVxuICAgIHRoaXMuX3RyaWdnZXJDaGFuRXJyb3IoKVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MuZXJyb3IuZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKGVycm9yKSlcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBfdHJpZ2dlckNoYW5FcnJvcigpIHtcbiAgICB0aGlzLmNoYW5uZWxzLmZvckVhY2goKGNoYW5uZWw6IFJlYWx0aW1lQ2hhbm5lbCkgPT5cbiAgICAgIGNoYW5uZWwuX3RyaWdnZXIoQ0hBTk5FTF9FVkVOVFMuZXJyb3IpXG4gICAgKVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIF9hcHBlbmRQYXJhbXMoXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgcGFyYW1zOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9XG4gICk6IHN0cmluZyB7XG4gICAgaWYgKE9iamVjdC5rZXlzKHBhcmFtcykubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdXJsXG4gICAgfVxuICAgIGNvbnN0IHByZWZpeCA9IHVybC5tYXRjaCgvXFw/LykgPyAnJicgOiAnPydcbiAgICBjb25zdCBxdWVyeSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1zKVxuXG4gICAgcmV0dXJuIGAke3VybH0ke3ByZWZpeH0ke3F1ZXJ5fWBcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBfZmx1c2hTZW5kQnVmZmVyKCkge1xuICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKCkgJiYgdGhpcy5zZW5kQnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuc2VuZEJ1ZmZlci5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2soKSlcbiAgICAgIHRoaXMuc2VuZEJ1ZmZlciA9IFtdXG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBfc2VuZEhlYXJ0YmVhdCgpIHtcbiAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICh0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYpIHtcbiAgICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGxcbiAgICAgIHRoaXMubG9nKFxuICAgICAgICAndHJhbnNwb3J0JyxcbiAgICAgICAgJ2hlYXJ0YmVhdCB0aW1lb3V0LiBBdHRlbXB0aW5nIHRvIHJlLWVzdGFibGlzaCBjb25uZWN0aW9uJ1xuICAgICAgKVxuICAgICAgdGhpcy5jb25uPy5jbG9zZShXU19DTE9TRV9OT1JNQUwsICdoZWFyYmVhdCB0aW1lb3V0JylcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSB0aGlzLl9tYWtlUmVmKClcbiAgICB0aGlzLnB1c2goe1xuICAgICAgdG9waWM6ICdwaG9lbml4JyxcbiAgICAgIGV2ZW50OiAnaGVhcnRiZWF0JyxcbiAgICAgIHBheWxvYWQ6IHt9LFxuICAgICAgcmVmOiB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYsXG4gICAgfSlcbiAgICB0aGlzLnNldEF1dGgodGhpcy5hY2Nlc3NUb2tlbilcbiAgfVxufVxuXG5jbGFzcyBXU1dlYlNvY2tldER1bW15IHtcbiAgYmluYXJ5VHlwZTogc3RyaW5nID0gJ2FycmF5YnVmZmVyJ1xuICBjbG9zZTogRnVuY3Rpb25cbiAgb25jbG9zZTogRnVuY3Rpb24gPSAoKSA9PiB7fVxuICBvbmVycm9yOiBGdW5jdGlvbiA9ICgpID0+IHt9XG4gIG9ubWVzc2FnZTogRnVuY3Rpb24gPSAoKSA9PiB7fVxuICBvbm9wZW46IEZ1bmN0aW9uID0gKCkgPT4ge31cbiAgcmVhZHlTdGF0ZTogbnVtYmVyID0gU09DS0VUX1NUQVRFUy5jb25uZWN0aW5nXG4gIHNlbmQ6IEZ1bmN0aW9uID0gKCkgPT4ge31cbiAgdXJsOiBzdHJpbmcgfCBVUkwgfCBudWxsID0gbnVsbFxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGFkZHJlc3M6IHN0cmluZyxcbiAgICBfcHJvdG9jb2xzOiB1bmRlZmluZWQsXG4gICAgb3B0aW9uczogeyBjbG9zZTogRnVuY3Rpb24gfVxuICApIHtcbiAgICB0aGlzLnVybCA9IGFkZHJlc3NcbiAgICB0aGlzLmNsb3NlID0gb3B0aW9ucy5jbG9zZVxuICB9XG59XG4iLCJpbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSAnLi92ZXJzaW9uJztcbmV4cG9ydCBjb25zdCBERUZBVUxUX0hFQURFUlMgPSB7ICdYLUNsaWVudC1JbmZvJzogYHJlYWx0aW1lLWpzLyR7dmVyc2lvbn1gIH07XG5leHBvcnQgY29uc3QgVlNOID0gJzEuMC4wJztcbmV4cG9ydCBjb25zdCBERUZBVUxUX1RJTUVPVVQgPSAxMDAwMDtcbmV4cG9ydCBjb25zdCBXU19DTE9TRV9OT1JNQUwgPSAxMDAwO1xuZXhwb3J0IHZhciBTT0NLRVRfU1RBVEVTO1xuKGZ1bmN0aW9uIChTT0NLRVRfU1RBVEVTKSB7XG4gICAgU09DS0VUX1NUQVRFU1tTT0NLRVRfU1RBVEVTW1wiY29ubmVjdGluZ1wiXSA9IDBdID0gXCJjb25uZWN0aW5nXCI7XG4gICAgU09DS0VUX1NUQVRFU1tTT0NLRVRfU1RBVEVTW1wib3BlblwiXSA9IDFdID0gXCJvcGVuXCI7XG4gICAgU09DS0VUX1NUQVRFU1tTT0NLRVRfU1RBVEVTW1wiY2xvc2luZ1wiXSA9IDJdID0gXCJjbG9zaW5nXCI7XG4gICAgU09DS0VUX1NUQVRFU1tTT0NLRVRfU1RBVEVTW1wiY2xvc2VkXCJdID0gM10gPSBcImNsb3NlZFwiO1xufSkoU09DS0VUX1NUQVRFUyB8fCAoU09DS0VUX1NUQVRFUyA9IHt9KSk7XG5leHBvcnQgdmFyIENIQU5ORUxfU1RBVEVTO1xuKGZ1bmN0aW9uIChDSEFOTkVMX1NUQVRFUykge1xuICAgIENIQU5ORUxfU1RBVEVTW1wiY2xvc2VkXCJdID0gXCJjbG9zZWRcIjtcbiAgICBDSEFOTkVMX1NUQVRFU1tcImVycm9yZWRcIl0gPSBcImVycm9yZWRcIjtcbiAgICBDSEFOTkVMX1NUQVRFU1tcImpvaW5lZFwiXSA9IFwiam9pbmVkXCI7XG4gICAgQ0hBTk5FTF9TVEFURVNbXCJqb2luaW5nXCJdID0gXCJqb2luaW5nXCI7XG4gICAgQ0hBTk5FTF9TVEFURVNbXCJsZWF2aW5nXCJdID0gXCJsZWF2aW5nXCI7XG59KShDSEFOTkVMX1NUQVRFUyB8fCAoQ0hBTk5FTF9TVEFURVMgPSB7fSkpO1xuZXhwb3J0IHZhciBDSEFOTkVMX0VWRU5UUztcbihmdW5jdGlvbiAoQ0hBTk5FTF9FVkVOVFMpIHtcbiAgICBDSEFOTkVMX0VWRU5UU1tcImNsb3NlXCJdID0gXCJwaHhfY2xvc2VcIjtcbiAgICBDSEFOTkVMX0VWRU5UU1tcImVycm9yXCJdID0gXCJwaHhfZXJyb3JcIjtcbiAgICBDSEFOTkVMX0VWRU5UU1tcImpvaW5cIl0gPSBcInBoeF9qb2luXCI7XG4gICAgQ0hBTk5FTF9FVkVOVFNbXCJyZXBseVwiXSA9IFwicGh4X3JlcGx5XCI7XG4gICAgQ0hBTk5FTF9FVkVOVFNbXCJsZWF2ZVwiXSA9IFwicGh4X2xlYXZlXCI7XG4gICAgQ0hBTk5FTF9FVkVOVFNbXCJhY2Nlc3NfdG9rZW5cIl0gPSBcImFjY2Vzc190b2tlblwiO1xufSkoQ0hBTk5FTF9FVkVOVFMgfHwgKENIQU5ORUxfRVZFTlRTID0ge30pKTtcbmV4cG9ydCB2YXIgVFJBTlNQT1JUUztcbihmdW5jdGlvbiAoVFJBTlNQT1JUUykge1xuICAgIFRSQU5TUE9SVFNbXCJ3ZWJzb2NrZXRcIl0gPSBcIndlYnNvY2tldFwiO1xufSkoVFJBTlNQT1JUUyB8fCAoVFJBTlNQT1JUUyA9IHt9KSk7XG5leHBvcnQgdmFyIENPTk5FQ1RJT05fU1RBVEU7XG4oZnVuY3Rpb24gKENPTk5FQ1RJT05fU1RBVEUpIHtcbiAgICBDT05ORUNUSU9OX1NUQVRFW1wiQ29ubmVjdGluZ1wiXSA9IFwiY29ubmVjdGluZ1wiO1xuICAgIENPTk5FQ1RJT05fU1RBVEVbXCJPcGVuXCJdID0gXCJvcGVuXCI7XG4gICAgQ09OTkVDVElPTl9TVEFURVtcIkNsb3NpbmdcIl0gPSBcImNsb3NpbmdcIjtcbiAgICBDT05ORUNUSU9OX1NUQVRFW1wiQ2xvc2VkXCJdID0gXCJjbG9zZWRcIjtcbn0pKENPTk5FQ1RJT05fU1RBVEUgfHwgKENPTk5FQ1RJT05fU1RBVEUgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCIsImltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24nXG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX0hFQURFUlMgPSB7ICdYLUNsaWVudC1JbmZvJzogYHJlYWx0aW1lLWpzLyR7dmVyc2lvbn1gIH1cblxuZXhwb3J0IGNvbnN0IFZTTjogc3RyaW5nID0gJzEuMC4wJ1xuXG5leHBvcnQgY29uc3QgREVGQVVMVF9USU1FT1VUID0gMTAwMDBcblxuZXhwb3J0IGNvbnN0IFdTX0NMT1NFX05PUk1BTCA9IDEwMDBcblxuZXhwb3J0IGVudW0gU09DS0VUX1NUQVRFUyB7XG4gIGNvbm5lY3RpbmcgPSAwLFxuICBvcGVuID0gMSxcbiAgY2xvc2luZyA9IDIsXG4gIGNsb3NlZCA9IDMsXG59XG5cbmV4cG9ydCBlbnVtIENIQU5ORUxfU1RBVEVTIHtcbiAgY2xvc2VkID0gJ2Nsb3NlZCcsXG4gIGVycm9yZWQgPSAnZXJyb3JlZCcsXG4gIGpvaW5lZCA9ICdqb2luZWQnLFxuICBqb2luaW5nID0gJ2pvaW5pbmcnLFxuICBsZWF2aW5nID0gJ2xlYXZpbmcnLFxufVxuXG5leHBvcnQgZW51bSBDSEFOTkVMX0VWRU5UUyB7XG4gIGNsb3NlID0gJ3BoeF9jbG9zZScsXG4gIGVycm9yID0gJ3BoeF9lcnJvcicsXG4gIGpvaW4gPSAncGh4X2pvaW4nLFxuICByZXBseSA9ICdwaHhfcmVwbHknLFxuICBsZWF2ZSA9ICdwaHhfbGVhdmUnLFxuICBhY2Nlc3NfdG9rZW4gPSAnYWNjZXNzX3Rva2VuJyxcbn1cblxuZXhwb3J0IGVudW0gVFJBTlNQT1JUUyB7XG4gIHdlYnNvY2tldCA9ICd3ZWJzb2NrZXQnLFxufVxuXG5leHBvcnQgZW51bSBDT05ORUNUSU9OX1NUQVRFIHtcbiAgQ29ubmVjdGluZyA9ICdjb25uZWN0aW5nJyxcbiAgT3BlbiA9ICdvcGVuJyxcbiAgQ2xvc2luZyA9ICdjbG9zaW5nJyxcbiAgQ2xvc2VkID0gJ2Nsb3NlZCcsXG59XG4iLCJleHBvcnQgY29uc3QgdmVyc2lvbiA9ICcyLjEwLjInO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5qcy5tYXAiLCJleHBvcnQgY29uc3QgdmVyc2lvbiA9ICcyLjEwLjInXG4iLCIvLyBUaGlzIGZpbGUgZHJhd3MgaGVhdmlseSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9waG9lbml4ZnJhbWV3b3JrL3Bob2VuaXgvY29tbWl0L2NmMDk4ZTljZjdhNDRlZTY0NzlkMzFkOTExYTk3ZDNjNzQzMGM2ZmVcbi8vIExpY2Vuc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9waG9lbml4ZnJhbWV3b3JrL3Bob2VuaXgvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZFxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VyaWFsaXplciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuSEVBREVSX0xFTkdUSCA9IDE7XG4gICAgfVxuICAgIGRlY29kZShyYXdQYXlsb2FkLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAocmF3UGF5bG9hZC5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh0aGlzLl9iaW5hcnlEZWNvZGUocmF3UGF5bG9hZCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcmF3UGF5bG9hZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhKU09OLnBhcnNlKHJhd1BheWxvYWQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2soe30pO1xuICAgIH1cbiAgICBfYmluYXJ5RGVjb2RlKGJ1ZmZlcikge1xuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlY29kZUJyb2FkY2FzdChidWZmZXIsIHZpZXcsIGRlY29kZXIpO1xuICAgIH1cbiAgICBfZGVjb2RlQnJvYWRjYXN0KGJ1ZmZlciwgdmlldywgZGVjb2Rlcikge1xuICAgICAgICBjb25zdCB0b3BpY1NpemUgPSB2aWV3LmdldFVpbnQ4KDEpO1xuICAgICAgICBjb25zdCBldmVudFNpemUgPSB2aWV3LmdldFVpbnQ4KDIpO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5IRUFERVJfTEVOR1RIICsgMjtcbiAgICAgICAgY29uc3QgdG9waWMgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyB0b3BpY1NpemUpKTtcbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgdG9waWNTaXplO1xuICAgICAgICBjb25zdCBldmVudCA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGV2ZW50U2l6ZSkpO1xuICAgICAgICBvZmZzZXQgPSBvZmZzZXQgKyBldmVudFNpemU7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIGJ1ZmZlci5ieXRlTGVuZ3RoKSkpO1xuICAgICAgICByZXR1cm4geyByZWY6IG51bGwsIHRvcGljOiB0b3BpYywgZXZlbnQ6IGV2ZW50LCBwYXlsb2FkOiBkYXRhIH07XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VyaWFsaXplci5qcy5tYXAiLCIvLyBUaGlzIGZpbGUgZHJhd3MgaGVhdmlseSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9waG9lbml4ZnJhbWV3b3JrL3Bob2VuaXgvY29tbWl0L2NmMDk4ZTljZjdhNDRlZTY0NzlkMzFkOTExYTk3ZDNjNzQzMGM2ZmVcbi8vIExpY2Vuc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9waG9lbml4ZnJhbWV3b3JrL3Bob2VuaXgvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZFxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZXJpYWxpemVyIHtcbiAgSEVBREVSX0xFTkdUSCA9IDFcblxuICBkZWNvZGUocmF3UGF5bG9hZDogQXJyYXlCdWZmZXIgfCBzdHJpbmcsIGNhbGxiYWNrOiBGdW5jdGlvbikge1xuICAgIGlmIChyYXdQYXlsb2FkLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcikge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuX2JpbmFyeURlY29kZShyYXdQYXlsb2FkKSlcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHJhd1BheWxvYWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soSlNPTi5wYXJzZShyYXdQYXlsb2FkKSlcbiAgICB9XG5cbiAgICByZXR1cm4gY2FsbGJhY2soe30pXG4gIH1cblxuICBwcml2YXRlIF9iaW5hcnlEZWNvZGUoYnVmZmVyOiBBcnJheUJ1ZmZlcikge1xuICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKVxuICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKVxuXG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZUJyb2FkY2FzdChidWZmZXIsIHZpZXcsIGRlY29kZXIpXG4gIH1cblxuICBwcml2YXRlIF9kZWNvZGVCcm9hZGNhc3QoXG4gICAgYnVmZmVyOiBBcnJheUJ1ZmZlcixcbiAgICB2aWV3OiBEYXRhVmlldyxcbiAgICBkZWNvZGVyOiBUZXh0RGVjb2RlclxuICApOiB7XG4gICAgcmVmOiBudWxsXG4gICAgdG9waWM6IHN0cmluZ1xuICAgIGV2ZW50OiBzdHJpbmdcbiAgICBwYXlsb2FkOiB7IFtrZXk6IHN0cmluZ106IGFueSB9XG4gIH0ge1xuICAgIGNvbnN0IHRvcGljU2l6ZSA9IHZpZXcuZ2V0VWludDgoMSlcbiAgICBjb25zdCBldmVudFNpemUgPSB2aWV3LmdldFVpbnQ4KDIpXG4gICAgbGV0IG9mZnNldCA9IHRoaXMuSEVBREVSX0xFTkdUSCArIDJcbiAgICBjb25zdCB0b3BpYyA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIHRvcGljU2l6ZSkpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgdG9waWNTaXplXG4gICAgY29uc3QgZXZlbnQgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBldmVudFNpemUpKVxuICAgIG9mZnNldCA9IG9mZnNldCArIGV2ZW50U2l6ZVxuICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKFxuICAgICAgZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgYnVmZmVyLmJ5dGVMZW5ndGgpKVxuICAgIClcblxuICAgIHJldHVybiB7IHJlZjogbnVsbCwgdG9waWM6IHRvcGljLCBldmVudDogZXZlbnQsIHBheWxvYWQ6IGRhdGEgfVxuICB9XG59XG4iLCIvKipcbiAqIENyZWF0ZXMgYSB0aW1lciB0aGF0IGFjY2VwdHMgYSBgdGltZXJDYWxjYCBmdW5jdGlvbiB0byBwZXJmb3JtIGNhbGN1bGF0ZWQgdGltZW91dCByZXRyaWVzLCBzdWNoIGFzIGV4cG9uZW50aWFsIGJhY2tvZmYuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgIGxldCByZWNvbm5lY3RUaW1lciA9IG5ldyBUaW1lcigoKSA9PiB0aGlzLmNvbm5lY3QoKSwgZnVuY3Rpb24odHJpZXMpe1xuICogICAgICByZXR1cm4gWzEwMDAsIDUwMDAsIDEwMDAwXVt0cmllcyAtIDFdIHx8IDEwMDAwXG4gKiAgICB9KVxuICogICAgcmVjb25uZWN0VGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgLy8gZmlyZXMgYWZ0ZXIgMTAwMFxuICogICAgcmVjb25uZWN0VGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgLy8gZmlyZXMgYWZ0ZXIgNTAwMFxuICogICAgcmVjb25uZWN0VGltZXIucmVzZXQoKVxuICogICAgcmVjb25uZWN0VGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgLy8gZmlyZXMgYWZ0ZXIgMTAwMFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaW1lciB7XG4gICAgY29uc3RydWN0b3IoY2FsbGJhY2ssIHRpbWVyQ2FsYykge1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHRoaXMudGltZXJDYWxjID0gdGltZXJDYWxjO1xuICAgICAgICB0aGlzLnRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnRyaWVzID0gMDtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLnRpbWVyQ2FsYyA9IHRpbWVyQ2FsYztcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMudHJpZXMgPSAwO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgfVxuICAgIC8vIENhbmNlbHMgYW55IHByZXZpb3VzIHNjaGVkdWxlVGltZW91dCBhbmQgc2NoZWR1bGVzIGNhbGxiYWNrXG4gICAgc2NoZWR1bGVUaW1lb3V0KCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudHJpZXMgPSB0aGlzLnRyaWVzICsgMTtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2soKTtcbiAgICAgICAgfSwgdGhpcy50aW1lckNhbGModGhpcy50cmllcyArIDEpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lci5qcy5tYXAiLCIvKipcbiAqIENyZWF0ZXMgYSB0aW1lciB0aGF0IGFjY2VwdHMgYSBgdGltZXJDYWxjYCBmdW5jdGlvbiB0byBwZXJmb3JtIGNhbGN1bGF0ZWQgdGltZW91dCByZXRyaWVzLCBzdWNoIGFzIGV4cG9uZW50aWFsIGJhY2tvZmYuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgIGxldCByZWNvbm5lY3RUaW1lciA9IG5ldyBUaW1lcigoKSA9PiB0aGlzLmNvbm5lY3QoKSwgZnVuY3Rpb24odHJpZXMpe1xuICogICAgICByZXR1cm4gWzEwMDAsIDUwMDAsIDEwMDAwXVt0cmllcyAtIDFdIHx8IDEwMDAwXG4gKiAgICB9KVxuICogICAgcmVjb25uZWN0VGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgLy8gZmlyZXMgYWZ0ZXIgMTAwMFxuICogICAgcmVjb25uZWN0VGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgLy8gZmlyZXMgYWZ0ZXIgNTAwMFxuICogICAgcmVjb25uZWN0VGltZXIucmVzZXQoKVxuICogICAgcmVjb25uZWN0VGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgLy8gZmlyZXMgYWZ0ZXIgMTAwMFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaW1lciB7XG4gIHRpbWVyOiBudW1iZXIgfCB1bmRlZmluZWQgPSB1bmRlZmluZWRcbiAgdHJpZXM6IG51bWJlciA9IDBcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgY2FsbGJhY2s6IEZ1bmN0aW9uLCBwdWJsaWMgdGltZXJDYWxjOiBGdW5jdGlvbikge1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFja1xuICAgIHRoaXMudGltZXJDYWxjID0gdGltZXJDYWxjXG4gIH1cblxuICByZXNldCgpIHtcbiAgICB0aGlzLnRyaWVzID0gMFxuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKVxuICB9XG5cbiAgLy8gQ2FuY2VscyBhbnkgcHJldmlvdXMgc2NoZWR1bGVUaW1lb3V0IGFuZCBzY2hlZHVsZXMgY2FsbGJhY2tcbiAgc2NoZWR1bGVUaW1lb3V0KCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKVxuXG4gICAgdGhpcy50aW1lciA9IDxhbnk+c2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnRyaWVzID0gdGhpcy50cmllcyArIDFcbiAgICAgIHRoaXMuY2FsbGJhY2soKVxuICAgIH0sIHRoaXMudGltZXJDYWxjKHRoaXMudHJpZXMgKyAxKSlcbiAgfVxufVxuIiwiLyoqXG4gKiBIZWxwZXJzIHRvIGNvbnZlcnQgdGhlIGNoYW5nZSBQYXlsb2FkIGludG8gbmF0aXZlIEpTIHR5cGVzLlxuICovXG4vLyBBZGFwdGVkIGZyb20gZXBnc3FsIChzcmMvZXBnc3FsX2JpbmFyeS5lcmwpLCB0aGlzIG1vZHVsZSBsaWNlbnNlZCB1bmRlclxuLy8gMy1jbGF1c2UgQlNEIGZvdW5kIGhlcmU6IGh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9lcGdzcWwvZXBnc3FsL2RldmVsL0xJQ0VOU0VcbmV4cG9ydCB2YXIgUG9zdGdyZXNUeXBlcztcbihmdW5jdGlvbiAoUG9zdGdyZXNUeXBlcykge1xuICAgIFBvc3RncmVzVHlwZXNbXCJhYnN0aW1lXCJdID0gXCJhYnN0aW1lXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcImJvb2xcIl0gPSBcImJvb2xcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wiZGF0ZVwiXSA9IFwiZGF0ZVwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJkYXRlcmFuZ2VcIl0gPSBcImRhdGVyYW5nZVwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJmbG9hdDRcIl0gPSBcImZsb2F0NFwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJmbG9hdDhcIl0gPSBcImZsb2F0OFwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJpbnQyXCJdID0gXCJpbnQyXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcImludDRcIl0gPSBcImludDRcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wiaW50NHJhbmdlXCJdID0gXCJpbnQ0cmFuZ2VcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wiaW50OFwiXSA9IFwiaW50OFwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJpbnQ4cmFuZ2VcIl0gPSBcImludDhyYW5nZVwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJqc29uXCJdID0gXCJqc29uXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcImpzb25iXCJdID0gXCJqc29uYlwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJtb25leVwiXSA9IFwibW9uZXlcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wibnVtZXJpY1wiXSA9IFwibnVtZXJpY1wiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJvaWRcIl0gPSBcIm9pZFwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJyZWx0aW1lXCJdID0gXCJyZWx0aW1lXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcInRleHRcIl0gPSBcInRleHRcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1widGltZVwiXSA9IFwidGltZVwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJ0aW1lc3RhbXBcIl0gPSBcInRpbWVzdGFtcFwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJ0aW1lc3RhbXB0elwiXSA9IFwidGltZXN0YW1wdHpcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1widGltZXR6XCJdID0gXCJ0aW1ldHpcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1widHNyYW5nZVwiXSA9IFwidHNyYW5nZVwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJ0c3R6cmFuZ2VcIl0gPSBcInRzdHpyYW5nZVwiO1xufSkoUG9zdGdyZXNUeXBlcyB8fCAoUG9zdGdyZXNUeXBlcyA9IHt9KSk7XG4vKipcbiAqIFRha2VzIGFuIGFycmF5IG9mIGNvbHVtbnMgYW5kIGFuIG9iamVjdCBvZiBzdHJpbmcgdmFsdWVzIHRoZW4gY29udmVydHMgZWFjaCBzdHJpbmcgdmFsdWVcbiAqIHRvIGl0cyBtYXBwZWQgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge3tuYW1lOiBTdHJpbmcsIHR5cGU6IFN0cmluZ31bXX0gY29sdW1uc1xuICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG1hcCBvZiB2YXJpb3VzIG9wdGlvbnMgdGhhdCBjYW4gYmUgYXBwbGllZCB0byB0aGUgbWFwcGVyXG4gKiBAcGFyYW0ge0FycmF5fSBvcHRpb25zLnNraXBUeXBlcyBUaGUgYXJyYXkgb2YgdHlwZXMgdGhhdCBzaG91bGQgbm90IGJlIGNvbnZlcnRlZFxuICpcbiAqIEBleGFtcGxlIGNvbnZlcnRDaGFuZ2VEYXRhKFt7bmFtZTogJ2ZpcnN0X25hbWUnLCB0eXBlOiAndGV4dCd9LCB7bmFtZTogJ2FnZScsIHR5cGU6ICdpbnQ0J31dLCB7Zmlyc3RfbmFtZTogJ1BhdWwnLCBhZ2U6JzMzJ30sIHt9KVxuICogLy89PnsgZmlyc3RfbmFtZTogJ1BhdWwnLCBhZ2U6IDMzIH1cbiAqL1xuZXhwb3J0IGNvbnN0IGNvbnZlcnRDaGFuZ2VEYXRhID0gKGNvbHVtbnMsIHJlY29yZCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHNraXBUeXBlcyA9IChfYSA9IG9wdGlvbnMuc2tpcFR5cGVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMocmVjb3JkKS5yZWR1Y2UoKGFjYywgcmVjX2tleSkgPT4ge1xuICAgICAgICBhY2NbcmVjX2tleV0gPSBjb252ZXJ0Q29sdW1uKHJlY19rZXksIGNvbHVtbnMsIHJlY29yZCwgc2tpcFR5cGVzKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyB0aGUgdmFsdWUgb2YgYW4gaW5kaXZpZHVhbCBjb2x1bW4uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbHVtbk5hbWUgVGhlIGNvbHVtbiB0aGF0IHlvdSB3YW50IHRvIGNvbnZlcnRcbiAqIEBwYXJhbSB7e25hbWU6IFN0cmluZywgdHlwZTogU3RyaW5nfVtdfSBjb2x1bW5zIEFsbCBvZiB0aGUgY29sdW1uc1xuICogQHBhcmFtIHtPYmplY3R9IHJlY29yZCBUaGUgbWFwIG9mIHN0cmluZyB2YWx1ZXNcbiAqIEBwYXJhbSB7QXJyYXl9IHNraXBUeXBlcyBBbiBhcnJheSBvZiB0eXBlcyB0aGF0IHNob3VsZCBub3QgYmUgY29udmVydGVkXG4gKiBAcmV0dXJuIHtvYmplY3R9IFVzZWxlc3MgaW5mb3JtYXRpb25cbiAqXG4gKiBAZXhhbXBsZSBjb252ZXJ0Q29sdW1uKCdhZ2UnLCBbe25hbWU6ICdmaXJzdF9uYW1lJywgdHlwZTogJ3RleHQnfSwge25hbWU6ICdhZ2UnLCB0eXBlOiAnaW50NCd9XSwge2ZpcnN0X25hbWU6ICdQYXVsJywgYWdlOiAnMzMnfSwgW10pXG4gKiAvLz0+IDMzXG4gKiBAZXhhbXBsZSBjb252ZXJ0Q29sdW1uKCdhZ2UnLCBbe25hbWU6ICdmaXJzdF9uYW1lJywgdHlwZTogJ3RleHQnfSwge25hbWU6ICdhZ2UnLCB0eXBlOiAnaW50NCd9XSwge2ZpcnN0X25hbWU6ICdQYXVsJywgYWdlOiAnMzMnfSwgWydpbnQ0J10pXG4gKiAvLz0+IFwiMzNcIlxuICovXG5leHBvcnQgY29uc3QgY29udmVydENvbHVtbiA9IChjb2x1bW5OYW1lLCBjb2x1bW5zLCByZWNvcmQsIHNraXBUeXBlcykgPT4ge1xuICAgIGNvbnN0IGNvbHVtbiA9IGNvbHVtbnMuZmluZCgoeCkgPT4geC5uYW1lID09PSBjb2x1bW5OYW1lKTtcbiAgICBjb25zdCBjb2xUeXBlID0gY29sdW1uID09PSBudWxsIHx8IGNvbHVtbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29sdW1uLnR5cGU7XG4gICAgY29uc3QgdmFsdWUgPSByZWNvcmRbY29sdW1uTmFtZV07XG4gICAgaWYgKGNvbFR5cGUgJiYgIXNraXBUeXBlcy5pbmNsdWRlcyhjb2xUeXBlKSkge1xuICAgICAgICByZXR1cm4gY29udmVydENlbGwoY29sVHlwZSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gbm9vcCh2YWx1ZSk7XG59O1xuLyoqXG4gKiBJZiB0aGUgdmFsdWUgb2YgdGhlIGNlbGwgaXMgYG51bGxgLCByZXR1cm5zIG51bGwuXG4gKiBPdGhlcndpc2UgY29udmVydHMgdGhlIHN0cmluZyB2YWx1ZSB0byB0aGUgY29ycmVjdCB0eXBlLlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgQSBwb3N0Z3JlcyBjb2x1bW4gdHlwZVxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFRoZSBjZWxsIHZhbHVlXG4gKlxuICogQGV4YW1wbGUgY29udmVydENlbGwoJ2Jvb2wnLCAndCcpXG4gKiAvLz0+IHRydWVcbiAqIEBleGFtcGxlIGNvbnZlcnRDZWxsKCdpbnQ4JywgJzEwJylcbiAqIC8vPT4gMTBcbiAqIEBleGFtcGxlIGNvbnZlcnRDZWxsKCdfaW50NCcsICd7MSwyLDMsNH0nKVxuICogLy89PiBbMSwyLDMsNF1cbiAqL1xuZXhwb3J0IGNvbnN0IGNvbnZlcnRDZWxsID0gKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgLy8gaWYgZGF0YSB0eXBlIGlzIGFuIGFycmF5XG4gICAgaWYgKHR5cGUuY2hhckF0KDApID09PSAnXycpIHtcbiAgICAgICAgY29uc3QgZGF0YVR5cGUgPSB0eXBlLnNsaWNlKDEsIHR5cGUubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHRvQXJyYXkodmFsdWUsIGRhdGFUeXBlKTtcbiAgICB9XG4gICAgLy8gSWYgbm90IG51bGwsIGNvbnZlcnQgdG8gY29ycmVjdCB0eXBlLlxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMuYm9vbDpcbiAgICAgICAgICAgIHJldHVybiB0b0Jvb2xlYW4odmFsdWUpO1xuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMuZmxvYXQ0OlxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMuZmxvYXQ4OlxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMuaW50MjpcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmludDQ6XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5pbnQ4OlxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMubnVtZXJpYzpcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLm9pZDpcbiAgICAgICAgICAgIHJldHVybiB0b051bWJlcih2YWx1ZSk7XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5qc29uOlxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMuanNvbmI6XG4gICAgICAgICAgICByZXR1cm4gdG9Kc29uKHZhbHVlKTtcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnRpbWVzdGFtcDpcbiAgICAgICAgICAgIHJldHVybiB0b1RpbWVzdGFtcFN0cmluZyh2YWx1ZSk7IC8vIEZvcm1hdCB0byBiZSBjb25zaXN0ZW50IHdpdGggUG9zdGdSRVNUXG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5hYnN0aW1lOiAvLyBUbyBhbGxvdyB1c2VycyB0byBjYXN0IGl0IGJhc2VkIG9uIFRpbWV6b25lXG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5kYXRlOiAvLyBUbyBhbGxvdyB1c2VycyB0byBjYXN0IGl0IGJhc2VkIG9uIFRpbWV6b25lXG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5kYXRlcmFuZ2U6XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5pbnQ0cmFuZ2U6XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5pbnQ4cmFuZ2U6XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5tb25leTpcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnJlbHRpbWU6IC8vIFRvIGFsbG93IHVzZXJzIHRvIGNhc3QgaXQgYmFzZWQgb24gVGltZXpvbmVcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnRleHQ6XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy50aW1lOiAvLyBUbyBhbGxvdyB1c2VycyB0byBjYXN0IGl0IGJhc2VkIG9uIFRpbWV6b25lXG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy50aW1lc3RhbXB0ejogLy8gVG8gYWxsb3cgdXNlcnMgdG8gY2FzdCBpdCBiYXNlZCBvbiBUaW1lem9uZVxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMudGltZXR6OiAvLyBUbyBhbGxvdyB1c2VycyB0byBjYXN0IGl0IGJhc2VkIG9uIFRpbWV6b25lXG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy50c3JhbmdlOlxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMudHN0enJhbmdlOlxuICAgICAgICAgICAgcmV0dXJuIG5vb3AodmFsdWUpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSB2YWx1ZSBmb3IgcmVtYWluaW5nIHR5cGVzXG4gICAgICAgICAgICByZXR1cm4gbm9vcCh2YWx1ZSk7XG4gICAgfVxufTtcbmNvbnN0IG5vb3AgPSAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gdmFsdWU7XG59O1xuZXhwb3J0IGNvbnN0IHRvQm9vbGVhbiA9ICh2YWx1ZSkgPT4ge1xuICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCB0b051bWJlciA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgIGlmICghTnVtYmVyLmlzTmFOKHBhcnNlZFZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZFZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG5leHBvcnQgY29uc3QgdG9Kc29uID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBKU09OIHBhcnNlIGVycm9yOiAke2Vycm9yfWApO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG4vKipcbiAqIENvbnZlcnRzIGEgUG9zdGdyZXMgQXJyYXkgaW50byBhIG5hdGl2ZSBKUyBhcnJheVxuICpcbiAqIEBleGFtcGxlIHRvQXJyYXkoJ3t9JywgJ2ludDQnKVxuICogLy89PiBbXVxuICogQGV4YW1wbGUgdG9BcnJheSgne1wiWzIwMjEtMDEtMDEsMjAyMS0xMi0zMSlcIixcIigyMDIxLTAxLTAxLDIwMjEtMTItMzJdXCJ9JywgJ2RhdGVyYW5nZScpXG4gKiAvLz0+IFsnWzIwMjEtMDEtMDEsMjAyMS0xMi0zMSknLCAnKDIwMjEtMDEtMDEsMjAyMS0xMi0zMl0nXVxuICogQGV4YW1wbGUgdG9BcnJheShbMSwyLDMsNF0sICdpbnQ0JylcbiAqIC8vPT4gWzEsMiwzLDRdXG4gKi9cbmV4cG9ydCBjb25zdCB0b0FycmF5ID0gKHZhbHVlLCB0eXBlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBsYXN0SWR4ID0gdmFsdWUubGVuZ3RoIC0gMTtcbiAgICBjb25zdCBjbG9zZUJyYWNlID0gdmFsdWVbbGFzdElkeF07XG4gICAgY29uc3Qgb3BlbkJyYWNlID0gdmFsdWVbMF07XG4gICAgLy8gQ29uZmlybSB2YWx1ZSBpcyBhIFBvc3RncmVzIGFycmF5IGJ5IGNoZWNraW5nIGN1cmx5IGJyYWNrZXRzXG4gICAgaWYgKG9wZW5CcmFjZSA9PT0gJ3snICYmIGNsb3NlQnJhY2UgPT09ICd9Jykge1xuICAgICAgICBsZXQgYXJyO1xuICAgICAgICBjb25zdCB2YWxUcmltID0gdmFsdWUuc2xpY2UoMSwgbGFzdElkeCk7XG4gICAgICAgIC8vIFRPRE86IGZpbmQgYSBiZXR0ZXIgc29sdXRpb24gdG8gc2VwYXJhdGUgUG9zdGdyZXMgYXJyYXkgZGF0YVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXJyID0gSlNPTi5wYXJzZSgnWycgKyB2YWxUcmltICsgJ10nKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgLy8gV0FSTklORzogc3BsaXR0aW5nIG9uIGNvbW1hIGRvZXMgbm90IGNvdmVyIGFsbCBlZGdlIGNhc2VzXG4gICAgICAgICAgICBhcnIgPSB2YWxUcmltID8gdmFsVHJpbS5zcGxpdCgnLCcpIDogW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyci5tYXAoKHZhbCkgPT4gY29udmVydENlbGwodHlwZSwgdmFsKSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG4vKipcbiAqIEZpeGVzIHRpbWVzdGFtcCB0byBiZSBJU08tODYwMS4gU3dhcHMgdGhlIHNwYWNlIGJldHdlZW4gdGhlIGRhdGUgYW5kIHRpbWUgZm9yIGEgJ1QnXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3N1cGFiYXNlL3N1cGFiYXNlL2lzc3Vlcy8xOFxuICpcbiAqIEBleGFtcGxlIHRvVGltZXN0YW1wU3RyaW5nKCcyMDE5LTA5LTEwIDAwOjAwOjAwJylcbiAqIC8vPT4gJzIwMTktMDktMTBUMDA6MDA6MDAnXG4gKi9cbmV4cG9ydCBjb25zdCB0b1RpbWVzdGFtcFN0cmluZyA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKCcgJywgJ1QnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbmV4cG9ydCBjb25zdCBodHRwRW5kcG9pbnRVUkwgPSAoc29ja2V0VXJsKSA9PiB7XG4gICAgbGV0IHVybCA9IHNvY2tldFVybDtcbiAgICB1cmwgPSB1cmwucmVwbGFjZSgvXndzL2ksICdodHRwJyk7XG4gICAgdXJsID0gdXJsLnJlcGxhY2UoLyhcXC9zb2NrZXRcXC93ZWJzb2NrZXR8XFwvc29ja2V0fFxcL3dlYnNvY2tldClcXC8/JC9pLCAnJyk7XG4gICAgcmV0dXJuIHVybC5yZXBsYWNlKC9cXC8rJC8sICcnKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2Zvcm1lcnMuanMubWFwIiwiLyoqXG4gKiBIZWxwZXJzIHRvIGNvbnZlcnQgdGhlIGNoYW5nZSBQYXlsb2FkIGludG8gbmF0aXZlIEpTIHR5cGVzLlxuICovXG5cbi8vIEFkYXB0ZWQgZnJvbSBlcGdzcWwgKHNyYy9lcGdzcWxfYmluYXJ5LmVybCksIHRoaXMgbW9kdWxlIGxpY2Vuc2VkIHVuZGVyXG4vLyAzLWNsYXVzZSBCU0QgZm91bmQgaGVyZTogaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2VwZ3NxbC9lcGdzcWwvZGV2ZWwvTElDRU5TRVxuXG5leHBvcnQgZW51bSBQb3N0Z3Jlc1R5cGVzIHtcbiAgYWJzdGltZSA9ICdhYnN0aW1lJyxcbiAgYm9vbCA9ICdib29sJyxcbiAgZGF0ZSA9ICdkYXRlJyxcbiAgZGF0ZXJhbmdlID0gJ2RhdGVyYW5nZScsXG4gIGZsb2F0NCA9ICdmbG9hdDQnLFxuICBmbG9hdDggPSAnZmxvYXQ4JyxcbiAgaW50MiA9ICdpbnQyJyxcbiAgaW50NCA9ICdpbnQ0JyxcbiAgaW50NHJhbmdlID0gJ2ludDRyYW5nZScsXG4gIGludDggPSAnaW50OCcsXG4gIGludDhyYW5nZSA9ICdpbnQ4cmFuZ2UnLFxuICBqc29uID0gJ2pzb24nLFxuICBqc29uYiA9ICdqc29uYicsXG4gIG1vbmV5ID0gJ21vbmV5JyxcbiAgbnVtZXJpYyA9ICdudW1lcmljJyxcbiAgb2lkID0gJ29pZCcsXG4gIHJlbHRpbWUgPSAncmVsdGltZScsXG4gIHRleHQgPSAndGV4dCcsXG4gIHRpbWUgPSAndGltZScsXG4gIHRpbWVzdGFtcCA9ICd0aW1lc3RhbXAnLFxuICB0aW1lc3RhbXB0eiA9ICd0aW1lc3RhbXB0eicsXG4gIHRpbWV0eiA9ICd0aW1ldHonLFxuICB0c3JhbmdlID0gJ3RzcmFuZ2UnLFxuICB0c3R6cmFuZ2UgPSAndHN0enJhbmdlJyxcbn1cblxudHlwZSBDb2x1bW5zID0ge1xuICBuYW1lOiBzdHJpbmcgLy8gdGhlIGNvbHVtbiBuYW1lLiBlZzogXCJ1c2VyX2lkXCJcbiAgdHlwZTogc3RyaW5nIC8vIHRoZSBjb2x1bW4gdHlwZS4gZWc6IFwidXVpZFwiXG4gIGZsYWdzPzogc3RyaW5nW10gLy8gYW55IHNwZWNpYWwgZmxhZ3MgZm9yIHRoZSBjb2x1bW4uIGVnOiBbXCJrZXlcIl1cbiAgdHlwZV9tb2RpZmllcj86IG51bWJlciAvLyB0aGUgdHlwZSBtb2RpZmllci4gZWc6IDQyOTQ5NjcyOTVcbn1bXVxuXG50eXBlIEJhc2VWYWx1ZSA9IG51bGwgfCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuXG50eXBlIFJlY29yZFZhbHVlID0gQmFzZVZhbHVlIHwgQmFzZVZhbHVlW11cblxudHlwZSBSZWNvcmQgPSB7XG4gIFtrZXk6IHN0cmluZ106IFJlY29yZFZhbHVlXG59XG5cbi8qKlxuICogVGFrZXMgYW4gYXJyYXkgb2YgY29sdW1ucyBhbmQgYW4gb2JqZWN0IG9mIHN0cmluZyB2YWx1ZXMgdGhlbiBjb252ZXJ0cyBlYWNoIHN0cmluZyB2YWx1ZVxuICogdG8gaXRzIG1hcHBlZCB0eXBlLlxuICpcbiAqIEBwYXJhbSB7e25hbWU6IFN0cmluZywgdHlwZTogU3RyaW5nfVtdfSBjb2x1bW5zXG4gKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgbWFwIG9mIHZhcmlvdXMgb3B0aW9ucyB0aGF0IGNhbiBiZSBhcHBsaWVkIHRvIHRoZSBtYXBwZXJcbiAqIEBwYXJhbSB7QXJyYXl9IG9wdGlvbnMuc2tpcFR5cGVzIFRoZSBhcnJheSBvZiB0eXBlcyB0aGF0IHNob3VsZCBub3QgYmUgY29udmVydGVkXG4gKlxuICogQGV4YW1wbGUgY29udmVydENoYW5nZURhdGEoW3tuYW1lOiAnZmlyc3RfbmFtZScsIHR5cGU6ICd0ZXh0J30sIHtuYW1lOiAnYWdlJywgdHlwZTogJ2ludDQnfV0sIHtmaXJzdF9uYW1lOiAnUGF1bCcsIGFnZTonMzMnfSwge30pXG4gKiAvLz0+eyBmaXJzdF9uYW1lOiAnUGF1bCcsIGFnZTogMzMgfVxuICovXG5leHBvcnQgY29uc3QgY29udmVydENoYW5nZURhdGEgPSAoXG4gIGNvbHVtbnM6IENvbHVtbnMsXG4gIHJlY29yZDogUmVjb3JkLFxuICBvcHRpb25zOiB7IHNraXBUeXBlcz86IHN0cmluZ1tdIH0gPSB7fVxuKTogUmVjb3JkID0+IHtcbiAgY29uc3Qgc2tpcFR5cGVzID0gb3B0aW9ucy5za2lwVHlwZXMgPz8gW11cblxuICByZXR1cm4gT2JqZWN0LmtleXMocmVjb3JkKS5yZWR1Y2UoKGFjYywgcmVjX2tleSkgPT4ge1xuICAgIGFjY1tyZWNfa2V5XSA9IGNvbnZlcnRDb2x1bW4ocmVjX2tleSwgY29sdW1ucywgcmVjb3JkLCBza2lwVHlwZXMpXG4gICAgcmV0dXJuIGFjY1xuICB9LCB7fSBhcyBSZWNvcmQpXG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlIHZhbHVlIG9mIGFuIGluZGl2aWR1YWwgY29sdW1uLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2x1bW5OYW1lIFRoZSBjb2x1bW4gdGhhdCB5b3Ugd2FudCB0byBjb252ZXJ0XG4gKiBAcGFyYW0ge3tuYW1lOiBTdHJpbmcsIHR5cGU6IFN0cmluZ31bXX0gY29sdW1ucyBBbGwgb2YgdGhlIGNvbHVtbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmQgVGhlIG1hcCBvZiBzdHJpbmcgdmFsdWVzXG4gKiBAcGFyYW0ge0FycmF5fSBza2lwVHlwZXMgQW4gYXJyYXkgb2YgdHlwZXMgdGhhdCBzaG91bGQgbm90IGJlIGNvbnZlcnRlZFxuICogQHJldHVybiB7b2JqZWN0fSBVc2VsZXNzIGluZm9ybWF0aW9uXG4gKlxuICogQGV4YW1wbGUgY29udmVydENvbHVtbignYWdlJywgW3tuYW1lOiAnZmlyc3RfbmFtZScsIHR5cGU6ICd0ZXh0J30sIHtuYW1lOiAnYWdlJywgdHlwZTogJ2ludDQnfV0sIHtmaXJzdF9uYW1lOiAnUGF1bCcsIGFnZTogJzMzJ30sIFtdKVxuICogLy89PiAzM1xuICogQGV4YW1wbGUgY29udmVydENvbHVtbignYWdlJywgW3tuYW1lOiAnZmlyc3RfbmFtZScsIHR5cGU6ICd0ZXh0J30sIHtuYW1lOiAnYWdlJywgdHlwZTogJ2ludDQnfV0sIHtmaXJzdF9uYW1lOiAnUGF1bCcsIGFnZTogJzMzJ30sIFsnaW50NCddKVxuICogLy89PiBcIjMzXCJcbiAqL1xuZXhwb3J0IGNvbnN0IGNvbnZlcnRDb2x1bW4gPSAoXG4gIGNvbHVtbk5hbWU6IHN0cmluZyxcbiAgY29sdW1uczogQ29sdW1ucyxcbiAgcmVjb3JkOiBSZWNvcmQsXG4gIHNraXBUeXBlczogc3RyaW5nW11cbik6IFJlY29yZFZhbHVlID0+IHtcbiAgY29uc3QgY29sdW1uID0gY29sdW1ucy5maW5kKCh4KSA9PiB4Lm5hbWUgPT09IGNvbHVtbk5hbWUpXG4gIGNvbnN0IGNvbFR5cGUgPSBjb2x1bW4/LnR5cGVcbiAgY29uc3QgdmFsdWUgPSByZWNvcmRbY29sdW1uTmFtZV1cblxuICBpZiAoY29sVHlwZSAmJiAhc2tpcFR5cGVzLmluY2x1ZGVzKGNvbFR5cGUpKSB7XG4gICAgcmV0dXJuIGNvbnZlcnRDZWxsKGNvbFR5cGUsIHZhbHVlKVxuICB9XG5cbiAgcmV0dXJuIG5vb3AodmFsdWUpXG59XG5cbi8qKlxuICogSWYgdGhlIHZhbHVlIG9mIHRoZSBjZWxsIGlzIGBudWxsYCwgcmV0dXJucyBudWxsLlxuICogT3RoZXJ3aXNlIGNvbnZlcnRzIHRoZSBzdHJpbmcgdmFsdWUgdG8gdGhlIGNvcnJlY3QgdHlwZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIEEgcG9zdGdyZXMgY29sdW1uIHR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBUaGUgY2VsbCB2YWx1ZVxuICpcbiAqIEBleGFtcGxlIGNvbnZlcnRDZWxsKCdib29sJywgJ3QnKVxuICogLy89PiB0cnVlXG4gKiBAZXhhbXBsZSBjb252ZXJ0Q2VsbCgnaW50OCcsICcxMCcpXG4gKiAvLz0+IDEwXG4gKiBAZXhhbXBsZSBjb252ZXJ0Q2VsbCgnX2ludDQnLCAnezEsMiwzLDR9JylcbiAqIC8vPT4gWzEsMiwzLDRdXG4gKi9cbmV4cG9ydCBjb25zdCBjb252ZXJ0Q2VsbCA9ICh0eXBlOiBzdHJpbmcsIHZhbHVlOiBSZWNvcmRWYWx1ZSk6IFJlY29yZFZhbHVlID0+IHtcbiAgLy8gaWYgZGF0YSB0eXBlIGlzIGFuIGFycmF5XG4gIGlmICh0eXBlLmNoYXJBdCgwKSA9PT0gJ18nKSB7XG4gICAgY29uc3QgZGF0YVR5cGUgPSB0eXBlLnNsaWNlKDEsIHR5cGUubGVuZ3RoKVxuICAgIHJldHVybiB0b0FycmF5KHZhbHVlLCBkYXRhVHlwZSlcbiAgfVxuXG4gIC8vIElmIG5vdCBudWxsLCBjb252ZXJ0IHRvIGNvcnJlY3QgdHlwZS5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmJvb2w6XG4gICAgICByZXR1cm4gdG9Cb29sZWFuKHZhbHVlKVxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5mbG9hdDQ6XG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmZsb2F0ODpcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMuaW50MjpcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMuaW50NDpcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMuaW50ODpcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMubnVtZXJpYzpcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMub2lkOlxuICAgICAgcmV0dXJuIHRvTnVtYmVyKHZhbHVlKVxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5qc29uOlxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5qc29uYjpcbiAgICAgIHJldHVybiB0b0pzb24odmFsdWUpXG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnRpbWVzdGFtcDpcbiAgICAgIHJldHVybiB0b1RpbWVzdGFtcFN0cmluZyh2YWx1ZSkgLy8gRm9ybWF0IHRvIGJlIGNvbnNpc3RlbnQgd2l0aCBQb3N0Z1JFU1RcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMuYWJzdGltZTogLy8gVG8gYWxsb3cgdXNlcnMgdG8gY2FzdCBpdCBiYXNlZCBvbiBUaW1lem9uZVxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5kYXRlOiAvLyBUbyBhbGxvdyB1c2VycyB0byBjYXN0IGl0IGJhc2VkIG9uIFRpbWV6b25lXG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmRhdGVyYW5nZTpcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMuaW50NHJhbmdlOlxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5pbnQ4cmFuZ2U6XG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLm1vbmV5OlxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5yZWx0aW1lOiAvLyBUbyBhbGxvdyB1c2VycyB0byBjYXN0IGl0IGJhc2VkIG9uIFRpbWV6b25lXG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnRleHQ6XG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnRpbWU6IC8vIFRvIGFsbG93IHVzZXJzIHRvIGNhc3QgaXQgYmFzZWQgb24gVGltZXpvbmVcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMudGltZXN0YW1wdHo6IC8vIFRvIGFsbG93IHVzZXJzIHRvIGNhc3QgaXQgYmFzZWQgb24gVGltZXpvbmVcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMudGltZXR6OiAvLyBUbyBhbGxvdyB1c2VycyB0byBjYXN0IGl0IGJhc2VkIG9uIFRpbWV6b25lXG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnRzcmFuZ2U6XG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnRzdHpyYW5nZTpcbiAgICAgIHJldHVybiBub29wKHZhbHVlKVxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBSZXR1cm4gdGhlIHZhbHVlIGZvciByZW1haW5pbmcgdHlwZXNcbiAgICAgIHJldHVybiBub29wKHZhbHVlKVxuICB9XG59XG5cbmNvbnN0IG5vb3AgPSAodmFsdWU6IFJlY29yZFZhbHVlKTogUmVjb3JkVmFsdWUgPT4ge1xuICByZXR1cm4gdmFsdWVcbn1cbmV4cG9ydCBjb25zdCB0b0Jvb2xlYW4gPSAodmFsdWU6IFJlY29yZFZhbHVlKTogUmVjb3JkVmFsdWUgPT4ge1xuICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgY2FzZSAndCc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGNhc2UgJ2YnOlxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB2YWx1ZVxuICB9XG59XG5leHBvcnQgY29uc3QgdG9OdW1iZXIgPSAodmFsdWU6IFJlY29yZFZhbHVlKTogUmVjb3JkVmFsdWUgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSlcbiAgICBpZiAoIU51bWJlci5pc05hTihwYXJzZWRWYWx1ZSkpIHtcbiAgICAgIHJldHVybiBwYXJzZWRWYWx1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWVcbn1cbmV4cG9ydCBjb25zdCB0b0pzb24gPSAodmFsdWU6IFJlY29yZFZhbHVlKTogUmVjb3JkVmFsdWUgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5sb2coYEpTT04gcGFyc2UgZXJyb3I6ICR7ZXJyb3J9YClcbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWVcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIFBvc3RncmVzIEFycmF5IGludG8gYSBuYXRpdmUgSlMgYXJyYXlcbiAqXG4gKiBAZXhhbXBsZSB0b0FycmF5KCd7fScsICdpbnQ0JylcbiAqIC8vPT4gW11cbiAqIEBleGFtcGxlIHRvQXJyYXkoJ3tcIlsyMDIxLTAxLTAxLDIwMjEtMTItMzEpXCIsXCIoMjAyMS0wMS0wMSwyMDIxLTEyLTMyXVwifScsICdkYXRlcmFuZ2UnKVxuICogLy89PiBbJ1syMDIxLTAxLTAxLDIwMjEtMTItMzEpJywgJygyMDIxLTAxLTAxLDIwMjEtMTItMzJdJ11cbiAqIEBleGFtcGxlIHRvQXJyYXkoWzEsMiwzLDRdLCAnaW50NCcpXG4gKiAvLz0+IFsxLDIsMyw0XVxuICovXG5leHBvcnQgY29uc3QgdG9BcnJheSA9ICh2YWx1ZTogUmVjb3JkVmFsdWUsIHR5cGU6IHN0cmluZyk6IFJlY29yZFZhbHVlID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIGNvbnN0IGxhc3RJZHggPSB2YWx1ZS5sZW5ndGggLSAxXG4gIGNvbnN0IGNsb3NlQnJhY2UgPSB2YWx1ZVtsYXN0SWR4XVxuICBjb25zdCBvcGVuQnJhY2UgPSB2YWx1ZVswXVxuXG4gIC8vIENvbmZpcm0gdmFsdWUgaXMgYSBQb3N0Z3JlcyBhcnJheSBieSBjaGVja2luZyBjdXJseSBicmFja2V0c1xuICBpZiAob3BlbkJyYWNlID09PSAneycgJiYgY2xvc2VCcmFjZSA9PT0gJ30nKSB7XG4gICAgbGV0IGFyclxuICAgIGNvbnN0IHZhbFRyaW0gPSB2YWx1ZS5zbGljZSgxLCBsYXN0SWR4KVxuXG4gICAgLy8gVE9ETzogZmluZCBhIGJldHRlciBzb2x1dGlvbiB0byBzZXBhcmF0ZSBQb3N0Z3JlcyBhcnJheSBkYXRhXG4gICAgdHJ5IHtcbiAgICAgIGFyciA9IEpTT04ucGFyc2UoJ1snICsgdmFsVHJpbSArICddJylcbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICAvLyBXQVJOSU5HOiBzcGxpdHRpbmcgb24gY29tbWEgZG9lcyBub3QgY292ZXIgYWxsIGVkZ2UgY2FzZXNcbiAgICAgIGFyciA9IHZhbFRyaW0gPyB2YWxUcmltLnNwbGl0KCcsJykgOiBbXVxuICAgIH1cblxuICAgIHJldHVybiBhcnIubWFwKCh2YWw6IEJhc2VWYWx1ZSkgPT4gY29udmVydENlbGwodHlwZSwgdmFsKSlcbiAgfVxuXG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIEZpeGVzIHRpbWVzdGFtcCB0byBiZSBJU08tODYwMS4gU3dhcHMgdGhlIHNwYWNlIGJldHdlZW4gdGhlIGRhdGUgYW5kIHRpbWUgZm9yIGEgJ1QnXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3N1cGFiYXNlL3N1cGFiYXNlL2lzc3Vlcy8xOFxuICpcbiAqIEBleGFtcGxlIHRvVGltZXN0YW1wU3RyaW5nKCcyMDE5LTA5LTEwIDAwOjAwOjAwJylcbiAqIC8vPT4gJzIwMTktMDktMTBUMDA6MDA6MDAnXG4gKi9cbmV4cG9ydCBjb25zdCB0b1RpbWVzdGFtcFN0cmluZyA9ICh2YWx1ZTogUmVjb3JkVmFsdWUpOiBSZWNvcmRWYWx1ZSA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoJyAnLCAnVCcpXG4gIH1cblxuICByZXR1cm4gdmFsdWVcbn1cblxuZXhwb3J0IGNvbnN0IGh0dHBFbmRwb2ludFVSTCA9IChzb2NrZXRVcmw6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gIGxldCB1cmwgPSBzb2NrZXRVcmxcbiAgdXJsID0gdXJsLnJlcGxhY2UoL153cy9pLCAnaHR0cCcpXG4gIHVybCA9IHVybC5yZXBsYWNlKC8oXFwvc29ja2V0XFwvd2Vic29ja2V0fFxcL3NvY2tldHxcXC93ZWJzb2NrZXQpXFwvPyQvaSwgJycpXG4gIHJldHVybiB1cmwucmVwbGFjZSgvXFwvKyQvLCAnJylcbn1cbiIsImltcG9ydCB7IENIQU5ORUxfRVZFTlRTLCBDSEFOTkVMX1NUQVRFUyB9IGZyb20gJy4vbGliL2NvbnN0YW50cyc7XG5pbXBvcnQgUHVzaCBmcm9tICcuL2xpYi9wdXNoJztcbmltcG9ydCBUaW1lciBmcm9tICcuL2xpYi90aW1lcic7XG5pbXBvcnQgUmVhbHRpbWVQcmVzZW5jZSBmcm9tICcuL1JlYWx0aW1lUHJlc2VuY2UnO1xuaW1wb3J0ICogYXMgVHJhbnNmb3JtZXJzIGZyb20gJy4vbGliL3RyYW5zZm9ybWVycyc7XG5pbXBvcnQgeyBodHRwRW5kcG9pbnRVUkwgfSBmcm9tICcuL2xpYi90cmFuc2Zvcm1lcnMnO1xuZXhwb3J0IHZhciBSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVDtcbihmdW5jdGlvbiAoUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQpIHtcbiAgICBSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVFtcIkFMTFwiXSA9IFwiKlwiO1xuICAgIFJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5UW1wiSU5TRVJUXCJdID0gXCJJTlNFUlRcIjtcbiAgICBSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVFtcIlVQREFURVwiXSA9IFwiVVBEQVRFXCI7XG4gICAgUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlRbXCJERUxFVEVcIl0gPSBcIkRFTEVURVwiO1xufSkoUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQgfHwgKFJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5UID0ge30pKTtcbmV4cG9ydCB2YXIgUkVBTFRJTUVfTElTVEVOX1RZUEVTO1xuKGZ1bmN0aW9uIChSRUFMVElNRV9MSVNURU5fVFlQRVMpIHtcbiAgICBSRUFMVElNRV9MSVNURU5fVFlQRVNbXCJCUk9BRENBU1RcIl0gPSBcImJyb2FkY2FzdFwiO1xuICAgIFJFQUxUSU1FX0xJU1RFTl9UWVBFU1tcIlBSRVNFTkNFXCJdID0gXCJwcmVzZW5jZVwiO1xuICAgIC8qKlxuICAgICAqIGxpc3RlbiB0byBQb3N0Z3JlcyBjaGFuZ2VzLlxuICAgICAqL1xuICAgIFJFQUxUSU1FX0xJU1RFTl9UWVBFU1tcIlBPU1RHUkVTX0NIQU5HRVNcIl0gPSBcInBvc3RncmVzX2NoYW5nZXNcIjtcbn0pKFJFQUxUSU1FX0xJU1RFTl9UWVBFUyB8fCAoUkVBTFRJTUVfTElTVEVOX1RZUEVTID0ge30pKTtcbmV4cG9ydCB2YXIgUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUztcbihmdW5jdGlvbiAoUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUykge1xuICAgIFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVNbXCJTVUJTQ1JJQkVEXCJdID0gXCJTVUJTQ1JJQkVEXCI7XG4gICAgUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFU1tcIlRJTUVEX09VVFwiXSA9IFwiVElNRURfT1VUXCI7XG4gICAgUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFU1tcIkNMT1NFRFwiXSA9IFwiQ0xPU0VEXCI7XG4gICAgUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFU1tcIkNIQU5ORUxfRVJST1JcIl0gPSBcIkNIQU5ORUxfRVJST1JcIjtcbn0pKFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMgfHwgKFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMgPSB7fSkpO1xuZXhwb3J0IGNvbnN0IFJFQUxUSU1FX0NIQU5ORUxfU1RBVEVTID0gQ0hBTk5FTF9TVEFURVM7XG4vKiogQSBjaGFubmVsIGlzIHRoZSBiYXNpYyBidWlsZGluZyBibG9jayBvZiBSZWFsdGltZVxuICogYW5kIG5hcnJvd3MgdGhlIHNjb3BlIG9mIGRhdGEgZmxvdyB0byBzdWJzY3JpYmVkIGNsaWVudHMuXG4gKiBZb3UgY2FuIHRoaW5rIG9mIGEgY2hhbm5lbCBhcyBhIGNoYXRyb29tIHdoZXJlIHBhcnRpY2lwYW50cyBhcmUgYWJsZSB0byBzZWUgd2hvJ3Mgb25saW5lXG4gKiBhbmQgc2VuZCBhbmQgcmVjZWl2ZSBtZXNzYWdlcy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVhbHRpbWVDaGFubmVsIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKiogVG9waWMgbmFtZSBjYW4gYmUgYW55IHN0cmluZy4gKi9cbiAgICB0b3BpYywgcGFyYW1zID0geyBjb25maWc6IHt9IH0sIHNvY2tldCkge1xuICAgICAgICB0aGlzLnRvcGljID0gdG9waWM7XG4gICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICB0aGlzLnNvY2tldCA9IHNvY2tldDtcbiAgICAgICAgdGhpcy5iaW5kaW5ncyA9IHt9O1xuICAgICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuY2xvc2VkO1xuICAgICAgICB0aGlzLmpvaW5lZE9uY2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wdXNoQnVmZmVyID0gW107XG4gICAgICAgIHRoaXMuc3ViVG9waWMgPSB0b3BpYy5yZXBsYWNlKC9ecmVhbHRpbWU6L2ksICcnKTtcbiAgICAgICAgdGhpcy5wYXJhbXMuY29uZmlnID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBicm9hZGNhc3Q6IHsgYWNrOiBmYWxzZSwgc2VsZjogZmFsc2UgfSxcbiAgICAgICAgICAgIHByZXNlbmNlOiB7IGtleTogJycgfSxcbiAgICAgICAgICAgIHByaXZhdGU6IGZhbHNlLFxuICAgICAgICB9LCBwYXJhbXMuY29uZmlnKTtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gdGhpcy5zb2NrZXQudGltZW91dDtcbiAgICAgICAgdGhpcy5qb2luUHVzaCA9IG5ldyBQdXNoKHRoaXMsIENIQU5ORUxfRVZFTlRTLmpvaW4sIHRoaXMucGFyYW1zLCB0aGlzLnRpbWVvdXQpO1xuICAgICAgICB0aGlzLnJlam9pblRpbWVyID0gbmV3IFRpbWVyKCgpID0+IHRoaXMuX3Jlam9pblVudGlsQ29ubmVjdGVkKCksIHRoaXMuc29ja2V0LnJlY29ubmVjdEFmdGVyTXMpO1xuICAgICAgICB0aGlzLmpvaW5QdXNoLnJlY2VpdmUoJ29rJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmpvaW5lZDtcbiAgICAgICAgICAgIHRoaXMucmVqb2luVGltZXIucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMucHVzaEJ1ZmZlci5mb3JFYWNoKChwdXNoRXZlbnQpID0+IHB1c2hFdmVudC5zZW5kKCkpO1xuICAgICAgICAgICAgdGhpcy5wdXNoQnVmZmVyID0gW107XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9vbkNsb3NlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVqb2luVGltZXIucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LmxvZygnY2hhbm5lbCcsIGBjbG9zZSAke3RoaXMudG9waWN9ICR7dGhpcy5fam9pblJlZigpfWApO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmNsb3NlZDtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0Ll9yZW1vdmUodGhpcyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9vbkVycm9yKChyZWFzb24pID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0xlYXZpbmcoKSB8fCB0aGlzLl9pc0Nsb3NlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zb2NrZXQubG9nKCdjaGFubmVsJywgYGVycm9yICR7dGhpcy50b3BpY31gLCByZWFzb24pO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmVycm9yZWQ7XG4gICAgICAgICAgICB0aGlzLnJlam9pblRpbWVyLnNjaGVkdWxlVGltZW91dCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5qb2luUHVzaC5yZWNlaXZlKCd0aW1lb3V0JywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0pvaW5pbmcoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc29ja2V0LmxvZygnY2hhbm5lbCcsIGB0aW1lb3V0ICR7dGhpcy50b3BpY31gLCB0aGlzLmpvaW5QdXNoLnRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmVycm9yZWQ7XG4gICAgICAgICAgICB0aGlzLnJlam9pblRpbWVyLnNjaGVkdWxlVGltZW91dCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fb24oQ0hBTk5FTF9FVkVOVFMucmVwbHksIHt9LCAocGF5bG9hZCwgcmVmKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyKHRoaXMuX3JlcGx5RXZlbnROYW1lKHJlZiksIHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wcmVzZW5jZSA9IG5ldyBSZWFsdGltZVByZXNlbmNlKHRoaXMpO1xuICAgICAgICB0aGlzLmJyb2FkY2FzdEVuZHBvaW50VVJMID1cbiAgICAgICAgICAgIGh0dHBFbmRwb2ludFVSTCh0aGlzLnNvY2tldC5lbmRQb2ludCkgKyAnL2FwaS9icm9hZGNhc3QnO1xuICAgIH1cbiAgICAvKiogU3Vic2NyaWJlIHJlZ2lzdGVycyB5b3VyIGNsaWVudCB3aXRoIHRoZSBzZXJ2ZXIgKi9cbiAgICBzdWJzY3JpYmUoY2FsbGJhY2ssIHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKCF0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuam9pbmVkT25jZSkge1xuICAgICAgICAgICAgdGhyb3cgYHRyaWVkIHRvIHN1YnNjcmliZSBtdWx0aXBsZSB0aW1lcy4gJ3N1YnNjcmliZScgY2FuIG9ubHkgYmUgY2FsbGVkIGEgc2luZ2xlIHRpbWUgcGVyIGNoYW5uZWwgaW5zdGFuY2VgO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgeyBjb25maWc6IHsgYnJvYWRjYXN0LCBwcmVzZW5jZSwgcHJpdmF0ZTogaXNQcml2YXRlIH0sIH0gPSB0aGlzLnBhcmFtcztcbiAgICAgICAgICAgIHRoaXMuX29uRXJyb3IoKGUpID0+IGNhbGxiYWNrICYmIGNhbGxiYWNrKCdDSEFOTkVMX0VSUk9SJywgZSkpO1xuICAgICAgICAgICAgdGhpcy5fb25DbG9zZSgoKSA9PiBjYWxsYmFjayAmJiBjYWxsYmFjaygnQ0xPU0VEJykpO1xuICAgICAgICAgICAgY29uc3QgYWNjZXNzVG9rZW5QYXlsb2FkID0ge307XG4gICAgICAgICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgICAgICAgICAgYnJvYWRjYXN0LFxuICAgICAgICAgICAgICAgIHByZXNlbmNlLFxuICAgICAgICAgICAgICAgIHBvc3RncmVzX2NoYW5nZXM6IChfYiA9IChfYSA9IHRoaXMuYmluZGluZ3MucG9zdGdyZXNfY2hhbmdlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgocikgPT4gci5maWx0ZXIpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSxcbiAgICAgICAgICAgICAgICBwcml2YXRlOiBpc1ByaXZhdGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuc29ja2V0LmFjY2Vzc1Rva2VuKSB7XG4gICAgICAgICAgICAgICAgYWNjZXNzVG9rZW5QYXlsb2FkLmFjY2Vzc190b2tlbiA9IHRoaXMuc29ja2V0LmFjY2Vzc1Rva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGVKb2luUGF5bG9hZChPYmplY3QuYXNzaWduKHsgY29uZmlnIH0sIGFjY2Vzc1Rva2VuUGF5bG9hZCkpO1xuICAgICAgICAgICAgdGhpcy5qb2luZWRPbmNlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3Jlam9pbih0aW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMuam9pblB1c2hcbiAgICAgICAgICAgICAgICAucmVjZWl2ZSgnb2snLCAoeyBwb3N0Z3Jlc19jaGFuZ2VzOiBzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlcnMsIH0pID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQuYWNjZXNzVG9rZW4gJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQuc2V0QXV0aCh0aGlzLnNvY2tldC5hY2Nlc3NUb2tlbik7XG4gICAgICAgICAgICAgICAgaWYgKHNlcnZlclBvc3RncmVzRmlsdGVycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCdTVUJTQ1JJQkVEJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudFBvc3RncmVzQmluZGluZ3MgPSB0aGlzLmJpbmRpbmdzLnBvc3RncmVzX2NoYW5nZXM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJpbmRpbmdzTGVuID0gKF9hID0gY2xpZW50UG9zdGdyZXNCaW5kaW5ncyA9PT0gbnVsbCB8fCBjbGllbnRQb3N0Z3Jlc0JpbmRpbmdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjbGllbnRQb3N0Z3Jlc0JpbmRpbmdzLmxlbmd0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3UG9zdGdyZXNCaW5kaW5ncyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmRpbmdzTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudFBvc3RncmVzQmluZGluZyA9IGNsaWVudFBvc3RncmVzQmluZGluZ3NbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGZpbHRlcjogeyBldmVudCwgc2NoZW1hLCB0YWJsZSwgZmlsdGVyIH0sIH0gPSBjbGllbnRQb3N0Z3Jlc0JpbmRpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlciA9IHNlcnZlclBvc3RncmVzRmlsdGVycyAmJiBzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlcnNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VydmVyUG9zdGdyZXNGaWx0ZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlci5ldmVudCA9PT0gZXZlbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlci5zY2hlbWEgPT09IHNjaGVtYSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlclBvc3RncmVzRmlsdGVyLnRhYmxlID09PSB0YWJsZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlclBvc3RncmVzRmlsdGVyLmZpbHRlciA9PT0gZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3UG9zdGdyZXNCaW5kaW5ncy5wdXNoKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY2xpZW50UG9zdGdyZXNCaW5kaW5nKSwgeyBpZDogc2VydmVyUG9zdGdyZXNGaWx0ZXIuaWQgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCdDSEFOTkVMX0VSUk9SJywgbmV3IEVycm9yKCdtaXNtYXRjaCBiZXR3ZWVuIHNlcnZlciBhbmQgY2xpZW50IGJpbmRpbmdzIGZvciBwb3N0Z3JlcyBjaGFuZ2VzJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJpbmRpbmdzLnBvc3RncmVzX2NoYW5nZXMgPSBuZXdQb3N0Z3Jlc0JpbmRpbmdzO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygnU1VCU0NSSUJFRCcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmVjZWl2ZSgnZXJyb3InLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayAmJlxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygnQ0hBTk5FTF9FUlJPUicsIG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeShPYmplY3QudmFsdWVzKGVycm9yKS5qb2luKCcsICcpIHx8ICdlcnJvcicpKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmVjZWl2ZSgndGltZW91dCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygnVElNRURfT1VUJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHByZXNlbmNlU3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXNlbmNlLnN0YXRlO1xuICAgIH1cbiAgICBhc3luYyB0cmFjayhwYXlsb2FkLCBvcHRzID0ge30pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VuZCh7XG4gICAgICAgICAgICB0eXBlOiAncHJlc2VuY2UnLFxuICAgICAgICAgICAgZXZlbnQ6ICd0cmFjaycsXG4gICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICB9LCBvcHRzLnRpbWVvdXQgfHwgdGhpcy50aW1lb3V0KTtcbiAgICB9XG4gICAgYXN5bmMgdW50cmFjayhvcHRzID0ge30pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VuZCh7XG4gICAgICAgICAgICB0eXBlOiAncHJlc2VuY2UnLFxuICAgICAgICAgICAgZXZlbnQ6ICd1bnRyYWNrJyxcbiAgICAgICAgfSwgb3B0cyk7XG4gICAgfVxuICAgIG9uKHR5cGUsIGZpbHRlciwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uKHR5cGUsIGZpbHRlciwgY2FsbGJhY2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIG1lc3NhZ2UgaW50byB0aGUgY2hhbm5lbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIEFyZ3VtZW50cyB0byBzZW5kIHRvIGNoYW5uZWxcbiAgICAgKiBAcGFyYW0gYXJncy50eXBlIFRoZSB0eXBlIG9mIGV2ZW50IHRvIHNlbmRcbiAgICAgKiBAcGFyYW0gYXJncy5ldmVudCBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgYmVpbmcgc2VudFxuICAgICAqIEBwYXJhbSBhcmdzLnBheWxvYWQgUGF5bG9hZCB0byBiZSBzZW50XG4gICAgICogQHBhcmFtIG9wdHMgT3B0aW9ucyB0byBiZSB1c2VkIGR1cmluZyB0aGUgc2VuZCBwcm9jZXNzXG4gICAgICovXG4gICAgYXN5bmMgc2VuZChhcmdzLCBvcHRzID0ge30pIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKCF0aGlzLl9jYW5QdXNoKCkgJiYgYXJncy50eXBlID09PSAnYnJvYWRjYXN0Jykge1xuICAgICAgICAgICAgY29uc3QgeyBldmVudCwgcGF5bG9hZDogZW5kcG9pbnRfcGF5bG9hZCB9ID0gYXJncztcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiB0aGlzLnNvY2tldC5hY2Nlc3NUb2tlblxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgQmVhcmVyICR7dGhpcy5zb2NrZXQuYWNjZXNzVG9rZW59YFxuICAgICAgICAgICAgICAgICAgICAgICAgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgYXBpa2V5OiB0aGlzLnNvY2tldC5hcGlLZXkgPyB0aGlzLnNvY2tldC5hcGlLZXkgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgdG9waWM6IHRoaXMuc3ViVG9waWMsIGV2ZW50LCBwYXlsb2FkOiBlbmRwb2ludF9wYXlsb2FkIH0sXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2ZldGNoV2l0aFRpbWVvdXQodGhpcy5icm9hZGNhc3RFbmRwb2ludFVSTCwgb3B0aW9ucywgKF9hID0gb3B0cy50aW1lb3V0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGF3YWl0ICgoX2IgPSByZXNwb25zZS5ib2R5KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FuY2VsKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5vayA/ICdvaycgOiAnZXJyb3InO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RpbWVkIG91dCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2Vycm9yJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgICAgICBjb25zdCBwdXNoID0gdGhpcy5fcHVzaChhcmdzLnR5cGUsIGFyZ3MsIG9wdHMudGltZW91dCB8fCB0aGlzLnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGlmIChhcmdzLnR5cGUgPT09ICdicm9hZGNhc3QnICYmICEoKF9jID0gKF9iID0gKF9hID0gdGhpcy5wYXJhbXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5icm9hZGNhc3QpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5hY2spKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoJ29rJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHB1c2gucmVjZWl2ZSgnb2snLCAoKSA9PiByZXNvbHZlKCdvaycpKTtcbiAgICAgICAgICAgICAgICBwdXNoLnJlY2VpdmUoJ2Vycm9yJywgKCkgPT4gcmVzb2x2ZSgnZXJyb3InKSk7XG4gICAgICAgICAgICAgICAgcHVzaC5yZWNlaXZlKCd0aW1lb3V0JywgKCkgPT4gcmVzb2x2ZSgndGltZWQgb3V0JykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlSm9pblBheWxvYWQocGF5bG9hZCkge1xuICAgICAgICB0aGlzLmpvaW5QdXNoLnVwZGF0ZVBheWxvYWQocGF5bG9hZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExlYXZlcyB0aGUgY2hhbm5lbC5cbiAgICAgKlxuICAgICAqIFVuc3Vic2NyaWJlcyBmcm9tIHNlcnZlciBldmVudHMsIGFuZCBpbnN0cnVjdHMgY2hhbm5lbCB0byB0ZXJtaW5hdGUgb24gc2VydmVyLlxuICAgICAqIFRyaWdnZXJzIG9uQ2xvc2UoKSBob29rcy5cbiAgICAgKlxuICAgICAqIFRvIHJlY2VpdmUgbGVhdmUgYWNrbm93bGVkZ2VtZW50cywgdXNlIHRoZSBhIGByZWNlaXZlYCBob29rIHRvIGJpbmQgdG8gdGhlIHNlcnZlciBhY2ssIGllOlxuICAgICAqIGNoYW5uZWwudW5zdWJzY3JpYmUoKS5yZWNlaXZlKFwib2tcIiwgKCkgPT4gYWxlcnQoXCJsZWZ0IVwiKSApXG4gICAgICovXG4gICAgdW5zdWJzY3JpYmUodGltZW91dCA9IHRoaXMudGltZW91dCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMubGVhdmluZztcbiAgICAgICAgY29uc3Qgb25DbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LmxvZygnY2hhbm5lbCcsIGBsZWF2ZSAke3RoaXMudG9waWN9YCk7XG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyKENIQU5ORUxfRVZFTlRTLmNsb3NlLCAnbGVhdmUnLCB0aGlzLl9qb2luUmVmKCkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlam9pblRpbWVyLnJlc2V0KCk7XG4gICAgICAgIC8vIERlc3Ryb3kgam9pblB1c2ggdG8gYXZvaWQgY29ubmVjdGlvbiB0aW1lb3V0cyBkdXJpbmcgdW5zY3JpcHRpb24gcGhhc2VcbiAgICAgICAgdGhpcy5qb2luUHVzaC5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGVhdmVQdXNoID0gbmV3IFB1c2godGhpcywgQ0hBTk5FTF9FVkVOVFMubGVhdmUsIHt9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgIGxlYXZlUHVzaFxuICAgICAgICAgICAgICAgIC5yZWNlaXZlKCdvaycsICgpID0+IHtcbiAgICAgICAgICAgICAgICBvbkNsb3NlKCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgnb2snKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnJlY2VpdmUoJ3RpbWVvdXQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgb25DbG9zZSgpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoJ3RpbWVkIG91dCcpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmVjZWl2ZSgnZXJyb3InLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgnZXJyb3InKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGVhdmVQdXNoLnNlbmQoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fY2FuUHVzaCgpKSB7XG4gICAgICAgICAgICAgICAgbGVhdmVQdXNoLnRyaWdnZXIoJ29rJywge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGFzeW5jIF9mZXRjaFdpdGhUaW1lb3V0KHVybCwgb3B0aW9ucywgdGltZW91dCkge1xuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBjb25zdCBpZCA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCB0aW1lb3V0KTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnNvY2tldC5mZXRjaCh1cmwsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCB9KSk7XG4gICAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9wdXNoKGV2ZW50LCBwYXlsb2FkLCB0aW1lb3V0ID0gdGhpcy50aW1lb3V0KSB7XG4gICAgICAgIGlmICghdGhpcy5qb2luZWRPbmNlKSB7XG4gICAgICAgICAgICB0aHJvdyBgdHJpZWQgdG8gcHVzaCAnJHtldmVudH0nIHRvICcke3RoaXMudG9waWN9JyBiZWZvcmUgam9pbmluZy4gVXNlIGNoYW5uZWwuc3Vic2NyaWJlKCkgYmVmb3JlIHB1c2hpbmcgZXZlbnRzYDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHVzaEV2ZW50ID0gbmV3IFB1c2godGhpcywgZXZlbnQsIHBheWxvYWQsIHRpbWVvdXQpO1xuICAgICAgICBpZiAodGhpcy5fY2FuUHVzaCgpKSB7XG4gICAgICAgICAgICBwdXNoRXZlbnQuc2VuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHVzaEV2ZW50LnN0YXJ0VGltZW91dCgpO1xuICAgICAgICAgICAgdGhpcy5wdXNoQnVmZmVyLnB1c2gocHVzaEV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHVzaEV2ZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkYWJsZSBtZXNzYWdlIGhvb2tcbiAgICAgKlxuICAgICAqIFJlY2VpdmVzIGFsbCBldmVudHMgZm9yIHNwZWNpYWxpemVkIG1lc3NhZ2UgaGFuZGxpbmcgYmVmb3JlIGRpc3BhdGNoaW5nIHRvIHRoZSBjaGFubmVsIGNhbGxiYWNrcy5cbiAgICAgKiBNdXN0IHJldHVybiB0aGUgcGF5bG9hZCwgbW9kaWZpZWQgb3IgdW5tb2RpZmllZC5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9vbk1lc3NhZ2UoX2V2ZW50LCBwYXlsb2FkLCBfcmVmKSB7XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2lzTWVtYmVyKHRvcGljKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvcGljID09PSB0b3BpYztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9qb2luUmVmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5qb2luUHVzaC5yZWY7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfdHJpZ2dlcih0eXBlLCBwYXlsb2FkLCByZWYpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgdHlwZUxvd2VyID0gdHlwZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCB7IGNsb3NlLCBlcnJvciwgbGVhdmUsIGpvaW4gfSA9IENIQU5ORUxfRVZFTlRTO1xuICAgICAgICBjb25zdCBldmVudHMgPSBbY2xvc2UsIGVycm9yLCBsZWF2ZSwgam9pbl07XG4gICAgICAgIGlmIChyZWYgJiYgZXZlbnRzLmluZGV4T2YodHlwZUxvd2VyKSA+PSAwICYmIHJlZiAhPT0gdGhpcy5fam9pblJlZigpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGhhbmRsZWRQYXlsb2FkID0gdGhpcy5fb25NZXNzYWdlKHR5cGVMb3dlciwgcGF5bG9hZCwgcmVmKTtcbiAgICAgICAgaWYgKHBheWxvYWQgJiYgIWhhbmRsZWRQYXlsb2FkKSB7XG4gICAgICAgICAgICB0aHJvdyAnY2hhbm5lbCBvbk1lc3NhZ2UgY2FsbGJhY2tzIG11c3QgcmV0dXJuIHRoZSBwYXlsb2FkLCBtb2RpZmllZCBvciB1bm1vZGlmaWVkJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoWydpbnNlcnQnLCAndXBkYXRlJywgJ2RlbGV0ZSddLmluY2x1ZGVzKHR5cGVMb3dlcikpIHtcbiAgICAgICAgICAgIChfYSA9IHRoaXMuYmluZGluZ3MucG9zdGdyZXNfY2hhbmdlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbHRlcigoYmluZCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKChfYSA9IGJpbmQuZmlsdGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZXZlbnQpID09PSAnKicgfHxcbiAgICAgICAgICAgICAgICAgICAgKChfYyA9IChfYiA9IGJpbmQuZmlsdGVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZXZlbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy50b0xvY2FsZUxvd2VyQ2FzZSgpKSA9PT0gdHlwZUxvd2VyKTtcbiAgICAgICAgICAgIH0pLm1hcCgoYmluZCkgPT4gYmluZC5jYWxsYmFjayhoYW5kbGVkUGF5bG9hZCwgcmVmKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAoX2IgPSB0aGlzLmJpbmRpbmdzW3R5cGVMb3dlcl0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5maWx0ZXIoKGJpbmQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgICAgICAgICBpZiAoWydicm9hZGNhc3QnLCAncHJlc2VuY2UnLCAncG9zdGdyZXNfY2hhbmdlcyddLmluY2x1ZGVzKHR5cGVMb3dlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCdpZCcgaW4gYmluZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmluZElkID0gYmluZC5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJpbmRFdmVudCA9IChfYSA9IGJpbmQuZmlsdGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZXZlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGJpbmRJZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoX2IgPSBwYXlsb2FkLmlkcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmluY2x1ZGVzKGJpbmRJZCkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJpbmRFdmVudCA9PT0gJyonIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChiaW5kRXZlbnQgPT09IG51bGwgfHwgYmluZEV2ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBiaW5kRXZlbnQudG9Mb2NhbGVMb3dlckNhc2UoKSkgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKF9jID0gcGF5bG9hZC5kYXRhKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudHlwZS50b0xvY2FsZUxvd2VyQ2FzZSgpKSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmluZEV2ZW50ID0gKF9lID0gKF9kID0gYmluZCA9PT0gbnVsbCB8fCBiaW5kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBiaW5kLmZpbHRlcikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmV2ZW50KSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoYmluZEV2ZW50ID09PSAnKicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5kRXZlbnQgPT09ICgoX2YgPSBwYXlsb2FkID09PSBudWxsIHx8IHBheWxvYWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBheWxvYWQuZXZlbnQpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi50b0xvY2FsZUxvd2VyQ2FzZSgpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiaW5kLnR5cGUudG9Mb2NhbGVMb3dlckNhc2UoKSA9PT0gdHlwZUxvd2VyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLm1hcCgoYmluZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaGFuZGxlZFBheWxvYWQgPT09ICdvYmplY3QnICYmICdpZHMnIGluIGhhbmRsZWRQYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvc3RncmVzQ2hhbmdlcyA9IGhhbmRsZWRQYXlsb2FkLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc2NoZW1hLCB0YWJsZSwgY29tbWl0X3RpbWVzdGFtcCwgdHlwZSwgZXJyb3JzIH0gPSBwb3N0Z3Jlc0NoYW5nZXM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVucmljaGVkUGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYTogc2NoZW1hLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGU6IHRhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWl0X3RpbWVzdGFtcDogY29tbWl0X3RpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50VHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldzoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbGQ6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiBlcnJvcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZWRQYXlsb2FkID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBlbnJpY2hlZFBheWxvYWQpLCB0aGlzLl9nZXRQYXlsb2FkUmVjb3Jkcyhwb3N0Z3Jlc0NoYW5nZXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmluZC5jYWxsYmFjayhoYW5kbGVkUGF5bG9hZCwgcmVmKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfaXNDbG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5jbG9zZWQ7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfaXNKb2luZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5qb2luZWQ7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfaXNKb2luaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gQ0hBTk5FTF9TVEFURVMuam9pbmluZztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9pc0xlYXZpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5sZWF2aW5nO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3JlcGx5RXZlbnROYW1lKHJlZikge1xuICAgICAgICByZXR1cm4gYGNoYW5fcmVwbHlfJHtyZWZ9YDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9vbih0eXBlLCBmaWx0ZXIsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHR5cGVMb3dlciA9IHR5cGUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgYmluZGluZyA9IHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGVMb3dlcixcbiAgICAgICAgICAgIGZpbHRlcjogZmlsdGVyLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5iaW5kaW5nc1t0eXBlTG93ZXJdKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmRpbmdzW3R5cGVMb3dlcl0ucHVzaChiaW5kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYmluZGluZ3NbdHlwZUxvd2VyXSA9IFtiaW5kaW5nXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9vZmYodHlwZSwgZmlsdGVyKSB7XG4gICAgICAgIGNvbnN0IHR5cGVMb3dlciA9IHR5cGUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgdGhpcy5iaW5kaW5nc1t0eXBlTG93ZXJdID0gdGhpcy5iaW5kaW5nc1t0eXBlTG93ZXJdLmZpbHRlcigoYmluZCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgcmV0dXJuICEoKChfYSA9IGJpbmQudHlwZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvTG9jYWxlTG93ZXJDYXNlKCkpID09PSB0eXBlTG93ZXIgJiZcbiAgICAgICAgICAgICAgICBSZWFsdGltZUNoYW5uZWwuaXNFcXVhbChiaW5kLmZpbHRlciwgZmlsdGVyKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHN0YXRpYyBpc0VxdWFsKG9iajEsIG9iajIpIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKG9iajEpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMob2JqMikubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrIGluIG9iajEpIHtcbiAgICAgICAgICAgIGlmIChvYmoxW2tdICE9PSBvYmoyW2tdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3Jlam9pblVudGlsQ29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLnJlam9pblRpbWVyLnNjaGVkdWxlVGltZW91dCgpO1xuICAgICAgICBpZiAodGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fcmVqb2luKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNoYW5uZWwgY2xvc2VzLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX29uQ2xvc2UoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fb24oQ0hBTk5FTF9FVkVOVFMuY2xvc2UsIHt9LCBjYWxsYmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHRoZSBjaGFubmVsIGVuY291bnRlcmVzIGFuIGVycm9yLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX29uRXJyb3IoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fb24oQ0hBTk5FTF9FVkVOVFMuZXJyb3IsIHt9LCAocmVhc29uKSA9PiBjYWxsYmFjayhyZWFzb24pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNvY2tldCBpcyBjb25uZWN0ZWQgYW5kIHRoZSBjaGFubmVsIGhhcyBiZWVuIGpvaW5lZC5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9jYW5QdXNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSAmJiB0aGlzLl9pc0pvaW5lZCgpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3Jlam9pbih0aW1lb3V0ID0gdGhpcy50aW1lb3V0KSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0xlYXZpbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc29ja2V0Ll9sZWF2ZU9wZW5Ub3BpYyh0aGlzLnRvcGljKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmpvaW5pbmc7XG4gICAgICAgIHRoaXMuam9pblB1c2gucmVzZW5kKHRpbWVvdXQpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2dldFBheWxvYWRSZWNvcmRzKHBheWxvYWQpIHtcbiAgICAgICAgY29uc3QgcmVjb3JkcyA9IHtcbiAgICAgICAgICAgIG5ldzoge30sXG4gICAgICAgICAgICBvbGQ6IHt9LFxuICAgICAgICB9O1xuICAgICAgICBpZiAocGF5bG9hZC50eXBlID09PSAnSU5TRVJUJyB8fCBwYXlsb2FkLnR5cGUgPT09ICdVUERBVEUnKSB7XG4gICAgICAgICAgICByZWNvcmRzLm5ldyA9IFRyYW5zZm9ybWVycy5jb252ZXJ0Q2hhbmdlRGF0YShwYXlsb2FkLmNvbHVtbnMsIHBheWxvYWQucmVjb3JkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF5bG9hZC50eXBlID09PSAnVVBEQVRFJyB8fCBwYXlsb2FkLnR5cGUgPT09ICdERUxFVEUnKSB7XG4gICAgICAgICAgICByZWNvcmRzLm9sZCA9IFRyYW5zZm9ybWVycy5jb252ZXJ0Q2hhbmdlRGF0YShwYXlsb2FkLmNvbHVtbnMsIHBheWxvYWQub2xkX3JlY29yZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY29yZHM7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVhbHRpbWVDaGFubmVsLmpzLm1hcCIsImltcG9ydCB7IENIQU5ORUxfRVZFTlRTLCBDSEFOTkVMX1NUQVRFUyB9IGZyb20gJy4vbGliL2NvbnN0YW50cydcbmltcG9ydCBQdXNoIGZyb20gJy4vbGliL3B1c2gnXG5pbXBvcnQgdHlwZSBSZWFsdGltZUNsaWVudCBmcm9tICcuL1JlYWx0aW1lQ2xpZW50J1xuaW1wb3J0IFRpbWVyIGZyb20gJy4vbGliL3RpbWVyJ1xuaW1wb3J0IFJlYWx0aW1lUHJlc2VuY2UsIHtcbiAgUkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UUyxcbn0gZnJvbSAnLi9SZWFsdGltZVByZXNlbmNlJ1xuaW1wb3J0IHR5cGUge1xuICBSZWFsdGltZVByZXNlbmNlSm9pblBheWxvYWQsXG4gIFJlYWx0aW1lUHJlc2VuY2VMZWF2ZVBheWxvYWQsXG4gIFJlYWx0aW1lUHJlc2VuY2VTdGF0ZSxcbn0gZnJvbSAnLi9SZWFsdGltZVByZXNlbmNlJ1xuaW1wb3J0ICogYXMgVHJhbnNmb3JtZXJzIGZyb20gJy4vbGliL3RyYW5zZm9ybWVycydcbmltcG9ydCB7IGh0dHBFbmRwb2ludFVSTCB9IGZyb20gJy4vbGliL3RyYW5zZm9ybWVycydcblxuZXhwb3J0IHR5cGUgUmVhbHRpbWVDaGFubmVsT3B0aW9ucyA9IHtcbiAgY29uZmlnOiB7XG4gICAgLyoqXG4gICAgICogc2VsZiBvcHRpb24gZW5hYmxlcyBjbGllbnQgdG8gcmVjZWl2ZSBtZXNzYWdlIGl0IGJyb2FkY2FzdFxuICAgICAqIGFjayBvcHRpb24gaW5zdHJ1Y3RzIHNlcnZlciB0byBhY2tub3dsZWRnZSB0aGF0IGJyb2FkY2FzdCBtZXNzYWdlIHdhcyByZWNlaXZlZFxuICAgICAqL1xuICAgIGJyb2FkY2FzdD86IHsgc2VsZj86IGJvb2xlYW47IGFjaz86IGJvb2xlYW4gfVxuICAgIC8qKlxuICAgICAqIGtleSBvcHRpb24gaXMgdXNlZCB0byB0cmFjayBwcmVzZW5jZSBwYXlsb2FkIGFjcm9zcyBjbGllbnRzXG4gICAgICovXG4gICAgcHJlc2VuY2U/OiB7IGtleT86IHN0cmluZyB9XG4gICAgLyoqXG4gICAgICogZGVmaW5lcyBpZiB0aGUgY2hhbm5lbCBpcyBwcml2YXRlIG9yIG5vdCBhbmQgaWYgUkxTIHBvbGljaWVzIHdpbGwgYmUgdXNlZCB0byBjaGVjayBkYXRhXG4gICAgICovXG4gICAgcHJpdmF0ZT86IGJvb2xlYW5cbiAgfVxufVxuXG50eXBlIFJlYWx0aW1lUG9zdGdyZXNDaGFuZ2VzUGF5bG9hZEJhc2UgPSB7XG4gIHNjaGVtYTogc3RyaW5nXG4gIHRhYmxlOiBzdHJpbmdcbiAgY29tbWl0X3RpbWVzdGFtcDogc3RyaW5nXG4gIGVycm9yczogc3RyaW5nW11cbn1cblxuZXhwb3J0IHR5cGUgUmVhbHRpbWVQb3N0Z3Jlc0luc2VydFBheWxvYWQ8VCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogYW55IH0+ID1cbiAgUmVhbHRpbWVQb3N0Z3Jlc0NoYW5nZXNQYXlsb2FkQmFzZSAmIHtcbiAgICBldmVudFR5cGU6IGAke1JFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5ULklOU0VSVH1gXG4gICAgbmV3OiBUXG4gICAgb2xkOiB7fVxuICB9XG5cbmV4cG9ydCB0eXBlIFJlYWx0aW1lUG9zdGdyZXNVcGRhdGVQYXlsb2FkPFQgZXh0ZW5kcyB7IFtrZXk6IHN0cmluZ106IGFueSB9PiA9XG4gIFJlYWx0aW1lUG9zdGdyZXNDaGFuZ2VzUGF5bG9hZEJhc2UgJiB7XG4gICAgZXZlbnRUeXBlOiBgJHtSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVC5VUERBVEV9YFxuICAgIG5ldzogVFxuICAgIG9sZDogUGFydGlhbDxUPlxuICB9XG5cbmV4cG9ydCB0eXBlIFJlYWx0aW1lUG9zdGdyZXNEZWxldGVQYXlsb2FkPFQgZXh0ZW5kcyB7IFtrZXk6IHN0cmluZ106IGFueSB9PiA9XG4gIFJlYWx0aW1lUG9zdGdyZXNDaGFuZ2VzUGF5bG9hZEJhc2UgJiB7XG4gICAgZXZlbnRUeXBlOiBgJHtSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVC5ERUxFVEV9YFxuICAgIG5ldzoge31cbiAgICBvbGQ6IFBhcnRpYWw8VD5cbiAgfVxuXG5leHBvcnQgdHlwZSBSZWFsdGltZVBvc3RncmVzQ2hhbmdlc1BheWxvYWQ8VCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogYW55IH0+ID1cbiAgfCBSZWFsdGltZVBvc3RncmVzSW5zZXJ0UGF5bG9hZDxUPlxuICB8IFJlYWx0aW1lUG9zdGdyZXNVcGRhdGVQYXlsb2FkPFQ+XG4gIHwgUmVhbHRpbWVQb3N0Z3Jlc0RlbGV0ZVBheWxvYWQ8VD5cblxuZXhwb3J0IHR5cGUgUmVhbHRpbWVQb3N0Z3Jlc0NoYW5nZXNGaWx0ZXI8XG4gIFQgZXh0ZW5kcyBgJHtSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVH1gXG4+ID0ge1xuICAvKipcbiAgICogVGhlIHR5cGUgb2YgZGF0YWJhc2UgY2hhbmdlIHRvIGxpc3RlbiB0by5cbiAgICovXG4gIGV2ZW50OiBUXG4gIC8qKlxuICAgKiBUaGUgZGF0YWJhc2Ugc2NoZW1hIHRvIGxpc3RlbiB0by5cbiAgICovXG4gIHNjaGVtYTogc3RyaW5nXG4gIC8qKlxuICAgKiBUaGUgZGF0YWJhc2UgdGFibGUgdG8gbGlzdGVuIHRvLlxuICAgKi9cbiAgdGFibGU/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFJlY2VpdmUgZGF0YWJhc2UgY2hhbmdlcyB3aGVuIGZpbHRlciBpcyBtYXRjaGVkLlxuICAgKi9cbiAgZmlsdGVyPzogc3RyaW5nXG59XG5cbmV4cG9ydCB0eXBlIFJlYWx0aW1lQ2hhbm5lbFNlbmRSZXNwb25zZSA9ICdvaycgfCAndGltZWQgb3V0JyB8ICdlcnJvcidcblxuZXhwb3J0IGVudW0gUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQge1xuICBBTEwgPSAnKicsXG4gIElOU0VSVCA9ICdJTlNFUlQnLFxuICBVUERBVEUgPSAnVVBEQVRFJyxcbiAgREVMRVRFID0gJ0RFTEVURScsXG59XG5cbmV4cG9ydCBlbnVtIFJFQUxUSU1FX0xJU1RFTl9UWVBFUyB7XG4gIEJST0FEQ0FTVCA9ICdicm9hZGNhc3QnLFxuICBQUkVTRU5DRSA9ICdwcmVzZW5jZScsXG4gIC8qKlxuICAgKiBsaXN0ZW4gdG8gUG9zdGdyZXMgY2hhbmdlcy5cbiAgICovXG4gIFBPU1RHUkVTX0NIQU5HRVMgPSAncG9zdGdyZXNfY2hhbmdlcycsXG59XG5cbmV4cG9ydCBlbnVtIFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMge1xuICBTVUJTQ1JJQkVEID0gJ1NVQlNDUklCRUQnLFxuICBUSU1FRF9PVVQgPSAnVElNRURfT1VUJyxcbiAgQ0xPU0VEID0gJ0NMT1NFRCcsXG4gIENIQU5ORUxfRVJST1IgPSAnQ0hBTk5FTF9FUlJPUicsXG59XG5cbmV4cG9ydCBjb25zdCBSRUFMVElNRV9DSEFOTkVMX1NUQVRFUyA9IENIQU5ORUxfU1RBVEVTXG5cbi8qKiBBIGNoYW5uZWwgaXMgdGhlIGJhc2ljIGJ1aWxkaW5nIGJsb2NrIG9mIFJlYWx0aW1lXG4gKiBhbmQgbmFycm93cyB0aGUgc2NvcGUgb2YgZGF0YSBmbG93IHRvIHN1YnNjcmliZWQgY2xpZW50cy5cbiAqIFlvdSBjYW4gdGhpbmsgb2YgYSBjaGFubmVsIGFzIGEgY2hhdHJvb20gd2hlcmUgcGFydGljaXBhbnRzIGFyZSBhYmxlIHRvIHNlZSB3aG8ncyBvbmxpbmVcbiAqIGFuZCBzZW5kIGFuZCByZWNlaXZlIG1lc3NhZ2VzLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWFsdGltZUNoYW5uZWwge1xuICBiaW5kaW5nczoge1xuICAgIFtrZXk6IHN0cmluZ106IHtcbiAgICAgIHR5cGU6IHN0cmluZ1xuICAgICAgZmlsdGVyOiB7IFtrZXk6IHN0cmluZ106IGFueSB9XG4gICAgICBjYWxsYmFjazogRnVuY3Rpb25cbiAgICAgIGlkPzogc3RyaW5nXG4gICAgfVtdXG4gIH0gPSB7fVxuICB0aW1lb3V0OiBudW1iZXJcbiAgc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5jbG9zZWRcbiAgam9pbmVkT25jZSA9IGZhbHNlXG4gIGpvaW5QdXNoOiBQdXNoXG4gIHJlam9pblRpbWVyOiBUaW1lclxuICBwdXNoQnVmZmVyOiBQdXNoW10gPSBbXVxuICBwcmVzZW5jZTogUmVhbHRpbWVQcmVzZW5jZVxuICBicm9hZGNhc3RFbmRwb2ludFVSTDogc3RyaW5nXG4gIHN1YlRvcGljOiBzdHJpbmdcblxuICBjb25zdHJ1Y3RvcihcbiAgICAvKiogVG9waWMgbmFtZSBjYW4gYmUgYW55IHN0cmluZy4gKi9cbiAgICBwdWJsaWMgdG9waWM6IHN0cmluZyxcbiAgICBwdWJsaWMgcGFyYW1zOiBSZWFsdGltZUNoYW5uZWxPcHRpb25zID0geyBjb25maWc6IHt9IH0sXG4gICAgcHVibGljIHNvY2tldDogUmVhbHRpbWVDbGllbnRcbiAgKSB7XG4gICAgdGhpcy5zdWJUb3BpYyA9IHRvcGljLnJlcGxhY2UoL15yZWFsdGltZTovaSwgJycpXG4gICAgdGhpcy5wYXJhbXMuY29uZmlnID0ge1xuICAgICAgLi4ue1xuICAgICAgICBicm9hZGNhc3Q6IHsgYWNrOiBmYWxzZSwgc2VsZjogZmFsc2UgfSxcbiAgICAgICAgcHJlc2VuY2U6IHsga2V5OiAnJyB9LFxuICAgICAgICBwcml2YXRlOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgICAuLi5wYXJhbXMuY29uZmlnLFxuICAgIH1cbiAgICB0aGlzLnRpbWVvdXQgPSB0aGlzLnNvY2tldC50aW1lb3V0XG4gICAgdGhpcy5qb2luUHVzaCA9IG5ldyBQdXNoKFxuICAgICAgdGhpcyxcbiAgICAgIENIQU5ORUxfRVZFTlRTLmpvaW4sXG4gICAgICB0aGlzLnBhcmFtcyxcbiAgICAgIHRoaXMudGltZW91dFxuICAgIClcbiAgICB0aGlzLnJlam9pblRpbWVyID0gbmV3IFRpbWVyKFxuICAgICAgKCkgPT4gdGhpcy5fcmVqb2luVW50aWxDb25uZWN0ZWQoKSxcbiAgICAgIHRoaXMuc29ja2V0LnJlY29ubmVjdEFmdGVyTXNcbiAgICApXG4gICAgdGhpcy5qb2luUHVzaC5yZWNlaXZlKCdvaycsICgpID0+IHtcbiAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5qb2luZWRcbiAgICAgIHRoaXMucmVqb2luVGltZXIucmVzZXQoKVxuICAgICAgdGhpcy5wdXNoQnVmZmVyLmZvckVhY2goKHB1c2hFdmVudDogUHVzaCkgPT4gcHVzaEV2ZW50LnNlbmQoKSlcbiAgICAgIHRoaXMucHVzaEJ1ZmZlciA9IFtdXG4gICAgfSlcbiAgICB0aGlzLl9vbkNsb3NlKCgpID0+IHtcbiAgICAgIHRoaXMucmVqb2luVGltZXIucmVzZXQoKVxuICAgICAgdGhpcy5zb2NrZXQubG9nKCdjaGFubmVsJywgYGNsb3NlICR7dGhpcy50b3BpY30gJHt0aGlzLl9qb2luUmVmKCl9YClcbiAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5jbG9zZWRcbiAgICAgIHRoaXMuc29ja2V0Ll9yZW1vdmUodGhpcylcbiAgICB9KVxuICAgIHRoaXMuX29uRXJyb3IoKHJlYXNvbjogc3RyaW5nKSA9PiB7XG4gICAgICBpZiAodGhpcy5faXNMZWF2aW5nKCkgfHwgdGhpcy5faXNDbG9zZWQoKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHRoaXMuc29ja2V0LmxvZygnY2hhbm5lbCcsIGBlcnJvciAke3RoaXMudG9waWN9YCwgcmVhc29uKVxuICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmVycm9yZWRcbiAgICAgIHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KClcbiAgICB9KVxuICAgIHRoaXMuam9pblB1c2gucmVjZWl2ZSgndGltZW91dCcsICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5faXNKb2luaW5nKCkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB0aGlzLnNvY2tldC5sb2coJ2NoYW5uZWwnLCBgdGltZW91dCAke3RoaXMudG9waWN9YCwgdGhpcy5qb2luUHVzaC50aW1lb3V0KVxuICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmVycm9yZWRcbiAgICAgIHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KClcbiAgICB9KVxuICAgIHRoaXMuX29uKENIQU5ORUxfRVZFTlRTLnJlcGx5LCB7fSwgKHBheWxvYWQ6IGFueSwgcmVmOiBzdHJpbmcpID0+IHtcbiAgICAgIHRoaXMuX3RyaWdnZXIodGhpcy5fcmVwbHlFdmVudE5hbWUocmVmKSwgcGF5bG9hZClcbiAgICB9KVxuXG4gICAgdGhpcy5wcmVzZW5jZSA9IG5ldyBSZWFsdGltZVByZXNlbmNlKHRoaXMpXG5cbiAgICB0aGlzLmJyb2FkY2FzdEVuZHBvaW50VVJMID1cbiAgICAgIGh0dHBFbmRwb2ludFVSTCh0aGlzLnNvY2tldC5lbmRQb2ludCkgKyAnL2FwaS9icm9hZGNhc3QnXG4gIH1cblxuICAvKiogU3Vic2NyaWJlIHJlZ2lzdGVycyB5b3VyIGNsaWVudCB3aXRoIHRoZSBzZXJ2ZXIgKi9cbiAgc3Vic2NyaWJlKFxuICAgIGNhbGxiYWNrPzogKHN0YXR1czogYCR7UkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFU31gLCBlcnI/OiBFcnJvcikgPT4gdm9pZCxcbiAgICB0aW1lb3V0ID0gdGhpcy50aW1lb3V0XG4gICk6IFJlYWx0aW1lQ2hhbm5lbCB7XG4gICAgaWYgKCF0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICB0aGlzLnNvY2tldC5jb25uZWN0KClcbiAgICB9XG5cbiAgICBpZiAodGhpcy5qb2luZWRPbmNlKSB7XG4gICAgICB0aHJvdyBgdHJpZWQgdG8gc3Vic2NyaWJlIG11bHRpcGxlIHRpbWVzLiAnc3Vic2NyaWJlJyBjYW4gb25seSBiZSBjYWxsZWQgYSBzaW5nbGUgdGltZSBwZXIgY2hhbm5lbCBpbnN0YW5jZWBcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb25maWc6IHsgYnJvYWRjYXN0LCBwcmVzZW5jZSwgcHJpdmF0ZTogaXNQcml2YXRlIH0sXG4gICAgICB9ID0gdGhpcy5wYXJhbXNcbiAgICAgIHRoaXMuX29uRXJyb3IoKGU6IEVycm9yKSA9PiBjYWxsYmFjayAmJiBjYWxsYmFjaygnQ0hBTk5FTF9FUlJPUicsIGUpKVxuICAgICAgdGhpcy5fb25DbG9zZSgoKSA9PiBjYWxsYmFjayAmJiBjYWxsYmFjaygnQ0xPU0VEJykpXG5cbiAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuUGF5bG9hZDogeyBhY2Nlc3NfdG9rZW4/OiBzdHJpbmcgfSA9IHt9XG4gICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgIGJyb2FkY2FzdCxcbiAgICAgICAgcHJlc2VuY2UsXG4gICAgICAgIHBvc3RncmVzX2NoYW5nZXM6XG4gICAgICAgICAgdGhpcy5iaW5kaW5ncy5wb3N0Z3Jlc19jaGFuZ2VzPy5tYXAoKHIpID0+IHIuZmlsdGVyKSA/PyBbXSxcbiAgICAgICAgcHJpdmF0ZTogaXNQcml2YXRlLFxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zb2NrZXQuYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgYWNjZXNzVG9rZW5QYXlsb2FkLmFjY2Vzc190b2tlbiA9IHRoaXMuc29ja2V0LmFjY2Vzc1Rva2VuXG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlSm9pblBheWxvYWQoeyAuLi57IGNvbmZpZyB9LCAuLi5hY2Nlc3NUb2tlblBheWxvYWQgfSlcblxuICAgICAgdGhpcy5qb2luZWRPbmNlID0gdHJ1ZVxuICAgICAgdGhpcy5fcmVqb2luKHRpbWVvdXQpXG5cbiAgICAgIHRoaXMuam9pblB1c2hcbiAgICAgICAgLnJlY2VpdmUoXG4gICAgICAgICAgJ29rJyxcbiAgICAgICAgICAoe1xuICAgICAgICAgICAgcG9zdGdyZXNfY2hhbmdlczogc2VydmVyUG9zdGdyZXNGaWx0ZXJzLFxuICAgICAgICAgIH06IHtcbiAgICAgICAgICAgIHBvc3RncmVzX2NoYW5nZXM6IHtcbiAgICAgICAgICAgICAgaWQ6IHN0cmluZ1xuICAgICAgICAgICAgICBldmVudDogc3RyaW5nXG4gICAgICAgICAgICAgIHNjaGVtYT86IHN0cmluZ1xuICAgICAgICAgICAgICB0YWJsZT86IHN0cmluZ1xuICAgICAgICAgICAgICBmaWx0ZXI/OiBzdHJpbmdcbiAgICAgICAgICAgIH1bXVxuICAgICAgICAgIH0pID0+IHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LmFjY2Vzc1Rva2VuICYmXG4gICAgICAgICAgICAgIHRoaXMuc29ja2V0LnNldEF1dGgodGhpcy5zb2NrZXQuYWNjZXNzVG9rZW4pXG5cbiAgICAgICAgICAgIGlmIChzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygnU1VCU0NSSUJFRCcpXG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3QgY2xpZW50UG9zdGdyZXNCaW5kaW5ncyA9IHRoaXMuYmluZGluZ3MucG9zdGdyZXNfY2hhbmdlc1xuICAgICAgICAgICAgICBjb25zdCBiaW5kaW5nc0xlbiA9IGNsaWVudFBvc3RncmVzQmluZGluZ3M/Lmxlbmd0aCA/PyAwXG4gICAgICAgICAgICAgIGNvbnN0IG5ld1Bvc3RncmVzQmluZGluZ3MgPSBbXVxuXG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluZGluZ3NMZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudFBvc3RncmVzQmluZGluZyA9IGNsaWVudFBvc3RncmVzQmluZGluZ3NbaV1cbiAgICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgICBmaWx0ZXI6IHsgZXZlbnQsIHNjaGVtYSwgdGFibGUsIGZpbHRlciB9LFxuICAgICAgICAgICAgICAgIH0gPSBjbGllbnRQb3N0Z3Jlc0JpbmRpbmdcbiAgICAgICAgICAgICAgICBjb25zdCBzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlciA9XG4gICAgICAgICAgICAgICAgICBzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlcnMgJiYgc2VydmVyUG9zdGdyZXNGaWx0ZXJzW2ldXG5cbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICBzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlciAmJlxuICAgICAgICAgICAgICAgICAgc2VydmVyUG9zdGdyZXNGaWx0ZXIuZXZlbnQgPT09IGV2ZW50ICYmXG4gICAgICAgICAgICAgICAgICBzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlci5zY2hlbWEgPT09IHNjaGVtYSAmJlxuICAgICAgICAgICAgICAgICAgc2VydmVyUG9zdGdyZXNGaWx0ZXIudGFibGUgPT09IHRhYmxlICYmXG4gICAgICAgICAgICAgICAgICBzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlci5maWx0ZXIgPT09IGZpbHRlclxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgbmV3UG9zdGdyZXNCaW5kaW5ncy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY2xpZW50UG9zdGdyZXNCaW5kaW5nLFxuICAgICAgICAgICAgICAgICAgICBpZDogc2VydmVyUG9zdGdyZXNGaWx0ZXIuaWQsXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKClcbiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKFxuICAgICAgICAgICAgICAgICAgICAgICdDSEFOTkVMX0VSUk9SJyxcbiAgICAgICAgICAgICAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWlzbWF0Y2ggYmV0d2VlbiBzZXJ2ZXIgYW5kIGNsaWVudCBiaW5kaW5ncyBmb3IgcG9zdGdyZXMgY2hhbmdlcydcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMuYmluZGluZ3MucG9zdGdyZXNfY2hhbmdlcyA9IG5ld1Bvc3RncmVzQmluZGluZ3NcblxuICAgICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygnU1VCU0NSSUJFRCcpXG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgICAucmVjZWl2ZSgnZXJyb3InLCAoZXJyb3I6IHsgW2tleTogc3RyaW5nXTogYW55IH0pID0+IHtcbiAgICAgICAgICBjYWxsYmFjayAmJlxuICAgICAgICAgICAgY2FsbGJhY2soXG4gICAgICAgICAgICAgICdDSEFOTkVMX0VSUk9SJyxcbiAgICAgICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KE9iamVjdC52YWx1ZXMoZXJyb3IpLmpvaW4oJywgJykgfHwgJ2Vycm9yJylcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9KVxuICAgICAgICAucmVjZWl2ZSgndGltZW91dCcsICgpID0+IHtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygnVElNRURfT1VUJylcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHJlc2VuY2VTdGF0ZTxcbiAgICBUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9XG4gID4oKTogUmVhbHRpbWVQcmVzZW5jZVN0YXRlPFQ+IHtcbiAgICByZXR1cm4gdGhpcy5wcmVzZW5jZS5zdGF0ZSBhcyBSZWFsdGltZVByZXNlbmNlU3RhdGU8VD5cbiAgfVxuXG4gIGFzeW5jIHRyYWNrKFxuICAgIHBheWxvYWQ6IHsgW2tleTogc3RyaW5nXTogYW55IH0sXG4gICAgb3B0czogeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9XG4gICk6IFByb21pc2U8UmVhbHRpbWVDaGFubmVsU2VuZFJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VuZChcbiAgICAgIHtcbiAgICAgICAgdHlwZTogJ3ByZXNlbmNlJyxcbiAgICAgICAgZXZlbnQ6ICd0cmFjaycsXG4gICAgICAgIHBheWxvYWQsXG4gICAgICB9LFxuICAgICAgb3B0cy50aW1lb3V0IHx8IHRoaXMudGltZW91dFxuICAgIClcbiAgfVxuXG4gIGFzeW5jIHVudHJhY2soXG4gICAgb3B0czogeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9XG4gICk6IFByb21pc2U8UmVhbHRpbWVDaGFubmVsU2VuZFJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VuZChcbiAgICAgIHtcbiAgICAgICAgdHlwZTogJ3ByZXNlbmNlJyxcbiAgICAgICAgZXZlbnQ6ICd1bnRyYWNrJyxcbiAgICAgIH0sXG4gICAgICBvcHRzXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gZXZlbnQgaGFuZGxlciB0aGF0IGxpc3RlbnMgdG8gY2hhbmdlcy5cbiAgICovXG4gIG9uKFxuICAgIHR5cGU6IGAke1JFQUxUSU1FX0xJU1RFTl9UWVBFUy5QUkVTRU5DRX1gLFxuICAgIGZpbHRlcjogeyBldmVudDogYCR7UkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UUy5TWU5DfWAgfSxcbiAgICBjYWxsYmFjazogKCkgPT4gdm9pZFxuICApOiBSZWFsdGltZUNoYW5uZWxcbiAgb248VCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogYW55IH0+KFxuICAgIHR5cGU6IGAke1JFQUxUSU1FX0xJU1RFTl9UWVBFUy5QUkVTRU5DRX1gLFxuICAgIGZpbHRlcjogeyBldmVudDogYCR7UkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UUy5KT0lOfWAgfSxcbiAgICBjYWxsYmFjazogKHBheWxvYWQ6IFJlYWx0aW1lUHJlc2VuY2VKb2luUGF5bG9hZDxUPikgPT4gdm9pZFxuICApOiBSZWFsdGltZUNoYW5uZWxcbiAgb248VCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogYW55IH0+KFxuICAgIHR5cGU6IGAke1JFQUxUSU1FX0xJU1RFTl9UWVBFUy5QUkVTRU5DRX1gLFxuICAgIGZpbHRlcjogeyBldmVudDogYCR7UkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UUy5MRUFWRX1gIH0sXG4gICAgY2FsbGJhY2s6IChwYXlsb2FkOiBSZWFsdGltZVByZXNlbmNlTGVhdmVQYXlsb2FkPFQ+KSA9PiB2b2lkXG4gICk6IFJlYWx0aW1lQ2hhbm5lbFxuICBvbjxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfT4oXG4gICAgdHlwZTogYCR7UkVBTFRJTUVfTElTVEVOX1RZUEVTLlBPU1RHUkVTX0NIQU5HRVN9YCxcbiAgICBmaWx0ZXI6IFJlYWx0aW1lUG9zdGdyZXNDaGFuZ2VzRmlsdGVyPGAke1JFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5ULkFMTH1gPixcbiAgICBjYWxsYmFjazogKHBheWxvYWQ6IFJlYWx0aW1lUG9zdGdyZXNDaGFuZ2VzUGF5bG9hZDxUPikgPT4gdm9pZFxuICApOiBSZWFsdGltZUNoYW5uZWxcbiAgb248VCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogYW55IH0+KFxuICAgIHR5cGU6IGAke1JFQUxUSU1FX0xJU1RFTl9UWVBFUy5QT1NUR1JFU19DSEFOR0VTfWAsXG4gICAgZmlsdGVyOiBSZWFsdGltZVBvc3RncmVzQ2hhbmdlc0ZpbHRlcjxgJHtSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVC5JTlNFUlR9YD4sXG4gICAgY2FsbGJhY2s6IChwYXlsb2FkOiBSZWFsdGltZVBvc3RncmVzSW5zZXJ0UGF5bG9hZDxUPikgPT4gdm9pZFxuICApOiBSZWFsdGltZUNoYW5uZWxcbiAgb248VCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogYW55IH0+KFxuICAgIHR5cGU6IGAke1JFQUxUSU1FX0xJU1RFTl9UWVBFUy5QT1NUR1JFU19DSEFOR0VTfWAsXG4gICAgZmlsdGVyOiBSZWFsdGltZVBvc3RncmVzQ2hhbmdlc0ZpbHRlcjxgJHtSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVC5VUERBVEV9YD4sXG4gICAgY2FsbGJhY2s6IChwYXlsb2FkOiBSZWFsdGltZVBvc3RncmVzVXBkYXRlUGF5bG9hZDxUPikgPT4gdm9pZFxuICApOiBSZWFsdGltZUNoYW5uZWxcbiAgb248VCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogYW55IH0+KFxuICAgIHR5cGU6IGAke1JFQUxUSU1FX0xJU1RFTl9UWVBFUy5QT1NUR1JFU19DSEFOR0VTfWAsXG4gICAgZmlsdGVyOiBSZWFsdGltZVBvc3RncmVzQ2hhbmdlc0ZpbHRlcjxgJHtSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVC5ERUxFVEV9YD4sXG4gICAgY2FsbGJhY2s6IChwYXlsb2FkOiBSZWFsdGltZVBvc3RncmVzRGVsZXRlUGF5bG9hZDxUPikgPT4gdm9pZFxuICApOiBSZWFsdGltZUNoYW5uZWxcbiAgLyoqXG4gICAqIFRoZSBmb2xsb3dpbmcgaXMgcGxhY2VkIGhlcmUgdG8gZGlzcGxheSBvbiBzdXBhYmFzZS5jb20vZG9jcy9yZWZlcmVuY2UvamF2YXNjcmlwdC9zdWJzY3JpYmUuXG4gICAqIEBwYXJhbSB0eXBlIE9uZSBvZiBcImJyb2FkY2FzdFwiLCBcInByZXNlbmNlXCIsIG9yIFwicG9zdGdyZXNfY2hhbmdlc1wiLlxuICAgKiBAcGFyYW0gZmlsdGVyIEN1c3RvbSBvYmplY3Qgc3BlY2lmaWMgdG8gdGhlIFJlYWx0aW1lIGZlYXR1cmUgZGV0YWlsaW5nIHdoaWNoIHBheWxvYWRzIHRvIHJlY2VpdmUuXG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBiZSBpbnZva2VkIHdoZW4gZXZlbnQgaGFuZGxlciBpcyB0cmlnZ2VyZWQuXG4gICAqL1xuICBvbihcbiAgICB0eXBlOiBgJHtSRUFMVElNRV9MSVNURU5fVFlQRVMuQlJPQURDQVNUfWAsXG4gICAgZmlsdGVyOiB7IGV2ZW50OiBzdHJpbmcgfSxcbiAgICBjYWxsYmFjazogKHBheWxvYWQ6IHtcbiAgICAgIHR5cGU6IGAke1JFQUxUSU1FX0xJU1RFTl9UWVBFUy5CUk9BRENBU1R9YFxuICAgICAgZXZlbnQ6IHN0cmluZ1xuICAgICAgW2tleTogc3RyaW5nXTogYW55XG4gICAgfSkgPT4gdm9pZFxuICApOiBSZWFsdGltZUNoYW5uZWxcbiAgb248VCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogYW55IH0+KFxuICAgIHR5cGU6IGAke1JFQUxUSU1FX0xJU1RFTl9UWVBFUy5CUk9BRENBU1R9YCxcbiAgICBmaWx0ZXI6IHsgZXZlbnQ6IHN0cmluZyB9LFxuICAgIGNhbGxiYWNrOiAocGF5bG9hZDoge1xuICAgICAgdHlwZTogYCR7UkVBTFRJTUVfTElTVEVOX1RZUEVTLkJST0FEQ0FTVH1gXG4gICAgICBldmVudDogc3RyaW5nXG4gICAgICBwYXlsb2FkOiBUXG4gICAgfSkgPT4gdm9pZFxuICApOiBSZWFsdGltZUNoYW5uZWxcbiAgb24oXG4gICAgdHlwZTogYCR7UkVBTFRJTUVfTElTVEVOX1RZUEVTfWAsXG4gICAgZmlsdGVyOiB7IGV2ZW50OiBzdHJpbmc7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9LFxuICAgIGNhbGxiYWNrOiAocGF5bG9hZDogYW55KSA9PiB2b2lkXG4gICk6IFJlYWx0aW1lQ2hhbm5lbCB7XG4gICAgcmV0dXJuIHRoaXMuX29uKHR5cGUsIGZpbHRlciwgY2FsbGJhY2spXG4gIH1cbiAgLyoqXG4gICAqIFNlbmRzIGEgbWVzc2FnZSBpbnRvIHRoZSBjaGFubmVsLlxuICAgKlxuICAgKiBAcGFyYW0gYXJncyBBcmd1bWVudHMgdG8gc2VuZCB0byBjaGFubmVsXG4gICAqIEBwYXJhbSBhcmdzLnR5cGUgVGhlIHR5cGUgb2YgZXZlbnQgdG8gc2VuZFxuICAgKiBAcGFyYW0gYXJncy5ldmVudCBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgYmVpbmcgc2VudFxuICAgKiBAcGFyYW0gYXJncy5wYXlsb2FkIFBheWxvYWQgdG8gYmUgc2VudFxuICAgKiBAcGFyYW0gb3B0cyBPcHRpb25zIHRvIGJlIHVzZWQgZHVyaW5nIHRoZSBzZW5kIHByb2Nlc3NcbiAgICovXG4gIGFzeW5jIHNlbmQoXG4gICAgYXJnczoge1xuICAgICAgdHlwZTogJ2Jyb2FkY2FzdCcgfCAncHJlc2VuY2UnIHwgJ3Bvc3RncmVzX2NoYW5nZXMnXG4gICAgICBldmVudDogc3RyaW5nXG4gICAgICBwYXlsb2FkPzogYW55XG4gICAgICBba2V5OiBzdHJpbmddOiBhbnlcbiAgICB9LFxuICAgIG9wdHM6IHsgW2tleTogc3RyaW5nXTogYW55IH0gPSB7fVxuICApOiBQcm9taXNlPFJlYWx0aW1lQ2hhbm5lbFNlbmRSZXNwb25zZT4ge1xuICAgIGlmICghdGhpcy5fY2FuUHVzaCgpICYmIGFyZ3MudHlwZSA9PT0gJ2Jyb2FkY2FzdCcpIHtcbiAgICAgIGNvbnN0IHsgZXZlbnQsIHBheWxvYWQ6IGVuZHBvaW50X3BheWxvYWQgfSA9IGFyZ3NcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgQXV0aG9yaXphdGlvbjogdGhpcy5zb2NrZXQuYWNjZXNzVG9rZW5cbiAgICAgICAgICAgID8gYEJlYXJlciAke3RoaXMuc29ja2V0LmFjY2Vzc1Rva2VufWBcbiAgICAgICAgICAgIDogJycsXG4gICAgICAgICAgYXBpa2V5OiB0aGlzLnNvY2tldC5hcGlLZXkgPyB0aGlzLnNvY2tldC5hcGlLZXkgOiAnJyxcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgbWVzc2FnZXM6IFtcbiAgICAgICAgICAgIHsgdG9waWM6IHRoaXMuc3ViVG9waWMsIGV2ZW50LCBwYXlsb2FkOiBlbmRwb2ludF9wYXlsb2FkIH0sXG4gICAgICAgICAgXSxcbiAgICAgICAgfSksXG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fZmV0Y2hXaXRoVGltZW91dChcbiAgICAgICAgICB0aGlzLmJyb2FkY2FzdEVuZHBvaW50VVJMLFxuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgb3B0cy50aW1lb3V0ID8/IHRoaXMudGltZW91dFxuICAgICAgICApXG5cbiAgICAgICAgYXdhaXQgcmVzcG9uc2UuYm9keT8uY2FuY2VsKClcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLm9rID8gJ29rJyA6ICdlcnJvcidcbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICAgIHJldHVybiAndGltZWQgb3V0J1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAnZXJyb3InXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGNvbnN0IHB1c2ggPSB0aGlzLl9wdXNoKGFyZ3MudHlwZSwgYXJncywgb3B0cy50aW1lb3V0IHx8IHRoaXMudGltZW91dClcblxuICAgICAgICBpZiAoYXJncy50eXBlID09PSAnYnJvYWRjYXN0JyAmJiAhdGhpcy5wYXJhbXM/LmNvbmZpZz8uYnJvYWRjYXN0Py5hY2spIHtcbiAgICAgICAgICByZXNvbHZlKCdvaycpXG4gICAgICAgIH1cblxuICAgICAgICBwdXNoLnJlY2VpdmUoJ29rJywgKCkgPT4gcmVzb2x2ZSgnb2snKSlcbiAgICAgICAgcHVzaC5yZWNlaXZlKCdlcnJvcicsICgpID0+IHJlc29sdmUoJ2Vycm9yJykpXG4gICAgICAgIHB1c2gucmVjZWl2ZSgndGltZW91dCcsICgpID0+IHJlc29sdmUoJ3RpbWVkIG91dCcpKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICB1cGRhdGVKb2luUGF5bG9hZChwYXlsb2FkOiB7IFtrZXk6IHN0cmluZ106IGFueSB9KTogdm9pZCB7XG4gICAgdGhpcy5qb2luUHVzaC51cGRhdGVQYXlsb2FkKHBheWxvYWQpXG4gIH1cblxuICAvKipcbiAgICogTGVhdmVzIHRoZSBjaGFubmVsLlxuICAgKlxuICAgKiBVbnN1YnNjcmliZXMgZnJvbSBzZXJ2ZXIgZXZlbnRzLCBhbmQgaW5zdHJ1Y3RzIGNoYW5uZWwgdG8gdGVybWluYXRlIG9uIHNlcnZlci5cbiAgICogVHJpZ2dlcnMgb25DbG9zZSgpIGhvb2tzLlxuICAgKlxuICAgKiBUbyByZWNlaXZlIGxlYXZlIGFja25vd2xlZGdlbWVudHMsIHVzZSB0aGUgYSBgcmVjZWl2ZWAgaG9vayB0byBiaW5kIHRvIHRoZSBzZXJ2ZXIgYWNrLCBpZTpcbiAgICogY2hhbm5lbC51bnN1YnNjcmliZSgpLnJlY2VpdmUoXCJva1wiLCAoKSA9PiBhbGVydChcImxlZnQhXCIpIClcbiAgICovXG4gIHVuc3Vic2NyaWJlKHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQpOiBQcm9taXNlPCdvaycgfCAndGltZWQgb3V0JyB8ICdlcnJvcic+IHtcbiAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMubGVhdmluZ1xuICAgIGNvbnN0IG9uQ2xvc2UgPSAoKSA9PiB7XG4gICAgICB0aGlzLnNvY2tldC5sb2coJ2NoYW5uZWwnLCBgbGVhdmUgJHt0aGlzLnRvcGljfWApXG4gICAgICB0aGlzLl90cmlnZ2VyKENIQU5ORUxfRVZFTlRTLmNsb3NlLCAnbGVhdmUnLCB0aGlzLl9qb2luUmVmKCkpXG4gICAgfVxuXG4gICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpXG4gICAgLy8gRGVzdHJveSBqb2luUHVzaCB0byBhdm9pZCBjb25uZWN0aW9uIHRpbWVvdXRzIGR1cmluZyB1bnNjcmlwdGlvbiBwaGFzZVxuICAgIHRoaXMuam9pblB1c2guZGVzdHJveSgpXG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGNvbnN0IGxlYXZlUHVzaCA9IG5ldyBQdXNoKHRoaXMsIENIQU5ORUxfRVZFTlRTLmxlYXZlLCB7fSwgdGltZW91dClcblxuICAgICAgbGVhdmVQdXNoXG4gICAgICAgIC5yZWNlaXZlKCdvaycsICgpID0+IHtcbiAgICAgICAgICBvbkNsb3NlKClcbiAgICAgICAgICByZXNvbHZlKCdvaycpXG4gICAgICAgIH0pXG4gICAgICAgIC5yZWNlaXZlKCd0aW1lb3V0JywgKCkgPT4ge1xuICAgICAgICAgIG9uQ2xvc2UoKVxuICAgICAgICAgIHJlc29sdmUoJ3RpbWVkIG91dCcpXG4gICAgICAgIH0pXG4gICAgICAgIC5yZWNlaXZlKCdlcnJvcicsICgpID0+IHtcbiAgICAgICAgICByZXNvbHZlKCdlcnJvcicpXG4gICAgICAgIH0pXG5cbiAgICAgIGxlYXZlUHVzaC5zZW5kKClcblxuICAgICAgaWYgKCF0aGlzLl9jYW5QdXNoKCkpIHtcbiAgICAgICAgbGVhdmVQdXNoLnRyaWdnZXIoJ29rJywge30pXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICBhc3luYyBfZmV0Y2hXaXRoVGltZW91dChcbiAgICB1cmw6IHN0cmluZyxcbiAgICBvcHRpb25zOiB7IFtrZXk6IHN0cmluZ106IGFueSB9LFxuICAgIHRpbWVvdXQ6IG51bWJlclxuICApIHtcbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpXG4gICAgY29uc3QgaWQgPSBzZXRUaW1lb3V0KCgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSwgdGltZW91dClcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zb2NrZXQuZmV0Y2godXJsLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcbiAgICB9KVxuXG4gICAgY2xlYXJUaW1lb3V0KGlkKVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIF9wdXNoKFxuICAgIGV2ZW50OiBzdHJpbmcsXG4gICAgcGF5bG9hZDogeyBba2V5OiBzdHJpbmddOiBhbnkgfSxcbiAgICB0aW1lb3V0ID0gdGhpcy50aW1lb3V0XG4gICkge1xuICAgIGlmICghdGhpcy5qb2luZWRPbmNlKSB7XG4gICAgICB0aHJvdyBgdHJpZWQgdG8gcHVzaCAnJHtldmVudH0nIHRvICcke3RoaXMudG9waWN9JyBiZWZvcmUgam9pbmluZy4gVXNlIGNoYW5uZWwuc3Vic2NyaWJlKCkgYmVmb3JlIHB1c2hpbmcgZXZlbnRzYFxuICAgIH1cbiAgICBsZXQgcHVzaEV2ZW50ID0gbmV3IFB1c2godGhpcywgZXZlbnQsIHBheWxvYWQsIHRpbWVvdXQpXG4gICAgaWYgKHRoaXMuX2NhblB1c2goKSkge1xuICAgICAgcHVzaEV2ZW50LnNlbmQoKVxuICAgIH0gZWxzZSB7XG4gICAgICBwdXNoRXZlbnQuc3RhcnRUaW1lb3V0KClcbiAgICAgIHRoaXMucHVzaEJ1ZmZlci5wdXNoKHB1c2hFdmVudClcbiAgICB9XG5cbiAgICByZXR1cm4gcHVzaEV2ZW50XG4gIH1cblxuICAvKipcbiAgICogT3ZlcnJpZGFibGUgbWVzc2FnZSBob29rXG4gICAqXG4gICAqIFJlY2VpdmVzIGFsbCBldmVudHMgZm9yIHNwZWNpYWxpemVkIG1lc3NhZ2UgaGFuZGxpbmcgYmVmb3JlIGRpc3BhdGNoaW5nIHRvIHRoZSBjaGFubmVsIGNhbGxiYWNrcy5cbiAgICogTXVzdCByZXR1cm4gdGhlIHBheWxvYWQsIG1vZGlmaWVkIG9yIHVubW9kaWZpZWQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX29uTWVzc2FnZShfZXZlbnQ6IHN0cmluZywgcGF5bG9hZDogYW55LCBfcmVmPzogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHBheWxvYWRcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2lzTWVtYmVyKHRvcGljOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy50b3BpYyA9PT0gdG9waWNcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2pvaW5SZWYoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5qb2luUHVzaC5yZWZcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RyaWdnZXIodHlwZTogc3RyaW5nLCBwYXlsb2FkPzogYW55LCByZWY/OiBzdHJpbmcpIHtcbiAgICBjb25zdCB0eXBlTG93ZXIgPSB0eXBlLnRvTG9jYWxlTG93ZXJDYXNlKClcbiAgICBjb25zdCB7IGNsb3NlLCBlcnJvciwgbGVhdmUsIGpvaW4gfSA9IENIQU5ORUxfRVZFTlRTXG4gICAgY29uc3QgZXZlbnRzOiBzdHJpbmdbXSA9IFtjbG9zZSwgZXJyb3IsIGxlYXZlLCBqb2luXVxuICAgIGlmIChyZWYgJiYgZXZlbnRzLmluZGV4T2YodHlwZUxvd2VyKSA+PSAwICYmIHJlZiAhPT0gdGhpcy5fam9pblJlZigpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgbGV0IGhhbmRsZWRQYXlsb2FkID0gdGhpcy5fb25NZXNzYWdlKHR5cGVMb3dlciwgcGF5bG9hZCwgcmVmKVxuICAgIGlmIChwYXlsb2FkICYmICFoYW5kbGVkUGF5bG9hZCkge1xuICAgICAgdGhyb3cgJ2NoYW5uZWwgb25NZXNzYWdlIGNhbGxiYWNrcyBtdXN0IHJldHVybiB0aGUgcGF5bG9hZCwgbW9kaWZpZWQgb3IgdW5tb2RpZmllZCdcbiAgICB9XG5cbiAgICBpZiAoWydpbnNlcnQnLCAndXBkYXRlJywgJ2RlbGV0ZSddLmluY2x1ZGVzKHR5cGVMb3dlcikpIHtcbiAgICAgIHRoaXMuYmluZGluZ3MucG9zdGdyZXNfY2hhbmdlc1xuICAgICAgICA/LmZpbHRlcigoYmluZCkgPT4ge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBiaW5kLmZpbHRlcj8uZXZlbnQgPT09ICcqJyB8fFxuICAgICAgICAgICAgYmluZC5maWx0ZXI/LmV2ZW50Py50b0xvY2FsZUxvd2VyQ2FzZSgpID09PSB0eXBlTG93ZXJcbiAgICAgICAgICApXG4gICAgICAgIH0pXG4gICAgICAgIC5tYXAoKGJpbmQpID0+IGJpbmQuY2FsbGJhY2soaGFuZGxlZFBheWxvYWQsIHJlZikpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYmluZGluZ3NbdHlwZUxvd2VyXVxuICAgICAgICA/LmZpbHRlcigoYmluZCkgPT4ge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIFsnYnJvYWRjYXN0JywgJ3ByZXNlbmNlJywgJ3Bvc3RncmVzX2NoYW5nZXMnXS5pbmNsdWRlcyh0eXBlTG93ZXIpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoJ2lkJyBpbiBiaW5kKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGJpbmRJZCA9IGJpbmQuaWRcbiAgICAgICAgICAgICAgY29uc3QgYmluZEV2ZW50ID0gYmluZC5maWx0ZXI/LmV2ZW50XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgYmluZElkICYmXG4gICAgICAgICAgICAgICAgcGF5bG9hZC5pZHM/LmluY2x1ZGVzKGJpbmRJZCkgJiZcbiAgICAgICAgICAgICAgICAoYmluZEV2ZW50ID09PSAnKicgfHxcbiAgICAgICAgICAgICAgICAgIGJpbmRFdmVudD8udG9Mb2NhbGVMb3dlckNhc2UoKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC5kYXRhPy50eXBlLnRvTG9jYWxlTG93ZXJDYXNlKCkpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnN0IGJpbmRFdmVudCA9IGJpbmQ/LmZpbHRlcj8uZXZlbnQ/LnRvTG9jYWxlTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBiaW5kRXZlbnQgPT09ICcqJyB8fFxuICAgICAgICAgICAgICAgIGJpbmRFdmVudCA9PT0gcGF5bG9hZD8uZXZlbnQ/LnRvTG9jYWxlTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZC50eXBlLnRvTG9jYWxlTG93ZXJDYXNlKCkgPT09IHR5cGVMb3dlclxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLm1hcCgoYmluZCkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2YgaGFuZGxlZFBheWxvYWQgPT09ICdvYmplY3QnICYmICdpZHMnIGluIGhhbmRsZWRQYXlsb2FkKSB7XG4gICAgICAgICAgICBjb25zdCBwb3N0Z3Jlc0NoYW5nZXMgPSBoYW5kbGVkUGF5bG9hZC5kYXRhXG4gICAgICAgICAgICBjb25zdCB7IHNjaGVtYSwgdGFibGUsIGNvbW1pdF90aW1lc3RhbXAsIHR5cGUsIGVycm9ycyB9ID1cbiAgICAgICAgICAgICAgcG9zdGdyZXNDaGFuZ2VzXG4gICAgICAgICAgICBjb25zdCBlbnJpY2hlZFBheWxvYWQgPSB7XG4gICAgICAgICAgICAgIHNjaGVtYTogc2NoZW1hLFxuICAgICAgICAgICAgICB0YWJsZTogdGFibGUsXG4gICAgICAgICAgICAgIGNvbW1pdF90aW1lc3RhbXA6IGNvbW1pdF90aW1lc3RhbXAsXG4gICAgICAgICAgICAgIGV2ZW50VHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgbmV3OiB7fSxcbiAgICAgICAgICAgICAgb2xkOiB7fSxcbiAgICAgICAgICAgICAgZXJyb3JzOiBlcnJvcnMsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYW5kbGVkUGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgLi4uZW5yaWNoZWRQYXlsb2FkLFxuICAgICAgICAgICAgICAuLi50aGlzLl9nZXRQYXlsb2FkUmVjb3Jkcyhwb3N0Z3Jlc0NoYW5nZXMpLFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBiaW5kLmNhbGxiYWNrKGhhbmRsZWRQYXlsb2FkLCByZWYpXG4gICAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfaXNDbG9zZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmNsb3NlZFxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfaXNKb2luZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmpvaW5lZFxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfaXNKb2luaW5nKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5qb2luaW5nXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIF9pc0xlYXZpbmcoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmxlYXZpbmdcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3JlcGx5RXZlbnROYW1lKHJlZjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYGNoYW5fcmVwbHlfJHtyZWZ9YFxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfb24odHlwZTogc3RyaW5nLCBmaWx0ZXI6IHsgW2tleTogc3RyaW5nXTogYW55IH0sIGNhbGxiYWNrOiBGdW5jdGlvbikge1xuICAgIGNvbnN0IHR5cGVMb3dlciA9IHR5cGUudG9Mb2NhbGVMb3dlckNhc2UoKVxuXG4gICAgY29uc3QgYmluZGluZyA9IHtcbiAgICAgIHR5cGU6IHR5cGVMb3dlcixcbiAgICAgIGZpbHRlcjogZmlsdGVyLFxuICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgIH1cblxuICAgIGlmICh0aGlzLmJpbmRpbmdzW3R5cGVMb3dlcl0pIHtcbiAgICAgIHRoaXMuYmluZGluZ3NbdHlwZUxvd2VyXS5wdXNoKGJpbmRpbmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYmluZGluZ3NbdHlwZUxvd2VyXSA9IFtiaW5kaW5nXVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIF9vZmYodHlwZTogc3RyaW5nLCBmaWx0ZXI6IHsgW2tleTogc3RyaW5nXTogYW55IH0pIHtcbiAgICBjb25zdCB0eXBlTG93ZXIgPSB0eXBlLnRvTG9jYWxlTG93ZXJDYXNlKClcblxuICAgIHRoaXMuYmluZGluZ3NbdHlwZUxvd2VyXSA9IHRoaXMuYmluZGluZ3NbdHlwZUxvd2VyXS5maWx0ZXIoKGJpbmQpID0+IHtcbiAgICAgIHJldHVybiAhKFxuICAgICAgICBiaW5kLnR5cGU/LnRvTG9jYWxlTG93ZXJDYXNlKCkgPT09IHR5cGVMb3dlciAmJlxuICAgICAgICBSZWFsdGltZUNoYW5uZWwuaXNFcXVhbChiaW5kLmZpbHRlciwgZmlsdGVyKVxuICAgICAgKVxuICAgIH0pXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgaXNFcXVhbChcbiAgICBvYmoxOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9LFxuICAgIG9iajI6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH1cbiAgKSB7XG4gICAgaWYgKE9iamVjdC5rZXlzKG9iajEpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMob2JqMikubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGsgaW4gb2JqMSkge1xuICAgICAgaWYgKG9iajFba10gIT09IG9iajJba10pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBfcmVqb2luVW50aWxDb25uZWN0ZWQoKSB7XG4gICAgdGhpcy5yZWpvaW5UaW1lci5zY2hlZHVsZVRpbWVvdXQoKVxuICAgIGlmICh0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICB0aGlzLl9yZWpvaW4oKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2hhbm5lbCBjbG9zZXMuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJpdmF0ZSBfb25DbG9zZShjYWxsYmFjazogRnVuY3Rpb24pIHtcbiAgICB0aGlzLl9vbihDSEFOTkVMX0VWRU5UUy5jbG9zZSwge30sIGNhbGxiYWNrKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHRoZSBjaGFubmVsIGVuY291bnRlcmVzIGFuIGVycm9yLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByaXZhdGUgX29uRXJyb3IoY2FsbGJhY2s6IEZ1bmN0aW9uKSB7XG4gICAgdGhpcy5fb24oQ0hBTk5FTF9FVkVOVFMuZXJyb3IsIHt9LCAocmVhc29uOiBzdHJpbmcpID0+IGNhbGxiYWNrKHJlYXNvbikpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNvY2tldCBpcyBjb25uZWN0ZWQgYW5kIHRoZSBjaGFubmVsIGhhcyBiZWVuIGpvaW5lZC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcml2YXRlIF9jYW5QdXNoKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpICYmIHRoaXMuX2lzSm9pbmVkKClcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBfcmVqb2luKHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5faXNMZWF2aW5nKCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0aGlzLnNvY2tldC5fbGVhdmVPcGVuVG9waWModGhpcy50b3BpYylcbiAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuam9pbmluZ1xuICAgIHRoaXMuam9pblB1c2gucmVzZW5kKHRpbWVvdXQpXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgX2dldFBheWxvYWRSZWNvcmRzKHBheWxvYWQ6IGFueSkge1xuICAgIGNvbnN0IHJlY29yZHMgPSB7XG4gICAgICBuZXc6IHt9LFxuICAgICAgb2xkOiB7fSxcbiAgICB9XG5cbiAgICBpZiAocGF5bG9hZC50eXBlID09PSAnSU5TRVJUJyB8fCBwYXlsb2FkLnR5cGUgPT09ICdVUERBVEUnKSB7XG4gICAgICByZWNvcmRzLm5ldyA9IFRyYW5zZm9ybWVycy5jb252ZXJ0Q2hhbmdlRGF0YShcbiAgICAgICAgcGF5bG9hZC5jb2x1bW5zLFxuICAgICAgICBwYXlsb2FkLnJlY29yZFxuICAgICAgKVxuICAgIH1cblxuICAgIGlmIChwYXlsb2FkLnR5cGUgPT09ICdVUERBVEUnIHx8IHBheWxvYWQudHlwZSA9PT0gJ0RFTEVURScpIHtcbiAgICAgIHJlY29yZHMub2xkID0gVHJhbnNmb3JtZXJzLmNvbnZlcnRDaGFuZ2VEYXRhKFxuICAgICAgICBwYXlsb2FkLmNvbHVtbnMsXG4gICAgICAgIHBheWxvYWQub2xkX3JlY29yZFxuICAgICAgKVxuICAgIH1cblxuICAgIHJldHVybiByZWNvcmRzXG4gIH1cbn1cbiIsImltcG9ydCB7IERFRkFVTFRfVElNRU9VVCB9IGZyb20gJy4uL2xpYi9jb25zdGFudHMnO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHVzaCB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIFB1c2hcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFubmVsIFRoZSBDaGFubmVsXG4gICAgICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCwgZm9yIGV4YW1wbGUgYFwicGh4X2pvaW5cImBcbiAgICAgKiBAcGFyYW0gcGF5bG9hZCBUaGUgcGF5bG9hZCwgZm9yIGV4YW1wbGUgYHt1c2VyX2lkOiAxMjN9YFxuICAgICAqIEBwYXJhbSB0aW1lb3V0IFRoZSBwdXNoIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY2hhbm5lbCwgZXZlbnQsIHBheWxvYWQgPSB7fSwgdGltZW91dCA9IERFRkFVTFRfVElNRU9VVCkge1xuICAgICAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuICAgICAgICB0aGlzLmV2ZW50ID0gZXZlbnQ7XG4gICAgICAgIHRoaXMucGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgICAgIHRoaXMudGltZW91dCA9IHRpbWVvdXQ7XG4gICAgICAgIHRoaXMuc2VudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRpbWVvdXRUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5yZWYgPSAnJztcbiAgICAgICAgdGhpcy5yZWNlaXZlZFJlc3AgPSBudWxsO1xuICAgICAgICB0aGlzLnJlY0hvb2tzID0gW107XG4gICAgICAgIHRoaXMucmVmRXZlbnQgPSBudWxsO1xuICAgIH1cbiAgICByZXNlbmQodGltZW91dCkge1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgICAgICB0aGlzLl9jYW5jZWxSZWZFdmVudCgpO1xuICAgICAgICB0aGlzLnJlZiA9ICcnO1xuICAgICAgICB0aGlzLnJlZkV2ZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWNlaXZlZFJlc3AgPSBudWxsO1xuICAgICAgICB0aGlzLnNlbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZW5kKCk7XG4gICAgfVxuICAgIHNlbmQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9oYXNSZWNlaXZlZCgndGltZW91dCcpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFydFRpbWVvdXQoKTtcbiAgICAgICAgdGhpcy5zZW50ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jaGFubmVsLnNvY2tldC5wdXNoKHtcbiAgICAgICAgICAgIHRvcGljOiB0aGlzLmNoYW5uZWwudG9waWMsXG4gICAgICAgICAgICBldmVudDogdGhpcy5ldmVudCxcbiAgICAgICAgICAgIHBheWxvYWQ6IHRoaXMucGF5bG9hZCxcbiAgICAgICAgICAgIHJlZjogdGhpcy5yZWYsXG4gICAgICAgICAgICBqb2luX3JlZjogdGhpcy5jaGFubmVsLl9qb2luUmVmKCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1cGRhdGVQYXlsb2FkKHBheWxvYWQpIHtcbiAgICAgICAgdGhpcy5wYXlsb2FkID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnBheWxvYWQpLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgcmVjZWl2ZShzdGF0dXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMuX2hhc1JlY2VpdmVkKHN0YXR1cykpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKChfYSA9IHRoaXMucmVjZWl2ZWRSZXNwKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVjSG9va3MucHVzaCh7IHN0YXR1cywgY2FsbGJhY2sgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzdGFydFRpbWVvdXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVvdXRUaW1lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVmID0gdGhpcy5jaGFubmVsLnNvY2tldC5fbWFrZVJlZigpO1xuICAgICAgICB0aGlzLnJlZkV2ZW50ID0gdGhpcy5jaGFubmVsLl9yZXBseUV2ZW50TmFtZSh0aGlzLnJlZik7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2NhbmNlbFJlZkV2ZW50KCk7XG4gICAgICAgICAgICB0aGlzLl9jYW5jZWxUaW1lb3V0KCk7XG4gICAgICAgICAgICB0aGlzLnJlY2VpdmVkUmVzcCA9IHBheWxvYWQ7XG4gICAgICAgICAgICB0aGlzLl9tYXRjaFJlY2VpdmUocGF5bG9hZCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2hhbm5lbC5fb24odGhpcy5yZWZFdmVudCwge30sIGNhbGxiYWNrKTtcbiAgICAgICAgdGhpcy50aW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcigndGltZW91dCcsIHt9KTtcbiAgICAgICAgfSwgdGhpcy50aW1lb3V0KTtcbiAgICB9XG4gICAgdHJpZ2dlcihzdGF0dXMsIHJlc3BvbnNlKSB7XG4gICAgICAgIGlmICh0aGlzLnJlZkV2ZW50KVxuICAgICAgICAgICAgdGhpcy5jaGFubmVsLl90cmlnZ2VyKHRoaXMucmVmRXZlbnQsIHsgc3RhdHVzLCByZXNwb25zZSB9KTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fY2FuY2VsUmVmRXZlbnQoKTtcbiAgICAgICAgdGhpcy5fY2FuY2VsVGltZW91dCgpO1xuICAgIH1cbiAgICBfY2FuY2VsUmVmRXZlbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5yZWZFdmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hhbm5lbC5fb2ZmKHRoaXMucmVmRXZlbnQsIHt9KTtcbiAgICB9XG4gICAgX2NhbmNlbFRpbWVvdXQoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRUaW1lcik7XG4gICAgICAgIHRoaXMudGltZW91dFRpbWVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBfbWF0Y2hSZWNlaXZlKHsgc3RhdHVzLCByZXNwb25zZSwgfSkge1xuICAgICAgICB0aGlzLnJlY0hvb2tzXG4gICAgICAgICAgICAuZmlsdGVyKChoKSA9PiBoLnN0YXR1cyA9PT0gc3RhdHVzKVxuICAgICAgICAgICAgLmZvckVhY2goKGgpID0+IGguY2FsbGJhY2socmVzcG9uc2UpKTtcbiAgICB9XG4gICAgX2hhc1JlY2VpdmVkKHN0YXR1cykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWNlaXZlZFJlc3AgJiYgdGhpcy5yZWNlaXZlZFJlc3Auc3RhdHVzID09PSBzdGF0dXM7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHVzaC5qcy5tYXAiLCJpbXBvcnQgeyBERUZBVUxUX1RJTUVPVVQgfSBmcm9tICcuLi9saWIvY29uc3RhbnRzJ1xuaW1wb3J0IHR5cGUgUmVhbHRpbWVDaGFubmVsIGZyb20gJy4uL1JlYWx0aW1lQ2hhbm5lbCdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHVzaCB7XG4gIHNlbnQ6IGJvb2xlYW4gPSBmYWxzZVxuICB0aW1lb3V0VGltZXI6IG51bWJlciB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZFxuICByZWY6IHN0cmluZyA9ICcnXG4gIHJlY2VpdmVkUmVzcDoge1xuICAgIHN0YXR1czogc3RyaW5nXG4gICAgcmVzcG9uc2U6IHsgW2tleTogc3RyaW5nXTogYW55IH1cbiAgfSB8IG51bGwgPSBudWxsXG4gIHJlY0hvb2tzOiB7XG4gICAgc3RhdHVzOiBzdHJpbmdcbiAgICBjYWxsYmFjazogRnVuY3Rpb25cbiAgfVtdID0gW11cbiAgcmVmRXZlbnQ6IHN0cmluZyB8IG51bGwgPSBudWxsXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBQdXNoXG4gICAqXG4gICAqIEBwYXJhbSBjaGFubmVsIFRoZSBDaGFubmVsXG4gICAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQsIGZvciBleGFtcGxlIGBcInBoeF9qb2luXCJgXG4gICAqIEBwYXJhbSBwYXlsb2FkIFRoZSBwYXlsb2FkLCBmb3IgZXhhbXBsZSBge3VzZXJfaWQ6IDEyM31gXG4gICAqIEBwYXJhbSB0aW1lb3V0IFRoZSBwdXNoIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgY2hhbm5lbDogUmVhbHRpbWVDaGFubmVsLFxuICAgIHB1YmxpYyBldmVudDogc3RyaW5nLFxuICAgIHB1YmxpYyBwYXlsb2FkOiB7IFtrZXk6IHN0cmluZ106IGFueSB9ID0ge30sXG4gICAgcHVibGljIHRpbWVvdXQ6IG51bWJlciA9IERFRkFVTFRfVElNRU9VVFxuICApIHt9XG5cbiAgcmVzZW5kKHRpbWVvdXQ6IG51bWJlcikge1xuICAgIHRoaXMudGltZW91dCA9IHRpbWVvdXRcbiAgICB0aGlzLl9jYW5jZWxSZWZFdmVudCgpXG4gICAgdGhpcy5yZWYgPSAnJ1xuICAgIHRoaXMucmVmRXZlbnQgPSBudWxsXG4gICAgdGhpcy5yZWNlaXZlZFJlc3AgPSBudWxsXG4gICAgdGhpcy5zZW50ID0gZmFsc2VcbiAgICB0aGlzLnNlbmQoKVxuICB9XG5cbiAgc2VuZCgpIHtcbiAgICBpZiAodGhpcy5faGFzUmVjZWl2ZWQoJ3RpbWVvdXQnKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRoaXMuc3RhcnRUaW1lb3V0KClcbiAgICB0aGlzLnNlbnQgPSB0cnVlXG4gICAgdGhpcy5jaGFubmVsLnNvY2tldC5wdXNoKHtcbiAgICAgIHRvcGljOiB0aGlzLmNoYW5uZWwudG9waWMsXG4gICAgICBldmVudDogdGhpcy5ldmVudCxcbiAgICAgIHBheWxvYWQ6IHRoaXMucGF5bG9hZCxcbiAgICAgIHJlZjogdGhpcy5yZWYsXG4gICAgICBqb2luX3JlZjogdGhpcy5jaGFubmVsLl9qb2luUmVmKCksXG4gICAgfSlcbiAgfVxuXG4gIHVwZGF0ZVBheWxvYWQocGF5bG9hZDogeyBba2V5OiBzdHJpbmddOiBhbnkgfSk6IHZvaWQge1xuICAgIHRoaXMucGF5bG9hZCA9IHsgLi4udGhpcy5wYXlsb2FkLCAuLi5wYXlsb2FkIH1cbiAgfVxuXG4gIHJlY2VpdmUoc3RhdHVzOiBzdHJpbmcsIGNhbGxiYWNrOiBGdW5jdGlvbikge1xuICAgIGlmICh0aGlzLl9oYXNSZWNlaXZlZChzdGF0dXMpKSB7XG4gICAgICBjYWxsYmFjayh0aGlzLnJlY2VpdmVkUmVzcD8ucmVzcG9uc2UpXG4gICAgfVxuXG4gICAgdGhpcy5yZWNIb29rcy5wdXNoKHsgc3RhdHVzLCBjYWxsYmFjayB9KVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydFRpbWVvdXQoKSB7XG4gICAgaWYgKHRoaXMudGltZW91dFRpbWVyKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy5yZWYgPSB0aGlzLmNoYW5uZWwuc29ja2V0Ll9tYWtlUmVmKClcbiAgICB0aGlzLnJlZkV2ZW50ID0gdGhpcy5jaGFubmVsLl9yZXBseUV2ZW50TmFtZSh0aGlzLnJlZilcblxuICAgIGNvbnN0IGNhbGxiYWNrID0gKHBheWxvYWQ6IGFueSkgPT4ge1xuICAgICAgdGhpcy5fY2FuY2VsUmVmRXZlbnQoKVxuICAgICAgdGhpcy5fY2FuY2VsVGltZW91dCgpXG4gICAgICB0aGlzLnJlY2VpdmVkUmVzcCA9IHBheWxvYWRcbiAgICAgIHRoaXMuX21hdGNoUmVjZWl2ZShwYXlsb2FkKVxuICAgIH1cblxuICAgIHRoaXMuY2hhbm5lbC5fb24odGhpcy5yZWZFdmVudCwge30sIGNhbGxiYWNrKVxuXG4gICAgdGhpcy50aW1lb3V0VGltZXIgPSA8YW55PnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy50cmlnZ2VyKCd0aW1lb3V0Jywge30pXG4gICAgfSwgdGhpcy50aW1lb3V0KVxuICB9XG5cbiAgdHJpZ2dlcihzdGF0dXM6IHN0cmluZywgcmVzcG9uc2U6IGFueSkge1xuICAgIGlmICh0aGlzLnJlZkV2ZW50KVxuICAgICAgdGhpcy5jaGFubmVsLl90cmlnZ2VyKHRoaXMucmVmRXZlbnQsIHsgc3RhdHVzLCByZXNwb25zZSB9KVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9jYW5jZWxSZWZFdmVudCgpXG4gICAgdGhpcy5fY2FuY2VsVGltZW91dCgpXG4gIH1cblxuICBwcml2YXRlIF9jYW5jZWxSZWZFdmVudCgpIHtcbiAgICBpZiAoIXRoaXMucmVmRXZlbnQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuY2hhbm5lbC5fb2ZmKHRoaXMucmVmRXZlbnQsIHt9KVxuICB9XG5cbiAgcHJpdmF0ZSBfY2FuY2VsVGltZW91dCgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0VGltZXIpXG4gICAgdGhpcy50aW1lb3V0VGltZXIgPSB1bmRlZmluZWRcbiAgfVxuXG4gIHByaXZhdGUgX21hdGNoUmVjZWl2ZSh7XG4gICAgc3RhdHVzLFxuICAgIHJlc3BvbnNlLFxuICB9OiB7XG4gICAgc3RhdHVzOiBzdHJpbmdcbiAgICByZXNwb25zZTogRnVuY3Rpb25cbiAgfSkge1xuICAgIHRoaXMucmVjSG9va3NcbiAgICAgIC5maWx0ZXIoKGgpID0+IGguc3RhdHVzID09PSBzdGF0dXMpXG4gICAgICAuZm9yRWFjaCgoaCkgPT4gaC5jYWxsYmFjayhyZXNwb25zZSkpXG4gIH1cblxuICBwcml2YXRlIF9oYXNSZWNlaXZlZChzdGF0dXM6IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLnJlY2VpdmVkUmVzcCAmJiB0aGlzLnJlY2VpdmVkUmVzcC5zdGF0dXMgPT09IHN0YXR1c1xuICB9XG59XG4iLCIvKlxuICBUaGlzIGZpbGUgZHJhd3MgaGVhdmlseSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9waG9lbml4ZnJhbWV3b3JrL3Bob2VuaXgvYmxvYi9kMzQ0ZWMwYTczMmFiNGVlMjA0MjE1YjMxZGU2OWNmNGJlNzJlM2JmL2Fzc2V0cy9qcy9waG9lbml4L3ByZXNlbmNlLmpzXG4gIExpY2Vuc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9waG9lbml4ZnJhbWV3b3JrL3Bob2VuaXgvYmxvYi9kMzQ0ZWMwYTczMmFiNGVlMjA0MjE1YjMxZGU2OWNmNGJlNzJlM2JmL0xJQ0VOU0UubWRcbiovXG5leHBvcnQgdmFyIFJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFM7XG4oZnVuY3Rpb24gKFJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFMpIHtcbiAgICBSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTW1wiU1lOQ1wiXSA9IFwic3luY1wiO1xuICAgIFJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFNbXCJKT0lOXCJdID0gXCJqb2luXCI7XG4gICAgUkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UU1tcIkxFQVZFXCJdID0gXCJsZWF2ZVwiO1xufSkoUkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UUyB8fCAoUkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UUyA9IHt9KSk7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWFsdGltZVByZXNlbmNlIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgUHJlc2VuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbm5lbCAtIFRoZSBSZWFsdGltZUNoYW5uZWxcbiAgICAgKiBAcGFyYW0gb3B0cyAtIFRoZSBvcHRpb25zLFxuICAgICAqICAgICAgICBmb3IgZXhhbXBsZSBge2V2ZW50czoge3N0YXRlOiAnc3RhdGUnLCBkaWZmOiAnZGlmZid9fWBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsLCBvcHRzKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7fTtcbiAgICAgICAgdGhpcy5wZW5kaW5nRGlmZnMgPSBbXTtcbiAgICAgICAgdGhpcy5qb2luUmVmID0gbnVsbDtcbiAgICAgICAgdGhpcy5jYWxsZXIgPSB7XG4gICAgICAgICAgICBvbkpvaW46ICgpID0+IHsgfSxcbiAgICAgICAgICAgIG9uTGVhdmU6ICgpID0+IHsgfSxcbiAgICAgICAgICAgIG9uU3luYzogKCkgPT4geyB9LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBldmVudHMgPSAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLmV2ZW50cykgfHwge1xuICAgICAgICAgICAgc3RhdGU6ICdwcmVzZW5jZV9zdGF0ZScsXG4gICAgICAgICAgICBkaWZmOiAncHJlc2VuY2VfZGlmZicsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2hhbm5lbC5fb24oZXZlbnRzLnN0YXRlLCB7fSwgKG5ld1N0YXRlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG9uSm9pbiwgb25MZWF2ZSwgb25TeW5jIH0gPSB0aGlzLmNhbGxlcjtcbiAgICAgICAgICAgIHRoaXMuam9pblJlZiA9IHRoaXMuY2hhbm5lbC5fam9pblJlZigpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFJlYWx0aW1lUHJlc2VuY2Uuc3luY1N0YXRlKHRoaXMuc3RhdGUsIG5ld1N0YXRlLCBvbkpvaW4sIG9uTGVhdmUpO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nRGlmZnMuZm9yRWFjaCgoZGlmZikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBSZWFsdGltZVByZXNlbmNlLnN5bmNEaWZmKHRoaXMuc3RhdGUsIGRpZmYsIG9uSm9pbiwgb25MZWF2ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0RpZmZzID0gW107XG4gICAgICAgICAgICBvblN5bmMoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2hhbm5lbC5fb24oZXZlbnRzLmRpZmYsIHt9LCAoZGlmZikgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBvbkpvaW4sIG9uTGVhdmUsIG9uU3luYyB9ID0gdGhpcy5jYWxsZXI7XG4gICAgICAgICAgICBpZiAodGhpcy5pblBlbmRpbmdTeW5jU3RhdGUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0RpZmZzLnB1c2goZGlmZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gUmVhbHRpbWVQcmVzZW5jZS5zeW5jRGlmZih0aGlzLnN0YXRlLCBkaWZmLCBvbkpvaW4sIG9uTGVhdmUpO1xuICAgICAgICAgICAgICAgIG9uU3luYygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbkpvaW4oKGtleSwgY3VycmVudFByZXNlbmNlcywgbmV3UHJlc2VuY2VzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWwuX3RyaWdnZXIoJ3ByZXNlbmNlJywge1xuICAgICAgICAgICAgICAgIGV2ZW50OiAnam9pbicsXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIGN1cnJlbnRQcmVzZW5jZXMsXG4gICAgICAgICAgICAgICAgbmV3UHJlc2VuY2VzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uTGVhdmUoKGtleSwgY3VycmVudFByZXNlbmNlcywgbGVmdFByZXNlbmNlcykgPT4ge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsLl90cmlnZ2VyKCdwcmVzZW5jZScsIHtcbiAgICAgICAgICAgICAgICBldmVudDogJ2xlYXZlJyxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgY3VycmVudFByZXNlbmNlcyxcbiAgICAgICAgICAgICAgICBsZWZ0UHJlc2VuY2VzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uU3luYygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWwuX3RyaWdnZXIoJ3ByZXNlbmNlJywgeyBldmVudDogJ3N5bmMnIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBzeW5jIHRoZSBsaXN0IG9mIHByZXNlbmNlcyBvbiB0aGUgc2VydmVyIHdpdGggdGhlXG4gICAgICogY2xpZW50J3Mgc3RhdGUuXG4gICAgICpcbiAgICAgKiBBbiBvcHRpb25hbCBgb25Kb2luYCBhbmQgYG9uTGVhdmVgIGNhbGxiYWNrIGNhbiBiZSBwcm92aWRlZCB0b1xuICAgICAqIHJlYWN0IHRvIGNoYW5nZXMgaW4gdGhlIGNsaWVudCdzIGxvY2FsIHByZXNlbmNlcyBhY3Jvc3NcbiAgICAgKiBkaXNjb25uZWN0cyBhbmQgcmVjb25uZWN0cyB3aXRoIHRoZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdGF0aWMgc3luY1N0YXRlKGN1cnJlbnRTdGF0ZSwgbmV3U3RhdGUsIG9uSm9pbiwgb25MZWF2ZSkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuY2xvbmVEZWVwKGN1cnJlbnRTdGF0ZSk7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkU3RhdGUgPSB0aGlzLnRyYW5zZm9ybVN0YXRlKG5ld1N0YXRlKTtcbiAgICAgICAgY29uc3Qgam9pbnMgPSB7fTtcbiAgICAgICAgY29uc3QgbGVhdmVzID0ge307XG4gICAgICAgIHRoaXMubWFwKHN0YXRlLCAoa2V5LCBwcmVzZW5jZXMpID0+IHtcbiAgICAgICAgICAgIGlmICghdHJhbnNmb3JtZWRTdGF0ZVtrZXldKSB7XG4gICAgICAgICAgICAgICAgbGVhdmVzW2tleV0gPSBwcmVzZW5jZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1hcCh0cmFuc2Zvcm1lZFN0YXRlLCAoa2V5LCBuZXdQcmVzZW5jZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQcmVzZW5jZXMgPSBzdGF0ZVtrZXldO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRQcmVzZW5jZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdQcmVzZW5jZVJlZnMgPSBuZXdQcmVzZW5jZXMubWFwKChtKSA9PiBtLnByZXNlbmNlX3JlZik7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VyUHJlc2VuY2VSZWZzID0gY3VycmVudFByZXNlbmNlcy5tYXAoKG0pID0+IG0ucHJlc2VuY2VfcmVmKTtcbiAgICAgICAgICAgICAgICBjb25zdCBqb2luZWRQcmVzZW5jZXMgPSBuZXdQcmVzZW5jZXMuZmlsdGVyKChtKSA9PiBjdXJQcmVzZW5jZVJlZnMuaW5kZXhPZihtLnByZXNlbmNlX3JlZikgPCAwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0UHJlc2VuY2VzID0gY3VycmVudFByZXNlbmNlcy5maWx0ZXIoKG0pID0+IG5ld1ByZXNlbmNlUmVmcy5pbmRleE9mKG0ucHJlc2VuY2VfcmVmKSA8IDApO1xuICAgICAgICAgICAgICAgIGlmIChqb2luZWRQcmVzZW5jZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBqb2luc1trZXldID0gam9pbmVkUHJlc2VuY2VzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGVmdFByZXNlbmNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlYXZlc1trZXldID0gbGVmdFByZXNlbmNlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBqb2luc1trZXldID0gbmV3UHJlc2VuY2VzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3luY0RpZmYoc3RhdGUsIHsgam9pbnMsIGxlYXZlcyB9LCBvbkpvaW4sIG9uTGVhdmUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIHN5bmMgYSBkaWZmIG9mIHByZXNlbmNlIGpvaW4gYW5kIGxlYXZlIGV2ZW50cyBmcm9tIHRoZVxuICAgICAqIHNlcnZlciwgYXMgdGhleSBoYXBwZW4uXG4gICAgICpcbiAgICAgKiBMaWtlIGBzeW5jU3RhdGVgLCBgc3luY0RpZmZgIGFjY2VwdHMgb3B0aW9uYWwgYG9uSm9pbmAgYW5kXG4gICAgICogYG9uTGVhdmVgIGNhbGxiYWNrcyB0byByZWFjdCB0byBhIHVzZXIgam9pbmluZyBvciBsZWF2aW5nIGZyb20gYVxuICAgICAqIGRldmljZS5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHN0YXRpYyBzeW5jRGlmZihzdGF0ZSwgZGlmZiwgb25Kb2luLCBvbkxlYXZlKSB7XG4gICAgICAgIGNvbnN0IHsgam9pbnMsIGxlYXZlcyB9ID0ge1xuICAgICAgICAgICAgam9pbnM6IHRoaXMudHJhbnNmb3JtU3RhdGUoZGlmZi5qb2lucyksXG4gICAgICAgICAgICBsZWF2ZXM6IHRoaXMudHJhbnNmb3JtU3RhdGUoZGlmZi5sZWF2ZXMpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoIW9uSm9pbikge1xuICAgICAgICAgICAgb25Kb2luID0gKCkgPT4geyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghb25MZWF2ZSkge1xuICAgICAgICAgICAgb25MZWF2ZSA9ICgpID0+IHsgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hcChqb2lucywgKGtleSwgbmV3UHJlc2VuY2VzKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50UHJlc2VuY2VzID0gKF9hID0gc3RhdGVba2V5XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgICAgICAgICBzdGF0ZVtrZXldID0gdGhpcy5jbG9uZURlZXAobmV3UHJlc2VuY2VzKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UHJlc2VuY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBqb2luZWRQcmVzZW5jZVJlZnMgPSBzdGF0ZVtrZXldLm1hcCgobSkgPT4gbS5wcmVzZW5jZV9yZWYpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1clByZXNlbmNlcyA9IGN1cnJlbnRQcmVzZW5jZXMuZmlsdGVyKChtKSA9PiBqb2luZWRQcmVzZW5jZVJlZnMuaW5kZXhPZihtLnByZXNlbmNlX3JlZikgPCAwKTtcbiAgICAgICAgICAgICAgICBzdGF0ZVtrZXldLnVuc2hpZnQoLi4uY3VyUHJlc2VuY2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uSm9pbihrZXksIGN1cnJlbnRQcmVzZW5jZXMsIG5ld1ByZXNlbmNlcyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1hcChsZWF2ZXMsIChrZXksIGxlZnRQcmVzZW5jZXMpID0+IHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50UHJlc2VuY2VzID0gc3RhdGVba2V5XTtcbiAgICAgICAgICAgIGlmICghY3VycmVudFByZXNlbmNlcylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBwcmVzZW5jZVJlZnNUb1JlbW92ZSA9IGxlZnRQcmVzZW5jZXMubWFwKChtKSA9PiBtLnByZXNlbmNlX3JlZik7XG4gICAgICAgICAgICBjdXJyZW50UHJlc2VuY2VzID0gY3VycmVudFByZXNlbmNlcy5maWx0ZXIoKG0pID0+IHByZXNlbmNlUmVmc1RvUmVtb3ZlLmluZGV4T2YobS5wcmVzZW5jZV9yZWYpIDwgMCk7XG4gICAgICAgICAgICBzdGF0ZVtrZXldID0gY3VycmVudFByZXNlbmNlcztcbiAgICAgICAgICAgIG9uTGVhdmUoa2V5LCBjdXJyZW50UHJlc2VuY2VzLCBsZWZ0UHJlc2VuY2VzKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UHJlc2VuY2VzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICBkZWxldGUgc3RhdGVba2V5XTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHN0YXRpYyBtYXAob2JqLCBmdW5jKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLm1hcCgoa2V5KSA9PiBmdW5jKGtleSwgb2JqW2tleV0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlICdtZXRhcycga2V5XG4gICAgICogQ2hhbmdlICdwaHhfcmVmJyB0byAncHJlc2VuY2VfcmVmJ1xuICAgICAqIFJlbW92ZSAncGh4X3JlZicgYW5kICdwaHhfcmVmX3ByZXYnXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIHJldHVybnMge1xuICAgICAqICBhYmMxMjM6IFtcbiAgICAgKiAgICB7IHByZXNlbmNlX3JlZjogJzInLCB1c2VyX2lkOiAxIH0sXG4gICAgICogICAgeyBwcmVzZW5jZV9yZWY6ICczJywgdXNlcl9pZDogMiB9XG4gICAgICogIF1cbiAgICAgKiB9XG4gICAgICogUmVhbHRpbWVQcmVzZW5jZS50cmFuc2Zvcm1TdGF0ZSh7XG4gICAgICogIGFiYzEyMzoge1xuICAgICAqICAgIG1ldGFzOiBbXG4gICAgICogICAgICB7IHBoeF9yZWY6ICcyJywgcGh4X3JlZl9wcmV2OiAnMScgdXNlcl9pZDogMSB9LFxuICAgICAqICAgICAgeyBwaHhfcmVmOiAnMycsIHVzZXJfaWQ6IDIgfVxuICAgICAqICAgIF1cbiAgICAgKiAgfVxuICAgICAqIH0pXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdGF0aWMgdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgICAgICAgc3RhdGUgPSB0aGlzLmNsb25lRGVlcChzdGF0ZSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzdGF0ZSkucmVkdWNlKChuZXdTdGF0ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcmVzZW5jZXMgPSBzdGF0ZVtrZXldO1xuICAgICAgICAgICAgaWYgKCdtZXRhcycgaW4gcHJlc2VuY2VzKSB7XG4gICAgICAgICAgICAgICAgbmV3U3RhdGVba2V5XSA9IHByZXNlbmNlcy5tZXRhcy5tYXAoKHByZXNlbmNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHByZXNlbmNlWydwcmVzZW5jZV9yZWYnXSA9IHByZXNlbmNlWydwaHhfcmVmJ107XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwcmVzZW5jZVsncGh4X3JlZiddO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcHJlc2VuY2VbJ3BoeF9yZWZfcHJldiddO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJlc2VuY2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZVtrZXldID0gcHJlc2VuY2VzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgICB9LCB7fSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBzdGF0aWMgY2xvbmVEZWVwKG9iaikge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIG9uSm9pbihjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmNhbGxlci5vbkpvaW4gPSBjYWxsYmFjaztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIG9uTGVhdmUoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5jYWxsZXIub25MZWF2ZSA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgb25TeW5jKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuY2FsbGVyLm9uU3luYyA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgaW5QZW5kaW5nU3luY1N0YXRlKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuam9pblJlZiB8fCB0aGlzLmpvaW5SZWYgIT09IHRoaXMuY2hhbm5lbC5fam9pblJlZigpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlYWx0aW1lUHJlc2VuY2UuanMubWFwIiwiLypcbiAgVGhpcyBmaWxlIGRyYXdzIGhlYXZpbHkgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vcGhvZW5peGZyYW1ld29yay9waG9lbml4L2Jsb2IvZDM0NGVjMGE3MzJhYjRlZTIwNDIxNWIzMWRlNjljZjRiZTcyZTNiZi9hc3NldHMvanMvcGhvZW5peC9wcmVzZW5jZS5qc1xuICBMaWNlbnNlOiBodHRwczovL2dpdGh1Yi5jb20vcGhvZW5peGZyYW1ld29yay9waG9lbml4L2Jsb2IvZDM0NGVjMGE3MzJhYjRlZTIwNDIxNWIzMWRlNjljZjRiZTcyZTNiZi9MSUNFTlNFLm1kXG4qL1xuXG5pbXBvcnQgdHlwZSB7XG4gIFByZXNlbmNlT3B0cyxcbiAgUHJlc2VuY2VPbkpvaW5DYWxsYmFjayxcbiAgUHJlc2VuY2VPbkxlYXZlQ2FsbGJhY2ssXG59IGZyb20gJ3Bob2VuaXgnXG5pbXBvcnQgdHlwZSBSZWFsdGltZUNoYW5uZWwgZnJvbSAnLi9SZWFsdGltZUNoYW5uZWwnXG5cbnR5cGUgUHJlc2VuY2U8VCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogYW55IH0gPSB7fT4gPSB7XG4gIHByZXNlbmNlX3JlZjogc3RyaW5nXG59ICYgVFxuXG5leHBvcnQgdHlwZSBSZWFsdGltZVByZXNlbmNlU3RhdGU8VCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogYW55IH0gPSB7fT4gPSB7XG4gIFtrZXk6IHN0cmluZ106IFByZXNlbmNlPFQ+W11cbn1cblxuZXhwb3J0IHR5cGUgUmVhbHRpbWVQcmVzZW5jZUpvaW5QYXlsb2FkPFQgZXh0ZW5kcyB7IFtrZXk6IHN0cmluZ106IGFueSB9PiA9IHtcbiAgZXZlbnQ6IGAke1JFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFMuSk9JTn1gXG4gIGtleTogc3RyaW5nXG4gIGN1cnJlbnRQcmVzZW5jZXM6IFByZXNlbmNlPFQ+W11cbiAgbmV3UHJlc2VuY2VzOiBQcmVzZW5jZTxUPltdXG59XG5cbmV4cG9ydCB0eXBlIFJlYWx0aW1lUHJlc2VuY2VMZWF2ZVBheWxvYWQ8VCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogYW55IH0+ID0ge1xuICBldmVudDogYCR7UkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UUy5MRUFWRX1gXG4gIGtleTogc3RyaW5nXG4gIGN1cnJlbnRQcmVzZW5jZXM6IFByZXNlbmNlPFQ+W11cbiAgbGVmdFByZXNlbmNlczogUHJlc2VuY2U8VD5bXVxufVxuXG5leHBvcnQgZW51bSBSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTIHtcbiAgU1lOQyA9ICdzeW5jJyxcbiAgSk9JTiA9ICdqb2luJyxcbiAgTEVBVkUgPSAnbGVhdmUnLFxufVxuXG50eXBlIFByZXNlbmNlRGlmZiA9IHtcbiAgam9pbnM6IFJlYWx0aW1lUHJlc2VuY2VTdGF0ZVxuICBsZWF2ZXM6IFJlYWx0aW1lUHJlc2VuY2VTdGF0ZVxufVxuXG50eXBlIFJhd1ByZXNlbmNlU3RhdGUgPSB7XG4gIFtrZXk6IHN0cmluZ106IHtcbiAgICBtZXRhczoge1xuICAgICAgcGh4X3JlZj86IHN0cmluZ1xuICAgICAgcGh4X3JlZl9wcmV2Pzogc3RyaW5nXG4gICAgICBba2V5OiBzdHJpbmddOiBhbnlcbiAgICB9W11cbiAgfVxufVxuXG50eXBlIFJhd1ByZXNlbmNlRGlmZiA9IHtcbiAgam9pbnM6IFJhd1ByZXNlbmNlU3RhdGVcbiAgbGVhdmVzOiBSYXdQcmVzZW5jZVN0YXRlXG59XG5cbnR5cGUgUHJlc2VuY2VDaG9vc2VyPFQ+ID0gKGtleTogc3RyaW5nLCBwcmVzZW5jZXM6IFByZXNlbmNlW10pID0+IFRcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVhbHRpbWVQcmVzZW5jZSB7XG4gIHN0YXRlOiBSZWFsdGltZVByZXNlbmNlU3RhdGUgPSB7fVxuICBwZW5kaW5nRGlmZnM6IFJhd1ByZXNlbmNlRGlmZltdID0gW11cbiAgam9pblJlZjogc3RyaW5nIHwgbnVsbCA9IG51bGxcbiAgY2FsbGVyOiB7XG4gICAgb25Kb2luOiBQcmVzZW5jZU9uSm9pbkNhbGxiYWNrXG4gICAgb25MZWF2ZTogUHJlc2VuY2VPbkxlYXZlQ2FsbGJhY2tcbiAgICBvblN5bmM6ICgpID0+IHZvaWRcbiAgfSA9IHtcbiAgICBvbkpvaW46ICgpID0+IHt9LFxuICAgIG9uTGVhdmU6ICgpID0+IHt9LFxuICAgIG9uU3luYzogKCkgPT4ge30sXG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIFByZXNlbmNlLlxuICAgKlxuICAgKiBAcGFyYW0gY2hhbm5lbCAtIFRoZSBSZWFsdGltZUNoYW5uZWxcbiAgICogQHBhcmFtIG9wdHMgLSBUaGUgb3B0aW9ucyxcbiAgICogICAgICAgIGZvciBleGFtcGxlIGB7ZXZlbnRzOiB7c3RhdGU6ICdzdGF0ZScsIGRpZmY6ICdkaWZmJ319YFxuICAgKi9cbiAgY29uc3RydWN0b3IocHVibGljIGNoYW5uZWw6IFJlYWx0aW1lQ2hhbm5lbCwgb3B0cz86IFByZXNlbmNlT3B0cykge1xuICAgIGNvbnN0IGV2ZW50cyA9IG9wdHM/LmV2ZW50cyB8fCB7XG4gICAgICBzdGF0ZTogJ3ByZXNlbmNlX3N0YXRlJyxcbiAgICAgIGRpZmY6ICdwcmVzZW5jZV9kaWZmJyxcbiAgICB9XG5cbiAgICB0aGlzLmNoYW5uZWwuX29uKGV2ZW50cy5zdGF0ZSwge30sIChuZXdTdGF0ZTogUmF3UHJlc2VuY2VTdGF0ZSkgPT4ge1xuICAgICAgY29uc3QgeyBvbkpvaW4sIG9uTGVhdmUsIG9uU3luYyB9ID0gdGhpcy5jYWxsZXJcblxuICAgICAgdGhpcy5qb2luUmVmID0gdGhpcy5jaGFubmVsLl9qb2luUmVmKClcblxuICAgICAgdGhpcy5zdGF0ZSA9IFJlYWx0aW1lUHJlc2VuY2Uuc3luY1N0YXRlKFxuICAgICAgICB0aGlzLnN0YXRlLFxuICAgICAgICBuZXdTdGF0ZSxcbiAgICAgICAgb25Kb2luLFxuICAgICAgICBvbkxlYXZlXG4gICAgICApXG5cbiAgICAgIHRoaXMucGVuZGluZ0RpZmZzLmZvckVhY2goKGRpZmYpID0+IHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFJlYWx0aW1lUHJlc2VuY2Uuc3luY0RpZmYoXG4gICAgICAgICAgdGhpcy5zdGF0ZSxcbiAgICAgICAgICBkaWZmLFxuICAgICAgICAgIG9uSm9pbixcbiAgICAgICAgICBvbkxlYXZlXG4gICAgICAgIClcbiAgICAgIH0pXG5cbiAgICAgIHRoaXMucGVuZGluZ0RpZmZzID0gW11cblxuICAgICAgb25TeW5jKClcbiAgICB9KVxuXG4gICAgdGhpcy5jaGFubmVsLl9vbihldmVudHMuZGlmZiwge30sIChkaWZmOiBSYXdQcmVzZW5jZURpZmYpID0+IHtcbiAgICAgIGNvbnN0IHsgb25Kb2luLCBvbkxlYXZlLCBvblN5bmMgfSA9IHRoaXMuY2FsbGVyXG5cbiAgICAgIGlmICh0aGlzLmluUGVuZGluZ1N5bmNTdGF0ZSgpKSB7XG4gICAgICAgIHRoaXMucGVuZGluZ0RpZmZzLnB1c2goZGlmZilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBSZWFsdGltZVByZXNlbmNlLnN5bmNEaWZmKFxuICAgICAgICAgIHRoaXMuc3RhdGUsXG4gICAgICAgICAgZGlmZixcbiAgICAgICAgICBvbkpvaW4sXG4gICAgICAgICAgb25MZWF2ZVxuICAgICAgICApXG5cbiAgICAgICAgb25TeW5jKClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpcy5vbkpvaW4oKGtleSwgY3VycmVudFByZXNlbmNlcywgbmV3UHJlc2VuY2VzKSA9PiB7XG4gICAgICB0aGlzLmNoYW5uZWwuX3RyaWdnZXIoJ3ByZXNlbmNlJywge1xuICAgICAgICBldmVudDogJ2pvaW4nLFxuICAgICAgICBrZXksXG4gICAgICAgIGN1cnJlbnRQcmVzZW5jZXMsXG4gICAgICAgIG5ld1ByZXNlbmNlcyxcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIHRoaXMub25MZWF2ZSgoa2V5LCBjdXJyZW50UHJlc2VuY2VzLCBsZWZ0UHJlc2VuY2VzKSA9PiB7XG4gICAgICB0aGlzLmNoYW5uZWwuX3RyaWdnZXIoJ3ByZXNlbmNlJywge1xuICAgICAgICBldmVudDogJ2xlYXZlJyxcbiAgICAgICAga2V5LFxuICAgICAgICBjdXJyZW50UHJlc2VuY2VzLFxuICAgICAgICBsZWZ0UHJlc2VuY2VzLFxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgdGhpcy5vblN5bmMoKCkgPT4ge1xuICAgICAgdGhpcy5jaGFubmVsLl90cmlnZ2VyKCdwcmVzZW5jZScsIHsgZXZlbnQ6ICdzeW5jJyB9KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogVXNlZCB0byBzeW5jIHRoZSBsaXN0IG9mIHByZXNlbmNlcyBvbiB0aGUgc2VydmVyIHdpdGggdGhlXG4gICAqIGNsaWVudCdzIHN0YXRlLlxuICAgKlxuICAgKiBBbiBvcHRpb25hbCBgb25Kb2luYCBhbmQgYG9uTGVhdmVgIGNhbGxiYWNrIGNhbiBiZSBwcm92aWRlZCB0b1xuICAgKiByZWFjdCB0byBjaGFuZ2VzIGluIHRoZSBjbGllbnQncyBsb2NhbCBwcmVzZW5jZXMgYWNyb3NzXG4gICAqIGRpc2Nvbm5lY3RzIGFuZCByZWNvbm5lY3RzIHdpdGggdGhlIHNlcnZlci5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBzeW5jU3RhdGUoXG4gICAgY3VycmVudFN0YXRlOiBSZWFsdGltZVByZXNlbmNlU3RhdGUsXG4gICAgbmV3U3RhdGU6IFJhd1ByZXNlbmNlU3RhdGUgfCBSZWFsdGltZVByZXNlbmNlU3RhdGUsXG4gICAgb25Kb2luOiBQcmVzZW5jZU9uSm9pbkNhbGxiYWNrLFxuICAgIG9uTGVhdmU6IFByZXNlbmNlT25MZWF2ZUNhbGxiYWNrXG4gICk6IFJlYWx0aW1lUHJlc2VuY2VTdGF0ZSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLmNsb25lRGVlcChjdXJyZW50U3RhdGUpXG4gICAgY29uc3QgdHJhbnNmb3JtZWRTdGF0ZSA9IHRoaXMudHJhbnNmb3JtU3RhdGUobmV3U3RhdGUpXG4gICAgY29uc3Qgam9pbnM6IFJlYWx0aW1lUHJlc2VuY2VTdGF0ZSA9IHt9XG4gICAgY29uc3QgbGVhdmVzOiBSZWFsdGltZVByZXNlbmNlU3RhdGUgPSB7fVxuXG4gICAgdGhpcy5tYXAoc3RhdGUsIChrZXk6IHN0cmluZywgcHJlc2VuY2VzOiBQcmVzZW5jZVtdKSA9PiB7XG4gICAgICBpZiAoIXRyYW5zZm9ybWVkU3RhdGVba2V5XSkge1xuICAgICAgICBsZWF2ZXNba2V5XSA9IHByZXNlbmNlc1xuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLm1hcCh0cmFuc2Zvcm1lZFN0YXRlLCAoa2V5LCBuZXdQcmVzZW5jZXM6IFByZXNlbmNlW10pID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRQcmVzZW5jZXM6IFByZXNlbmNlW10gPSBzdGF0ZVtrZXldXG5cbiAgICAgIGlmIChjdXJyZW50UHJlc2VuY2VzKSB7XG4gICAgICAgIGNvbnN0IG5ld1ByZXNlbmNlUmVmcyA9IG5ld1ByZXNlbmNlcy5tYXAoXG4gICAgICAgICAgKG06IFByZXNlbmNlKSA9PiBtLnByZXNlbmNlX3JlZlxuICAgICAgICApXG4gICAgICAgIGNvbnN0IGN1clByZXNlbmNlUmVmcyA9IGN1cnJlbnRQcmVzZW5jZXMubWFwKFxuICAgICAgICAgIChtOiBQcmVzZW5jZSkgPT4gbS5wcmVzZW5jZV9yZWZcbiAgICAgICAgKVxuICAgICAgICBjb25zdCBqb2luZWRQcmVzZW5jZXM6IFByZXNlbmNlW10gPSBuZXdQcmVzZW5jZXMuZmlsdGVyKFxuICAgICAgICAgIChtOiBQcmVzZW5jZSkgPT4gY3VyUHJlc2VuY2VSZWZzLmluZGV4T2YobS5wcmVzZW5jZV9yZWYpIDwgMFxuICAgICAgICApXG4gICAgICAgIGNvbnN0IGxlZnRQcmVzZW5jZXM6IFByZXNlbmNlW10gPSBjdXJyZW50UHJlc2VuY2VzLmZpbHRlcihcbiAgICAgICAgICAobTogUHJlc2VuY2UpID0+IG5ld1ByZXNlbmNlUmVmcy5pbmRleE9mKG0ucHJlc2VuY2VfcmVmKSA8IDBcbiAgICAgICAgKVxuXG4gICAgICAgIGlmIChqb2luZWRQcmVzZW5jZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGpvaW5zW2tleV0gPSBqb2luZWRQcmVzZW5jZXNcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZWZ0UHJlc2VuY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBsZWF2ZXNba2V5XSA9IGxlZnRQcmVzZW5jZXNcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgam9pbnNba2V5XSA9IG5ld1ByZXNlbmNlc1xuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gdGhpcy5zeW5jRGlmZihzdGF0ZSwgeyBqb2lucywgbGVhdmVzIH0sIG9uSm9pbiwgb25MZWF2ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIHN5bmMgYSBkaWZmIG9mIHByZXNlbmNlIGpvaW4gYW5kIGxlYXZlIGV2ZW50cyBmcm9tIHRoZVxuICAgKiBzZXJ2ZXIsIGFzIHRoZXkgaGFwcGVuLlxuICAgKlxuICAgKiBMaWtlIGBzeW5jU3RhdGVgLCBgc3luY0RpZmZgIGFjY2VwdHMgb3B0aW9uYWwgYG9uSm9pbmAgYW5kXG4gICAqIGBvbkxlYXZlYCBjYWxsYmFja3MgdG8gcmVhY3QgdG8gYSB1c2VyIGpvaW5pbmcgb3IgbGVhdmluZyBmcm9tIGFcbiAgICogZGV2aWNlLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIHN5bmNEaWZmKFxuICAgIHN0YXRlOiBSZWFsdGltZVByZXNlbmNlU3RhdGUsXG4gICAgZGlmZjogUmF3UHJlc2VuY2VEaWZmIHwgUHJlc2VuY2VEaWZmLFxuICAgIG9uSm9pbjogUHJlc2VuY2VPbkpvaW5DYWxsYmFjayxcbiAgICBvbkxlYXZlOiBQcmVzZW5jZU9uTGVhdmVDYWxsYmFja1xuICApOiBSZWFsdGltZVByZXNlbmNlU3RhdGUge1xuICAgIGNvbnN0IHsgam9pbnMsIGxlYXZlcyB9ID0ge1xuICAgICAgam9pbnM6IHRoaXMudHJhbnNmb3JtU3RhdGUoZGlmZi5qb2lucyksXG4gICAgICBsZWF2ZXM6IHRoaXMudHJhbnNmb3JtU3RhdGUoZGlmZi5sZWF2ZXMpLFxuICAgIH1cblxuICAgIGlmICghb25Kb2luKSB7XG4gICAgICBvbkpvaW4gPSAoKSA9PiB7fVxuICAgIH1cblxuICAgIGlmICghb25MZWF2ZSkge1xuICAgICAgb25MZWF2ZSA9ICgpID0+IHt9XG4gICAgfVxuXG4gICAgdGhpcy5tYXAoam9pbnMsIChrZXksIG5ld1ByZXNlbmNlczogUHJlc2VuY2VbXSkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudFByZXNlbmNlczogUHJlc2VuY2VbXSA9IHN0YXRlW2tleV0gPz8gW11cbiAgICAgIHN0YXRlW2tleV0gPSB0aGlzLmNsb25lRGVlcChuZXdQcmVzZW5jZXMpXG5cbiAgICAgIGlmIChjdXJyZW50UHJlc2VuY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3Qgam9pbmVkUHJlc2VuY2VSZWZzID0gc3RhdGVba2V5XS5tYXAoXG4gICAgICAgICAgKG06IFByZXNlbmNlKSA9PiBtLnByZXNlbmNlX3JlZlxuICAgICAgICApXG4gICAgICAgIGNvbnN0IGN1clByZXNlbmNlczogUHJlc2VuY2VbXSA9IGN1cnJlbnRQcmVzZW5jZXMuZmlsdGVyKFxuICAgICAgICAgIChtOiBQcmVzZW5jZSkgPT4gam9pbmVkUHJlc2VuY2VSZWZzLmluZGV4T2YobS5wcmVzZW5jZV9yZWYpIDwgMFxuICAgICAgICApXG5cbiAgICAgICAgc3RhdGVba2V5XS51bnNoaWZ0KC4uLmN1clByZXNlbmNlcylcbiAgICAgIH1cblxuICAgICAgb25Kb2luKGtleSwgY3VycmVudFByZXNlbmNlcywgbmV3UHJlc2VuY2VzKVxuICAgIH0pXG5cbiAgICB0aGlzLm1hcChsZWF2ZXMsIChrZXksIGxlZnRQcmVzZW5jZXM6IFByZXNlbmNlW10pID0+IHtcbiAgICAgIGxldCBjdXJyZW50UHJlc2VuY2VzOiBQcmVzZW5jZVtdID0gc3RhdGVba2V5XVxuXG4gICAgICBpZiAoIWN1cnJlbnRQcmVzZW5jZXMpIHJldHVyblxuXG4gICAgICBjb25zdCBwcmVzZW5jZVJlZnNUb1JlbW92ZSA9IGxlZnRQcmVzZW5jZXMubWFwKFxuICAgICAgICAobTogUHJlc2VuY2UpID0+IG0ucHJlc2VuY2VfcmVmXG4gICAgICApXG4gICAgICBjdXJyZW50UHJlc2VuY2VzID0gY3VycmVudFByZXNlbmNlcy5maWx0ZXIoXG4gICAgICAgIChtOiBQcmVzZW5jZSkgPT4gcHJlc2VuY2VSZWZzVG9SZW1vdmUuaW5kZXhPZihtLnByZXNlbmNlX3JlZikgPCAwXG4gICAgICApXG5cbiAgICAgIHN0YXRlW2tleV0gPSBjdXJyZW50UHJlc2VuY2VzXG5cbiAgICAgIG9uTGVhdmUoa2V5LCBjdXJyZW50UHJlc2VuY2VzLCBsZWZ0UHJlc2VuY2VzKVxuXG4gICAgICBpZiAoY3VycmVudFByZXNlbmNlcy5sZW5ndGggPT09IDApIGRlbGV0ZSBzdGF0ZVtrZXldXG4gICAgfSlcblxuICAgIHJldHVybiBzdGF0ZVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIHN0YXRpYyBtYXA8VCA9IGFueT4oXG4gICAgb2JqOiBSZWFsdGltZVByZXNlbmNlU3RhdGUsXG4gICAgZnVuYzogUHJlc2VuY2VDaG9vc2VyPFQ+XG4gICk6IFRbXSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubWFwKChrZXkpID0+IGZ1bmMoa2V5LCBvYmpba2V5XSkpXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlICdtZXRhcycga2V5XG4gICAqIENoYW5nZSAncGh4X3JlZicgdG8gJ3ByZXNlbmNlX3JlZidcbiAgICogUmVtb3ZlICdwaHhfcmVmJyBhbmQgJ3BoeF9yZWZfcHJldidcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogLy8gcmV0dXJucyB7XG4gICAqICBhYmMxMjM6IFtcbiAgICogICAgeyBwcmVzZW5jZV9yZWY6ICcyJywgdXNlcl9pZDogMSB9LFxuICAgKiAgICB7IHByZXNlbmNlX3JlZjogJzMnLCB1c2VyX2lkOiAyIH1cbiAgICogIF1cbiAgICogfVxuICAgKiBSZWFsdGltZVByZXNlbmNlLnRyYW5zZm9ybVN0YXRlKHtcbiAgICogIGFiYzEyMzoge1xuICAgKiAgICBtZXRhczogW1xuICAgKiAgICAgIHsgcGh4X3JlZjogJzInLCBwaHhfcmVmX3ByZXY6ICcxJyB1c2VyX2lkOiAxIH0sXG4gICAqICAgICAgeyBwaHhfcmVmOiAnMycsIHVzZXJfaWQ6IDIgfVxuICAgKiAgICBdXG4gICAqICB9XG4gICAqIH0pXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgdHJhbnNmb3JtU3RhdGUoXG4gICAgc3RhdGU6IFJhd1ByZXNlbmNlU3RhdGUgfCBSZWFsdGltZVByZXNlbmNlU3RhdGVcbiAgKTogUmVhbHRpbWVQcmVzZW5jZVN0YXRlIHtcbiAgICBzdGF0ZSA9IHRoaXMuY2xvbmVEZWVwKHN0YXRlKVxuXG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHN0YXRlKS5yZWR1Y2UoKG5ld1N0YXRlLCBrZXkpID0+IHtcbiAgICAgIGNvbnN0IHByZXNlbmNlcyA9IHN0YXRlW2tleV1cblxuICAgICAgaWYgKCdtZXRhcycgaW4gcHJlc2VuY2VzKSB7XG4gICAgICAgIG5ld1N0YXRlW2tleV0gPSBwcmVzZW5jZXMubWV0YXMubWFwKChwcmVzZW5jZSkgPT4ge1xuICAgICAgICAgIHByZXNlbmNlWydwcmVzZW5jZV9yZWYnXSA9IHByZXNlbmNlWydwaHhfcmVmJ11cblxuICAgICAgICAgIGRlbGV0ZSBwcmVzZW5jZVsncGh4X3JlZiddXG4gICAgICAgICAgZGVsZXRlIHByZXNlbmNlWydwaHhfcmVmX3ByZXYnXVxuXG4gICAgICAgICAgcmV0dXJuIHByZXNlbmNlXG4gICAgICAgIH0pIGFzIFByZXNlbmNlW11cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld1N0YXRlW2tleV0gPSBwcmVzZW5jZXNcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld1N0YXRlXG4gICAgfSwge30gYXMgUmVhbHRpbWVQcmVzZW5jZVN0YXRlKVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIHN0YXRpYyBjbG9uZURlZXAob2JqOiB7IFtrZXk6IHN0cmluZ106IGFueSB9KSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSlcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBvbkpvaW4oY2FsbGJhY2s6IFByZXNlbmNlT25Kb2luQ2FsbGJhY2spOiB2b2lkIHtcbiAgICB0aGlzLmNhbGxlci5vbkpvaW4gPSBjYWxsYmFja1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIG9uTGVhdmUoY2FsbGJhY2s6IFByZXNlbmNlT25MZWF2ZUNhbGxiYWNrKTogdm9pZCB7XG4gICAgdGhpcy5jYWxsZXIub25MZWF2ZSA9IGNhbGxiYWNrXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgb25TeW5jKGNhbGxiYWNrOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5jYWxsZXIub25TeW5jID0gY2FsbGJhY2tcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBpblBlbmRpbmdTeW5jU3RhdGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICF0aGlzLmpvaW5SZWYgfHwgdGhpcy5qb2luUmVmICE9PSB0aGlzLmNoYW5uZWwuX2pvaW5SZWYoKVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IChyZXF1aXJlKFwiLi9oZWxwZXJzL3dvcmtlci9qcy1sb2FkZXJcIikocmVxdWlyZSgnLi9oZWxwZXJzL2J1bmRsZS11cmwnKS5nZXRCdW5kbGVVUkwoJ2dMOUhRJykgKyBcIi4uLy4uL2Jyb3dzZXIuMTAxYjgyOGIuanNcIiArIFwiP1wiICsgRGF0ZS5ub3coKSkuY2F0Y2goZXJyID0+IHtkZWxldGUgbW9kdWxlLmJ1bmRsZS5jYWNoZVttb2R1bGUuaWRdOyB0aHJvdyBlcnI7fSkpLnRoZW4oKCkgPT4gbW9kdWxlLmJ1bmRsZS5yb290KCdib1JROScpKTsiLCJleHBvcnQgeyBTdG9yYWdlQ2xpZW50IGFzIFN0b3JhZ2VDbGllbnQgfSBmcm9tICcuL1N0b3JhZ2VDbGllbnQnO1xuZXhwb3J0ICogZnJvbSAnLi9saWIvdHlwZXMnO1xuZXhwb3J0ICogZnJvbSAnLi9saWIvZXJyb3JzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImV4cG9ydCB7IFN0b3JhZ2VDbGllbnQgYXMgU3RvcmFnZUNsaWVudCB9IGZyb20gJy4vU3RvcmFnZUNsaWVudCdcbmV4cG9ydCAqIGZyb20gJy4vbGliL3R5cGVzJ1xuZXhwb3J0ICogZnJvbSAnLi9saWIvZXJyb3JzJ1xuIiwiaW1wb3J0IFN0b3JhZ2VGaWxlQXBpIGZyb20gJy4vcGFja2FnZXMvU3RvcmFnZUZpbGVBcGknO1xuaW1wb3J0IFN0b3JhZ2VCdWNrZXRBcGkgZnJvbSAnLi9wYWNrYWdlcy9TdG9yYWdlQnVja2V0QXBpJztcbmV4cG9ydCBjbGFzcyBTdG9yYWdlQ2xpZW50IGV4dGVuZHMgU3RvcmFnZUJ1Y2tldEFwaSB7XG4gICAgY29uc3RydWN0b3IodXJsLCBoZWFkZXJzID0ge30sIGZldGNoKSB7XG4gICAgICAgIHN1cGVyKHVybCwgaGVhZGVycywgZmV0Y2gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGZpbGUgb3BlcmF0aW9uIGluIGEgYnVja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIFRoZSBidWNrZXQgaWQgdG8gb3BlcmF0ZSBvbi5cbiAgICAgKi9cbiAgICBmcm9tKGlkKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RvcmFnZUZpbGVBcGkodGhpcy51cmwsIHRoaXMuaGVhZGVycywgaWQsIHRoaXMuZmV0Y2gpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0b3JhZ2VDbGllbnQuanMubWFwIiwiaW1wb3J0IFN0b3JhZ2VGaWxlQXBpIGZyb20gJy4vcGFja2FnZXMvU3RvcmFnZUZpbGVBcGknXG5pbXBvcnQgU3RvcmFnZUJ1Y2tldEFwaSBmcm9tICcuL3BhY2thZ2VzL1N0b3JhZ2VCdWNrZXRBcGknXG5pbXBvcnQgeyBGZXRjaCB9IGZyb20gJy4vbGliL2ZldGNoJ1xuXG5leHBvcnQgY2xhc3MgU3RvcmFnZUNsaWVudCBleHRlbmRzIFN0b3JhZ2VCdWNrZXRBcGkge1xuICBjb25zdHJ1Y3Rvcih1cmw6IHN0cmluZywgaGVhZGVyczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9LCBmZXRjaD86IEZldGNoKSB7XG4gICAgc3VwZXIodXJsLCBoZWFkZXJzLCBmZXRjaClcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGZpbGUgb3BlcmF0aW9uIGluIGEgYnVja2V0LlxuICAgKlxuICAgKiBAcGFyYW0gaWQgVGhlIGJ1Y2tldCBpZCB0byBvcGVyYXRlIG9uLlxuICAgKi9cbiAgZnJvbShpZDogc3RyaW5nKTogU3RvcmFnZUZpbGVBcGkge1xuICAgIHJldHVybiBuZXcgU3RvcmFnZUZpbGVBcGkodGhpcy51cmwsIHRoaXMuaGVhZGVycywgaWQsIHRoaXMuZmV0Y2gpXG4gIH1cbn1cbiIsInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgaXNTdG9yYWdlRXJyb3IsIFN0b3JhZ2VFcnJvciB9IGZyb20gJy4uL2xpYi9lcnJvcnMnO1xuaW1wb3J0IHsgZ2V0LCBwb3N0LCByZW1vdmUgfSBmcm9tICcuLi9saWIvZmV0Y2gnO1xuaW1wb3J0IHsgcmVzb2x2ZUZldGNoIH0gZnJvbSAnLi4vbGliL2hlbHBlcnMnO1xuY29uc3QgREVGQVVMVF9TRUFSQ0hfT1BUSU9OUyA9IHtcbiAgICBsaW1pdDogMTAwLFxuICAgIG9mZnNldDogMCxcbiAgICBzb3J0Qnk6IHtcbiAgICAgICAgY29sdW1uOiAnbmFtZScsXG4gICAgICAgIG9yZGVyOiAnYXNjJyxcbiAgICB9LFxufTtcbmNvbnN0IERFRkFVTFRfRklMRV9PUFRJT05TID0ge1xuICAgIGNhY2hlQ29udHJvbDogJzM2MDAnLFxuICAgIGNvbnRlbnRUeXBlOiAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04JyxcbiAgICB1cHNlcnQ6IGZhbHNlLFxufTtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0b3JhZ2VGaWxlQXBpIHtcbiAgICBjb25zdHJ1Y3Rvcih1cmwsIGhlYWRlcnMgPSB7fSwgYnVja2V0SWQsIGZldGNoKSB7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICB0aGlzLmJ1Y2tldElkID0gYnVja2V0SWQ7XG4gICAgICAgIHRoaXMuZmV0Y2ggPSByZXNvbHZlRmV0Y2goZmV0Y2gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIGEgZmlsZSB0byBhbiBleGlzdGluZyBidWNrZXQgb3IgcmVwbGFjZXMgYW4gZXhpc3RpbmcgZmlsZSBhdCB0aGUgc3BlY2lmaWVkIHBhdGggd2l0aCBhIG5ldyBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWV0aG9kIEhUVFAgbWV0aG9kLlxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSByZWxhdGl2ZSBmaWxlIHBhdGguIFNob3VsZCBiZSBvZiB0aGUgZm9ybWF0IGBmb2xkZXIvc3ViZm9sZGVyL2ZpbGVuYW1lLnBuZ2AuIFRoZSBidWNrZXQgbXVzdCBhbHJlYWR5IGV4aXN0IGJlZm9yZSBhdHRlbXB0aW5nIHRvIHVwbG9hZC5cbiAgICAgKiBAcGFyYW0gZmlsZUJvZHkgVGhlIGJvZHkgb2YgdGhlIGZpbGUgdG8gYmUgc3RvcmVkIGluIHRoZSBidWNrZXQuXG4gICAgICovXG4gICAgdXBsb2FkT3JVcGRhdGUobWV0aG9kLCBwYXRoLCBmaWxlQm9keSwgZmlsZU9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9GSUxFX09QVElPTlMpLCBmaWxlT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5oZWFkZXJzKSwgKG1ldGhvZCA9PT0gJ1BPU1QnICYmIHsgJ3gtdXBzZXJ0JzogU3RyaW5nKG9wdGlvbnMudXBzZXJ0KSB9KSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiBmaWxlQm9keSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICBib2R5LmFwcGVuZCgnY2FjaGVDb250cm9sJywgb3B0aW9ucy5jYWNoZUNvbnRyb2wpO1xuICAgICAgICAgICAgICAgICAgICBib2R5LmFwcGVuZCgnJywgZmlsZUJvZHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnICYmIGZpbGVCb2R5IGluc3RhbmNlb2YgRm9ybURhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IGZpbGVCb2R5O1xuICAgICAgICAgICAgICAgICAgICBib2R5LmFwcGVuZCgnY2FjaGVDb250cm9sJywgb3B0aW9ucy5jYWNoZUNvbnRyb2wpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IGZpbGVCb2R5O1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzWydjYWNoZS1jb250cm9sJ10gPSBgbWF4LWFnZT0ke29wdGlvbnMuY2FjaGVDb250cm9sfWA7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID0gb3B0aW9ucy5jb250ZW50VHlwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2xlYW5QYXRoID0gdGhpcy5fcmVtb3ZlRW1wdHlGb2xkZXJzKHBhdGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IF9wYXRoID0gdGhpcy5fZ2V0RmluYWxQYXRoKGNsZWFuUGF0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0geWllbGQgdGhpcy5mZXRjaChgJHt0aGlzLnVybH0vb2JqZWN0LyR7X3BhdGh9YCwgT2JqZWN0LmFzc2lnbih7IG1ldGhvZCwgYm9keTogYm9keSwgaGVhZGVycyB9LCAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kdXBsZXgpID8geyBkdXBsZXg6IG9wdGlvbnMuZHVwbGV4IH0gOiB7fSkpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0geWllbGQgcmVzLmpzb24oKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzLm9rKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7IHBhdGg6IGNsZWFuUGF0aCwgaWQ6IGRhdGEuSWQsIGZ1bGxQYXRoOiBkYXRhLktleSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwbG9hZHMgYSBmaWxlIHRvIGFuIGV4aXN0aW5nIGJ1Y2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgZmlsZSBuYW1lLiBTaG91bGQgYmUgb2YgdGhlIGZvcm1hdCBgZm9sZGVyL3N1YmZvbGRlci9maWxlbmFtZS5wbmdgLiBUaGUgYnVja2V0IG11c3QgYWxyZWFkeSBleGlzdCBiZWZvcmUgYXR0ZW1wdGluZyB0byB1cGxvYWQuXG4gICAgICogQHBhcmFtIGZpbGVCb2R5IFRoZSBib2R5IG9mIHRoZSBmaWxlIHRvIGJlIHN0b3JlZCBpbiB0aGUgYnVja2V0LlxuICAgICAqL1xuICAgIHVwbG9hZChwYXRoLCBmaWxlQm9keSwgZmlsZU9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwbG9hZE9yVXBkYXRlKCdQT1NUJywgcGF0aCwgZmlsZUJvZHksIGZpbGVPcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwbG9hZCBhIGZpbGUgd2l0aCBhIHRva2VuIGdlbmVyYXRlZCBmcm9tIGBjcmVhdGVTaWduZWRVcGxvYWRVcmxgLlxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgZmlsZSBuYW1lLiBTaG91bGQgYmUgb2YgdGhlIGZvcm1hdCBgZm9sZGVyL3N1YmZvbGRlci9maWxlbmFtZS5wbmdgLiBUaGUgYnVja2V0IG11c3QgYWxyZWFkeSBleGlzdCBiZWZvcmUgYXR0ZW1wdGluZyB0byB1cGxvYWQuXG4gICAgICogQHBhcmFtIHRva2VuIFRoZSB0b2tlbiBnZW5lcmF0ZWQgZnJvbSBgY3JlYXRlU2lnbmVkVXBsb2FkVXJsYFxuICAgICAqIEBwYXJhbSBmaWxlQm9keSBUaGUgYm9keSBvZiB0aGUgZmlsZSB0byBiZSBzdG9yZWQgaW4gdGhlIGJ1Y2tldC5cbiAgICAgKi9cbiAgICB1cGxvYWRUb1NpZ25lZFVybChwYXRoLCB0b2tlbiwgZmlsZUJvZHksIGZpbGVPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBjbGVhblBhdGggPSB0aGlzLl9yZW1vdmVFbXB0eUZvbGRlcnMocGF0aCk7XG4gICAgICAgICAgICBjb25zdCBfcGF0aCA9IHRoaXMuX2dldEZpbmFsUGF0aChjbGVhblBhdGgpO1xuICAgICAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTCh0aGlzLnVybCArIGAvb2JqZWN0L3VwbG9hZC9zaWduLyR7X3BhdGh9YCk7XG4gICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgndG9rZW4nLCB0b2tlbik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCBib2R5O1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgdXBzZXJ0OiBERUZBVUxUX0ZJTEVfT1BUSU9OUy51cHNlcnQgfSwgZmlsZU9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuaGVhZGVycyksIHsgJ3gtdXBzZXJ0JzogU3RyaW5nKG9wdGlvbnMudXBzZXJ0KSB9KTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIGZpbGVCb2R5IGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICAgICAgICAgICAgICBib2R5ID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgIGJvZHkuYXBwZW5kKCdjYWNoZUNvbnRyb2wnLCBvcHRpb25zLmNhY2hlQ29udHJvbCk7XG4gICAgICAgICAgICAgICAgICAgIGJvZHkuYXBwZW5kKCcnLCBmaWxlQm9keSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcgJiYgZmlsZUJvZHkgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBib2R5ID0gZmlsZUJvZHk7XG4gICAgICAgICAgICAgICAgICAgIGJvZHkuYXBwZW5kKCdjYWNoZUNvbnRyb2wnLCBvcHRpb25zLmNhY2hlQ29udHJvbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBib2R5ID0gZmlsZUJvZHk7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbJ2NhY2hlLWNvbnRyb2wnXSA9IGBtYXgtYWdlPSR7b3B0aW9ucy5jYWNoZUNvbnRyb2x9YDtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1snY29udGVudC10eXBlJ10gPSBvcHRpb25zLmNvbnRlbnRUeXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSB5aWVsZCB0aGlzLmZldGNoKHVybC50b1N0cmluZygpLCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHJlcy5qc29uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcy5vaykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogeyBwYXRoOiBjbGVhblBhdGgsIGZ1bGxQYXRoOiBkYXRhLktleSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzaWduZWQgdXBsb2FkIFVSTC5cbiAgICAgKiBTaWduZWQgdXBsb2FkIFVSTHMgY2FuIGJlIHVzZWQgdG8gdXBsb2FkIGZpbGVzIHRvIHRoZSBidWNrZXQgd2l0aG91dCBmdXJ0aGVyIGF1dGhlbnRpY2F0aW9uLlxuICAgICAqIFRoZXkgYXJlIHZhbGlkIGZvciAyIGhvdXJzLlxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgY3VycmVudCBmaWxlIG5hbWUuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UucG5nYC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy51cHNlcnQgSWYgc2V0IHRvIHRydWUsIGFsbG93cyB0aGUgZmlsZSB0byBiZSBvdmVyd3JpdHRlbiBpZiBpdCBhbHJlYWR5IGV4aXN0cy5cbiAgICAgKi9cbiAgICBjcmVhdGVTaWduZWRVcGxvYWRVcmwocGF0aCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgX3BhdGggPSB0aGlzLl9nZXRGaW5hbFBhdGgocGF0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuaGVhZGVycyk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy51cHNlcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1sneC11cHNlcnQnXSA9ICd0cnVlJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHBvc3QodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L29iamVjdC91cGxvYWQvc2lnbi8ke19wYXRofWAsIHt9LCB7IGhlYWRlcnMgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTCh0aGlzLnVybCArIGRhdGEudXJsKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0b2tlbiA9IHVybC5zZWFyY2hQYXJhbXMuZ2V0KCd0b2tlbicpO1xuICAgICAgICAgICAgICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN0b3JhZ2VFcnJvcignTm8gdG9rZW4gcmV0dXJuZWQgYnkgQVBJJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgc2lnbmVkVXJsOiB1cmwudG9TdHJpbmcoKSwgcGF0aCwgdG9rZW4gfSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBhbiBleGlzdGluZyBmaWxlIGF0IHRoZSBzcGVjaWZpZWQgcGF0aCB3aXRoIGEgbmV3IG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSByZWxhdGl2ZSBmaWxlIHBhdGguIFNob3VsZCBiZSBvZiB0aGUgZm9ybWF0IGBmb2xkZXIvc3ViZm9sZGVyL2ZpbGVuYW1lLnBuZ2AuIFRoZSBidWNrZXQgbXVzdCBhbHJlYWR5IGV4aXN0IGJlZm9yZSBhdHRlbXB0aW5nIHRvIHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0gZmlsZUJvZHkgVGhlIGJvZHkgb2YgdGhlIGZpbGUgdG8gYmUgc3RvcmVkIGluIHRoZSBidWNrZXQuXG4gICAgICovXG4gICAgdXBkYXRlKHBhdGgsIGZpbGVCb2R5LCBmaWxlT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBsb2FkT3JVcGRhdGUoJ1BVVCcsIHBhdGgsIGZpbGVCb2R5LCBmaWxlT3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhbiBleGlzdGluZyBmaWxlIHRvIGEgbmV3IHBhdGggaW4gdGhlIHNhbWUgYnVja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGZyb21QYXRoIFRoZSBvcmlnaW5hbCBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgY3VycmVudCBmaWxlIG5hbWUuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UucG5nYC5cbiAgICAgKiBAcGFyYW0gdG9QYXRoIFRoZSBuZXcgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIG5ldyBmaWxlIG5hbWUuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UtbmV3LnBuZ2AuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGRlc3RpbmF0aW9uIG9wdGlvbnMuXG4gICAgICovXG4gICAgbW92ZShmcm9tUGF0aCwgdG9QYXRoLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB5aWVsZCBwb3N0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9vYmplY3QvbW92ZWAsIHtcbiAgICAgICAgICAgICAgICAgICAgYnVja2V0SWQ6IHRoaXMuYnVja2V0SWQsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZUtleTogZnJvbVBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uS2V5OiB0b1BhdGgsXG4gICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uQnVja2V0OiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVzdGluYXRpb25CdWNrZXQsXG4gICAgICAgICAgICAgICAgfSwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgYW4gZXhpc3RpbmcgZmlsZSB0byBhIG5ldyBwYXRoIGluIHRoZSBzYW1lIGJ1Y2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmcm9tUGF0aCBUaGUgb3JpZ2luYWwgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGN1cnJlbnQgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLnBuZ2AuXG4gICAgICogQHBhcmFtIHRvUGF0aCBUaGUgbmV3IGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBuZXcgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLWNvcHkucG5nYC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgZGVzdGluYXRpb24gb3B0aW9ucy5cbiAgICAgKi9cbiAgICBjb3B5KGZyb21QYXRoLCB0b1BhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHBvc3QodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L29iamVjdC9jb3B5YCwge1xuICAgICAgICAgICAgICAgICAgICBidWNrZXRJZDogdGhpcy5idWNrZXRJZCxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlS2V5OiBmcm9tUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb25LZXk6IHRvUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb25CdWNrZXQ6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kZXN0aW5hdGlvbkJ1Y2tldCxcbiAgICAgICAgICAgICAgICB9LCB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHBhdGg6IGRhdGEuS2V5IH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNpZ25lZCBVUkwuIFVzZSBhIHNpZ25lZCBVUkwgdG8gc2hhcmUgYSBmaWxlIGZvciBhIGZpeGVkIGFtb3VudCBvZiB0aW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhdGggVGhlIGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBjdXJyZW50IGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuICAgICAqIEBwYXJhbSBleHBpcmVzSW4gVGhlIG51bWJlciBvZiBzZWNvbmRzIHVudGlsIHRoZSBzaWduZWQgVVJMIGV4cGlyZXMuIEZvciBleGFtcGxlLCBgNjBgIGZvciBhIFVSTCB3aGljaCBpcyB2YWxpZCBmb3Igb25lIG1pbnV0ZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5kb3dubG9hZCB0cmlnZ2VycyB0aGUgZmlsZSBhcyBhIGRvd25sb2FkIGlmIHNldCB0byB0cnVlLiBTZXQgdGhpcyBwYXJhbWV0ZXIgYXMgdGhlIG5hbWUgb2YgdGhlIGZpbGUgaWYgeW91IHdhbnQgdG8gdHJpZ2dlciB0aGUgZG93bmxvYWQgd2l0aCBhIGRpZmZlcmVudCBmaWxlbmFtZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy50cmFuc2Zvcm0gVHJhbnNmb3JtIHRoZSBhc3NldCBiZWZvcmUgc2VydmluZyBpdCB0byB0aGUgY2xpZW50LlxuICAgICAqL1xuICAgIGNyZWF0ZVNpZ25lZFVybChwYXRoLCBleHBpcmVzSW4sIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IF9wYXRoID0gdGhpcy5fZ2V0RmluYWxQYXRoKHBhdGgpO1xuICAgICAgICAgICAgICAgIGxldCBkYXRhID0geWllbGQgcG9zdCh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vb2JqZWN0L3NpZ24vJHtfcGF0aH1gLCBPYmplY3QuYXNzaWduKHsgZXhwaXJlc0luIH0sICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRyYW5zZm9ybSkgPyB7IHRyYW5zZm9ybTogb3B0aW9ucy50cmFuc2Zvcm0gfSA6IHt9KSksIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRvd25sb2FkUXVlcnlQYXJhbSA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZG93bmxvYWQpXG4gICAgICAgICAgICAgICAgICAgID8gYCZkb3dubG9hZD0ke29wdGlvbnMuZG93bmxvYWQgPT09IHRydWUgPyAnJyA6IG9wdGlvbnMuZG93bmxvYWR9YFxuICAgICAgICAgICAgICAgICAgICA6ICcnO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25lZFVybCA9IGVuY29kZVVSSShgJHt0aGlzLnVybH0ke2RhdGEuc2lnbmVkVVJMfSR7ZG93bmxvYWRRdWVyeVBhcmFtfWApO1xuICAgICAgICAgICAgICAgIGRhdGEgPSB7IHNpZ25lZFVybCB9O1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBtdWx0aXBsZSBzaWduZWQgVVJMcy4gVXNlIGEgc2lnbmVkIFVSTCB0byBzaGFyZSBhIGZpbGUgZm9yIGEgZml4ZWQgYW1vdW50IG9mIHRpbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aHMgVGhlIGZpbGUgcGF0aHMgdG8gYmUgZG93bmxvYWRlZCwgaW5jbHVkaW5nIHRoZSBjdXJyZW50IGZpbGUgbmFtZXMuIEZvciBleGFtcGxlIGBbJ2ZvbGRlci9pbWFnZS5wbmcnLCAnZm9sZGVyMi9pbWFnZTIucG5nJ11gLlxuICAgICAqIEBwYXJhbSBleHBpcmVzSW4gVGhlIG51bWJlciBvZiBzZWNvbmRzIHVudGlsIHRoZSBzaWduZWQgVVJMcyBleHBpcmUuIEZvciBleGFtcGxlLCBgNjBgIGZvciBVUkxzIHdoaWNoIGFyZSB2YWxpZCBmb3Igb25lIG1pbnV0ZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5kb3dubG9hZCB0cmlnZ2VycyB0aGUgZmlsZSBhcyBhIGRvd25sb2FkIGlmIHNldCB0byB0cnVlLiBTZXQgdGhpcyBwYXJhbWV0ZXIgYXMgdGhlIG5hbWUgb2YgdGhlIGZpbGUgaWYgeW91IHdhbnQgdG8gdHJpZ2dlciB0aGUgZG93bmxvYWQgd2l0aCBhIGRpZmZlcmVudCBmaWxlbmFtZS5cbiAgICAgKi9cbiAgICBjcmVhdGVTaWduZWRVcmxzKHBhdGhzLCBleHBpcmVzSW4sIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHBvc3QodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L29iamVjdC9zaWduLyR7dGhpcy5idWNrZXRJZH1gLCB7IGV4cGlyZXNJbiwgcGF0aHMgfSwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZG93bmxvYWRRdWVyeVBhcmFtID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kb3dubG9hZClcbiAgICAgICAgICAgICAgICAgICAgPyBgJmRvd25sb2FkPSR7b3B0aW9ucy5kb3dubG9hZCA9PT0gdHJ1ZSA/ICcnIDogb3B0aW9ucy5kb3dubG9hZH1gXG4gICAgICAgICAgICAgICAgICAgIDogJyc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YS5tYXAoKGRhdHVtKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkYXR1bSksIHsgc2lnbmVkVXJsOiBkYXR1bS5zaWduZWRVUkxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGVuY29kZVVSSShgJHt0aGlzLnVybH0ke2RhdHVtLnNpZ25lZFVSTH0ke2Rvd25sb2FkUXVlcnlQYXJhbX1gKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbCB9KSkpLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERvd25sb2FkcyBhIGZpbGUgZnJvbSBhIHByaXZhdGUgYnVja2V0LiBGb3IgcHVibGljIGJ1Y2tldHMsIG1ha2UgYSByZXF1ZXN0IHRvIHRoZSBVUkwgcmV0dXJuZWQgZnJvbSBgZ2V0UHVibGljVXJsYCBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhdGggVGhlIGZ1bGwgcGF0aCBhbmQgZmlsZSBuYW1lIG9mIHRoZSBmaWxlIHRvIGJlIGRvd25sb2FkZWQuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UucG5nYC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy50cmFuc2Zvcm0gVHJhbnNmb3JtIHRoZSBhc3NldCBiZWZvcmUgc2VydmluZyBpdCB0byB0aGUgY2xpZW50LlxuICAgICAqL1xuICAgIGRvd25sb2FkKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHdhbnRzVHJhbnNmb3JtYXRpb24gPSB0eXBlb2YgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50cmFuc2Zvcm0pICE9PSAndW5kZWZpbmVkJztcbiAgICAgICAgICAgIGNvbnN0IHJlbmRlclBhdGggPSB3YW50c1RyYW5zZm9ybWF0aW9uID8gJ3JlbmRlci9pbWFnZS9hdXRoZW50aWNhdGVkJyA6ICdvYmplY3QnO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtYXRpb25RdWVyeSA9IHRoaXMudHJhbnNmb3JtT3B0c1RvUXVlcnlTdHJpbmcoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50cmFuc2Zvcm0pIHx8IHt9KTtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5U3RyaW5nID0gdHJhbnNmb3JtYXRpb25RdWVyeSA/IGA/JHt0cmFuc2Zvcm1hdGlvblF1ZXJ5fWAgOiAnJztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgX3BhdGggPSB0aGlzLl9nZXRGaW5hbFBhdGgocGF0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0geWllbGQgZ2V0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS8ke3JlbmRlclBhdGh9LyR7X3BhdGh9JHtxdWVyeVN0cmluZ31gLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgbm9SZXNvbHZlSnNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0geWllbGQgcmVzLmJsb2IoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgc2ltcGxlIGNvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGdldCB0aGUgVVJMIGZvciBhbiBhc3NldCBpbiBhIHB1YmxpYyBidWNrZXQuIElmIHlvdSBkbyBub3Qgd2FudCB0byB1c2UgdGhpcyBmdW5jdGlvbiwgeW91IGNhbiBjb25zdHJ1Y3QgdGhlIHB1YmxpYyBVUkwgYnkgY29uY2F0ZW5hdGluZyB0aGUgYnVja2V0IFVSTCB3aXRoIHRoZSBwYXRoIHRvIHRoZSBhc3NldC5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHZlcmlmeSBpZiB0aGUgYnVja2V0IGlzIHB1YmxpYy4gSWYgYSBwdWJsaWMgVVJMIGlzIGNyZWF0ZWQgZm9yIGEgYnVja2V0IHdoaWNoIGlzIG5vdCBwdWJsaWMsIHlvdSB3aWxsIG5vdCBiZSBhYmxlIHRvIGRvd25sb2FkIHRoZSBhc3NldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIGFuZCBuYW1lIG9mIHRoZSBmaWxlIHRvIGdlbmVyYXRlIHRoZSBwdWJsaWMgVVJMIGZvci4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmRvd25sb2FkIFRyaWdnZXJzIHRoZSBmaWxlIGFzIGEgZG93bmxvYWQgaWYgc2V0IHRvIHRydWUuIFNldCB0aGlzIHBhcmFtZXRlciBhcyB0aGUgbmFtZSBvZiB0aGUgZmlsZSBpZiB5b3Ugd2FudCB0byB0cmlnZ2VyIHRoZSBkb3dubG9hZCB3aXRoIGEgZGlmZmVyZW50IGZpbGVuYW1lLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnRyYW5zZm9ybSBUcmFuc2Zvcm0gdGhlIGFzc2V0IGJlZm9yZSBzZXJ2aW5nIGl0IHRvIHRoZSBjbGllbnQuXG4gICAgICovXG4gICAgZ2V0UHVibGljVXJsKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgX3BhdGggPSB0aGlzLl9nZXRGaW5hbFBhdGgocGF0aCk7XG4gICAgICAgIGNvbnN0IF9xdWVyeVN0cmluZyA9IFtdO1xuICAgICAgICBjb25zdCBkb3dubG9hZFF1ZXJ5UGFyYW0gPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRvd25sb2FkKVxuICAgICAgICAgICAgPyBgZG93bmxvYWQ9JHtvcHRpb25zLmRvd25sb2FkID09PSB0cnVlID8gJycgOiBvcHRpb25zLmRvd25sb2FkfWBcbiAgICAgICAgICAgIDogJyc7XG4gICAgICAgIGlmIChkb3dubG9hZFF1ZXJ5UGFyYW0gIT09ICcnKSB7XG4gICAgICAgICAgICBfcXVlcnlTdHJpbmcucHVzaChkb3dubG9hZFF1ZXJ5UGFyYW0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdhbnRzVHJhbnNmb3JtYXRpb24gPSB0eXBlb2YgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50cmFuc2Zvcm0pICE9PSAndW5kZWZpbmVkJztcbiAgICAgICAgY29uc3QgcmVuZGVyUGF0aCA9IHdhbnRzVHJhbnNmb3JtYXRpb24gPyAncmVuZGVyL2ltYWdlJyA6ICdvYmplY3QnO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1hdGlvblF1ZXJ5ID0gdGhpcy50cmFuc2Zvcm1PcHRzVG9RdWVyeVN0cmluZygob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRyYW5zZm9ybSkgfHwge30pO1xuICAgICAgICBpZiAodHJhbnNmb3JtYXRpb25RdWVyeSAhPT0gJycpIHtcbiAgICAgICAgICAgIF9xdWVyeVN0cmluZy5wdXNoKHRyYW5zZm9ybWF0aW9uUXVlcnkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBxdWVyeVN0cmluZyA9IF9xdWVyeVN0cmluZy5qb2luKCcmJyk7XG4gICAgICAgIGlmIChxdWVyeVN0cmluZyAhPT0gJycpIHtcbiAgICAgICAgICAgIHF1ZXJ5U3RyaW5nID0gYD8ke3F1ZXJ5U3RyaW5nfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IHsgcHVibGljVXJsOiBlbmNvZGVVUkkoYCR7dGhpcy51cmx9LyR7cmVuZGVyUGF0aH0vcHVibGljLyR7X3BhdGh9JHtxdWVyeVN0cmluZ31gKSB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGZpbGVzIHdpdGhpbiB0aGUgc2FtZSBidWNrZXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRocyBBbiBhcnJheSBvZiBmaWxlcyB0byBkZWxldGUsIGluY2x1ZGluZyB0aGUgcGF0aCBhbmQgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBbYCdmb2xkZXIvaW1hZ2UucG5nJ2BdLlxuICAgICAqL1xuICAgIHJlbW92ZShwYXRocykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0geWllbGQgcmVtb3ZlKHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9vYmplY3QvJHt0aGlzLmJ1Y2tldElkfWAsIHsgcHJlZml4ZXM6IHBhdGhzIH0sIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGZpbGUgbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0gaWQgdGhlIGZpbGUgaWQgdG8gcmV0cmlldmUgbWV0YWRhdGFcbiAgICAgKi9cbiAgICAvLyBhc3luYyBnZXRNZXRhZGF0YShcbiAgICAvLyAgIGlkOiBzdHJpbmdcbiAgICAvLyApOiBQcm9taXNlPFxuICAgIC8vICAgfCB7XG4gICAgLy8gICAgICAgZGF0YTogTWV0YWRhdGFcbiAgICAvLyAgICAgICBlcnJvcjogbnVsbFxuICAgIC8vICAgICB9XG4gICAgLy8gICB8IHtcbiAgICAvLyAgICAgICBkYXRhOiBudWxsXG4gICAgLy8gICAgICAgZXJyb3I6IFN0b3JhZ2VFcnJvclxuICAgIC8vICAgICB9XG4gICAgLy8gPiB7XG4gICAgLy8gICB0cnkge1xuICAgIC8vICAgICBjb25zdCBkYXRhID0gYXdhaXQgZ2V0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9tZXRhZGF0YS8ke2lkfWAsIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH0pXG4gICAgLy8gICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH1cbiAgICAvLyAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAvLyAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgLy8gICAgIH1cbiAgICAvLyAgICAgdGhyb3cgZXJyb3JcbiAgICAvLyAgIH1cbiAgICAvLyB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGZpbGUgbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0gaWQgdGhlIGZpbGUgaWQgdG8gdXBkYXRlIG1ldGFkYXRhXG4gICAgICogQHBhcmFtIG1ldGEgdGhlIG5ldyBmaWxlIG1ldGFkYXRhXG4gICAgICovXG4gICAgLy8gYXN5bmMgdXBkYXRlTWV0YWRhdGEoXG4gICAgLy8gICBpZDogc3RyaW5nLFxuICAgIC8vICAgbWV0YTogTWV0YWRhdGFcbiAgICAvLyApOiBQcm9taXNlPFxuICAgIC8vICAgfCB7XG4gICAgLy8gICAgICAgZGF0YTogTWV0YWRhdGFcbiAgICAvLyAgICAgICBlcnJvcjogbnVsbFxuICAgIC8vICAgICB9XG4gICAgLy8gICB8IHtcbiAgICAvLyAgICAgICBkYXRhOiBudWxsXG4gICAgLy8gICAgICAgZXJyb3I6IFN0b3JhZ2VFcnJvclxuICAgIC8vICAgICB9XG4gICAgLy8gPiB7XG4gICAgLy8gICB0cnkge1xuICAgIC8vICAgICBjb25zdCBkYXRhID0gYXdhaXQgcG9zdChcbiAgICAvLyAgICAgICB0aGlzLmZldGNoLFxuICAgIC8vICAgICAgIGAke3RoaXMudXJsfS9tZXRhZGF0YS8ke2lkfWAsXG4gICAgLy8gICAgICAgeyAuLi5tZXRhIH0sXG4gICAgLy8gICAgICAgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfVxuICAgIC8vICAgICApXG4gICAgLy8gICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH1cbiAgICAvLyAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAvLyAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgLy8gICAgIH1cbiAgICAvLyAgICAgdGhyb3cgZXJyb3JcbiAgICAvLyAgIH1cbiAgICAvLyB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgYWxsIHRoZSBmaWxlcyB3aXRoaW4gYSBidWNrZXQuXG4gICAgICogQHBhcmFtIHBhdGggVGhlIGZvbGRlciBwYXRoLlxuICAgICAqL1xuICAgIGxpc3QocGF0aCwgb3B0aW9ucywgcGFyYW1ldGVycykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBib2R5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfU0VBUkNIX09QVElPTlMpLCBvcHRpb25zKSwgeyBwcmVmaXg6IHBhdGggfHwgJycgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHBvc3QodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L29iamVjdC9saXN0LyR7dGhpcy5idWNrZXRJZH1gLCBib2R5LCB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9LCBwYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9nZXRGaW5hbFBhdGgocGF0aCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5idWNrZXRJZH0vJHtwYXRofWA7XG4gICAgfVxuICAgIF9yZW1vdmVFbXB0eUZvbGRlcnMocGF0aCkge1xuICAgICAgICByZXR1cm4gcGF0aC5yZXBsYWNlKC9eXFwvfFxcLyQvZywgJycpLnJlcGxhY2UoL1xcLysvZywgJy8nKTtcbiAgICB9XG4gICAgdHJhbnNmb3JtT3B0c1RvUXVlcnlTdHJpbmcodHJhbnNmb3JtKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xuICAgICAgICBpZiAodHJhbnNmb3JtLndpZHRoKSB7XG4gICAgICAgICAgICBwYXJhbXMucHVzaChgd2lkdGg9JHt0cmFuc2Zvcm0ud2lkdGh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYW5zZm9ybS5oZWlnaHQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKGBoZWlnaHQ9JHt0cmFuc2Zvcm0uaGVpZ2h0fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFuc2Zvcm0ucmVzaXplKSB7XG4gICAgICAgICAgICBwYXJhbXMucHVzaChgcmVzaXplPSR7dHJhbnNmb3JtLnJlc2l6ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhbnNmb3JtLmZvcm1hdCkge1xuICAgICAgICAgICAgcGFyYW1zLnB1c2goYGZvcm1hdD0ke3RyYW5zZm9ybS5mb3JtYXR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYW5zZm9ybS5xdWFsaXR5KSB7XG4gICAgICAgICAgICBwYXJhbXMucHVzaChgcXVhbGl0eT0ke3RyYW5zZm9ybS5xdWFsaXR5fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbXMuam9pbignJicpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0b3JhZ2VGaWxlQXBpLmpzLm1hcCIsImltcG9ydCB7IGlzU3RvcmFnZUVycm9yLCBTdG9yYWdlRXJyb3IgfSBmcm9tICcuLi9saWIvZXJyb3JzJ1xuaW1wb3J0IHsgRmV0Y2gsIGdldCwgcG9zdCwgcmVtb3ZlIH0gZnJvbSAnLi4vbGliL2ZldGNoJ1xuaW1wb3J0IHsgcmVzb2x2ZUZldGNoIH0gZnJvbSAnLi4vbGliL2hlbHBlcnMnXG5pbXBvcnQge1xuICBGaWxlT2JqZWN0LFxuICBGaWxlT3B0aW9ucyxcbiAgU2VhcmNoT3B0aW9ucyxcbiAgRmV0Y2hQYXJhbWV0ZXJzLFxuICBUcmFuc2Zvcm1PcHRpb25zLFxuICBEZXN0aW5hdGlvbk9wdGlvbnMsXG59IGZyb20gJy4uL2xpYi90eXBlcydcblxuY29uc3QgREVGQVVMVF9TRUFSQ0hfT1BUSU9OUyA9IHtcbiAgbGltaXQ6IDEwMCxcbiAgb2Zmc2V0OiAwLFxuICBzb3J0Qnk6IHtcbiAgICBjb2x1bW46ICduYW1lJyxcbiAgICBvcmRlcjogJ2FzYycsXG4gIH0sXG59XG5cbmNvbnN0IERFRkFVTFRfRklMRV9PUFRJT05TOiBGaWxlT3B0aW9ucyA9IHtcbiAgY2FjaGVDb250cm9sOiAnMzYwMCcsXG4gIGNvbnRlbnRUeXBlOiAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04JyxcbiAgdXBzZXJ0OiBmYWxzZSxcbn1cblxudHlwZSBGaWxlQm9keSA9XG4gIHwgQXJyYXlCdWZmZXJcbiAgfCBBcnJheUJ1ZmZlclZpZXdcbiAgfCBCbG9iXG4gIHwgQnVmZmVyXG4gIHwgRmlsZVxuICB8IEZvcm1EYXRhXG4gIHwgTm9kZUpTLlJlYWRhYmxlU3RyZWFtXG4gIHwgUmVhZGFibGVTdHJlYW08VWludDhBcnJheT5cbiAgfCBVUkxTZWFyY2hQYXJhbXNcbiAgfCBzdHJpbmdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RvcmFnZUZpbGVBcGkge1xuICBwcm90ZWN0ZWQgdXJsOiBzdHJpbmdcbiAgcHJvdGVjdGVkIGhlYWRlcnM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH1cbiAgcHJvdGVjdGVkIGJ1Y2tldElkPzogc3RyaW5nXG4gIHByb3RlY3RlZCBmZXRjaDogRmV0Y2hcblxuICBjb25zdHJ1Y3RvcihcbiAgICB1cmw6IHN0cmluZyxcbiAgICBoZWFkZXJzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge30sXG4gICAgYnVja2V0SWQ/OiBzdHJpbmcsXG4gICAgZmV0Y2g/OiBGZXRjaFxuICApIHtcbiAgICB0aGlzLnVybCA9IHVybFxuICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnNcbiAgICB0aGlzLmJ1Y2tldElkID0gYnVja2V0SWRcbiAgICB0aGlzLmZldGNoID0gcmVzb2x2ZUZldGNoKGZldGNoKVxuICB9XG5cbiAgLyoqXG4gICAqIFVwbG9hZHMgYSBmaWxlIHRvIGFuIGV4aXN0aW5nIGJ1Y2tldCBvciByZXBsYWNlcyBhbiBleGlzdGluZyBmaWxlIGF0IHRoZSBzcGVjaWZpZWQgcGF0aCB3aXRoIGEgbmV3IG9uZS5cbiAgICpcbiAgICogQHBhcmFtIG1ldGhvZCBIVFRQIG1ldGhvZC5cbiAgICogQHBhcmFtIHBhdGggVGhlIHJlbGF0aXZlIGZpbGUgcGF0aC4gU2hvdWxkIGJlIG9mIHRoZSBmb3JtYXQgYGZvbGRlci9zdWJmb2xkZXIvZmlsZW5hbWUucG5nYC4gVGhlIGJ1Y2tldCBtdXN0IGFscmVhZHkgZXhpc3QgYmVmb3JlIGF0dGVtcHRpbmcgdG8gdXBsb2FkLlxuICAgKiBAcGFyYW0gZmlsZUJvZHkgVGhlIGJvZHkgb2YgdGhlIGZpbGUgdG8gYmUgc3RvcmVkIGluIHRoZSBidWNrZXQuXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHVwbG9hZE9yVXBkYXRlKFxuICAgIG1ldGhvZDogJ1BPU1QnIHwgJ1BVVCcsXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIGZpbGVCb2R5OiBGaWxlQm9keSxcbiAgICBmaWxlT3B0aW9ucz86IEZpbGVPcHRpb25zXG4gICk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHsgaWQ6IHN0cmluZzsgcGF0aDogc3RyaW5nOyBmdWxsUGF0aDogc3RyaW5nIH1cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgICB9XG4gID4ge1xuICAgIHRyeSB7XG4gICAgICBsZXQgYm9keVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHsgLi4uREVGQVVMVF9GSUxFX09QVElPTlMsIC4uLmZpbGVPcHRpb25zIH1cbiAgICAgIGNvbnN0IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgICAgIC4uLnRoaXMuaGVhZGVycyxcbiAgICAgICAgLi4uKG1ldGhvZCA9PT0gJ1BPU1QnICYmIHsgJ3gtdXBzZXJ0JzogU3RyaW5nKG9wdGlvbnMudXBzZXJ0IGFzIGJvb2xlYW4pIH0pLFxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIGZpbGVCb2R5IGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICBib2R5ID0gbmV3IEZvcm1EYXRhKClcbiAgICAgICAgYm9keS5hcHBlbmQoJ2NhY2hlQ29udHJvbCcsIG9wdGlvbnMuY2FjaGVDb250cm9sIGFzIHN0cmluZylcbiAgICAgICAgYm9keS5hcHBlbmQoJycsIGZpbGVCb2R5KVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnICYmIGZpbGVCb2R5IGluc3RhbmNlb2YgRm9ybURhdGEpIHtcbiAgICAgICAgYm9keSA9IGZpbGVCb2R5XG4gICAgICAgIGJvZHkuYXBwZW5kKCdjYWNoZUNvbnRyb2wnLCBvcHRpb25zLmNhY2hlQ29udHJvbCBhcyBzdHJpbmcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBib2R5ID0gZmlsZUJvZHlcbiAgICAgICAgaGVhZGVyc1snY2FjaGUtY29udHJvbCddID0gYG1heC1hZ2U9JHtvcHRpb25zLmNhY2hlQ29udHJvbH1gXG4gICAgICAgIGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID0gb3B0aW9ucy5jb250ZW50VHlwZSBhcyBzdHJpbmdcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2xlYW5QYXRoID0gdGhpcy5fcmVtb3ZlRW1wdHlGb2xkZXJzKHBhdGgpXG4gICAgICBjb25zdCBfcGF0aCA9IHRoaXMuX2dldEZpbmFsUGF0aChjbGVhblBhdGgpXG4gICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmZldGNoKGAke3RoaXMudXJsfS9vYmplY3QvJHtfcGF0aH1gLCB7XG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgYm9keTogYm9keSBhcyBCb2R5SW5pdCxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgLi4uKG9wdGlvbnM/LmR1cGxleCA/IHsgZHVwbGV4OiBvcHRpb25zLmR1cGxleCB9IDoge30pLFxuICAgICAgfSlcblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKClcblxuICAgICAgaWYgKHJlcy5vaykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IHsgcGF0aDogY2xlYW5QYXRoLCBpZDogZGF0YS5JZCwgZnVsbFBhdGg6IGRhdGEuS2V5IH0sXG4gICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gZGF0YVxuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGxvYWRzIGEgZmlsZSB0byBhbiBleGlzdGluZyBidWNrZXQuXG4gICAqXG4gICAqIEBwYXJhbSBwYXRoIFRoZSBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgZmlsZSBuYW1lLiBTaG91bGQgYmUgb2YgdGhlIGZvcm1hdCBgZm9sZGVyL3N1YmZvbGRlci9maWxlbmFtZS5wbmdgLiBUaGUgYnVja2V0IG11c3QgYWxyZWFkeSBleGlzdCBiZWZvcmUgYXR0ZW1wdGluZyB0byB1cGxvYWQuXG4gICAqIEBwYXJhbSBmaWxlQm9keSBUaGUgYm9keSBvZiB0aGUgZmlsZSB0byBiZSBzdG9yZWQgaW4gdGhlIGJ1Y2tldC5cbiAgICovXG4gIGFzeW5jIHVwbG9hZChcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgZmlsZUJvZHk6IEZpbGVCb2R5LFxuICAgIGZpbGVPcHRpb25zPzogRmlsZU9wdGlvbnNcbiAgKTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YTogeyBpZDogc3RyaW5nOyBwYXRoOiBzdHJpbmc7IGZ1bGxQYXRoOiBzdHJpbmcgfVxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgICAgIH1cbiAgPiB7XG4gICAgcmV0dXJuIHRoaXMudXBsb2FkT3JVcGRhdGUoJ1BPU1QnLCBwYXRoLCBmaWxlQm9keSwgZmlsZU9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogVXBsb2FkIGEgZmlsZSB3aXRoIGEgdG9rZW4gZ2VuZXJhdGVkIGZyb20gYGNyZWF0ZVNpZ25lZFVwbG9hZFVybGAuXG4gICAqIEBwYXJhbSBwYXRoIFRoZSBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgZmlsZSBuYW1lLiBTaG91bGQgYmUgb2YgdGhlIGZvcm1hdCBgZm9sZGVyL3N1YmZvbGRlci9maWxlbmFtZS5wbmdgLiBUaGUgYnVja2V0IG11c3QgYWxyZWFkeSBleGlzdCBiZWZvcmUgYXR0ZW1wdGluZyB0byB1cGxvYWQuXG4gICAqIEBwYXJhbSB0b2tlbiBUaGUgdG9rZW4gZ2VuZXJhdGVkIGZyb20gYGNyZWF0ZVNpZ25lZFVwbG9hZFVybGBcbiAgICogQHBhcmFtIGZpbGVCb2R5IFRoZSBib2R5IG9mIHRoZSBmaWxlIHRvIGJlIHN0b3JlZCBpbiB0aGUgYnVja2V0LlxuICAgKi9cbiAgYXN5bmMgdXBsb2FkVG9TaWduZWRVcmwoXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIHRva2VuOiBzdHJpbmcsXG4gICAgZmlsZUJvZHk6IEZpbGVCb2R5LFxuICAgIGZpbGVPcHRpb25zPzogRmlsZU9wdGlvbnNcbiAgKSB7XG4gICAgY29uc3QgY2xlYW5QYXRoID0gdGhpcy5fcmVtb3ZlRW1wdHlGb2xkZXJzKHBhdGgpXG4gICAgY29uc3QgX3BhdGggPSB0aGlzLl9nZXRGaW5hbFBhdGgoY2xlYW5QYXRoKVxuXG4gICAgY29uc3QgdXJsID0gbmV3IFVSTCh0aGlzLnVybCArIGAvb2JqZWN0L3VwbG9hZC9zaWduLyR7X3BhdGh9YClcbiAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgndG9rZW4nLCB0b2tlbilcblxuICAgIHRyeSB7XG4gICAgICBsZXQgYm9keVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHsgdXBzZXJ0OiBERUZBVUxUX0ZJTEVfT1BUSU9OUy51cHNlcnQsIC4uLmZpbGVPcHRpb25zIH1cbiAgICAgIGNvbnN0IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgICAgIC4uLnRoaXMuaGVhZGVycyxcbiAgICAgICAgLi4ueyAneC11cHNlcnQnOiBTdHJpbmcob3B0aW9ucy51cHNlcnQgYXMgYm9vbGVhbikgfSxcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiBmaWxlQm9keSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgYm9keSA9IG5ldyBGb3JtRGF0YSgpXG4gICAgICAgIGJvZHkuYXBwZW5kKCdjYWNoZUNvbnRyb2wnLCBvcHRpb25zLmNhY2hlQ29udHJvbCBhcyBzdHJpbmcpXG4gICAgICAgIGJvZHkuYXBwZW5kKCcnLCBmaWxlQm9keSlcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJyAmJiBmaWxlQm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG4gICAgICAgIGJvZHkgPSBmaWxlQm9keVxuICAgICAgICBib2R5LmFwcGVuZCgnY2FjaGVDb250cm9sJywgb3B0aW9ucy5jYWNoZUNvbnRyb2wgYXMgc3RyaW5nKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYm9keSA9IGZpbGVCb2R5XG4gICAgICAgIGhlYWRlcnNbJ2NhY2hlLWNvbnRyb2wnXSA9IGBtYXgtYWdlPSR7b3B0aW9ucy5jYWNoZUNvbnRyb2x9YFxuICAgICAgICBoZWFkZXJzWydjb250ZW50LXR5cGUnXSA9IG9wdGlvbnMuY29udGVudFR5cGUgYXMgc3RyaW5nXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZmV0Y2godXJsLnRvU3RyaW5nKCksIHtcbiAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgYm9keTogYm9keSBhcyBCb2R5SW5pdCxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpXG5cbiAgICAgIGlmIChyZXMub2spIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiB7IHBhdGg6IGNsZWFuUGF0aCwgZnVsbFBhdGg6IGRhdGEuS2V5IH0sXG4gICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gZGF0YVxuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc2lnbmVkIHVwbG9hZCBVUkwuXG4gICAqIFNpZ25lZCB1cGxvYWQgVVJMcyBjYW4gYmUgdXNlZCB0byB1cGxvYWQgZmlsZXMgdG8gdGhlIGJ1Y2tldCB3aXRob3V0IGZ1cnRoZXIgYXV0aGVudGljYXRpb24uXG4gICAqIFRoZXkgYXJlIHZhbGlkIGZvciAyIGhvdXJzLlxuICAgKiBAcGFyYW0gcGF0aCBUaGUgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGN1cnJlbnQgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLnBuZ2AuXG4gICAqIEBwYXJhbSBvcHRpb25zLnVwc2VydCBJZiBzZXQgdG8gdHJ1ZSwgYWxsb3dzIHRoZSBmaWxlIHRvIGJlIG92ZXJ3cml0dGVuIGlmIGl0IGFscmVhZHkgZXhpc3RzLlxuICAgKi9cbiAgYXN5bmMgY3JlYXRlU2lnbmVkVXBsb2FkVXJsKFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICBvcHRpb25zPzogeyB1cHNlcnQ6IGJvb2xlYW4gfVxuICApOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiB7IHNpZ25lZFVybDogc3RyaW5nOyB0b2tlbjogc3RyaW5nOyBwYXRoOiBzdHJpbmcgfVxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgICAgIH1cbiAgPiB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBfcGF0aCA9IHRoaXMuX2dldEZpbmFsUGF0aChwYXRoKVxuXG4gICAgICBjb25zdCBoZWFkZXJzID0geyAuLi50aGlzLmhlYWRlcnMgfVxuXG4gICAgICBpZiAob3B0aW9ucz8udXBzZXJ0KSB7XG4gICAgICAgIGhlYWRlcnNbJ3gtdXBzZXJ0J10gPSAndHJ1ZSdcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHBvc3QoXG4gICAgICAgIHRoaXMuZmV0Y2gsXG4gICAgICAgIGAke3RoaXMudXJsfS9vYmplY3QvdXBsb2FkL3NpZ24vJHtfcGF0aH1gLFxuICAgICAgICB7fSxcbiAgICAgICAgeyBoZWFkZXJzIH1cbiAgICAgIClcblxuICAgICAgY29uc3QgdXJsID0gbmV3IFVSTCh0aGlzLnVybCArIGRhdGEudXJsKVxuXG4gICAgICBjb25zdCB0b2tlbiA9IHVybC5zZWFyY2hQYXJhbXMuZ2V0KCd0b2tlbicpXG5cbiAgICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IFN0b3JhZ2VFcnJvcignTm8gdG9rZW4gcmV0dXJuZWQgYnkgQVBJJylcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgZGF0YTogeyBzaWduZWRVcmw6IHVybC50b1N0cmluZygpLCBwYXRoLCB0b2tlbiB9LCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbiBleGlzdGluZyBmaWxlIGF0IHRoZSBzcGVjaWZpZWQgcGF0aCB3aXRoIGEgbmV3IG9uZS5cbiAgICpcbiAgICogQHBhcmFtIHBhdGggVGhlIHJlbGF0aXZlIGZpbGUgcGF0aC4gU2hvdWxkIGJlIG9mIHRoZSBmb3JtYXQgYGZvbGRlci9zdWJmb2xkZXIvZmlsZW5hbWUucG5nYC4gVGhlIGJ1Y2tldCBtdXN0IGFscmVhZHkgZXhpc3QgYmVmb3JlIGF0dGVtcHRpbmcgdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0gZmlsZUJvZHkgVGhlIGJvZHkgb2YgdGhlIGZpbGUgdG8gYmUgc3RvcmVkIGluIHRoZSBidWNrZXQuXG4gICAqL1xuICBhc3luYyB1cGRhdGUoXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIGZpbGVCb2R5OlxuICAgICAgfCBBcnJheUJ1ZmZlclxuICAgICAgfCBBcnJheUJ1ZmZlclZpZXdcbiAgICAgIHwgQmxvYlxuICAgICAgfCBCdWZmZXJcbiAgICAgIHwgRmlsZVxuICAgICAgfCBGb3JtRGF0YVxuICAgICAgfCBOb2RlSlMuUmVhZGFibGVTdHJlYW1cbiAgICAgIHwgUmVhZGFibGVTdHJlYW08VWludDhBcnJheT5cbiAgICAgIHwgVVJMU2VhcmNoUGFyYW1zXG4gICAgICB8IHN0cmluZyxcbiAgICBmaWxlT3B0aW9ucz86IEZpbGVPcHRpb25zXG4gICk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHsgaWQ6IHN0cmluZzsgcGF0aDogc3RyaW5nOyBmdWxsUGF0aDogc3RyaW5nIH1cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgICB9XG4gID4ge1xuICAgIHJldHVybiB0aGlzLnVwbG9hZE9yVXBkYXRlKCdQVVQnLCBwYXRoLCBmaWxlQm9keSwgZmlsZU9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogTW92ZXMgYW4gZXhpc3RpbmcgZmlsZSB0byBhIG5ldyBwYXRoIGluIHRoZSBzYW1lIGJ1Y2tldC5cbiAgICpcbiAgICogQHBhcmFtIGZyb21QYXRoIFRoZSBvcmlnaW5hbCBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgY3VycmVudCBmaWxlIG5hbWUuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UucG5nYC5cbiAgICogQHBhcmFtIHRvUGF0aCBUaGUgbmV3IGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBuZXcgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLW5ldy5wbmdgLlxuICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgZGVzdGluYXRpb24gb3B0aW9ucy5cbiAgICovXG4gIGFzeW5jIG1vdmUoXG4gICAgZnJvbVBhdGg6IHN0cmluZyxcbiAgICB0b1BhdGg6IHN0cmluZyxcbiAgICBvcHRpb25zPzogRGVzdGluYXRpb25PcHRpb25zXG4gICk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHsgbWVzc2FnZTogc3RyaW5nIH1cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgICB9XG4gID4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcG9zdChcbiAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgYCR7dGhpcy51cmx9L29iamVjdC9tb3ZlYCxcbiAgICAgICAge1xuICAgICAgICAgIGJ1Y2tldElkOiB0aGlzLmJ1Y2tldElkLFxuICAgICAgICAgIHNvdXJjZUtleTogZnJvbVBhdGgsXG4gICAgICAgICAgZGVzdGluYXRpb25LZXk6IHRvUGF0aCxcbiAgICAgICAgICBkZXN0aW5hdGlvbkJ1Y2tldDogb3B0aW9ucz8uZGVzdGluYXRpb25CdWNrZXQsXG4gICAgICAgIH0sXG4gICAgICAgIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH1cbiAgICAgIClcbiAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvcGllcyBhbiBleGlzdGluZyBmaWxlIHRvIGEgbmV3IHBhdGggaW4gdGhlIHNhbWUgYnVja2V0LlxuICAgKlxuICAgKiBAcGFyYW0gZnJvbVBhdGggVGhlIG9yaWdpbmFsIGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBjdXJyZW50IGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuICAgKiBAcGFyYW0gdG9QYXRoIFRoZSBuZXcgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIG5ldyBmaWxlIG5hbWUuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UtY29weS5wbmdgLlxuICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgZGVzdGluYXRpb24gb3B0aW9ucy5cbiAgICovXG4gIGFzeW5jIGNvcHkoXG4gICAgZnJvbVBhdGg6IHN0cmluZyxcbiAgICB0b1BhdGg6IHN0cmluZyxcbiAgICBvcHRpb25zPzogRGVzdGluYXRpb25PcHRpb25zXG4gICk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHsgcGF0aDogc3RyaW5nIH1cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgICB9XG4gID4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcG9zdChcbiAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgYCR7dGhpcy51cmx9L29iamVjdC9jb3B5YCxcbiAgICAgICAge1xuICAgICAgICAgIGJ1Y2tldElkOiB0aGlzLmJ1Y2tldElkLFxuICAgICAgICAgIHNvdXJjZUtleTogZnJvbVBhdGgsXG4gICAgICAgICAgZGVzdGluYXRpb25LZXk6IHRvUGF0aCxcbiAgICAgICAgICBkZXN0aW5hdGlvbkJ1Y2tldDogb3B0aW9ucz8uZGVzdGluYXRpb25CdWNrZXQsXG4gICAgICAgIH0sXG4gICAgICAgIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH1cbiAgICAgIClcbiAgICAgIHJldHVybiB7IGRhdGE6IHsgcGF0aDogZGF0YS5LZXkgfSwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHNpZ25lZCBVUkwuIFVzZSBhIHNpZ25lZCBVUkwgdG8gc2hhcmUgYSBmaWxlIGZvciBhIGZpeGVkIGFtb3VudCBvZiB0aW1lLlxuICAgKlxuICAgKiBAcGFyYW0gcGF0aCBUaGUgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGN1cnJlbnQgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLnBuZ2AuXG4gICAqIEBwYXJhbSBleHBpcmVzSW4gVGhlIG51bWJlciBvZiBzZWNvbmRzIHVudGlsIHRoZSBzaWduZWQgVVJMIGV4cGlyZXMuIEZvciBleGFtcGxlLCBgNjBgIGZvciBhIFVSTCB3aGljaCBpcyB2YWxpZCBmb3Igb25lIG1pbnV0ZS5cbiAgICogQHBhcmFtIG9wdGlvbnMuZG93bmxvYWQgdHJpZ2dlcnMgdGhlIGZpbGUgYXMgYSBkb3dubG9hZCBpZiBzZXQgdG8gdHJ1ZS4gU2V0IHRoaXMgcGFyYW1ldGVyIGFzIHRoZSBuYW1lIG9mIHRoZSBmaWxlIGlmIHlvdSB3YW50IHRvIHRyaWdnZXIgdGhlIGRvd25sb2FkIHdpdGggYSBkaWZmZXJlbnQgZmlsZW5hbWUuXG4gICAqIEBwYXJhbSBvcHRpb25zLnRyYW5zZm9ybSBUcmFuc2Zvcm0gdGhlIGFzc2V0IGJlZm9yZSBzZXJ2aW5nIGl0IHRvIHRoZSBjbGllbnQuXG4gICAqL1xuICBhc3luYyBjcmVhdGVTaWduZWRVcmwoXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIGV4cGlyZXNJbjogbnVtYmVyLFxuICAgIG9wdGlvbnM/OiB7IGRvd25sb2FkPzogc3RyaW5nIHwgYm9vbGVhbjsgdHJhbnNmb3JtPzogVHJhbnNmb3JtT3B0aW9ucyB9XG4gICk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHsgc2lnbmVkVXJsOiBzdHJpbmcgfVxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgICAgIH1cbiAgPiB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBfcGF0aCA9IHRoaXMuX2dldEZpbmFsUGF0aChwYXRoKVxuXG4gICAgICBsZXQgZGF0YSA9IGF3YWl0IHBvc3QoXG4gICAgICAgIHRoaXMuZmV0Y2gsXG4gICAgICAgIGAke3RoaXMudXJsfS9vYmplY3Qvc2lnbi8ke19wYXRofWAsXG4gICAgICAgIHsgZXhwaXJlc0luLCAuLi4ob3B0aW9ucz8udHJhbnNmb3JtID8geyB0cmFuc2Zvcm06IG9wdGlvbnMudHJhbnNmb3JtIH0gOiB7fSkgfSxcbiAgICAgICAgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfVxuICAgICAgKVxuICAgICAgY29uc3QgZG93bmxvYWRRdWVyeVBhcmFtID0gb3B0aW9ucz8uZG93bmxvYWRcbiAgICAgICAgPyBgJmRvd25sb2FkPSR7b3B0aW9ucy5kb3dubG9hZCA9PT0gdHJ1ZSA/ICcnIDogb3B0aW9ucy5kb3dubG9hZH1gXG4gICAgICAgIDogJydcbiAgICAgIGNvbnN0IHNpZ25lZFVybCA9IGVuY29kZVVSSShgJHt0aGlzLnVybH0ke2RhdGEuc2lnbmVkVVJMfSR7ZG93bmxvYWRRdWVyeVBhcmFtfWApXG4gICAgICBkYXRhID0geyBzaWduZWRVcmwgfVxuICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBtdWx0aXBsZSBzaWduZWQgVVJMcy4gVXNlIGEgc2lnbmVkIFVSTCB0byBzaGFyZSBhIGZpbGUgZm9yIGEgZml4ZWQgYW1vdW50IG9mIHRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSBwYXRocyBUaGUgZmlsZSBwYXRocyB0byBiZSBkb3dubG9hZGVkLCBpbmNsdWRpbmcgdGhlIGN1cnJlbnQgZmlsZSBuYW1lcy4gRm9yIGV4YW1wbGUgYFsnZm9sZGVyL2ltYWdlLnBuZycsICdmb2xkZXIyL2ltYWdlMi5wbmcnXWAuXG4gICAqIEBwYXJhbSBleHBpcmVzSW4gVGhlIG51bWJlciBvZiBzZWNvbmRzIHVudGlsIHRoZSBzaWduZWQgVVJMcyBleHBpcmUuIEZvciBleGFtcGxlLCBgNjBgIGZvciBVUkxzIHdoaWNoIGFyZSB2YWxpZCBmb3Igb25lIG1pbnV0ZS5cbiAgICogQHBhcmFtIG9wdGlvbnMuZG93bmxvYWQgdHJpZ2dlcnMgdGhlIGZpbGUgYXMgYSBkb3dubG9hZCBpZiBzZXQgdG8gdHJ1ZS4gU2V0IHRoaXMgcGFyYW1ldGVyIGFzIHRoZSBuYW1lIG9mIHRoZSBmaWxlIGlmIHlvdSB3YW50IHRvIHRyaWdnZXIgdGhlIGRvd25sb2FkIHdpdGggYSBkaWZmZXJlbnQgZmlsZW5hbWUuXG4gICAqL1xuICBhc3luYyBjcmVhdGVTaWduZWRVcmxzKFxuICAgIHBhdGhzOiBzdHJpbmdbXSxcbiAgICBleHBpcmVzSW46IG51bWJlcixcbiAgICBvcHRpb25zPzogeyBkb3dubG9hZDogc3RyaW5nIHwgYm9vbGVhbiB9XG4gICk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHsgZXJyb3I6IHN0cmluZyB8IG51bGw7IHBhdGg6IHN0cmluZyB8IG51bGw7IHNpZ25lZFVybDogc3RyaW5nIH1bXVxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgICAgIH1cbiAgPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBwb3N0KFxuICAgICAgICB0aGlzLmZldGNoLFxuICAgICAgICBgJHt0aGlzLnVybH0vb2JqZWN0L3NpZ24vJHt0aGlzLmJ1Y2tldElkfWAsXG4gICAgICAgIHsgZXhwaXJlc0luLCBwYXRocyB9LFxuICAgICAgICB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9XG4gICAgICApXG5cbiAgICAgIGNvbnN0IGRvd25sb2FkUXVlcnlQYXJhbSA9IG9wdGlvbnM/LmRvd25sb2FkXG4gICAgICAgID8gYCZkb3dubG9hZD0ke29wdGlvbnMuZG93bmxvYWQgPT09IHRydWUgPyAnJyA6IG9wdGlvbnMuZG93bmxvYWR9YFxuICAgICAgICA6ICcnXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiBkYXRhLm1hcCgoZGF0dW06IHsgc2lnbmVkVVJMOiBzdHJpbmcgfSkgPT4gKHtcbiAgICAgICAgICAuLi5kYXR1bSxcbiAgICAgICAgICBzaWduZWRVcmw6IGRhdHVtLnNpZ25lZFVSTFxuICAgICAgICAgICAgPyBlbmNvZGVVUkkoYCR7dGhpcy51cmx9JHtkYXR1bS5zaWduZWRVUkx9JHtkb3dubG9hZFF1ZXJ5UGFyYW19YClcbiAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgfSkpLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERvd25sb2FkcyBhIGZpbGUgZnJvbSBhIHByaXZhdGUgYnVja2V0LiBGb3IgcHVibGljIGJ1Y2tldHMsIG1ha2UgYSByZXF1ZXN0IHRvIHRoZSBVUkwgcmV0dXJuZWQgZnJvbSBgZ2V0UHVibGljVXJsYCBpbnN0ZWFkLlxuICAgKlxuICAgKiBAcGFyYW0gcGF0aCBUaGUgZnVsbCBwYXRoIGFuZCBmaWxlIG5hbWUgb2YgdGhlIGZpbGUgdG8gYmUgZG93bmxvYWRlZC4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuICAgKiBAcGFyYW0gb3B0aW9ucy50cmFuc2Zvcm0gVHJhbnNmb3JtIHRoZSBhc3NldCBiZWZvcmUgc2VydmluZyBpdCB0byB0aGUgY2xpZW50LlxuICAgKi9cbiAgYXN5bmMgZG93bmxvYWQoXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiB7IHRyYW5zZm9ybT86IFRyYW5zZm9ybU9wdGlvbnMgfVxuICApOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiBCbG9iXG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IG51bGxcbiAgICAgICAgZXJyb3I6IFN0b3JhZ2VFcnJvclxuICAgICAgfVxuICA+IHtcbiAgICBjb25zdCB3YW50c1RyYW5zZm9ybWF0aW9uID0gdHlwZW9mIG9wdGlvbnM/LnRyYW5zZm9ybSAhPT0gJ3VuZGVmaW5lZCdcbiAgICBjb25zdCByZW5kZXJQYXRoID0gd2FudHNUcmFuc2Zvcm1hdGlvbiA/ICdyZW5kZXIvaW1hZ2UvYXV0aGVudGljYXRlZCcgOiAnb2JqZWN0J1xuICAgIGNvbnN0IHRyYW5zZm9ybWF0aW9uUXVlcnkgPSB0aGlzLnRyYW5zZm9ybU9wdHNUb1F1ZXJ5U3RyaW5nKG9wdGlvbnM/LnRyYW5zZm9ybSB8fCB7fSlcbiAgICBjb25zdCBxdWVyeVN0cmluZyA9IHRyYW5zZm9ybWF0aW9uUXVlcnkgPyBgPyR7dHJhbnNmb3JtYXRpb25RdWVyeX1gIDogJydcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBfcGF0aCA9IHRoaXMuX2dldEZpbmFsUGF0aChwYXRoKVxuICAgICAgY29uc3QgcmVzID0gYXdhaXQgZ2V0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS8ke3JlbmRlclBhdGh9LyR7X3BhdGh9JHtxdWVyeVN0cmluZ31gLCB7XG4gICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgbm9SZXNvbHZlSnNvbjogdHJ1ZSxcbiAgICAgIH0pXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmJsb2IoKVxuICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQSBzaW1wbGUgY29udmVuaWVuY2UgZnVuY3Rpb24gdG8gZ2V0IHRoZSBVUkwgZm9yIGFuIGFzc2V0IGluIGEgcHVibGljIGJ1Y2tldC4gSWYgeW91IGRvIG5vdCB3YW50IHRvIHVzZSB0aGlzIGZ1bmN0aW9uLCB5b3UgY2FuIGNvbnN0cnVjdCB0aGUgcHVibGljIFVSTCBieSBjb25jYXRlbmF0aW5nIHRoZSBidWNrZXQgVVJMIHdpdGggdGhlIHBhdGggdG8gdGhlIGFzc2V0LlxuICAgKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHZlcmlmeSBpZiB0aGUgYnVja2V0IGlzIHB1YmxpYy4gSWYgYSBwdWJsaWMgVVJMIGlzIGNyZWF0ZWQgZm9yIGEgYnVja2V0IHdoaWNoIGlzIG5vdCBwdWJsaWMsIHlvdSB3aWxsIG5vdCBiZSBhYmxlIHRvIGRvd25sb2FkIHRoZSBhc3NldC5cbiAgICpcbiAgICogQHBhcmFtIHBhdGggVGhlIHBhdGggYW5kIG5hbWUgb2YgdGhlIGZpbGUgdG8gZ2VuZXJhdGUgdGhlIHB1YmxpYyBVUkwgZm9yLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLnBuZ2AuXG4gICAqIEBwYXJhbSBvcHRpb25zLmRvd25sb2FkIFRyaWdnZXJzIHRoZSBmaWxlIGFzIGEgZG93bmxvYWQgaWYgc2V0IHRvIHRydWUuIFNldCB0aGlzIHBhcmFtZXRlciBhcyB0aGUgbmFtZSBvZiB0aGUgZmlsZSBpZiB5b3Ugd2FudCB0byB0cmlnZ2VyIHRoZSBkb3dubG9hZCB3aXRoIGEgZGlmZmVyZW50IGZpbGVuYW1lLlxuICAgKiBAcGFyYW0gb3B0aW9ucy50cmFuc2Zvcm0gVHJhbnNmb3JtIHRoZSBhc3NldCBiZWZvcmUgc2VydmluZyBpdCB0byB0aGUgY2xpZW50LlxuICAgKi9cbiAgZ2V0UHVibGljVXJsKFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICBvcHRpb25zPzogeyBkb3dubG9hZD86IHN0cmluZyB8IGJvb2xlYW47IHRyYW5zZm9ybT86IFRyYW5zZm9ybU9wdGlvbnMgfVxuICApOiB7IGRhdGE6IHsgcHVibGljVXJsOiBzdHJpbmcgfSB9IHtcbiAgICBjb25zdCBfcGF0aCA9IHRoaXMuX2dldEZpbmFsUGF0aChwYXRoKVxuICAgIGNvbnN0IF9xdWVyeVN0cmluZyA9IFtdXG5cbiAgICBjb25zdCBkb3dubG9hZFF1ZXJ5UGFyYW0gPSBvcHRpb25zPy5kb3dubG9hZFxuICAgICAgPyBgZG93bmxvYWQ9JHtvcHRpb25zLmRvd25sb2FkID09PSB0cnVlID8gJycgOiBvcHRpb25zLmRvd25sb2FkfWBcbiAgICAgIDogJydcblxuICAgIGlmIChkb3dubG9hZFF1ZXJ5UGFyYW0gIT09ICcnKSB7XG4gICAgICBfcXVlcnlTdHJpbmcucHVzaChkb3dubG9hZFF1ZXJ5UGFyYW0pXG4gICAgfVxuXG4gICAgY29uc3Qgd2FudHNUcmFuc2Zvcm1hdGlvbiA9IHR5cGVvZiBvcHRpb25zPy50cmFuc2Zvcm0gIT09ICd1bmRlZmluZWQnXG4gICAgY29uc3QgcmVuZGVyUGF0aCA9IHdhbnRzVHJhbnNmb3JtYXRpb24gPyAncmVuZGVyL2ltYWdlJyA6ICdvYmplY3QnXG4gICAgY29uc3QgdHJhbnNmb3JtYXRpb25RdWVyeSA9IHRoaXMudHJhbnNmb3JtT3B0c1RvUXVlcnlTdHJpbmcob3B0aW9ucz8udHJhbnNmb3JtIHx8IHt9KVxuXG4gICAgaWYgKHRyYW5zZm9ybWF0aW9uUXVlcnkgIT09ICcnKSB7XG4gICAgICBfcXVlcnlTdHJpbmcucHVzaCh0cmFuc2Zvcm1hdGlvblF1ZXJ5KVxuICAgIH1cblxuICAgIGxldCBxdWVyeVN0cmluZyA9IF9xdWVyeVN0cmluZy5qb2luKCcmJylcbiAgICBpZiAocXVlcnlTdHJpbmcgIT09ICcnKSB7XG4gICAgICBxdWVyeVN0cmluZyA9IGA/JHtxdWVyeVN0cmluZ31gXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IHsgcHVibGljVXJsOiBlbmNvZGVVUkkoYCR7dGhpcy51cmx9LyR7cmVuZGVyUGF0aH0vcHVibGljLyR7X3BhdGh9JHtxdWVyeVN0cmluZ31gKSB9LFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGZpbGVzIHdpdGhpbiB0aGUgc2FtZSBidWNrZXRcbiAgICpcbiAgICogQHBhcmFtIHBhdGhzIEFuIGFycmF5IG9mIGZpbGVzIHRvIGRlbGV0ZSwgaW5jbHVkaW5nIHRoZSBwYXRoIGFuZCBmaWxlIG5hbWUuIEZvciBleGFtcGxlIFtgJ2ZvbGRlci9pbWFnZS5wbmcnYF0uXG4gICAqL1xuICBhc3luYyByZW1vdmUoXG4gICAgcGF0aHM6IHN0cmluZ1tdXG4gICk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IEZpbGVPYmplY3RbXVxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgICAgIH1cbiAgPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZW1vdmUoXG4gICAgICAgIHRoaXMuZmV0Y2gsXG4gICAgICAgIGAke3RoaXMudXJsfS9vYmplY3QvJHt0aGlzLmJ1Y2tldElkfWAsXG4gICAgICAgIHsgcHJlZml4ZXM6IHBhdGhzIH0sXG4gICAgICAgIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH1cbiAgICAgIClcbiAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBmaWxlIG1ldGFkYXRhXG4gICAqIEBwYXJhbSBpZCB0aGUgZmlsZSBpZCB0byByZXRyaWV2ZSBtZXRhZGF0YVxuICAgKi9cbiAgLy8gYXN5bmMgZ2V0TWV0YWRhdGEoXG4gIC8vICAgaWQ6IHN0cmluZ1xuICAvLyApOiBQcm9taXNlPFxuICAvLyAgIHwge1xuICAvLyAgICAgICBkYXRhOiBNZXRhZGF0YVxuICAvLyAgICAgICBlcnJvcjogbnVsbFxuICAvLyAgICAgfVxuICAvLyAgIHwge1xuICAvLyAgICAgICBkYXRhOiBudWxsXG4gIC8vICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgLy8gICAgIH1cbiAgLy8gPiB7XG4gIC8vICAgdHJ5IHtcbiAgLy8gICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXQodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L21ldGFkYXRhLyR7aWR9YCwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSlcbiAgLy8gICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH1cbiAgLy8gICB9IGNhdGNoIChlcnJvcikge1xuICAvLyAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAvLyAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gIC8vICAgICB9XG5cbiAgLy8gICAgIHRocm93IGVycm9yXG4gIC8vICAgfVxuICAvLyB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBmaWxlIG1ldGFkYXRhXG4gICAqIEBwYXJhbSBpZCB0aGUgZmlsZSBpZCB0byB1cGRhdGUgbWV0YWRhdGFcbiAgICogQHBhcmFtIG1ldGEgdGhlIG5ldyBmaWxlIG1ldGFkYXRhXG4gICAqL1xuICAvLyBhc3luYyB1cGRhdGVNZXRhZGF0YShcbiAgLy8gICBpZDogc3RyaW5nLFxuICAvLyAgIG1ldGE6IE1ldGFkYXRhXG4gIC8vICk6IFByb21pc2U8XG4gIC8vICAgfCB7XG4gIC8vICAgICAgIGRhdGE6IE1ldGFkYXRhXG4gIC8vICAgICAgIGVycm9yOiBudWxsXG4gIC8vICAgICB9XG4gIC8vICAgfCB7XG4gIC8vICAgICAgIGRhdGE6IG51bGxcbiAgLy8gICAgICAgZXJyb3I6IFN0b3JhZ2VFcnJvclxuICAvLyAgICAgfVxuICAvLyA+IHtcbiAgLy8gICB0cnkge1xuICAvLyAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHBvc3QoXG4gIC8vICAgICAgIHRoaXMuZmV0Y2gsXG4gIC8vICAgICAgIGAke3RoaXMudXJsfS9tZXRhZGF0YS8ke2lkfWAsXG4gIC8vICAgICAgIHsgLi4ubWV0YSB9LFxuICAvLyAgICAgICB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9XG4gIC8vICAgICApXG4gIC8vICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9XG4gIC8vICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgLy8gICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgLy8gICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAvLyAgICAgfVxuXG4gIC8vICAgICB0aHJvdyBlcnJvclxuICAvLyAgIH1cbiAgLy8gfVxuXG4gIC8qKlxuICAgKiBMaXN0cyBhbGwgdGhlIGZpbGVzIHdpdGhpbiBhIGJ1Y2tldC5cbiAgICogQHBhcmFtIHBhdGggVGhlIGZvbGRlciBwYXRoLlxuICAgKi9cbiAgYXN5bmMgbGlzdChcbiAgICBwYXRoPzogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBTZWFyY2hPcHRpb25zLFxuICAgIHBhcmFtZXRlcnM/OiBGZXRjaFBhcmFtZXRlcnNcbiAgKTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YTogRmlsZU9iamVjdFtdXG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IG51bGxcbiAgICAgICAgZXJyb3I6IFN0b3JhZ2VFcnJvclxuICAgICAgfVxuICA+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYm9keSA9IHsgLi4uREVGQVVMVF9TRUFSQ0hfT1BUSU9OUywgLi4ub3B0aW9ucywgcHJlZml4OiBwYXRoIHx8ICcnIH1cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBwb3N0KFxuICAgICAgICB0aGlzLmZldGNoLFxuICAgICAgICBgJHt0aGlzLnVybH0vb2JqZWN0L2xpc3QvJHt0aGlzLmJ1Y2tldElkfWAsXG4gICAgICAgIGJvZHksXG4gICAgICAgIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH0sXG4gICAgICAgIHBhcmFtZXRlcnNcbiAgICAgIClcbiAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfZ2V0RmluYWxQYXRoKHBhdGg6IHN0cmluZykge1xuICAgIHJldHVybiBgJHt0aGlzLmJ1Y2tldElkfS8ke3BhdGh9YFxuICB9XG5cbiAgcHJpdmF0ZSBfcmVtb3ZlRW1wdHlGb2xkZXJzKHBhdGg6IHN0cmluZykge1xuICAgIHJldHVybiBwYXRoLnJlcGxhY2UoL15cXC98XFwvJC9nLCAnJykucmVwbGFjZSgvXFwvKy9nLCAnLycpXG4gIH1cblxuICBwcml2YXRlIHRyYW5zZm9ybU9wdHNUb1F1ZXJ5U3RyaW5nKHRyYW5zZm9ybTogVHJhbnNmb3JtT3B0aW9ucykge1xuICAgIGNvbnN0IHBhcmFtcyA9IFtdXG4gICAgaWYgKHRyYW5zZm9ybS53aWR0aCkge1xuICAgICAgcGFyYW1zLnB1c2goYHdpZHRoPSR7dHJhbnNmb3JtLndpZHRofWApXG4gICAgfVxuXG4gICAgaWYgKHRyYW5zZm9ybS5oZWlnaHQpIHtcbiAgICAgIHBhcmFtcy5wdXNoKGBoZWlnaHQ9JHt0cmFuc2Zvcm0uaGVpZ2h0fWApXG4gICAgfVxuXG4gICAgaWYgKHRyYW5zZm9ybS5yZXNpemUpIHtcbiAgICAgIHBhcmFtcy5wdXNoKGByZXNpemU9JHt0cmFuc2Zvcm0ucmVzaXplfWApXG4gICAgfVxuXG4gICAgaWYgKHRyYW5zZm9ybS5mb3JtYXQpIHtcbiAgICAgIHBhcmFtcy5wdXNoKGBmb3JtYXQ9JHt0cmFuc2Zvcm0uZm9ybWF0fWApXG4gICAgfVxuXG4gICAgaWYgKHRyYW5zZm9ybS5xdWFsaXR5KSB7XG4gICAgICBwYXJhbXMucHVzaChgcXVhbGl0eT0ke3RyYW5zZm9ybS5xdWFsaXR5fWApXG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmFtcy5qb2luKCcmJylcbiAgfVxufVxuIiwiZXhwb3J0IGNsYXNzIFN0b3JhZ2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLl9faXNTdG9yYWdlRXJyb3IgPSB0cnVlO1xuICAgICAgICB0aGlzLm5hbWUgPSAnU3RvcmFnZUVycm9yJztcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNTdG9yYWdlRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiBlcnJvciAhPT0gbnVsbCAmJiAnX19pc1N0b3JhZ2VFcnJvcicgaW4gZXJyb3I7XG59XG5leHBvcnQgY2xhc3MgU3RvcmFnZUFwaUVycm9yIGV4dGVuZHMgU3RvcmFnZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGF0dXMpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdTdG9yYWdlQXBpRXJyb3InO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgU3RvcmFnZVVua25vd25FcnJvciBleHRlbmRzIFN0b3JhZ2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgb3JpZ2luYWxFcnJvcikge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1N0b3JhZ2VVbmtub3duRXJyb3InO1xuICAgICAgICB0aGlzLm9yaWdpbmFsRXJyb3IgPSBvcmlnaW5hbEVycm9yO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXAiLCJleHBvcnQgY2xhc3MgU3RvcmFnZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBwcm90ZWN0ZWQgX19pc1N0b3JhZ2VFcnJvciA9IHRydWVcblxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdTdG9yYWdlRXJyb3InXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU3RvcmFnZUVycm9yKGVycm9yOiB1bmtub3duKTogZXJyb3IgaXMgU3RvcmFnZUVycm9yIHtcbiAgcmV0dXJuIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgZXJyb3IgIT09IG51bGwgJiYgJ19faXNTdG9yYWdlRXJyb3InIGluIGVycm9yXG59XG5cbmV4cG9ydCBjbGFzcyBTdG9yYWdlQXBpRXJyb3IgZXh0ZW5kcyBTdG9yYWdlRXJyb3Ige1xuICBzdGF0dXM6IG51bWJlclxuXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgc3RhdHVzOiBudW1iZXIpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdTdG9yYWdlQXBpRXJyb3InXG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXNcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFN0b3JhZ2VVbmtub3duRXJyb3IgZXh0ZW5kcyBTdG9yYWdlRXJyb3Ige1xuICBvcmlnaW5hbEVycm9yOiB1bmtub3duXG5cbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBvcmlnaW5hbEVycm9yOiB1bmtub3duKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnU3RvcmFnZVVua25vd25FcnJvcidcbiAgICB0aGlzLm9yaWdpbmFsRXJyb3IgPSBvcmlnaW5hbEVycm9yXG4gIH1cbn1cbiIsInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgU3RvcmFnZUFwaUVycm9yLCBTdG9yYWdlVW5rbm93bkVycm9yIH0gZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0IHsgcmVzb2x2ZVJlc3BvbnNlIH0gZnJvbSAnLi9oZWxwZXJzJztcbmNvbnN0IF9nZXRFcnJvck1lc3NhZ2UgPSAoZXJyKSA9PiBlcnIubXNnIHx8IGVyci5tZXNzYWdlIHx8IGVyci5lcnJvcl9kZXNjcmlwdGlvbiB8fCBlcnIuZXJyb3IgfHwgSlNPTi5zdHJpbmdpZnkoZXJyKTtcbmNvbnN0IGhhbmRsZUVycm9yID0gKGVycm9yLCByZWplY3QpID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IFJlcyA9IHlpZWxkIHJlc29sdmVSZXNwb25zZSgpO1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFJlcykge1xuICAgICAgICBlcnJvclxuICAgICAgICAgICAgLmpzb24oKVxuICAgICAgICAgICAgLnRoZW4oKGVycikgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBTdG9yYWdlQXBpRXJyb3IoX2dldEVycm9yTWVzc2FnZShlcnIpLCBlcnJvci5zdGF0dXMgfHwgNTAwKSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBTdG9yYWdlVW5rbm93bkVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZXJyKSwgZXJyKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVqZWN0KG5ldyBTdG9yYWdlVW5rbm93bkVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZXJyb3IpLCBlcnJvcikpO1xuICAgIH1cbn0pO1xuY29uc3QgX2dldFJlcXVlc3RQYXJhbXMgPSAobWV0aG9kLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KSA9PiB7XG4gICAgY29uc3QgcGFyYW1zID0geyBtZXRob2QsIGhlYWRlcnM6IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhZGVycykgfHwge30gfTtcbiAgICBpZiAobWV0aG9kID09PSAnR0VUJykge1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICBwYXJhbXMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5oZWFkZXJzKTtcbiAgICBwYXJhbXMuYm9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHkpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyksIHBhcmFtZXRlcnMpO1xufTtcbmZ1bmN0aW9uIF9oYW5kbGVSZXF1ZXN0KGZldGNoZXIsIG1ldGhvZCwgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGZldGNoZXIodXJsLCBfZ2V0UmVxdWVzdFBhcmFtcyhtZXRob2QsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpKVxuICAgICAgICAgICAgICAgIC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5vaylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubm9SZXNvbHZlSnNvbilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0Lmpzb24oKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGRhdGEpID0+IHJlc29sdmUoZGF0YSkpXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4gaGFuZGxlRXJyb3IoZXJyb3IsIHJlamVjdCkpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXQoZmV0Y2hlciwgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIF9oYW5kbGVSZXF1ZXN0KGZldGNoZXIsICdHRVQnLCB1cmwsIG9wdGlvbnMsIHBhcmFtZXRlcnMpO1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBvc3QoZmV0Y2hlciwgdXJsLCBib2R5LCBvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIF9oYW5kbGVSZXF1ZXN0KGZldGNoZXIsICdQT1NUJywgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KTtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwdXQoZmV0Y2hlciwgdXJsLCBib2R5LCBvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIF9oYW5kbGVSZXF1ZXN0KGZldGNoZXIsICdQVVQnLCB1cmwsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpO1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZShmZXRjaGVyLCB1cmwsIGJvZHksIG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICByZXR1cm4gX2hhbmRsZVJlcXVlc3QoZmV0Y2hlciwgJ0RFTEVURScsIHVybCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSk7XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mZXRjaC5qcy5tYXAiLCJpbXBvcnQgeyBTdG9yYWdlQXBpRXJyb3IsIFN0b3JhZ2VVbmtub3duRXJyb3IgfSBmcm9tICcuL2Vycm9ycydcbmltcG9ydCB7IHJlc29sdmVSZXNwb25zZSB9IGZyb20gJy4vaGVscGVycydcbmltcG9ydCB7IEZldGNoUGFyYW1ldGVycyB9IGZyb20gJy4vdHlwZXMnXG5cbmV4cG9ydCB0eXBlIEZldGNoID0gdHlwZW9mIGZldGNoXG5cbmV4cG9ydCBpbnRlcmZhY2UgRmV0Y2hPcHRpb25zIHtcbiAgaGVhZGVycz86IHtcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmdcbiAgfVxuICBub1Jlc29sdmVKc29uPzogYm9vbGVhblxufVxuXG5leHBvcnQgdHlwZSBSZXF1ZXN0TWV0aG9kVHlwZSA9ICdHRVQnIHwgJ1BPU1QnIHwgJ1BVVCcgfCAnREVMRVRFJ1xuXG5jb25zdCBfZ2V0RXJyb3JNZXNzYWdlID0gKGVycjogYW55KTogc3RyaW5nID0+XG4gIGVyci5tc2cgfHwgZXJyLm1lc3NhZ2UgfHwgZXJyLmVycm9yX2Rlc2NyaXB0aW9uIHx8IGVyci5lcnJvciB8fCBKU09OLnN0cmluZ2lmeShlcnIpXG5cbmNvbnN0IGhhbmRsZUVycm9yID0gYXN5bmMgKGVycm9yOiB1bmtub3duLCByZWplY3Q6IChyZWFzb24/OiBhbnkpID0+IHZvaWQpID0+IHtcbiAgY29uc3QgUmVzID0gYXdhaXQgcmVzb2x2ZVJlc3BvbnNlKClcblxuICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBSZXMpIHtcbiAgICBlcnJvclxuICAgICAgLmpzb24oKVxuICAgICAgLnRoZW4oKGVycikgPT4ge1xuICAgICAgICByZWplY3QobmV3IFN0b3JhZ2VBcGlFcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGVyciksIGVycm9yLnN0YXR1cyB8fCA1MDApKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIHJlamVjdChuZXcgU3RvcmFnZVVua25vd25FcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGVyciksIGVycikpXG4gICAgICB9KVxuICB9IGVsc2Uge1xuICAgIHJlamVjdChuZXcgU3RvcmFnZVVua25vd25FcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGVycm9yKSwgZXJyb3IpKVxuICB9XG59XG5cbmNvbnN0IF9nZXRSZXF1ZXN0UGFyYW1zID0gKFxuICBtZXRob2Q6IFJlcXVlc3RNZXRob2RUeXBlLFxuICBvcHRpb25zPzogRmV0Y2hPcHRpb25zLFxuICBwYXJhbWV0ZXJzPzogRmV0Y2hQYXJhbWV0ZXJzLFxuICBib2R5Pzogb2JqZWN0XG4pID0+IHtcbiAgY29uc3QgcGFyYW1zOiB7IFtrOiBzdHJpbmddOiBhbnkgfSA9IHsgbWV0aG9kLCBoZWFkZXJzOiBvcHRpb25zPy5oZWFkZXJzIHx8IHt9IH1cblxuICBpZiAobWV0aG9kID09PSAnR0VUJykge1xuICAgIHJldHVybiBwYXJhbXNcbiAgfVxuXG4gIHBhcmFtcy5oZWFkZXJzID0geyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLCAuLi5vcHRpb25zPy5oZWFkZXJzIH1cbiAgcGFyYW1zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5KVxuICByZXR1cm4geyAuLi5wYXJhbXMsIC4uLnBhcmFtZXRlcnMgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBfaGFuZGxlUmVxdWVzdChcbiAgZmV0Y2hlcjogRmV0Y2gsXG4gIG1ldGhvZDogUmVxdWVzdE1ldGhvZFR5cGUsXG4gIHVybDogc3RyaW5nLFxuICBvcHRpb25zPzogRmV0Y2hPcHRpb25zLFxuICBwYXJhbWV0ZXJzPzogRmV0Y2hQYXJhbWV0ZXJzLFxuICBib2R5Pzogb2JqZWN0XG4pOiBQcm9taXNlPGFueT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGZldGNoZXIodXJsLCBfZ2V0UmVxdWVzdFBhcmFtcyhtZXRob2QsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpKVxuICAgICAgLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICBpZiAoIXJlc3VsdC5vaykgdGhyb3cgcmVzdWx0XG4gICAgICAgIGlmIChvcHRpb25zPy5ub1Jlc29sdmVKc29uKSByZXR1cm4gcmVzdWx0XG4gICAgICAgIHJldHVybiByZXN1bHQuanNvbigpXG4gICAgICB9KVxuICAgICAgLnRoZW4oKGRhdGEpID0+IHJlc29sdmUoZGF0YSkpXG4gICAgICAuY2F0Y2goKGVycm9yKSA9PiBoYW5kbGVFcnJvcihlcnJvciwgcmVqZWN0KSlcbiAgfSlcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldChcbiAgZmV0Y2hlcjogRmV0Y2gsXG4gIHVybDogc3RyaW5nLFxuICBvcHRpb25zPzogRmV0Y2hPcHRpb25zLFxuICBwYXJhbWV0ZXJzPzogRmV0Y2hQYXJhbWV0ZXJzXG4pOiBQcm9taXNlPGFueT4ge1xuICByZXR1cm4gX2hhbmRsZVJlcXVlc3QoZmV0Y2hlciwgJ0dFVCcsIHVybCwgb3B0aW9ucywgcGFyYW1ldGVycylcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBvc3QoXG4gIGZldGNoZXI6IEZldGNoLFxuICB1cmw6IHN0cmluZyxcbiAgYm9keTogb2JqZWN0LFxuICBvcHRpb25zPzogRmV0Y2hPcHRpb25zLFxuICBwYXJhbWV0ZXJzPzogRmV0Y2hQYXJhbWV0ZXJzXG4pOiBQcm9taXNlPGFueT4ge1xuICByZXR1cm4gX2hhbmRsZVJlcXVlc3QoZmV0Y2hlciwgJ1BPU1QnLCB1cmwsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwdXQoXG4gIGZldGNoZXI6IEZldGNoLFxuICB1cmw6IHN0cmluZyxcbiAgYm9keTogb2JqZWN0LFxuICBvcHRpb25zPzogRmV0Y2hPcHRpb25zLFxuICBwYXJhbWV0ZXJzPzogRmV0Y2hQYXJhbWV0ZXJzXG4pOiBQcm9taXNlPGFueT4ge1xuICByZXR1cm4gX2hhbmRsZVJlcXVlc3QoZmV0Y2hlciwgJ1BVVCcsIHVybCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSlcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlbW92ZShcbiAgZmV0Y2hlcjogRmV0Y2gsXG4gIHVybDogc3RyaW5nLFxuICBib2R5OiBvYmplY3QsXG4gIG9wdGlvbnM/OiBGZXRjaE9wdGlvbnMsXG4gIHBhcmFtZXRlcnM/OiBGZXRjaFBhcmFtZXRlcnNcbik6IFByb21pc2U8YW55PiB7XG4gIHJldHVybiBfaGFuZGxlUmVxdWVzdChmZXRjaGVyLCAnREVMRVRFJywgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KVxufVxuIiwidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5leHBvcnQgY29uc3QgcmVzb2x2ZUZldGNoID0gKGN1c3RvbUZldGNoKSA9PiB7XG4gICAgbGV0IF9mZXRjaDtcbiAgICBpZiAoY3VzdG9tRmV0Y2gpIHtcbiAgICAgICAgX2ZldGNoID0gY3VzdG9tRmV0Y2g7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBmZXRjaCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgX2ZldGNoID0gKC4uLmFyZ3MpID0+IGltcG9ydCgnQHN1cGFiYXNlL25vZGUtZmV0Y2gnKS50aGVuKCh7IGRlZmF1bHQ6IGZldGNoIH0pID0+IGZldGNoKC4uLmFyZ3MpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIF9mZXRjaCA9IGZldGNoO1xuICAgIH1cbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IF9mZXRjaCguLi5hcmdzKTtcbn07XG5leHBvcnQgY29uc3QgcmVzb2x2ZVJlc3BvbnNlID0gKCkgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgaWYgKHR5cGVvZiBSZXNwb25zZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gKHlpZWxkIGltcG9ydCgnQHN1cGFiYXNlL25vZGUtZmV0Y2gnKSkuUmVzcG9uc2U7XG4gICAgfVxuICAgIHJldHVybiBSZXNwb25zZTtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVscGVycy5qcy5tYXAiLCJ0eXBlIEZldGNoID0gdHlwZW9mIGZldGNoXG5cbmV4cG9ydCBjb25zdCByZXNvbHZlRmV0Y2ggPSAoY3VzdG9tRmV0Y2g/OiBGZXRjaCk6IEZldGNoID0+IHtcbiAgbGV0IF9mZXRjaDogRmV0Y2hcbiAgaWYgKGN1c3RvbUZldGNoKSB7XG4gICAgX2ZldGNoID0gY3VzdG9tRmV0Y2hcbiAgfSBlbHNlIGlmICh0eXBlb2YgZmV0Y2ggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgX2ZldGNoID0gKC4uLmFyZ3MpID0+XG4gICAgICBpbXBvcnQoJ0BzdXBhYmFzZS9ub2RlLWZldGNoJyBhcyBhbnkpLnRoZW4oKHsgZGVmYXVsdDogZmV0Y2ggfSkgPT4gZmV0Y2goLi4uYXJncykpXG4gIH0gZWxzZSB7XG4gICAgX2ZldGNoID0gZmV0Y2hcbiAgfVxuICByZXR1cm4gKC4uLmFyZ3MpID0+IF9mZXRjaCguLi5hcmdzKVxufVxuXG5leHBvcnQgY29uc3QgcmVzb2x2ZVJlc3BvbnNlID0gYXN5bmMgKCk6IFByb21pc2U8dHlwZW9mIFJlc3BvbnNlPiA9PiB7XG4gIGlmICh0eXBlb2YgUmVzcG9uc2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiAoYXdhaXQgaW1wb3J0KCdAc3VwYWJhc2Uvbm9kZS1mZXRjaCcgYXMgYW55KSkuUmVzcG9uc2VcbiAgfVxuXG4gIHJldHVybiBSZXNwb25zZVxufVxuIiwidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBERUZBVUxUX0hFQURFUlMgfSBmcm9tICcuLi9saWIvY29uc3RhbnRzJztcbmltcG9ydCB7IGlzU3RvcmFnZUVycm9yIH0gZnJvbSAnLi4vbGliL2Vycm9ycyc7XG5pbXBvcnQgeyBnZXQsIHBvc3QsIHB1dCwgcmVtb3ZlIH0gZnJvbSAnLi4vbGliL2ZldGNoJztcbmltcG9ydCB7IHJlc29sdmVGZXRjaCB9IGZyb20gJy4uL2xpYi9oZWxwZXJzJztcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0b3JhZ2VCdWNrZXRBcGkge1xuICAgIGNvbnN0cnVjdG9yKHVybCwgaGVhZGVycyA9IHt9LCBmZXRjaCkge1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX0hFQURFUlMpLCBoZWFkZXJzKTtcbiAgICAgICAgdGhpcy5mZXRjaCA9IHJlc29sdmVGZXRjaChmZXRjaCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgZGV0YWlscyBvZiBhbGwgU3RvcmFnZSBidWNrZXRzIHdpdGhpbiBhbiBleGlzdGluZyBwcm9qZWN0LlxuICAgICAqL1xuICAgIGxpc3RCdWNrZXRzKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0geWllbGQgZ2V0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9idWNrZXRgLCB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgZGV0YWlscyBvZiBhbiBleGlzdGluZyBTdG9yYWdlIGJ1Y2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGJ1Y2tldCB5b3Ugd291bGQgbGlrZSB0byByZXRyaWV2ZS5cbiAgICAgKi9cbiAgICBnZXRCdWNrZXQoaWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIGdldCh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vYnVja2V0LyR7aWR9YCwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFN0b3JhZ2UgYnVja2V0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgQSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGJ1Y2tldCB5b3UgYXJlIGNyZWF0aW5nLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnB1YmxpYyBUaGUgdmlzaWJpbGl0eSBvZiB0aGUgYnVja2V0LiBQdWJsaWMgYnVja2V0cyBkb24ndCByZXF1aXJlIGFuIGF1dGhvcml6YXRpb24gdG9rZW4gdG8gZG93bmxvYWQgb2JqZWN0cywgYnV0IHN0aWxsIHJlcXVpcmUgYSB2YWxpZCB0b2tlbiBmb3IgYWxsIG90aGVyIG9wZXJhdGlvbnMuIEJ5IGRlZmF1bHQsIGJ1Y2tldHMgYXJlIHByaXZhdGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZmlsZVNpemVMaW1pdCBzcGVjaWZpZXMgdGhlIG1heCBmaWxlIHNpemUgaW4gYnl0ZXMgdGhhdCBjYW4gYmUgdXBsb2FkZWQgdG8gdGhpcyBidWNrZXQuXG4gICAgICogVGhlIGdsb2JhbCBmaWxlIHNpemUgbGltaXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIHRoaXMgdmFsdWUuXG4gICAgICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgbnVsbCwgd2hpY2ggZG9lc24ndCBzZXQgYSBwZXIgYnVja2V0IGZpbGUgc2l6ZSBsaW1pdC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hbGxvd2VkTWltZVR5cGVzIHNwZWNpZmllcyB0aGUgYWxsb3dlZCBtaW1lIHR5cGVzIHRoYXQgdGhpcyBidWNrZXQgY2FuIGFjY2VwdCBkdXJpbmcgdXBsb2FkLlxuICAgICAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIG51bGwsIHdoaWNoIGFsbG93cyBmaWxlcyB3aXRoIGFsbCBtaW1lIHR5cGVzIHRvIGJlIHVwbG9hZGVkLlxuICAgICAqIEVhY2ggbWltZSB0eXBlIHNwZWNpZmllZCBjYW4gYmUgYSB3aWxkY2FyZCwgZS5nLiBpbWFnZS8qLCBvciBhIHNwZWNpZmljIG1pbWUgdHlwZSwgZS5nLiBpbWFnZS9wbmcuXG4gICAgICogQHJldHVybnMgbmV3bHkgY3JlYXRlZCBidWNrZXQgaWRcbiAgICAgKi9cbiAgICBjcmVhdGVCdWNrZXQoaWQsIG9wdGlvbnMgPSB7XG4gICAgICAgIHB1YmxpYzogZmFsc2UsXG4gICAgfSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0geWllbGQgcG9zdCh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vYnVja2V0YCwge1xuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogaWQsXG4gICAgICAgICAgICAgICAgICAgIHB1YmxpYzogb3B0aW9ucy5wdWJsaWMsXG4gICAgICAgICAgICAgICAgICAgIGZpbGVfc2l6ZV9saW1pdDogb3B0aW9ucy5maWxlU2l6ZUxpbWl0LFxuICAgICAgICAgICAgICAgICAgICBhbGxvd2VkX21pbWVfdHlwZXM6IG9wdGlvbnMuYWxsb3dlZE1pbWVUeXBlcyxcbiAgICAgICAgICAgICAgICB9LCB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgYSBTdG9yYWdlIGJ1Y2tldFxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIEEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBidWNrZXQgeW91IGFyZSB1cGRhdGluZy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5wdWJsaWMgVGhlIHZpc2liaWxpdHkgb2YgdGhlIGJ1Y2tldC4gUHVibGljIGJ1Y2tldHMgZG9uJ3QgcmVxdWlyZSBhbiBhdXRob3JpemF0aW9uIHRva2VuIHRvIGRvd25sb2FkIG9iamVjdHMsIGJ1dCBzdGlsbCByZXF1aXJlIGEgdmFsaWQgdG9rZW4gZm9yIGFsbCBvdGhlciBvcGVyYXRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmZpbGVTaXplTGltaXQgc3BlY2lmaWVzIHRoZSBtYXggZmlsZSBzaXplIGluIGJ5dGVzIHRoYXQgY2FuIGJlIHVwbG9hZGVkIHRvIHRoaXMgYnVja2V0LlxuICAgICAqIFRoZSBnbG9iYWwgZmlsZSBzaXplIGxpbWl0IHRha2VzIHByZWNlZGVuY2Ugb3ZlciB0aGlzIHZhbHVlLlxuICAgICAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIG51bGwsIHdoaWNoIGRvZXNuJ3Qgc2V0IGEgcGVyIGJ1Y2tldCBmaWxlIHNpemUgbGltaXQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYWxsb3dlZE1pbWVUeXBlcyBzcGVjaWZpZXMgdGhlIGFsbG93ZWQgbWltZSB0eXBlcyB0aGF0IHRoaXMgYnVja2V0IGNhbiBhY2NlcHQgZHVyaW5nIHVwbG9hZC5cbiAgICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBudWxsLCB3aGljaCBhbGxvd3MgZmlsZXMgd2l0aCBhbGwgbWltZSB0eXBlcyB0byBiZSB1cGxvYWRlZC5cbiAgICAgKiBFYWNoIG1pbWUgdHlwZSBzcGVjaWZpZWQgY2FuIGJlIGEgd2lsZGNhcmQsIGUuZy4gaW1hZ2UvKiwgb3IgYSBzcGVjaWZpYyBtaW1lIHR5cGUsIGUuZy4gaW1hZ2UvcG5nLlxuICAgICAqL1xuICAgIHVwZGF0ZUJ1Y2tldChpZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0geWllbGQgcHV0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9idWNrZXQvJHtpZH1gLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgcHVibGljOiBvcHRpb25zLnB1YmxpYyxcbiAgICAgICAgICAgICAgICAgICAgZmlsZV9zaXplX2xpbWl0OiBvcHRpb25zLmZpbGVTaXplTGltaXQsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93ZWRfbWltZV90eXBlczogb3B0aW9ucy5hbGxvd2VkTWltZVR5cGVzLFxuICAgICAgICAgICAgICAgIH0sIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgb2JqZWN0cyBpbnNpZGUgYSBzaW5nbGUgYnVja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgYnVja2V0IHlvdSB3b3VsZCBsaWtlIHRvIGVtcHR5LlxuICAgICAqL1xuICAgIGVtcHR5QnVja2V0KGlkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB5aWVsZCBwb3N0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9idWNrZXQvJHtpZH0vZW1wdHlgLCB7fSwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGFuIGV4aXN0aW5nIGJ1Y2tldC4gQSBidWNrZXQgY2FuJ3QgYmUgZGVsZXRlZCB3aXRoIGV4aXN0aW5nIG9iamVjdHMgaW5zaWRlIGl0LlxuICAgICAqIFlvdSBtdXN0IGZpcnN0IGBlbXB0eSgpYCB0aGUgYnVja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgYnVja2V0IHlvdSB3b3VsZCBsaWtlIHRvIGRlbGV0ZS5cbiAgICAgKi9cbiAgICBkZWxldGVCdWNrZXQoaWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHJlbW92ZSh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vYnVja2V0LyR7aWR9YCwge30sIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdG9yYWdlQnVja2V0QXBpLmpzLm1hcCIsImltcG9ydCB7IERFRkFVTFRfSEVBREVSUyB9IGZyb20gJy4uL2xpYi9jb25zdGFudHMnXG5pbXBvcnQgeyBpc1N0b3JhZ2VFcnJvciwgU3RvcmFnZUVycm9yIH0gZnJvbSAnLi4vbGliL2Vycm9ycydcbmltcG9ydCB7IEZldGNoLCBnZXQsIHBvc3QsIHB1dCwgcmVtb3ZlIH0gZnJvbSAnLi4vbGliL2ZldGNoJ1xuaW1wb3J0IHsgcmVzb2x2ZUZldGNoIH0gZnJvbSAnLi4vbGliL2hlbHBlcnMnXG5pbXBvcnQgeyBCdWNrZXQgfSBmcm9tICcuLi9saWIvdHlwZXMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0b3JhZ2VCdWNrZXRBcGkge1xuICBwcm90ZWN0ZWQgdXJsOiBzdHJpbmdcbiAgcHJvdGVjdGVkIGhlYWRlcnM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH1cbiAgcHJvdGVjdGVkIGZldGNoOiBGZXRjaFxuXG4gIGNvbnN0cnVjdG9yKHVybDogc3RyaW5nLCBoZWFkZXJzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge30sIGZldGNoPzogRmV0Y2gpIHtcbiAgICB0aGlzLnVybCA9IHVybFxuICAgIHRoaXMuaGVhZGVycyA9IHsgLi4uREVGQVVMVF9IRUFERVJTLCAuLi5oZWFkZXJzIH1cbiAgICB0aGlzLmZldGNoID0gcmVzb2x2ZUZldGNoKGZldGNoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgZGV0YWlscyBvZiBhbGwgU3RvcmFnZSBidWNrZXRzIHdpdGhpbiBhbiBleGlzdGluZyBwcm9qZWN0LlxuICAgKi9cbiAgYXN5bmMgbGlzdEJ1Y2tldHMoKTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YTogQnVja2V0W11cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgICB9XG4gID4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgZ2V0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9idWNrZXRgLCB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9KVxuICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBkZXRhaWxzIG9mIGFuIGV4aXN0aW5nIFN0b3JhZ2UgYnVja2V0LlxuICAgKlxuICAgKiBAcGFyYW0gaWQgVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBidWNrZXQgeW91IHdvdWxkIGxpa2UgdG8gcmV0cmlldmUuXG4gICAqL1xuICBhc3luYyBnZXRCdWNrZXQoXG4gICAgaWQ6IHN0cmluZ1xuICApOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiBCdWNrZXRcbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgICB9XG4gID4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgZ2V0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9idWNrZXQvJHtpZH1gLCB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9KVxuICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBTdG9yYWdlIGJ1Y2tldFxuICAgKlxuICAgKiBAcGFyYW0gaWQgQSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGJ1Y2tldCB5b3UgYXJlIGNyZWF0aW5nLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5wdWJsaWMgVGhlIHZpc2liaWxpdHkgb2YgdGhlIGJ1Y2tldC4gUHVibGljIGJ1Y2tldHMgZG9uJ3QgcmVxdWlyZSBhbiBhdXRob3JpemF0aW9uIHRva2VuIHRvIGRvd25sb2FkIG9iamVjdHMsIGJ1dCBzdGlsbCByZXF1aXJlIGEgdmFsaWQgdG9rZW4gZm9yIGFsbCBvdGhlciBvcGVyYXRpb25zLiBCeSBkZWZhdWx0LCBidWNrZXRzIGFyZSBwcml2YXRlLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5maWxlU2l6ZUxpbWl0IHNwZWNpZmllcyB0aGUgbWF4IGZpbGUgc2l6ZSBpbiBieXRlcyB0aGF0IGNhbiBiZSB1cGxvYWRlZCB0byB0aGlzIGJ1Y2tldC5cbiAgICogVGhlIGdsb2JhbCBmaWxlIHNpemUgbGltaXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIHRoaXMgdmFsdWUuXG4gICAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIG51bGwsIHdoaWNoIGRvZXNuJ3Qgc2V0IGEgcGVyIGJ1Y2tldCBmaWxlIHNpemUgbGltaXQuXG4gICAqIEBwYXJhbSBvcHRpb25zLmFsbG93ZWRNaW1lVHlwZXMgc3BlY2lmaWVzIHRoZSBhbGxvd2VkIG1pbWUgdHlwZXMgdGhhdCB0aGlzIGJ1Y2tldCBjYW4gYWNjZXB0IGR1cmluZyB1cGxvYWQuXG4gICAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIG51bGwsIHdoaWNoIGFsbG93cyBmaWxlcyB3aXRoIGFsbCBtaW1lIHR5cGVzIHRvIGJlIHVwbG9hZGVkLlxuICAgKiBFYWNoIG1pbWUgdHlwZSBzcGVjaWZpZWQgY2FuIGJlIGEgd2lsZGNhcmQsIGUuZy4gaW1hZ2UvKiwgb3IgYSBzcGVjaWZpYyBtaW1lIHR5cGUsIGUuZy4gaW1hZ2UvcG5nLlxuICAgKiBAcmV0dXJucyBuZXdseSBjcmVhdGVkIGJ1Y2tldCBpZFxuICAgKi9cbiAgYXN5bmMgY3JlYXRlQnVja2V0KFxuICAgIGlkOiBzdHJpbmcsXG4gICAgb3B0aW9uczoge1xuICAgICAgcHVibGljOiBib29sZWFuXG4gICAgICBmaWxlU2l6ZUxpbWl0PzogbnVtYmVyIHwgc3RyaW5nIHwgbnVsbFxuICAgICAgYWxsb3dlZE1pbWVUeXBlcz86IHN0cmluZ1tdIHwgbnVsbFxuICAgIH0gPSB7XG4gICAgICBwdWJsaWM6IGZhbHNlLFxuICAgIH1cbiAgKTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YTogUGljazxCdWNrZXQsICduYW1lJz5cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgICB9XG4gID4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcG9zdChcbiAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgYCR7dGhpcy51cmx9L2J1Y2tldGAsXG4gICAgICAgIHtcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBuYW1lOiBpZCxcbiAgICAgICAgICBwdWJsaWM6IG9wdGlvbnMucHVibGljLFxuICAgICAgICAgIGZpbGVfc2l6ZV9saW1pdDogb3B0aW9ucy5maWxlU2l6ZUxpbWl0LFxuICAgICAgICAgIGFsbG93ZWRfbWltZV90eXBlczogb3B0aW9ucy5hbGxvd2VkTWltZVR5cGVzLFxuICAgICAgICB9LFxuICAgICAgICB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9XG4gICAgICApXG4gICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgU3RvcmFnZSBidWNrZXRcbiAgICpcbiAgICogQHBhcmFtIGlkIEEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBidWNrZXQgeW91IGFyZSB1cGRhdGluZy5cbiAgICogQHBhcmFtIG9wdGlvbnMucHVibGljIFRoZSB2aXNpYmlsaXR5IG9mIHRoZSBidWNrZXQuIFB1YmxpYyBidWNrZXRzIGRvbid0IHJlcXVpcmUgYW4gYXV0aG9yaXphdGlvbiB0b2tlbiB0byBkb3dubG9hZCBvYmplY3RzLCBidXQgc3RpbGwgcmVxdWlyZSBhIHZhbGlkIHRva2VuIGZvciBhbGwgb3RoZXIgb3BlcmF0aW9ucy5cbiAgICogQHBhcmFtIG9wdGlvbnMuZmlsZVNpemVMaW1pdCBzcGVjaWZpZXMgdGhlIG1heCBmaWxlIHNpemUgaW4gYnl0ZXMgdGhhdCBjYW4gYmUgdXBsb2FkZWQgdG8gdGhpcyBidWNrZXQuXG4gICAqIFRoZSBnbG9iYWwgZmlsZSBzaXplIGxpbWl0IHRha2VzIHByZWNlZGVuY2Ugb3ZlciB0aGlzIHZhbHVlLlxuICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBudWxsLCB3aGljaCBkb2Vzbid0IHNldCBhIHBlciBidWNrZXQgZmlsZSBzaXplIGxpbWl0LlxuICAgKiBAcGFyYW0gb3B0aW9ucy5hbGxvd2VkTWltZVR5cGVzIHNwZWNpZmllcyB0aGUgYWxsb3dlZCBtaW1lIHR5cGVzIHRoYXQgdGhpcyBidWNrZXQgY2FuIGFjY2VwdCBkdXJpbmcgdXBsb2FkLlxuICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBudWxsLCB3aGljaCBhbGxvd3MgZmlsZXMgd2l0aCBhbGwgbWltZSB0eXBlcyB0byBiZSB1cGxvYWRlZC5cbiAgICogRWFjaCBtaW1lIHR5cGUgc3BlY2lmaWVkIGNhbiBiZSBhIHdpbGRjYXJkLCBlLmcuIGltYWdlLyosIG9yIGEgc3BlY2lmaWMgbWltZSB0eXBlLCBlLmcuIGltYWdlL3BuZy5cbiAgICovXG4gIGFzeW5jIHVwZGF0ZUJ1Y2tldChcbiAgICBpZDogc3RyaW5nLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIHB1YmxpYzogYm9vbGVhblxuICAgICAgZmlsZVNpemVMaW1pdD86IG51bWJlciB8IHN0cmluZyB8IG51bGxcbiAgICAgIGFsbG93ZWRNaW1lVHlwZXM/OiBzdHJpbmdbXSB8IG51bGxcbiAgICB9XG4gICk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHsgbWVzc2FnZTogc3RyaW5nIH1cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgICB9XG4gID4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcHV0KFxuICAgICAgICB0aGlzLmZldGNoLFxuICAgICAgICBgJHt0aGlzLnVybH0vYnVja2V0LyR7aWR9YCxcbiAgICAgICAge1xuICAgICAgICAgIGlkLFxuICAgICAgICAgIG5hbWU6IGlkLFxuICAgICAgICAgIHB1YmxpYzogb3B0aW9ucy5wdWJsaWMsXG4gICAgICAgICAgZmlsZV9zaXplX2xpbWl0OiBvcHRpb25zLmZpbGVTaXplTGltaXQsXG4gICAgICAgICAgYWxsb3dlZF9taW1lX3R5cGVzOiBvcHRpb25zLmFsbG93ZWRNaW1lVHlwZXMsXG4gICAgICAgIH0sXG4gICAgICAgIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH1cbiAgICAgIClcbiAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIG9iamVjdHMgaW5zaWRlIGEgc2luZ2xlIGJ1Y2tldC5cbiAgICpcbiAgICogQHBhcmFtIGlkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgYnVja2V0IHlvdSB3b3VsZCBsaWtlIHRvIGVtcHR5LlxuICAgKi9cbiAgYXN5bmMgZW1wdHlCdWNrZXQoXG4gICAgaWQ6IHN0cmluZ1xuICApOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiB7IG1lc3NhZ2U6IHN0cmluZyB9XG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IG51bGxcbiAgICAgICAgZXJyb3I6IFN0b3JhZ2VFcnJvclxuICAgICAgfVxuICA+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHBvc3QoXG4gICAgICAgIHRoaXMuZmV0Y2gsXG4gICAgICAgIGAke3RoaXMudXJsfS9idWNrZXQvJHtpZH0vZW1wdHlgLFxuICAgICAgICB7fSxcbiAgICAgICAgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfVxuICAgICAgKVxuICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBhbiBleGlzdGluZyBidWNrZXQuIEEgYnVja2V0IGNhbid0IGJlIGRlbGV0ZWQgd2l0aCBleGlzdGluZyBvYmplY3RzIGluc2lkZSBpdC5cbiAgICogWW91IG11c3QgZmlyc3QgYGVtcHR5KClgIHRoZSBidWNrZXQuXG4gICAqXG4gICAqIEBwYXJhbSBpZCBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGJ1Y2tldCB5b3Ugd291bGQgbGlrZSB0byBkZWxldGUuXG4gICAqL1xuICBhc3luYyBkZWxldGVCdWNrZXQoXG4gICAgaWQ6IHN0cmluZ1xuICApOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiB7IG1lc3NhZ2U6IHN0cmluZyB9XG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IG51bGxcbiAgICAgICAgZXJyb3I6IFN0b3JhZ2VFcnJvclxuICAgICAgfVxuICA+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlbW92ZShcbiAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgYCR7dGhpcy51cmx9L2J1Y2tldC8ke2lkfWAsXG4gICAgICAgIHt9LFxuICAgICAgICB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9XG4gICAgICApXG4gICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbic7XG5leHBvcnQgY29uc3QgREVGQVVMVF9IRUFERVJTID0geyAnWC1DbGllbnQtSW5mbyc6IGBzdG9yYWdlLWpzLyR7dmVyc2lvbn1gIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIiwiaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbidcbmV4cG9ydCBjb25zdCBERUZBVUxUX0hFQURFUlMgPSB7ICdYLUNsaWVudC1JbmZvJzogYHN0b3JhZ2UtanMvJHt2ZXJzaW9ufWAgfVxuIiwiLy8gZ2VuZXJhdGVkIGJ5IGdlbnZlcnNpb25cbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gJzIuNi4wJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb24uanMubWFwIiwiLy8gZ2VuZXJhdGVkIGJ5IGdlbnZlcnNpb25cbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gJzIuNi4wJ1xuIiwiZXhwb3J0IGludGVyZmFjZSBCdWNrZXQge1xuICBpZDogc3RyaW5nXG4gIG5hbWU6IHN0cmluZ1xuICBvd25lcjogc3RyaW5nXG4gIGZpbGVfc2l6ZV9saW1pdD86IG51bWJlclxuICBhbGxvd2VkX21pbWVfdHlwZXM/OiBzdHJpbmdbXVxuICBjcmVhdGVkX2F0OiBzdHJpbmdcbiAgdXBkYXRlZF9hdDogc3RyaW5nXG4gIHB1YmxpYzogYm9vbGVhblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVPYmplY3Qge1xuICBuYW1lOiBzdHJpbmdcbiAgYnVja2V0X2lkOiBzdHJpbmdcbiAgb3duZXI6IHN0cmluZ1xuICBpZDogc3RyaW5nXG4gIHVwZGF0ZWRfYXQ6IHN0cmluZ1xuICBjcmVhdGVkX2F0OiBzdHJpbmdcbiAgbGFzdF9hY2Nlc3NlZF9hdDogc3RyaW5nXG4gIG1ldGFkYXRhOiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gIGJ1Y2tldHM6IEJ1Y2tldFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNvcnRCeSB7XG4gIGNvbHVtbj86IHN0cmluZ1xuICBvcmRlcj86IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyB0aGUgYXNzZXQgaXMgY2FjaGVkIGluIHRoZSBicm93c2VyIGFuZCBpbiB0aGUgU3VwYWJhc2UgQ0ROLiBUaGlzIGlzIHNldCBpbiB0aGUgYENhY2hlLUNvbnRyb2w6IG1heC1hZ2U9PHNlY29uZHM+YCBoZWFkZXIuIERlZmF1bHRzIHRvIDM2MDAgc2Vjb25kcy5cbiAgICovXG4gIGNhY2hlQ29udHJvbD86IHN0cmluZ1xuICAvKipcbiAgICogdGhlIGBDb250ZW50LVR5cGVgIGhlYWRlciB2YWx1ZS4gU2hvdWxkIGJlIHNwZWNpZmllZCBpZiB1c2luZyBhIGBmaWxlQm9keWAgdGhhdCBpcyBuZWl0aGVyIGBCbG9iYCBub3IgYEZpbGVgIG5vciBgRm9ybURhdGFgLCBvdGhlcndpc2Ugd2lsbCBkZWZhdWx0IHRvIGB0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLThgLlxuICAgKi9cbiAgY29udGVudFR5cGU/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFdoZW4gdXBzZXJ0IGlzIHNldCB0byB0cnVlLCB0aGUgZmlsZSBpcyBvdmVyd3JpdHRlbiBpZiBpdCBleGlzdHMuIFdoZW4gc2V0IHRvIGZhbHNlLCBhbiBlcnJvciBpcyB0aHJvd24gaWYgdGhlIG9iamVjdCBhbHJlYWR5IGV4aXN0cy4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAqL1xuICB1cHNlcnQ/OiBib29sZWFuXG4gIC8qKlxuICAgKiBUaGUgZHVwbGV4IG9wdGlvbiBpcyBhIHN0cmluZyBwYXJhbWV0ZXIgdGhhdCBlbmFibGVzIG9yIGRpc2FibGVzIGR1cGxleCBzdHJlYW1pbmcsIGFsbG93aW5nIGZvciBib3RoIHJlYWRpbmcgYW5kIHdyaXRpbmcgZGF0YSBpbiB0aGUgc2FtZSBzdHJlYW0uIEl0IGNhbiBiZSBwYXNzZWQgYXMgYW4gb3B0aW9uIHRvIHRoZSBmZXRjaCgpIG1ldGhvZC5cbiAgICovXG4gIGR1cGxleD86IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERlc3RpbmF0aW9uT3B0aW9ucyB7XG4gIGRlc3RpbmF0aW9uQnVja2V0Pzogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VhcmNoT3B0aW9ucyB7XG4gIC8qKlxuICAgKiAgVGhlIG51bWJlciBvZiBmaWxlcyB5b3Ugd2FudCB0byBiZSByZXR1cm5lZC5cbiAgICovXG4gIGxpbWl0PzogbnVtYmVyXG5cbiAgLyoqXG4gICAqIFRoZSBzdGFydGluZyBwb3NpdGlvbi5cbiAgICovXG4gIG9mZnNldD86IG51bWJlclxuXG4gIC8qKlxuICAgKiBUaGUgY29sdW1uIHRvIHNvcnQgYnkuIENhbiBiZSBhbnkgY29sdW1uIGluc2lkZSBhIEZpbGVPYmplY3QuXG4gICAqL1xuICBzb3J0Qnk/OiBTb3J0QnlcblxuICAvKipcbiAgICogVGhlIHNlYXJjaCBzdHJpbmcgdG8gZmlsdGVyIGZpbGVzIGJ5LlxuICAgKi9cbiAgc2VhcmNoPzogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmV0Y2hQYXJhbWV0ZXJzIHtcbiAgLyoqXG4gICAqIFBhc3MgaW4gYW4gQWJvcnRDb250cm9sbGVyJ3Mgc2lnbmFsIHRvIGNhbmNlbCB0aGUgcmVxdWVzdC5cbiAgICovXG4gIHNpZ25hbD86IEFib3J0U2lnbmFsXG59XG5cbi8vIFRPRE86IG5lZWQgdG8gY2hlY2sgZm9yIG1ldGFkYXRhIHByb3BzLiBUaGUgYXBpIHN3YWdnZXIgZG9lc250IGhhdmUuXG5leHBvcnQgaW50ZXJmYWNlIE1ldGFkYXRhIHtcbiAgbmFtZTogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNmb3JtT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgd2lkdGggb2YgdGhlIGltYWdlIGluIHBpeGVscy5cbiAgICovXG4gIHdpZHRoPzogbnVtYmVyXG4gIC8qKlxuICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBpbWFnZSBpbiBwaXhlbHMuXG4gICAqL1xuICBoZWlnaHQ/OiBudW1iZXJcbiAgLyoqXG4gICAqIFRoZSByZXNpemUgbW9kZSBjYW4gYmUgY292ZXIsIGNvbnRhaW4gb3IgZmlsbC4gRGVmYXVsdHMgdG8gY292ZXIuXG4gICAqIENvdmVyIHJlc2l6ZXMgdGhlIGltYWdlIHRvIG1haW50YWluIGl0J3MgYXNwZWN0IHJhdGlvIHdoaWxlIGZpbGxpbmcgdGhlIGVudGlyZSB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgKiBDb250YWluIHJlc2l6ZXMgdGhlIGltYWdlIHRvIG1haW50YWluIGl0J3MgYXNwZWN0IHJhdGlvIHdoaWxlIGZpdHRpbmcgdGhlIGVudGlyZSBpbWFnZSB3aXRoaW4gdGhlIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAqIEZpbGwgcmVzaXplcyB0aGUgaW1hZ2UgdG8gZmlsbCB0aGUgZW50aXJlIHdpZHRoIGFuZCBoZWlnaHQuIElmIHRoZSBvYmplY3QncyBhc3BlY3QgcmF0aW8gZG9lcyBub3QgbWF0Y2ggdGhlIHdpZHRoIGFuZCBoZWlnaHQsIHRoZSBpbWFnZSB3aWxsIGJlIHN0cmV0Y2hlZCB0byBmaXQuXG4gICAqL1xuICByZXNpemU/OiAnY292ZXInIHwgJ2NvbnRhaW4nIHwgJ2ZpbGwnXG4gIC8qKlxuICAgKiBTZXQgdGhlIHF1YWxpdHkgb2YgdGhlIHJldHVybmVkIGltYWdlLlxuICAgKiBBIG51bWJlciBmcm9tIDIwIHRvIDEwMCwgd2l0aCAxMDAgYmVpbmcgdGhlIGhpZ2hlc3QgcXVhbGl0eS5cbiAgICogRGVmYXVsdHMgdG8gODBcbiAgICovXG4gIHF1YWxpdHk/OiBudW1iZXJcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIGZvcm1hdCBvZiB0aGUgaW1hZ2UgcmVxdWVzdGVkLlxuICAgKlxuICAgKiBXaGVuIHVzaW5nICdvcmlnaW4nIHdlIGZvcmNlIHRoZSBmb3JtYXQgdG8gYmUgdGhlIHNhbWUgYXMgdGhlIG9yaWdpbmFsIGltYWdlLlxuICAgKiBXaGVuIHRoaXMgb3B0aW9uIGlzIG5vdCBwYXNzZWQgaW4sIGltYWdlcyBhcmUgb3B0aW1pemVkIHRvIG1vZGVybiBpbWFnZSBmb3JtYXRzIGxpa2UgV2VicC5cbiAgICovXG4gIGZvcm1hdD86ICdvcmlnaW4nXG59XG4iLCJpbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSAnLi92ZXJzaW9uJztcbmxldCBKU19FTlYgPSAnJztcbi8vIEB0cy1pZ25vcmVcbmlmICh0eXBlb2YgRGVubyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBKU19FTlYgPSAnZGVubyc7XG59XG5lbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgSlNfRU5WID0gJ3dlYic7XG59XG5lbHNlIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJykge1xuICAgIEpTX0VOViA9ICdyZWFjdC1uYXRpdmUnO1xufVxuZWxzZSB7XG4gICAgSlNfRU5WID0gJ25vZGUnO1xufVxuZXhwb3J0IGNvbnN0IERFRkFVTFRfSEVBREVSUyA9IHsgJ1gtQ2xpZW50LUluZm8nOiBgc3VwYWJhc2UtanMtJHtKU19FTlZ9LyR7dmVyc2lvbn1gIH07XG5leHBvcnQgY29uc3QgREVGQVVMVF9HTE9CQUxfT1BUSU9OUyA9IHtcbiAgICBoZWFkZXJzOiBERUZBVUxUX0hFQURFUlMsXG59O1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfREJfT1BUSU9OUyA9IHtcbiAgICBzY2hlbWE6ICdwdWJsaWMnLFxufTtcbmV4cG9ydCBjb25zdCBERUZBVUxUX0FVVEhfT1BUSU9OUyA9IHtcbiAgICBhdXRvUmVmcmVzaFRva2VuOiB0cnVlLFxuICAgIHBlcnNpc3RTZXNzaW9uOiB0cnVlLFxuICAgIGRldGVjdFNlc3Npb25JblVybDogdHJ1ZSxcbiAgICBmbG93VHlwZTogJ2ltcGxpY2l0Jyxcbn07XG5leHBvcnQgY29uc3QgREVGQVVMVF9SRUFMVElNRV9PUFRJT05TID0ge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIiwiLy8gY29uc3RhbnRzLnRzXG5pbXBvcnQgeyBSZWFsdGltZUNsaWVudE9wdGlvbnMgfSBmcm9tICdAc3VwYWJhc2UvcmVhbHRpbWUtanMnXG5pbXBvcnQgeyBTdXBhYmFzZUF1dGhDbGllbnRPcHRpb25zIH0gZnJvbSAnLi90eXBlcydcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24nXG5cbmxldCBKU19FTlYgPSAnJ1xuLy8gQHRzLWlnbm9yZVxuaWYgKHR5cGVvZiBEZW5vICE9PSAndW5kZWZpbmVkJykge1xuICBKU19FTlYgPSAnZGVubydcbn0gZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICBKU19FTlYgPSAnd2ViJ1xufSBlbHNlIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJykge1xuICBKU19FTlYgPSAncmVhY3QtbmF0aXZlJ1xufSBlbHNlIHtcbiAgSlNfRU5WID0gJ25vZGUnXG59XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX0hFQURFUlMgPSB7ICdYLUNsaWVudC1JbmZvJzogYHN1cGFiYXNlLWpzLSR7SlNfRU5WfS8ke3ZlcnNpb259YCB9XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX0dMT0JBTF9PUFRJT05TID0ge1xuICBoZWFkZXJzOiBERUZBVUxUX0hFQURFUlMsXG59XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX0RCX09QVElPTlMgPSB7XG4gIHNjaGVtYTogJ3B1YmxpYycsXG59XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX0FVVEhfT1BUSU9OUzogU3VwYWJhc2VBdXRoQ2xpZW50T3B0aW9ucyA9IHtcbiAgYXV0b1JlZnJlc2hUb2tlbjogdHJ1ZSxcbiAgcGVyc2lzdFNlc3Npb246IHRydWUsXG4gIGRldGVjdFNlc3Npb25JblVybDogdHJ1ZSxcbiAgZmxvd1R5cGU6ICdpbXBsaWNpdCcsXG59XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1JFQUxUSU1FX09QVElPTlM6IFJlYWx0aW1lQ2xpZW50T3B0aW9ucyA9IHt9XG4iLCJleHBvcnQgY29uc3QgdmVyc2lvbiA9ICcyLjQ0LjQnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5qcy5tYXAiLCJleHBvcnQgY29uc3QgdmVyc2lvbiA9ICcyLjQ0LjQnXG4iLCJ2YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCBub2RlRmV0Y2gsIHsgSGVhZGVycyBhcyBOb2RlRmV0Y2hIZWFkZXJzIH0gZnJvbSAnQHN1cGFiYXNlL25vZGUtZmV0Y2gnO1xuZXhwb3J0IGNvbnN0IHJlc29sdmVGZXRjaCA9IChjdXN0b21GZXRjaCkgPT4ge1xuICAgIGxldCBfZmV0Y2g7XG4gICAgaWYgKGN1c3RvbUZldGNoKSB7XG4gICAgICAgIF9mZXRjaCA9IGN1c3RvbUZldGNoO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZmV0Y2ggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIF9mZXRjaCA9IG5vZGVGZXRjaDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIF9mZXRjaCA9IGZldGNoO1xuICAgIH1cbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IF9mZXRjaCguLi5hcmdzKTtcbn07XG5leHBvcnQgY29uc3QgcmVzb2x2ZUhlYWRlcnNDb25zdHJ1Y3RvciA9ICgpID0+IHtcbiAgICBpZiAodHlwZW9mIEhlYWRlcnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBOb2RlRmV0Y2hIZWFkZXJzO1xuICAgIH1cbiAgICByZXR1cm4gSGVhZGVycztcbn07XG5leHBvcnQgY29uc3QgZmV0Y2hXaXRoQXV0aCA9IChzdXBhYmFzZUtleSwgZ2V0QWNjZXNzVG9rZW4sIGN1c3RvbUZldGNoKSA9PiB7XG4gICAgY29uc3QgZmV0Y2ggPSByZXNvbHZlRmV0Y2goY3VzdG9tRmV0Y2gpO1xuICAgIGNvbnN0IEhlYWRlcnNDb25zdHJ1Y3RvciA9IHJlc29sdmVIZWFkZXJzQ29uc3RydWN0b3IoKTtcbiAgICByZXR1cm4gKGlucHV0LCBpbml0KSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBhY2Nlc3NUb2tlbiA9IChfYSA9ICh5aWVsZCBnZXRBY2Nlc3NUb2tlbigpKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogc3VwYWJhc2VLZXk7XG4gICAgICAgIGxldCBoZWFkZXJzID0gbmV3IEhlYWRlcnNDb25zdHJ1Y3Rvcihpbml0ID09PSBudWxsIHx8IGluaXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluaXQuaGVhZGVycyk7XG4gICAgICAgIGlmICghaGVhZGVycy5oYXMoJ2FwaWtleScpKSB7XG4gICAgICAgICAgICBoZWFkZXJzLnNldCgnYXBpa2V5Jywgc3VwYWJhc2VLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaGVhZGVycy5oYXMoJ0F1dGhvcml6YXRpb24nKSkge1xuICAgICAgICAgICAgaGVhZGVycy5zZXQoJ0F1dGhvcml6YXRpb24nLCBgQmVhcmVyICR7YWNjZXNzVG9rZW59YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZldGNoKGlucHV0LCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGluaXQpLCB7IGhlYWRlcnMgfSkpO1xuICAgIH0pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZldGNoLmpzLm1hcCIsIi8vIEB0cy1pZ25vcmVcbmltcG9ydCBub2RlRmV0Y2gsIHsgSGVhZGVycyBhcyBOb2RlRmV0Y2hIZWFkZXJzIH0gZnJvbSAnQHN1cGFiYXNlL25vZGUtZmV0Y2gnXG5cbnR5cGUgRmV0Y2ggPSB0eXBlb2YgZmV0Y2hcblxuZXhwb3J0IGNvbnN0IHJlc29sdmVGZXRjaCA9IChjdXN0b21GZXRjaD86IEZldGNoKTogRmV0Y2ggPT4ge1xuICBsZXQgX2ZldGNoOiBGZXRjaFxuICBpZiAoY3VzdG9tRmV0Y2gpIHtcbiAgICBfZmV0Y2ggPSBjdXN0b21GZXRjaFxuICB9IGVsc2UgaWYgKHR5cGVvZiBmZXRjaCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBfZmV0Y2ggPSBub2RlRmV0Y2ggYXMgdW5rbm93biBhcyBGZXRjaFxuICB9IGVsc2Uge1xuICAgIF9mZXRjaCA9IGZldGNoXG4gIH1cbiAgcmV0dXJuICguLi5hcmdzOiBQYXJhbWV0ZXJzPEZldGNoPikgPT4gX2ZldGNoKC4uLmFyZ3MpXG59XG5cbmV4cG9ydCBjb25zdCByZXNvbHZlSGVhZGVyc0NvbnN0cnVjdG9yID0gKCkgPT4ge1xuICBpZiAodHlwZW9mIEhlYWRlcnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIE5vZGVGZXRjaEhlYWRlcnNcbiAgfVxuXG4gIHJldHVybiBIZWFkZXJzXG59XG5cbmV4cG9ydCBjb25zdCBmZXRjaFdpdGhBdXRoID0gKFxuICBzdXBhYmFzZUtleTogc3RyaW5nLFxuICBnZXRBY2Nlc3NUb2tlbjogKCkgPT4gUHJvbWlzZTxzdHJpbmcgfCBudWxsPixcbiAgY3VzdG9tRmV0Y2g/OiBGZXRjaFxuKTogRmV0Y2ggPT4ge1xuICBjb25zdCBmZXRjaCA9IHJlc29sdmVGZXRjaChjdXN0b21GZXRjaClcbiAgY29uc3QgSGVhZGVyc0NvbnN0cnVjdG9yID0gcmVzb2x2ZUhlYWRlcnNDb25zdHJ1Y3RvcigpXG5cbiAgcmV0dXJuIGFzeW5jIChpbnB1dCwgaW5pdCkgPT4ge1xuICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gKGF3YWl0IGdldEFjY2Vzc1Rva2VuKCkpID8/IHN1cGFiYXNlS2V5XG4gICAgbGV0IGhlYWRlcnMgPSBuZXcgSGVhZGVyc0NvbnN0cnVjdG9yKGluaXQ/LmhlYWRlcnMpXG5cbiAgICBpZiAoIWhlYWRlcnMuaGFzKCdhcGlrZXknKSkge1xuICAgICAgaGVhZGVycy5zZXQoJ2FwaWtleScsIHN1cGFiYXNlS2V5KVxuICAgIH1cblxuICAgIGlmICghaGVhZGVycy5oYXMoJ0F1dGhvcml6YXRpb24nKSkge1xuICAgICAgaGVhZGVycy5zZXQoJ0F1dGhvcml6YXRpb24nLCBgQmVhcmVyICR7YWNjZXNzVG9rZW59YClcbiAgICB9XG5cbiAgICByZXR1cm4gZmV0Y2goaW5wdXQsIHsgLi4uaW5pdCwgaGVhZGVycyB9KVxuICB9XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gdXVpZCgpIHtcbiAgICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgciA9IChNYXRoLnJhbmRvbSgpICogMTYpIHwgMCwgdiA9IGMgPT0gJ3gnID8gciA6IChyICYgMHgzKSB8IDB4ODtcbiAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHN0cmlwVHJhaWxpbmdTbGFzaCh1cmwpIHtcbiAgICByZXR1cm4gdXJsLnJlcGxhY2UoL1xcLyQvLCAnJyk7XG59XG5leHBvcnQgY29uc3QgaXNCcm93c2VyID0gKCkgPT4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG5leHBvcnQgZnVuY3Rpb24gYXBwbHlTZXR0aW5nRGVmYXVsdHMob3B0aW9ucywgZGVmYXVsdHMpIHtcbiAgICBjb25zdCB7IGRiOiBkYk9wdGlvbnMsIGF1dGg6IGF1dGhPcHRpb25zLCByZWFsdGltZTogcmVhbHRpbWVPcHRpb25zLCBnbG9iYWw6IGdsb2JhbE9wdGlvbnMsIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHsgZGI6IERFRkFVTFRfREJfT1BUSU9OUywgYXV0aDogREVGQVVMVF9BVVRIX09QVElPTlMsIHJlYWx0aW1lOiBERUZBVUxUX1JFQUxUSU1FX09QVElPTlMsIGdsb2JhbDogREVGQVVMVF9HTE9CQUxfT1BUSU9OUywgfSA9IGRlZmF1bHRzO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRiOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfREJfT1BUSU9OUyksIGRiT3B0aW9ucyksXG4gICAgICAgIGF1dGg6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9BVVRIX09QVElPTlMpLCBhdXRoT3B0aW9ucyksXG4gICAgICAgIHJlYWx0aW1lOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfUkVBTFRJTUVfT1BUSU9OUyksIHJlYWx0aW1lT3B0aW9ucyksXG4gICAgICAgIGdsb2JhbDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX0dMT0JBTF9PUFRJT05TKSwgZ2xvYmFsT3B0aW9ucyksXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbHBlcnMuanMubWFwIiwiLy8gaGVscGVycy50c1xuaW1wb3J0IHsgU3VwYWJhc2VDbGllbnRPcHRpb25zIH0gZnJvbSAnLi90eXBlcydcblxuZXhwb3J0IGZ1bmN0aW9uIHV1aWQoKSB7XG4gIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgdmFyIHIgPSAoTWF0aC5yYW5kb20oKSAqIDE2KSB8IDAsXG4gICAgICB2ID0gYyA9PSAneCcgPyByIDogKHIgJiAweDMpIHwgMHg4XG4gICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpXG4gIH0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJpcFRyYWlsaW5nU2xhc2godXJsOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gdXJsLnJlcGxhY2UoL1xcLyQvLCAnJylcbn1cblxuZXhwb3J0IGNvbnN0IGlzQnJvd3NlciA9ICgpID0+IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVNldHRpbmdEZWZhdWx0czxcbiAgRGF0YWJhc2UgPSBhbnksXG4gIFNjaGVtYU5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBEYXRhYmFzZSA9ICdwdWJsaWMnIGV4dGVuZHMga2V5b2YgRGF0YWJhc2VcbiAgICA/ICdwdWJsaWMnXG4gICAgOiBzdHJpbmcgJiBrZXlvZiBEYXRhYmFzZVxuPihcbiAgb3B0aW9uczogU3VwYWJhc2VDbGllbnRPcHRpb25zPFNjaGVtYU5hbWU+LFxuICBkZWZhdWx0czogU3VwYWJhc2VDbGllbnRPcHRpb25zPGFueT5cbik6IFJlcXVpcmVkPFN1cGFiYXNlQ2xpZW50T3B0aW9uczxTY2hlbWFOYW1lPj4ge1xuICBjb25zdCB7XG4gICAgZGI6IGRiT3B0aW9ucyxcbiAgICBhdXRoOiBhdXRoT3B0aW9ucyxcbiAgICByZWFsdGltZTogcmVhbHRpbWVPcHRpb25zLFxuICAgIGdsb2JhbDogZ2xvYmFsT3B0aW9ucyxcbiAgfSA9IG9wdGlvbnNcbiAgY29uc3Qge1xuICAgIGRiOiBERUZBVUxUX0RCX09QVElPTlMsXG4gICAgYXV0aDogREVGQVVMVF9BVVRIX09QVElPTlMsXG4gICAgcmVhbHRpbWU6IERFRkFVTFRfUkVBTFRJTUVfT1BUSU9OUyxcbiAgICBnbG9iYWw6IERFRkFVTFRfR0xPQkFMX09QVElPTlMsXG4gIH0gPSBkZWZhdWx0c1xuXG4gIHJldHVybiB7XG4gICAgZGI6IHtcbiAgICAgIC4uLkRFRkFVTFRfREJfT1BUSU9OUyxcbiAgICAgIC4uLmRiT3B0aW9ucyxcbiAgICB9LFxuICAgIGF1dGg6IHtcbiAgICAgIC4uLkRFRkFVTFRfQVVUSF9PUFRJT05TLFxuICAgICAgLi4uYXV0aE9wdGlvbnMsXG4gICAgfSxcbiAgICByZWFsdGltZToge1xuICAgICAgLi4uREVGQVVMVF9SRUFMVElNRV9PUFRJT05TLFxuICAgICAgLi4ucmVhbHRpbWVPcHRpb25zLFxuICAgIH0sXG4gICAgZ2xvYmFsOiB7XG4gICAgICAuLi5ERUZBVUxUX0dMT0JBTF9PUFRJT05TLFxuICAgICAgLi4uZ2xvYmFsT3B0aW9ucyxcbiAgICB9LFxuICB9XG59XG4iLCJpbXBvcnQgeyBBdXRoQ2xpZW50IH0gZnJvbSAnQHN1cGFiYXNlL2F1dGgtanMnO1xuZXhwb3J0IGNsYXNzIFN1cGFiYXNlQXV0aENsaWVudCBleHRlbmRzIEF1dGhDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3VwYWJhc2VBdXRoQ2xpZW50LmpzLm1hcCIsImltcG9ydCB7IEF1dGhDbGllbnQgfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcydcbmltcG9ydCB7IFN1cGFiYXNlQXV0aENsaWVudE9wdGlvbnMgfSBmcm9tICcuL3R5cGVzJ1xuXG5leHBvcnQgY2xhc3MgU3VwYWJhc2VBdXRoQ2xpZW50IGV4dGVuZHMgQXV0aENsaWVudCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IFN1cGFiYXNlQXV0aENsaWVudE9wdGlvbnMpIHtcbiAgICBzdXBlcihvcHRpb25zKVxuICB9XG59XG4iLCJpbXBvcnQgR29UcnVlQWRtaW5BcGkgZnJvbSAnLi9Hb1RydWVBZG1pbkFwaSc7XG5pbXBvcnQgR29UcnVlQ2xpZW50IGZyb20gJy4vR29UcnVlQ2xpZW50JztcbmltcG9ydCBBdXRoQWRtaW5BcGkgZnJvbSAnLi9BdXRoQWRtaW5BcGknO1xuaW1wb3J0IEF1dGhDbGllbnQgZnJvbSAnLi9BdXRoQ2xpZW50JztcbmV4cG9ydCB7IEdvVHJ1ZUFkbWluQXBpLCBHb1RydWVDbGllbnQsIEF1dGhBZG1pbkFwaSwgQXV0aENsaWVudCB9O1xuZXhwb3J0ICogZnJvbSAnLi9saWIvdHlwZXMnO1xuZXhwb3J0ICogZnJvbSAnLi9saWIvZXJyb3JzJztcbmV4cG9ydCB7IG5hdmlnYXRvckxvY2ssIE5hdmlnYXRvckxvY2tBY3F1aXJlVGltZW91dEVycm9yLCBpbnRlcm5hbHMgYXMgbG9ja0ludGVybmFscywgfSBmcm9tICcuL2xpYi9sb2Nrcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJpbXBvcnQgR29UcnVlQWRtaW5BcGkgZnJvbSAnLi9Hb1RydWVBZG1pbkFwaSdcbmltcG9ydCBHb1RydWVDbGllbnQgZnJvbSAnLi9Hb1RydWVDbGllbnQnXG5pbXBvcnQgQXV0aEFkbWluQXBpIGZyb20gJy4vQXV0aEFkbWluQXBpJ1xuaW1wb3J0IEF1dGhDbGllbnQgZnJvbSAnLi9BdXRoQ2xpZW50J1xuZXhwb3J0IHsgR29UcnVlQWRtaW5BcGksIEdvVHJ1ZUNsaWVudCwgQXV0aEFkbWluQXBpLCBBdXRoQ2xpZW50IH1cbmV4cG9ydCAqIGZyb20gJy4vbGliL3R5cGVzJ1xuZXhwb3J0ICogZnJvbSAnLi9saWIvZXJyb3JzJ1xuZXhwb3J0IHtcbiAgbmF2aWdhdG9yTG9jayxcbiAgTmF2aWdhdG9yTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IsXG4gIGludGVybmFscyBhcyBsb2NrSW50ZXJuYWxzLFxufSBmcm9tICcuL2xpYi9sb2NrcydcbiIsInZhciBfX3Jlc3QgPSAodGhpcyAmJiB0aGlzLl9fcmVzdCkgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgICB0W3BdID0gc1twXTtcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgICAgfVxuICAgIHJldHVybiB0O1xufTtcbmltcG9ydCB7IF9nZW5lcmF0ZUxpbmtSZXNwb25zZSwgX25vUmVzb2x2ZUpzb25SZXNwb25zZSwgX3JlcXVlc3QsIF91c2VyUmVzcG9uc2UsIH0gZnJvbSAnLi9saWIvZmV0Y2gnO1xuaW1wb3J0IHsgcmVzb2x2ZUZldGNoIH0gZnJvbSAnLi9saWIvaGVscGVycyc7XG5pbXBvcnQgeyBpc0F1dGhFcnJvciB9IGZyb20gJy4vbGliL2Vycm9ycyc7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHb1RydWVBZG1pbkFwaSB7XG4gICAgY29uc3RydWN0b3IoeyB1cmwgPSAnJywgaGVhZGVycyA9IHt9LCBmZXRjaCwgfSkge1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICAgICAgdGhpcy5mZXRjaCA9IHJlc29sdmVGZXRjaChmZXRjaCk7XG4gICAgICAgIHRoaXMubWZhID0ge1xuICAgICAgICAgICAgbGlzdEZhY3RvcnM6IHRoaXMuX2xpc3RGYWN0b3JzLmJpbmQodGhpcyksXG4gICAgICAgICAgICBkZWxldGVGYWN0b3I6IHRoaXMuX2RlbGV0ZUZhY3Rvci5iaW5kKHRoaXMpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgbG9nZ2VkLWluIHNlc3Npb24uXG4gICAgICogQHBhcmFtIGp3dCBBIHZhbGlkLCBsb2dnZWQtaW4gSldULlxuICAgICAqIEBwYXJhbSBzY29wZSBUaGUgbG9nb3V0IHNvcGUuXG4gICAgICovXG4gICAgYXN5bmMgc2lnbk91dChqd3QsIHNjb3BlID0gJ2dsb2JhbCcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L2xvZ291dD9zY29wZT0ke3Njb3BlfWAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgand0LFxuICAgICAgICAgICAgICAgIG5vUmVzb2x2ZUpzb246IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGFuIGludml0ZSBsaW5rIHRvIGFuIGVtYWlsIGFkZHJlc3MuXG4gICAgICogQHBhcmFtIGVtYWlsIFRoZSBlbWFpbCBhZGRyZXNzIG9mIHRoZSB1c2VyLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucyB0byBiZSBpbmNsdWRlZCB3aGVuIGludml0aW5nLlxuICAgICAqL1xuICAgIGFzeW5jIGludml0ZVVzZXJCeUVtYWlsKGVtYWlsLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9pbnZpdGVgLCB7XG4gICAgICAgICAgICAgICAgYm9keTogeyBlbWFpbCwgZGF0YTogb3B0aW9ucy5kYXRhIH0sXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHJlZGlyZWN0VG86IG9wdGlvbnMucmVkaXJlY3RUbyxcbiAgICAgICAgICAgICAgICB4Zm9ybTogX3VzZXJSZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGVtYWlsIGxpbmtzIGFuZCBPVFBzIHRvIGJlIHNlbnQgdmlhIGEgY3VzdG9tIGVtYWlsIHByb3ZpZGVyLlxuICAgICAqIEBwYXJhbSBlbWFpbCBUaGUgdXNlcidzIGVtYWlsLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnBhc3N3b3JkIFVzZXIgcGFzc3dvcmQuIEZvciBzaWdudXAgb25seS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5kYXRhIE9wdGlvbmFsIHVzZXIgbWV0YWRhdGEuIEZvciBzaWdudXAgb25seS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5yZWRpcmVjdFRvIFRoZSByZWRpcmVjdCB1cmwgd2hpY2ggc2hvdWxkIGJlIGFwcGVuZGVkIHRvIHRoZSBnZW5lcmF0ZWQgbGlua1xuICAgICAqL1xuICAgIGFzeW5jIGdlbmVyYXRlTGluayhwYXJhbXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gcGFyYW1zLCByZXN0ID0gX19yZXN0KHBhcmFtcywgW1wib3B0aW9uc1wiXSk7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXN0KSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoJ25ld0VtYWlsJyBpbiByZXN0KSB7XG4gICAgICAgICAgICAgICAgLy8gcmVwbGFjZSBuZXdFbWFpbCB3aXRoIG5ld19lbWFpbCBpbiByZXF1ZXN0IGJvZHlcbiAgICAgICAgICAgICAgICBib2R5Lm5ld19lbWFpbCA9IHJlc3QgPT09IG51bGwgfHwgcmVzdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzdC5uZXdFbWFpbDtcbiAgICAgICAgICAgICAgICBkZWxldGUgYm9keVsnbmV3RW1haWwnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9hZG1pbi9nZW5lcmF0ZV9saW5rYCwge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHhmb3JtOiBfZ2VuZXJhdGVMaW5rUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJlZGlyZWN0VG8sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFVzZXIgQWRtaW4gQVBJXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB1c2VyLlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlVXNlcihhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vYWRtaW4vdXNlcnNgLCB7XG4gICAgICAgICAgICAgICAgYm9keTogYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgeGZvcm06IF91c2VyUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIGxpc3Qgb2YgdXNlcnMuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgICAqIEBwYXJhbSBwYXJhbXMgQW4gb2JqZWN0IHdoaWNoIHN1cHBvcnRzIGBwYWdlYCBhbmQgYHBlclBhZ2VgIGFzIG51bWJlcnMsIHRvIGFsdGVyIHRoZSBwYWdpbmF0ZWQgcmVzdWx0cy5cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0VXNlcnMocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBhZ2luYXRpb24gPSB7IG5leHRQYWdlOiBudWxsLCBsYXN0UGFnZTogMCwgdG90YWw6IDAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS9hZG1pbi91c2Vyc2AsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgbm9SZXNvbHZlSnNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgICAgICBwYWdlOiAoX2IgPSAoX2EgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMucGFnZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvU3RyaW5nKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnLFxuICAgICAgICAgICAgICAgICAgICBwZXJfcGFnZTogKF9kID0gKF9jID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLnBlclBhZ2UpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy50b1N0cmluZygpKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAnJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHhmb3JtOiBfbm9SZXNvbHZlSnNvblJlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IpXG4gICAgICAgICAgICAgICAgdGhyb3cgcmVzcG9uc2UuZXJyb3I7XG4gICAgICAgICAgICBjb25zdCB1c2VycyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsID0gKF9lID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtdG90YWwtY291bnQnKSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxpbmtzID0gKF9nID0gKF9mID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2xpbmsnKSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLnNwbGl0KCcsJykpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IFtdO1xuICAgICAgICAgICAgaWYgKGxpbmtzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBsaW5rcy5mb3JFYWNoKChsaW5rKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhZ2UgPSBwYXJzZUludChsaW5rLnNwbGl0KCc7JylbMF0uc3BsaXQoJz0nKVsxXS5zdWJzdHJpbmcoMCwgMSkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWwgPSBKU09OLnBhcnNlKGxpbmsuc3BsaXQoJzsnKVsxXS5zcGxpdCgnPScpWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgcGFnaW5hdGlvbltgJHtyZWx9UGFnZWBdID0gcGFnZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBwYWdpbmF0aW9uLnRvdGFsID0gcGFyc2VJbnQodG90YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB1c2VycyksIHBhZ2luYXRpb24pLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcnM6IFtdIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdXNlciBieSBpZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1aWQgVGhlIHVzZXIncyB1bmlxdWUgaWRlbnRpZmllclxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gYSBzZXJ2ZXIuIE5ldmVyIGV4cG9zZSB5b3VyIGBzZXJ2aWNlX3JvbGVgIGtleSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRVc2VyQnlJZCh1aWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9L2FkbWluL3VzZXJzLyR7dWlkfWAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgeGZvcm06IF91c2VyUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHVzZXIgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVzIFRoZSBkYXRhIHlvdSB3YW50IHRvIHVwZGF0ZS5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlVXNlckJ5SWQodWlkLCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BVVCcsIGAke3RoaXMudXJsfS9hZG1pbi91c2Vycy8ke3VpZH1gLCB7XG4gICAgICAgICAgICAgICAgYm9keTogYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgeGZvcm06IF91c2VyUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIHVzZXIuIFJlcXVpcmVzIGEgYHNlcnZpY2Vfcm9sZWAga2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIFRoZSB1c2VyIGlkIHlvdSB3YW50IHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0gc2hvdWxkU29mdERlbGV0ZSBJZiB0cnVlLCB0aGVuIHRoZSB1c2VyIHdpbGwgYmUgc29mdC1kZWxldGVkIChzZXR0aW5nIGBkZWxldGVkX2F0YCB0byB0aGUgY3VycmVudCB0aW1lc3RhbXAgYW5kIGRpc2FibGluZyB0aGVpciBhY2NvdW50IHdoaWxlIHByZXNlcnZpbmcgdGhlaXIgZGF0YSkgZnJvbSB0aGUgYXV0aCBzY2hlbWEuXG4gICAgICogRGVmYXVsdHMgdG8gZmFsc2UgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZVVzZXIoaWQsIHNob3VsZFNvZnREZWxldGUgPSBmYWxzZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdERUxFVEUnLCBgJHt0aGlzLnVybH0vYWRtaW4vdXNlcnMvJHtpZH1gLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkX3NvZnRfZGVsZXRlOiBzaG91bGRTb2Z0RGVsZXRlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgeGZvcm06IF91c2VyUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9saXN0RmFjdG9ycyhwYXJhbXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdHRVQnLCBgJHt0aGlzLnVybH0vYWRtaW4vdXNlcnMvJHtwYXJhbXMudXNlcklkfS9mYWN0b3JzYCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICB4Zm9ybTogKGZhY3RvcnMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBmYWN0b3JzIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3IgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2RlbGV0ZUZhY3RvcihwYXJhbXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnREVMRVRFJywgYCR7dGhpcy51cmx9L2FkbWluL3VzZXJzLyR7cGFyYW1zLnVzZXJJZH0vZmFjdG9ycy8ke3BhcmFtcy5pZH1gLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdvVHJ1ZUFkbWluQXBpLmpzLm1hcCIsImltcG9ydCB7XG4gIEZldGNoLFxuICBfZ2VuZXJhdGVMaW5rUmVzcG9uc2UsXG4gIF9ub1Jlc29sdmVKc29uUmVzcG9uc2UsXG4gIF9yZXF1ZXN0LFxuICBfdXNlclJlc3BvbnNlLFxufSBmcm9tICcuL2xpYi9mZXRjaCdcbmltcG9ydCB7IHJlc29sdmVGZXRjaCB9IGZyb20gJy4vbGliL2hlbHBlcnMnXG5pbXBvcnQge1xuICBBZG1pblVzZXJBdHRyaWJ1dGVzLFxuICBHZW5lcmF0ZUxpbmtQYXJhbXMsXG4gIEdlbmVyYXRlTGlua1Jlc3BvbnNlLFxuICBQYWdpbmF0aW9uLFxuICBVc2VyLFxuICBVc2VyUmVzcG9uc2UsXG4gIEdvVHJ1ZUFkbWluTUZBQXBpLFxuICBBdXRoTUZBQWRtaW5EZWxldGVGYWN0b3JQYXJhbXMsXG4gIEF1dGhNRkFBZG1pbkRlbGV0ZUZhY3RvclJlc3BvbnNlLFxuICBBdXRoTUZBQWRtaW5MaXN0RmFjdG9yc1BhcmFtcyxcbiAgQXV0aE1GQUFkbWluTGlzdEZhY3RvcnNSZXNwb25zZSxcbiAgUGFnZVBhcmFtcyxcbn0gZnJvbSAnLi9saWIvdHlwZXMnXG5pbXBvcnQgeyBBdXRoRXJyb3IsIGlzQXV0aEVycm9yIH0gZnJvbSAnLi9saWIvZXJyb3JzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHb1RydWVBZG1pbkFwaSB7XG4gIC8qKiBDb250YWlucyBhbGwgTUZBIGFkbWluaXN0cmF0aW9uIG1ldGhvZHMuICovXG4gIG1mYTogR29UcnVlQWRtaW5NRkFBcGlcblxuICBwcm90ZWN0ZWQgdXJsOiBzdHJpbmdcbiAgcHJvdGVjdGVkIGhlYWRlcnM6IHtcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmdcbiAgfVxuICBwcm90ZWN0ZWQgZmV0Y2g6IEZldGNoXG5cbiAgY29uc3RydWN0b3Ioe1xuICAgIHVybCA9ICcnLFxuICAgIGhlYWRlcnMgPSB7fSxcbiAgICBmZXRjaCxcbiAgfToge1xuICAgIHVybDogc3RyaW5nXG4gICAgaGVhZGVycz86IHtcbiAgICAgIFtrZXk6IHN0cmluZ106IHN0cmluZ1xuICAgIH1cbiAgICBmZXRjaD86IEZldGNoXG4gIH0pIHtcbiAgICB0aGlzLnVybCA9IHVybFxuICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnNcbiAgICB0aGlzLmZldGNoID0gcmVzb2x2ZUZldGNoKGZldGNoKVxuICAgIHRoaXMubWZhID0ge1xuICAgICAgbGlzdEZhY3RvcnM6IHRoaXMuX2xpc3RGYWN0b3JzLmJpbmQodGhpcyksXG4gICAgICBkZWxldGVGYWN0b3I6IHRoaXMuX2RlbGV0ZUZhY3Rvci5iaW5kKHRoaXMpLFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgbG9nZ2VkLWluIHNlc3Npb24uXG4gICAqIEBwYXJhbSBqd3QgQSB2YWxpZCwgbG9nZ2VkLWluIEpXVC5cbiAgICogQHBhcmFtIHNjb3BlIFRoZSBsb2dvdXQgc29wZS5cbiAgICovXG4gIGFzeW5jIHNpZ25PdXQoXG4gICAgand0OiBzdHJpbmcsXG4gICAgc2NvcGU6ICdnbG9iYWwnIHwgJ2xvY2FsJyB8ICdvdGhlcnMnID0gJ2dsb2JhbCdcbiAgKTogUHJvbWlzZTx7IGRhdGE6IG51bGw7IGVycm9yOiBBdXRoRXJyb3IgfCBudWxsIH0+IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vbG9nb3V0P3Njb3BlPSR7c2NvcGV9YCwge1xuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgIGp3dCxcbiAgICAgICAgbm9SZXNvbHZlSnNvbjogdHJ1ZSxcbiAgICAgIH0pXG4gICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhbiBpbnZpdGUgbGluayB0byBhbiBlbWFpbCBhZGRyZXNzLlxuICAgKiBAcGFyYW0gZW1haWwgVGhlIGVtYWlsIGFkZHJlc3Mgb2YgdGhlIHVzZXIuXG4gICAqIEBwYXJhbSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucyB0byBiZSBpbmNsdWRlZCB3aGVuIGludml0aW5nLlxuICAgKi9cbiAgYXN5bmMgaW52aXRlVXNlckJ5RW1haWwoXG4gICAgZW1haWw6IHN0cmluZyxcbiAgICBvcHRpb25zOiB7XG4gICAgICAvKiogQSBjdXN0b20gZGF0YSBvYmplY3QgdG8gc3RvcmUgYWRkaXRpb25hbCBtZXRhZGF0YSBhYm91dCB0aGUgdXNlci4gVGhpcyBtYXBzIHRvIHRoZSBgYXV0aC51c2Vycy51c2VyX21ldGFkYXRhYCBjb2x1bW4uICovXG4gICAgICBkYXRhPzogb2JqZWN0XG5cbiAgICAgIC8qKiBUaGUgVVJMIHdoaWNoIHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhlIGVtYWlsIGxpbmsgc2VudCB0byB0aGUgdXNlcidzIGVtYWlsIGFkZHJlc3MuIE9uY2UgY2xpY2tlZCB0aGUgdXNlciB3aWxsIGVuZCB1cCBvbiB0aGlzIFVSTC4gKi9cbiAgICAgIHJlZGlyZWN0VG8/OiBzdHJpbmdcbiAgICB9ID0ge31cbiAgKTogUHJvbWlzZTxVc2VyUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L2ludml0ZWAsIHtcbiAgICAgICAgYm9keTogeyBlbWFpbCwgZGF0YTogb3B0aW9ucy5kYXRhIH0sXG4gICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucy5yZWRpcmVjdFRvLFxuICAgICAgICB4Zm9ybTogX3VzZXJSZXNwb25zZSxcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGVtYWlsIGxpbmtzIGFuZCBPVFBzIHRvIGJlIHNlbnQgdmlhIGEgY3VzdG9tIGVtYWlsIHByb3ZpZGVyLlxuICAgKiBAcGFyYW0gZW1haWwgVGhlIHVzZXIncyBlbWFpbC5cbiAgICogQHBhcmFtIG9wdGlvbnMucGFzc3dvcmQgVXNlciBwYXNzd29yZC4gRm9yIHNpZ251cCBvbmx5LlxuICAgKiBAcGFyYW0gb3B0aW9ucy5kYXRhIE9wdGlvbmFsIHVzZXIgbWV0YWRhdGEuIEZvciBzaWdudXAgb25seS5cbiAgICogQHBhcmFtIG9wdGlvbnMucmVkaXJlY3RUbyBUaGUgcmVkaXJlY3QgdXJsIHdoaWNoIHNob3VsZCBiZSBhcHBlbmRlZCB0byB0aGUgZ2VuZXJhdGVkIGxpbmtcbiAgICovXG4gIGFzeW5jIGdlbmVyYXRlTGluayhwYXJhbXM6IEdlbmVyYXRlTGlua1BhcmFtcyk6IFByb21pc2U8R2VuZXJhdGVMaW5rUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBvcHRpb25zLCAuLi5yZXN0IH0gPSBwYXJhbXNcbiAgICAgIGNvbnN0IGJvZHk6IGFueSA9IHsgLi4ucmVzdCwgLi4ub3B0aW9ucyB9XG4gICAgICBpZiAoJ25ld0VtYWlsJyBpbiByZXN0KSB7XG4gICAgICAgIC8vIHJlcGxhY2UgbmV3RW1haWwgd2l0aCBuZXdfZW1haWwgaW4gcmVxdWVzdCBib2R5XG4gICAgICAgIGJvZHkubmV3X2VtYWlsID0gcmVzdD8ubmV3RW1haWxcbiAgICAgICAgZGVsZXRlIGJvZHlbJ25ld0VtYWlsJ11cbiAgICAgIH1cbiAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9hZG1pbi9nZW5lcmF0ZV9saW5rYCwge1xuICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgIHhmb3JtOiBfZ2VuZXJhdGVMaW5rUmVzcG9uc2UsXG4gICAgICAgIHJlZGlyZWN0VG86IG9wdGlvbnM/LnJlZGlyZWN0VG8sXG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgcHJvcGVydGllczogbnVsbCxcbiAgICAgICAgICAgIHVzZXI6IG51bGwsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvLyBVc2VyIEFkbWluIEFQSVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB1c2VyLlxuICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgKi9cbiAgYXN5bmMgY3JlYXRlVXNlcihhdHRyaWJ1dGVzOiBBZG1pblVzZXJBdHRyaWJ1dGVzKTogUHJvbWlzZTxVc2VyUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L2FkbWluL3VzZXJzYCwge1xuICAgICAgICBib2R5OiBhdHRyaWJ1dGVzLFxuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgIHhmb3JtOiBfdXNlclJlc3BvbnNlLFxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBsaXN0IG9mIHVzZXJzLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgKiBAcGFyYW0gcGFyYW1zIEFuIG9iamVjdCB3aGljaCBzdXBwb3J0cyBgcGFnZWAgYW5kIGBwZXJQYWdlYCBhcyBudW1iZXJzLCB0byBhbHRlciB0aGUgcGFnaW5hdGVkIHJlc3VsdHMuXG4gICAqL1xuICBhc3luYyBsaXN0VXNlcnMoXG4gICAgcGFyYW1zPzogUGFnZVBhcmFtc1xuICApOiBQcm9taXNlPFxuICAgIHwgeyBkYXRhOiB7IHVzZXJzOiBVc2VyW107IGF1ZDogc3RyaW5nIH0gJiBQYWdpbmF0aW9uOyBlcnJvcjogbnVsbCB9XG4gICAgfCB7IGRhdGE6IHsgdXNlcnM6IFtdIH07IGVycm9yOiBBdXRoRXJyb3IgfVxuICA+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGFnaW5hdGlvbjogUGFnaW5hdGlvbiA9IHsgbmV4dFBhZ2U6IG51bGwsIGxhc3RQYWdlOiAwLCB0b3RhbDogMCB9XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdHRVQnLCBgJHt0aGlzLnVybH0vYWRtaW4vdXNlcnNgLCB7XG4gICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgbm9SZXNvbHZlSnNvbjogdHJ1ZSxcbiAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICBwYWdlOiBwYXJhbXM/LnBhZ2U/LnRvU3RyaW5nKCkgPz8gJycsXG4gICAgICAgICAgcGVyX3BhZ2U6IHBhcmFtcz8ucGVyUGFnZT8udG9TdHJpbmcoKSA/PyAnJyxcbiAgICAgICAgfSxcbiAgICAgICAgeGZvcm06IF9ub1Jlc29sdmVKc29uUmVzcG9uc2UsXG4gICAgICB9KVxuICAgICAgaWYgKHJlc3BvbnNlLmVycm9yKSB0aHJvdyByZXNwb25zZS5lcnJvclxuXG4gICAgICBjb25zdCB1c2VycyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgICAgY29uc3QgdG90YWwgPSByZXNwb25zZS5oZWFkZXJzLmdldCgneC10b3RhbC1jb3VudCcpID8/IDBcbiAgICAgIGNvbnN0IGxpbmtzID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2xpbmsnKT8uc3BsaXQoJywnKSA/PyBbXVxuICAgICAgaWYgKGxpbmtzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbGlua3MuZm9yRWFjaCgobGluazogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgcGFnZSA9IHBhcnNlSW50KGxpbmsuc3BsaXQoJzsnKVswXS5zcGxpdCgnPScpWzFdLnN1YnN0cmluZygwLCAxKSlcbiAgICAgICAgICBjb25zdCByZWwgPSBKU09OLnBhcnNlKGxpbmsuc3BsaXQoJzsnKVsxXS5zcGxpdCgnPScpWzFdKVxuICAgICAgICAgIHBhZ2luYXRpb25bYCR7cmVsfVBhZ2VgXSA9IHBhZ2VcbiAgICAgICAgfSlcblxuICAgICAgICBwYWdpbmF0aW9uLnRvdGFsID0gcGFyc2VJbnQodG90YWwpXG4gICAgICB9XG4gICAgICByZXR1cm4geyBkYXRhOiB7IC4uLnVzZXJzLCAuLi5wYWdpbmF0aW9uIH0sIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXJzOiBbXSB9LCBlcnJvciB9XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdXNlciBieSBpZC5cbiAgICpcbiAgICogQHBhcmFtIHVpZCBUaGUgdXNlcidzIHVuaXF1ZSBpZGVudGlmaWVyXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAqL1xuICBhc3luYyBnZXRVc2VyQnlJZCh1aWQ6IHN0cmluZyk6IFByb21pc2U8VXNlclJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9L2FkbWluL3VzZXJzLyR7dWlkfWAsIHtcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICB4Zm9ybTogX3VzZXJSZXNwb25zZSxcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgdXNlciBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0gYXR0cmlidXRlcyBUaGUgZGF0YSB5b3Ugd2FudCB0byB1cGRhdGUuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAqL1xuICBhc3luYyB1cGRhdGVVc2VyQnlJZCh1aWQ6IHN0cmluZywgYXR0cmlidXRlczogQWRtaW5Vc2VyQXR0cmlidXRlcyk6IFByb21pc2U8VXNlclJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUFVUJywgYCR7dGhpcy51cmx9L2FkbWluL3VzZXJzLyR7dWlkfWAsIHtcbiAgICAgICAgYm9keTogYXR0cmlidXRlcyxcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICB4Zm9ybTogX3VzZXJSZXNwb25zZSxcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIGEgdXNlci4gUmVxdWlyZXMgYSBgc2VydmljZV9yb2xlYCBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSBpZCBUaGUgdXNlciBpZCB5b3Ugd2FudCB0byByZW1vdmUuXG4gICAqIEBwYXJhbSBzaG91bGRTb2Z0RGVsZXRlIElmIHRydWUsIHRoZW4gdGhlIHVzZXIgd2lsbCBiZSBzb2Z0LWRlbGV0ZWQgKHNldHRpbmcgYGRlbGV0ZWRfYXRgIHRvIHRoZSBjdXJyZW50IHRpbWVzdGFtcCBhbmQgZGlzYWJsaW5nIHRoZWlyIGFjY291bnQgd2hpbGUgcHJlc2VydmluZyB0aGVpciBkYXRhKSBmcm9tIHRoZSBhdXRoIHNjaGVtYS5cbiAgICogRGVmYXVsdHMgdG8gZmFsc2UgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAqL1xuICBhc3luYyBkZWxldGVVc2VyKGlkOiBzdHJpbmcsIHNob3VsZFNvZnREZWxldGUgPSBmYWxzZSk6IFByb21pc2U8VXNlclJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnREVMRVRFJywgYCR7dGhpcy51cmx9L2FkbWluL3VzZXJzLyR7aWR9YCwge1xuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgIGJvZHk6IHtcbiAgICAgICAgICBzaG91bGRfc29mdF9kZWxldGU6IHNob3VsZFNvZnREZWxldGUsXG4gICAgICAgIH0sXG4gICAgICAgIHhmb3JtOiBfdXNlclJlc3BvbnNlLFxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX2xpc3RGYWN0b3JzKFxuICAgIHBhcmFtczogQXV0aE1GQUFkbWluTGlzdEZhY3RvcnNQYXJhbXNcbiAgKTogUHJvbWlzZTxBdXRoTUZBQWRtaW5MaXN0RmFjdG9yc1Jlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KFxuICAgICAgICB0aGlzLmZldGNoLFxuICAgICAgICAnR0VUJyxcbiAgICAgICAgYCR7dGhpcy51cmx9L2FkbWluL3VzZXJzLyR7cGFyYW1zLnVzZXJJZH0vZmFjdG9yc2AsXG4gICAgICAgIHtcbiAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgeGZvcm06IChmYWN0b3JzOiBhbnkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgZmFjdG9ycyB9LCBlcnJvcjogbnVsbCB9XG4gICAgICAgICAgfSxcbiAgICAgICAgfVxuICAgICAgKVxuICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3IgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF9kZWxldGVGYWN0b3IoXG4gICAgcGFyYW1zOiBBdXRoTUZBQWRtaW5EZWxldGVGYWN0b3JQYXJhbXNcbiAgKTogUHJvbWlzZTxBdXRoTUZBQWRtaW5EZWxldGVGYWN0b3JSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgX3JlcXVlc3QoXG4gICAgICAgIHRoaXMuZmV0Y2gsXG4gICAgICAgICdERUxFVEUnLFxuICAgICAgICBgJHt0aGlzLnVybH0vYWRtaW4vdXNlcnMvJHtwYXJhbXMudXNlcklkfS9mYWN0b3JzLyR7cGFyYW1zLmlkfWAsXG4gICAgICAgIHtcbiAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgIH1cbiAgICAgIClcblxuICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cbn1cbiIsInZhciBfX3Jlc3QgPSAodGhpcyAmJiB0aGlzLl9fcmVzdCkgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgICB0W3BdID0gc1twXTtcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgICAgfVxuICAgIHJldHVybiB0O1xufTtcbmltcG9ydCB7IEFQSV9WRVJTSU9OUywgQVBJX1ZFUlNJT05fSEVBREVSX05BTUUgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBleHBpcmVzQXQsIGxvb2tzTGlrZUZldGNoUmVzcG9uc2UsIHBhcnNlUmVzcG9uc2VBUElWZXJzaW9uIH0gZnJvbSAnLi9oZWxwZXJzJztcbmltcG9ydCB7IEF1dGhBcGlFcnJvciwgQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IsIEF1dGhXZWFrUGFzc3dvcmRFcnJvciwgQXV0aFVua25vd25FcnJvciwgfSBmcm9tICcuL2Vycm9ycyc7XG5jb25zdCBfZ2V0RXJyb3JNZXNzYWdlID0gKGVycikgPT4gZXJyLm1zZyB8fCBlcnIubWVzc2FnZSB8fCBlcnIuZXJyb3JfZGVzY3JpcHRpb24gfHwgZXJyLmVycm9yIHx8IEpTT04uc3RyaW5naWZ5KGVycik7XG5jb25zdCBORVRXT1JLX0VSUk9SX0NPREVTID0gWzUwMiwgNTAzLCA1MDRdO1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUVycm9yKGVycm9yKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghbG9va3NMaWtlRmV0Y2hSZXNwb25zZShlcnJvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEF1dGhSZXRyeWFibGVGZXRjaEVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZXJyb3IpLCAwKTtcbiAgICB9XG4gICAgaWYgKE5FVFdPUktfRVJST1JfQ09ERVMuaW5jbHVkZXMoZXJyb3Iuc3RhdHVzKSkge1xuICAgICAgICAvLyBzdGF0dXMgaW4gNTAwLi4uNTk5IHJhbmdlIC0gc2VydmVyIGhhZCBhbiBlcnJvciwgcmVxdWVzdCBtaWdodCBiZSByZXRyeWVkLlxuICAgICAgICB0aHJvdyBuZXcgQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IoX2dldEVycm9yTWVzc2FnZShlcnJvciksIGVycm9yLnN0YXR1cyk7XG4gICAgfVxuICAgIGxldCBkYXRhO1xuICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSBhd2FpdCBlcnJvci5qc29uKCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBBdXRoVW5rbm93bkVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZSksIGUpO1xuICAgIH1cbiAgICBsZXQgZXJyb3JDb2RlID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHJlc3BvbnNlQVBJVmVyc2lvbiA9IHBhcnNlUmVzcG9uc2VBUElWZXJzaW9uKGVycm9yKTtcbiAgICBpZiAocmVzcG9uc2VBUElWZXJzaW9uICYmXG4gICAgICAgIHJlc3BvbnNlQVBJVmVyc2lvbi5nZXRUaW1lKCkgPj0gQVBJX1ZFUlNJT05TWycyMDI0LTAxLTAxJ10udGltZXN0YW1wICYmXG4gICAgICAgIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBkYXRhICYmXG4gICAgICAgIHR5cGVvZiBkYXRhLmNvZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVycm9yQ29kZSA9IGRhdGEuY29kZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmIGRhdGEgJiYgdHlwZW9mIGRhdGEuZXJyb3JfY29kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZXJyb3JDb2RlID0gZGF0YS5lcnJvcl9jb2RlO1xuICAgIH1cbiAgICBpZiAoIWVycm9yQ29kZSkge1xuICAgICAgICAvLyBMZWdhY3kgc3VwcG9ydCBmb3Igd2VhayBwYXNzd29yZCBlcnJvcnMsIHdoZW4gdGhlcmUgd2VyZSBubyBlcnJvciBjb2Rlc1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBkYXRhICYmXG4gICAgICAgICAgICB0eXBlb2YgZGF0YS53ZWFrX3Bhc3N3b3JkID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgZGF0YS53ZWFrX3Bhc3N3b3JkICYmXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KGRhdGEud2Vha19wYXNzd29yZC5yZWFzb25zKSAmJlxuICAgICAgICAgICAgZGF0YS53ZWFrX3Bhc3N3b3JkLnJlYXNvbnMubGVuZ3RoICYmXG4gICAgICAgICAgICBkYXRhLndlYWtfcGFzc3dvcmQucmVhc29ucy5yZWR1Y2UoKGEsIGkpID0+IGEgJiYgdHlwZW9mIGkgPT09ICdzdHJpbmcnLCB0cnVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhXZWFrUGFzc3dvcmRFcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGRhdGEpLCBlcnJvci5zdGF0dXMsIGRhdGEud2Vha19wYXNzd29yZC5yZWFzb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChlcnJvckNvZGUgPT09ICd3ZWFrX3Bhc3N3b3JkJykge1xuICAgICAgICB0aHJvdyBuZXcgQXV0aFdlYWtQYXNzd29yZEVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZGF0YSksIGVycm9yLnN0YXR1cywgKChfYSA9IGRhdGEud2Vha19wYXNzd29yZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlYXNvbnMpIHx8IFtdKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEF1dGhBcGlFcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGRhdGEpLCBlcnJvci5zdGF0dXMgfHwgNTAwLCBlcnJvckNvZGUpO1xufVxuY29uc3QgX2dldFJlcXVlc3RQYXJhbXMgPSAobWV0aG9kLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KSA9PiB7XG4gICAgY29uc3QgcGFyYW1zID0geyBtZXRob2QsIGhlYWRlcnM6IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhZGVycykgfHwge30gfTtcbiAgICBpZiAobWV0aG9kID09PSAnR0VUJykge1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICBwYXJhbXMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb247Y2hhcnNldD1VVEYtOCcgfSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMpO1xuICAgIHBhcmFtcy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zKSwgcGFyYW1ldGVycyk7XG59O1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIF9yZXF1ZXN0KGZldGNoZXIsIG1ldGhvZCwgdXJsLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhZGVycyk7XG4gICAgaWYgKCFoZWFkZXJzW0FQSV9WRVJTSU9OX0hFQURFUl9OQU1FXSkge1xuICAgICAgICBoZWFkZXJzW0FQSV9WRVJTSU9OX0hFQURFUl9OQU1FXSA9IEFQSV9WRVJTSU9OU1snMjAyNC0wMS0wMSddLm5hbWU7XG4gICAgfVxuICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuand0KSB7XG4gICAgICAgIGhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXSA9IGBCZWFyZXIgJHtvcHRpb25zLmp3dH1gO1xuICAgIH1cbiAgICBjb25zdCBxcyA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5xdWVyeSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge307XG4gICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yZWRpcmVjdFRvKSB7XG4gICAgICAgIHFzWydyZWRpcmVjdF90byddID0gb3B0aW9ucy5yZWRpcmVjdFRvO1xuICAgIH1cbiAgICBjb25zdCBxdWVyeVN0cmluZyA9IE9iamVjdC5rZXlzKHFzKS5sZW5ndGggPyAnPycgKyBuZXcgVVJMU2VhcmNoUGFyYW1zKHFzKS50b1N0cmluZygpIDogJyc7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IF9oYW5kbGVSZXF1ZXN0KGZldGNoZXIsIG1ldGhvZCwgdXJsICsgcXVlcnlTdHJpbmcsIHtcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgbm9SZXNvbHZlSnNvbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm5vUmVzb2x2ZUpzb24sXG4gICAgfSwge30sIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ib2R5KTtcbiAgICByZXR1cm4gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy54Zm9ybSkgPyBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMueGZvcm0oZGF0YSkgOiB7IGRhdGE6IE9iamVjdC5hc3NpZ24oe30sIGRhdGEpLCBlcnJvcjogbnVsbCB9O1xufVxuYXN5bmMgZnVuY3Rpb24gX2hhbmRsZVJlcXVlc3QoZmV0Y2hlciwgbWV0aG9kLCB1cmwsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpIHtcbiAgICBjb25zdCByZXF1ZXN0UGFyYW1zID0gX2dldFJlcXVlc3RQYXJhbXMobWV0aG9kLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdCA9IGF3YWl0IGZldGNoZXIodXJsLCBPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0UGFyYW1zKSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIC8vIGZldGNoIGZhaWxlZCwgbGlrZWx5IGR1ZSB0byBhIG5ldHdvcmsgb3IgQ09SUyBlcnJvclxuICAgICAgICB0aHJvdyBuZXcgQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IoX2dldEVycm9yTWVzc2FnZShlKSwgMCk7XG4gICAgfVxuICAgIGlmICghcmVzdWx0Lm9rKSB7XG4gICAgICAgIGF3YWl0IGhhbmRsZUVycm9yKHJlc3VsdCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubm9SZXNvbHZlSnNvbikge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVzdWx0Lmpzb24oKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgYXdhaXQgaGFuZGxlRXJyb3IoZSk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIF9zZXNzaW9uUmVzcG9uc2UoZGF0YSkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgc2Vzc2lvbiA9IG51bGw7XG4gICAgaWYgKGhhc1Nlc3Npb24oZGF0YSkpIHtcbiAgICAgICAgc2Vzc2lvbiA9IE9iamVjdC5hc3NpZ24oe30sIGRhdGEpO1xuICAgICAgICBpZiAoIWRhdGEuZXhwaXJlc19hdCkge1xuICAgICAgICAgICAgc2Vzc2lvbi5leHBpcmVzX2F0ID0gZXhwaXJlc0F0KGRhdGEuZXhwaXJlc19pbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdXNlciA9IChfYSA9IGRhdGEudXNlcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGF0YTtcbiAgICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb24sIHVzZXIgfSwgZXJyb3I6IG51bGwgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBfc2Vzc2lvblJlc3BvbnNlUGFzc3dvcmQoZGF0YSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gX3Nlc3Npb25SZXNwb25zZShkYXRhKTtcbiAgICBpZiAoIXJlc3BvbnNlLmVycm9yICYmXG4gICAgICAgIGRhdGEud2Vha19wYXNzd29yZCAmJlxuICAgICAgICB0eXBlb2YgZGF0YS53ZWFrX3Bhc3N3b3JkID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBBcnJheS5pc0FycmF5KGRhdGEud2Vha19wYXNzd29yZC5yZWFzb25zKSAmJlxuICAgICAgICBkYXRhLndlYWtfcGFzc3dvcmQucmVhc29ucy5sZW5ndGggJiZcbiAgICAgICAgZGF0YS53ZWFrX3Bhc3N3b3JkLm1lc3NhZ2UgJiZcbiAgICAgICAgdHlwZW9mIGRhdGEud2Vha19wYXNzd29yZC5tZXNzYWdlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICBkYXRhLndlYWtfcGFzc3dvcmQucmVhc29ucy5yZWR1Y2UoKGEsIGkpID0+IGEgJiYgdHlwZW9mIGkgPT09ICdzdHJpbmcnLCB0cnVlKSkge1xuICAgICAgICByZXNwb25zZS5kYXRhLndlYWtfcGFzc3dvcmQgPSBkYXRhLndlYWtfcGFzc3dvcmQ7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBfdXNlclJlc3BvbnNlKGRhdGEpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgdXNlciA9IChfYSA9IGRhdGEudXNlcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGF0YTtcbiAgICByZXR1cm4geyBkYXRhOiB7IHVzZXIgfSwgZXJyb3I6IG51bGwgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBfc3NvUmVzcG9uc2UoZGF0YSkge1xuICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH07XG59XG5leHBvcnQgZnVuY3Rpb24gX2dlbmVyYXRlTGlua1Jlc3BvbnNlKGRhdGEpIHtcbiAgICBjb25zdCB7IGFjdGlvbl9saW5rLCBlbWFpbF9vdHAsIGhhc2hlZF90b2tlbiwgcmVkaXJlY3RfdG8sIHZlcmlmaWNhdGlvbl90eXBlIH0gPSBkYXRhLCByZXN0ID0gX19yZXN0KGRhdGEsIFtcImFjdGlvbl9saW5rXCIsIFwiZW1haWxfb3RwXCIsIFwiaGFzaGVkX3Rva2VuXCIsIFwicmVkaXJlY3RfdG9cIiwgXCJ2ZXJpZmljYXRpb25fdHlwZVwiXSk7XG4gICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgYWN0aW9uX2xpbmssXG4gICAgICAgIGVtYWlsX290cCxcbiAgICAgICAgaGFzaGVkX3Rva2VuLFxuICAgICAgICByZWRpcmVjdF90byxcbiAgICAgICAgdmVyaWZpY2F0aW9uX3R5cGUsXG4gICAgfTtcbiAgICBjb25zdCB1c2VyID0gT2JqZWN0LmFzc2lnbih7fSwgcmVzdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgcHJvcGVydGllcyxcbiAgICAgICAgICAgIHVzZXIsXG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gX25vUmVzb2x2ZUpzb25SZXNwb25zZShkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vKipcbiAqIGhhc1Nlc3Npb24gY2hlY2tzIGlmIHRoZSByZXNwb25zZSBvYmplY3QgY29udGFpbnMgYSB2YWxpZCBzZXNzaW9uXG4gKiBAcGFyYW0gZGF0YSBBIHJlc3BvbnNlIG9iamVjdFxuICogQHJldHVybnMgdHJ1ZSBpZiBhIHNlc3Npb24gaXMgaW4gdGhlIHJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIGhhc1Nlc3Npb24oZGF0YSkge1xuICAgIHJldHVybiBkYXRhLmFjY2Vzc190b2tlbiAmJiBkYXRhLnJlZnJlc2hfdG9rZW4gJiYgZGF0YS5leHBpcmVzX2luO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmV0Y2guanMubWFwIiwiaW1wb3J0IHsgQVBJX1ZFUlNJT05TLCBBUElfVkVSU0lPTl9IRUFERVJfTkFNRSB9IGZyb20gJy4vY29uc3RhbnRzJ1xuaW1wb3J0IHsgZXhwaXJlc0F0LCBsb29rc0xpa2VGZXRjaFJlc3BvbnNlLCBwYXJzZVJlc3BvbnNlQVBJVmVyc2lvbiB9IGZyb20gJy4vaGVscGVycydcbmltcG9ydCB7XG4gIEF1dGhSZXNwb25zZSxcbiAgQXV0aFJlc3BvbnNlUGFzc3dvcmQsXG4gIFNTT1Jlc3BvbnNlLFxuICBHZW5lcmF0ZUxpbmtQcm9wZXJ0aWVzLFxuICBHZW5lcmF0ZUxpbmtSZXNwb25zZSxcbiAgVXNlcixcbiAgVXNlclJlc3BvbnNlLFxufSBmcm9tICcuL3R5cGVzJ1xuaW1wb3J0IHtcbiAgQXV0aEFwaUVycm9yLFxuICBBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcixcbiAgQXV0aFdlYWtQYXNzd29yZEVycm9yLFxuICBBdXRoVW5rbm93bkVycm9yLFxufSBmcm9tICcuL2Vycm9ycydcblxuZXhwb3J0IHR5cGUgRmV0Y2ggPSB0eXBlb2YgZmV0Y2hcblxuZXhwb3J0IGludGVyZmFjZSBGZXRjaE9wdGlvbnMge1xuICBoZWFkZXJzPzoge1xuICAgIFtrZXk6IHN0cmluZ106IHN0cmluZ1xuICB9XG4gIG5vUmVzb2x2ZUpzb24/OiBib29sZWFuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmV0Y2hQYXJhbWV0ZXJzIHtcbiAgc2lnbmFsPzogQWJvcnRTaWduYWxcbn1cblxuZXhwb3J0IHR5cGUgUmVxdWVzdE1ldGhvZFR5cGUgPSAnR0VUJyB8ICdQT1NUJyB8ICdQVVQnIHwgJ0RFTEVURSdcblxuY29uc3QgX2dldEVycm9yTWVzc2FnZSA9IChlcnI6IGFueSk6IHN0cmluZyA9PlxuICBlcnIubXNnIHx8IGVyci5tZXNzYWdlIHx8IGVyci5lcnJvcl9kZXNjcmlwdGlvbiB8fCBlcnIuZXJyb3IgfHwgSlNPTi5zdHJpbmdpZnkoZXJyKVxuXG5jb25zdCBORVRXT1JLX0VSUk9SX0NPREVTID0gWzUwMiwgNTAzLCA1MDRdXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBoYW5kbGVFcnJvcihlcnJvcjogdW5rbm93bikge1xuICBpZiAoIWxvb2tzTGlrZUZldGNoUmVzcG9uc2UoZXJyb3IpKSB7XG4gICAgdGhyb3cgbmV3IEF1dGhSZXRyeWFibGVGZXRjaEVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZXJyb3IpLCAwKVxuICB9XG5cbiAgaWYgKE5FVFdPUktfRVJST1JfQ09ERVMuaW5jbHVkZXMoZXJyb3Iuc3RhdHVzKSkge1xuICAgIC8vIHN0YXR1cyBpbiA1MDAuLi41OTkgcmFuZ2UgLSBzZXJ2ZXIgaGFkIGFuIGVycm9yLCByZXF1ZXN0IG1pZ2h0IGJlIHJldHJ5ZWQuXG4gICAgdGhyb3cgbmV3IEF1dGhSZXRyeWFibGVGZXRjaEVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZXJyb3IpLCBlcnJvci5zdGF0dXMpXG4gIH1cblxuICBsZXQgZGF0YTogYW55XG4gIHRyeSB7XG4gICAgZGF0YSA9IGF3YWl0IGVycm9yLmpzb24oKVxuICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICB0aHJvdyBuZXcgQXV0aFVua25vd25FcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGUpLCBlKVxuICB9XG5cbiAgbGV0IGVycm9yQ29kZTogc3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkXG5cbiAgY29uc3QgcmVzcG9uc2VBUElWZXJzaW9uID0gcGFyc2VSZXNwb25zZUFQSVZlcnNpb24oZXJyb3IpXG4gIGlmIChcbiAgICByZXNwb25zZUFQSVZlcnNpb24gJiZcbiAgICByZXNwb25zZUFQSVZlcnNpb24uZ2V0VGltZSgpID49IEFQSV9WRVJTSU9OU1snMjAyNC0wMS0wMSddLnRpbWVzdGFtcCAmJlxuICAgIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJlxuICAgIGRhdGEgJiZcbiAgICB0eXBlb2YgZGF0YS5jb2RlID09PSAnc3RyaW5nJ1xuICApIHtcbiAgICBlcnJvckNvZGUgPSBkYXRhLmNvZGVcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiYgZGF0YSAmJiB0eXBlb2YgZGF0YS5lcnJvcl9jb2RlID09PSAnc3RyaW5nJykge1xuICAgIGVycm9yQ29kZSA9IGRhdGEuZXJyb3JfY29kZVxuICB9XG5cbiAgaWYgKCFlcnJvckNvZGUpIHtcbiAgICAvLyBMZWdhY3kgc3VwcG9ydCBmb3Igd2VhayBwYXNzd29yZCBlcnJvcnMsIHdoZW4gdGhlcmUgd2VyZSBubyBlcnJvciBjb2Rlc1xuICAgIGlmIChcbiAgICAgIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJlxuICAgICAgZGF0YSAmJlxuICAgICAgdHlwZW9mIGRhdGEud2Vha19wYXNzd29yZCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIGRhdGEud2Vha19wYXNzd29yZCAmJlxuICAgICAgQXJyYXkuaXNBcnJheShkYXRhLndlYWtfcGFzc3dvcmQucmVhc29ucykgJiZcbiAgICAgIGRhdGEud2Vha19wYXNzd29yZC5yZWFzb25zLmxlbmd0aCAmJlxuICAgICAgZGF0YS53ZWFrX3Bhc3N3b3JkLnJlYXNvbnMucmVkdWNlKChhOiBib29sZWFuLCBpOiBhbnkpID0+IGEgJiYgdHlwZW9mIGkgPT09ICdzdHJpbmcnLCB0cnVlKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEF1dGhXZWFrUGFzc3dvcmRFcnJvcihcbiAgICAgICAgX2dldEVycm9yTWVzc2FnZShkYXRhKSxcbiAgICAgICAgZXJyb3Iuc3RhdHVzLFxuICAgICAgICBkYXRhLndlYWtfcGFzc3dvcmQucmVhc29uc1xuICAgICAgKVxuICAgIH1cbiAgfSBlbHNlIGlmIChlcnJvckNvZGUgPT09ICd3ZWFrX3Bhc3N3b3JkJykge1xuICAgIHRocm93IG5ldyBBdXRoV2Vha1Bhc3N3b3JkRXJyb3IoXG4gICAgICBfZ2V0RXJyb3JNZXNzYWdlKGRhdGEpLFxuICAgICAgZXJyb3Iuc3RhdHVzLFxuICAgICAgZGF0YS53ZWFrX3Bhc3N3b3JkPy5yZWFzb25zIHx8IFtdXG4gICAgKVxuICB9XG5cbiAgdGhyb3cgbmV3IEF1dGhBcGlFcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGRhdGEpLCBlcnJvci5zdGF0dXMgfHwgNTAwLCBlcnJvckNvZGUpXG59XG5cbmNvbnN0IF9nZXRSZXF1ZXN0UGFyYW1zID0gKFxuICBtZXRob2Q6IFJlcXVlc3RNZXRob2RUeXBlLFxuICBvcHRpb25zPzogRmV0Y2hPcHRpb25zLFxuICBwYXJhbWV0ZXJzPzogRmV0Y2hQYXJhbWV0ZXJzLFxuICBib2R5Pzogb2JqZWN0XG4pID0+IHtcbiAgY29uc3QgcGFyYW1zOiB7IFtrOiBzdHJpbmddOiBhbnkgfSA9IHsgbWV0aG9kLCBoZWFkZXJzOiBvcHRpb25zPy5oZWFkZXJzIHx8IHt9IH1cblxuICBpZiAobWV0aG9kID09PSAnR0VUJykge1xuICAgIHJldHVybiBwYXJhbXNcbiAgfVxuXG4gIHBhcmFtcy5oZWFkZXJzID0geyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb247Y2hhcnNldD1VVEYtOCcsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfVxuICBwYXJhbXMuYm9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHkpXG4gIHJldHVybiB7IC4uLnBhcmFtcywgLi4ucGFyYW1ldGVycyB9XG59XG5cbmludGVyZmFjZSBHb3RydWVSZXF1ZXN0T3B0aW9ucyBleHRlbmRzIEZldGNoT3B0aW9ucyB7XG4gIGp3dD86IHN0cmluZ1xuICByZWRpcmVjdFRvPzogc3RyaW5nXG4gIGJvZHk/OiBvYmplY3RcbiAgcXVlcnk/OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9XG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0aGF0IHRyYW5zZm9ybXMgYXBpIHJlc3BvbnNlIGZyb20gZ290cnVlIGludG8gYSBkZXNpcmFibGUgLyBzdGFuZGFyZGlzZWQgZm9ybWF0XG4gICAqL1xuICB4Zm9ybT86IChkYXRhOiBhbnkpID0+IGFueVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gX3JlcXVlc3QoXG4gIGZldGNoZXI6IEZldGNoLFxuICBtZXRob2Q6IFJlcXVlc3RNZXRob2RUeXBlLFxuICB1cmw6IHN0cmluZyxcbiAgb3B0aW9ucz86IEdvdHJ1ZVJlcXVlc3RPcHRpb25zXG4pIHtcbiAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAuLi5vcHRpb25zPy5oZWFkZXJzLFxuICB9XG5cbiAgaWYgKCFoZWFkZXJzW0FQSV9WRVJTSU9OX0hFQURFUl9OQU1FXSkge1xuICAgIGhlYWRlcnNbQVBJX1ZFUlNJT05fSEVBREVSX05BTUVdID0gQVBJX1ZFUlNJT05TWycyMDI0LTAxLTAxJ10ubmFtZVxuICB9XG5cbiAgaWYgKG9wdGlvbnM/Lmp3dCkge1xuICAgIGhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXSA9IGBCZWFyZXIgJHtvcHRpb25zLmp3dH1gXG4gIH1cblxuICBjb25zdCBxcyA9IG9wdGlvbnM/LnF1ZXJ5ID8/IHt9XG4gIGlmIChvcHRpb25zPy5yZWRpcmVjdFRvKSB7XG4gICAgcXNbJ3JlZGlyZWN0X3RvJ10gPSBvcHRpb25zLnJlZGlyZWN0VG9cbiAgfVxuXG4gIGNvbnN0IHF1ZXJ5U3RyaW5nID0gT2JqZWN0LmtleXMocXMpLmxlbmd0aCA/ICc/JyArIG5ldyBVUkxTZWFyY2hQYXJhbXMocXMpLnRvU3RyaW5nKCkgOiAnJ1xuICBjb25zdCBkYXRhID0gYXdhaXQgX2hhbmRsZVJlcXVlc3QoXG4gICAgZmV0Y2hlcixcbiAgICBtZXRob2QsXG4gICAgdXJsICsgcXVlcnlTdHJpbmcsXG4gICAge1xuICAgICAgaGVhZGVycyxcbiAgICAgIG5vUmVzb2x2ZUpzb246IG9wdGlvbnM/Lm5vUmVzb2x2ZUpzb24sXG4gICAgfSxcbiAgICB7fSxcbiAgICBvcHRpb25zPy5ib2R5XG4gIClcbiAgcmV0dXJuIG9wdGlvbnM/Lnhmb3JtID8gb3B0aW9ucz8ueGZvcm0oZGF0YSkgOiB7IGRhdGE6IHsgLi4uZGF0YSB9LCBlcnJvcjogbnVsbCB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIF9oYW5kbGVSZXF1ZXN0KFxuICBmZXRjaGVyOiBGZXRjaCxcbiAgbWV0aG9kOiBSZXF1ZXN0TWV0aG9kVHlwZSxcbiAgdXJsOiBzdHJpbmcsXG4gIG9wdGlvbnM/OiBGZXRjaE9wdGlvbnMsXG4gIHBhcmFtZXRlcnM/OiBGZXRjaFBhcmFtZXRlcnMsXG4gIGJvZHk/OiBvYmplY3Rcbik6IFByb21pc2U8YW55PiB7XG4gIGNvbnN0IHJlcXVlc3RQYXJhbXMgPSBfZ2V0UmVxdWVzdFBhcmFtcyhtZXRob2QsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpXG5cbiAgbGV0IHJlc3VsdDogYW55XG5cbiAgdHJ5IHtcbiAgICByZXN1bHQgPSBhd2FpdCBmZXRjaGVyKHVybCwge1xuICAgICAgLi4ucmVxdWVzdFBhcmFtcyxcbiAgICB9KVxuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihlKVxuXG4gICAgLy8gZmV0Y2ggZmFpbGVkLCBsaWtlbHkgZHVlIHRvIGEgbmV0d29yayBvciBDT1JTIGVycm9yXG4gICAgdGhyb3cgbmV3IEF1dGhSZXRyeWFibGVGZXRjaEVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZSksIDApXG4gIH1cblxuICBpZiAoIXJlc3VsdC5vaykge1xuICAgIGF3YWl0IGhhbmRsZUVycm9yKHJlc3VsdClcbiAgfVxuXG4gIGlmIChvcHRpb25zPy5ub1Jlc29sdmVKc29uKSB7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgcmVzdWx0Lmpzb24oKVxuICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICBhd2FpdCBoYW5kbGVFcnJvcihlKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfc2Vzc2lvblJlc3BvbnNlKGRhdGE6IGFueSk6IEF1dGhSZXNwb25zZSB7XG4gIGxldCBzZXNzaW9uID0gbnVsbFxuICBpZiAoaGFzU2Vzc2lvbihkYXRhKSkge1xuICAgIHNlc3Npb24gPSB7IC4uLmRhdGEgfVxuXG4gICAgaWYgKCFkYXRhLmV4cGlyZXNfYXQpIHtcbiAgICAgIHNlc3Npb24uZXhwaXJlc19hdCA9IGV4cGlyZXNBdChkYXRhLmV4cGlyZXNfaW4pXG4gICAgfVxuICB9XG5cbiAgY29uc3QgdXNlcjogVXNlciA9IGRhdGEudXNlciA/PyAoZGF0YSBhcyBVc2VyKVxuICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb24sIHVzZXIgfSwgZXJyb3I6IG51bGwgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX3Nlc3Npb25SZXNwb25zZVBhc3N3b3JkKGRhdGE6IGFueSk6IEF1dGhSZXNwb25zZVBhc3N3b3JkIHtcbiAgY29uc3QgcmVzcG9uc2UgPSBfc2Vzc2lvblJlc3BvbnNlKGRhdGEpIGFzIEF1dGhSZXNwb25zZVBhc3N3b3JkXG5cbiAgaWYgKFxuICAgICFyZXNwb25zZS5lcnJvciAmJlxuICAgIGRhdGEud2Vha19wYXNzd29yZCAmJlxuICAgIHR5cGVvZiBkYXRhLndlYWtfcGFzc3dvcmQgPT09ICdvYmplY3QnICYmXG4gICAgQXJyYXkuaXNBcnJheShkYXRhLndlYWtfcGFzc3dvcmQucmVhc29ucykgJiZcbiAgICBkYXRhLndlYWtfcGFzc3dvcmQucmVhc29ucy5sZW5ndGggJiZcbiAgICBkYXRhLndlYWtfcGFzc3dvcmQubWVzc2FnZSAmJlxuICAgIHR5cGVvZiBkYXRhLndlYWtfcGFzc3dvcmQubWVzc2FnZSA9PT0gJ3N0cmluZycgJiZcbiAgICBkYXRhLndlYWtfcGFzc3dvcmQucmVhc29ucy5yZWR1Y2UoKGE6IGJvb2xlYW4sIGk6IGFueSkgPT4gYSAmJiB0eXBlb2YgaSA9PT0gJ3N0cmluZycsIHRydWUpXG4gICkge1xuICAgIHJlc3BvbnNlLmRhdGEud2Vha19wYXNzd29yZCA9IGRhdGEud2Vha19wYXNzd29yZFxuICB9XG5cbiAgcmV0dXJuIHJlc3BvbnNlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfdXNlclJlc3BvbnNlKGRhdGE6IGFueSk6IFVzZXJSZXNwb25zZSB7XG4gIGNvbnN0IHVzZXI6IFVzZXIgPSBkYXRhLnVzZXIgPz8gKGRhdGEgYXMgVXNlcilcbiAgcmV0dXJuIHsgZGF0YTogeyB1c2VyIH0sIGVycm9yOiBudWxsIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9zc29SZXNwb25zZShkYXRhOiBhbnkpOiBTU09SZXNwb25zZSB7XG4gIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9nZW5lcmF0ZUxpbmtSZXNwb25zZShkYXRhOiBhbnkpOiBHZW5lcmF0ZUxpbmtSZXNwb25zZSB7XG4gIGNvbnN0IHsgYWN0aW9uX2xpbmssIGVtYWlsX290cCwgaGFzaGVkX3Rva2VuLCByZWRpcmVjdF90bywgdmVyaWZpY2F0aW9uX3R5cGUsIC4uLnJlc3QgfSA9IGRhdGFcblxuICBjb25zdCBwcm9wZXJ0aWVzOiBHZW5lcmF0ZUxpbmtQcm9wZXJ0aWVzID0ge1xuICAgIGFjdGlvbl9saW5rLFxuICAgIGVtYWlsX290cCxcbiAgICBoYXNoZWRfdG9rZW4sXG4gICAgcmVkaXJlY3RfdG8sXG4gICAgdmVyaWZpY2F0aW9uX3R5cGUsXG4gIH1cblxuICBjb25zdCB1c2VyOiBVc2VyID0geyAuLi5yZXN0IH1cbiAgcmV0dXJuIHtcbiAgICBkYXRhOiB7XG4gICAgICBwcm9wZXJ0aWVzLFxuICAgICAgdXNlcixcbiAgICB9LFxuICAgIGVycm9yOiBudWxsLFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfbm9SZXNvbHZlSnNvblJlc3BvbnNlKGRhdGE6IGFueSk6IFJlc3BvbnNlIHtcbiAgcmV0dXJuIGRhdGFcbn1cblxuLyoqXG4gKiBoYXNTZXNzaW9uIGNoZWNrcyBpZiB0aGUgcmVzcG9uc2Ugb2JqZWN0IGNvbnRhaW5zIGEgdmFsaWQgc2Vzc2lvblxuICogQHBhcmFtIGRhdGEgQSByZXNwb25zZSBvYmplY3RcbiAqIEByZXR1cm5zIHRydWUgaWYgYSBzZXNzaW9uIGlzIGluIHRoZSByZXNwb25zZVxuICovXG5mdW5jdGlvbiBoYXNTZXNzaW9uKGRhdGE6IGFueSk6IGJvb2xlYW4ge1xuICByZXR1cm4gZGF0YS5hY2Nlc3NfdG9rZW4gJiYgZGF0YS5yZWZyZXNoX3Rva2VuICYmIGRhdGEuZXhwaXJlc19pblxufVxuIiwiaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbic7XG5leHBvcnQgY29uc3QgR09UUlVFX1VSTCA9ICdodHRwOi8vbG9jYWxob3N0Ojk5OTknO1xuZXhwb3J0IGNvbnN0IFNUT1JBR0VfS0VZID0gJ3N1cGFiYXNlLmF1dGgudG9rZW4nO1xuZXhwb3J0IGNvbnN0IEFVRElFTkNFID0gJyc7XG5leHBvcnQgY29uc3QgREVGQVVMVF9IRUFERVJTID0geyAnWC1DbGllbnQtSW5mbyc6IGBnb3RydWUtanMvJHt2ZXJzaW9ufWAgfTtcbmV4cG9ydCBjb25zdCBFWFBJUllfTUFSR0lOID0gMTA7IC8vIGluIHNlY29uZHNcbmV4cG9ydCBjb25zdCBORVRXT1JLX0ZBSUxVUkUgPSB7XG4gICAgTUFYX1JFVFJJRVM6IDEwLFxuICAgIFJFVFJZX0lOVEVSVkFMOiAyLCAvLyBpbiBkZWNpc2Vjb25kc1xufTtcbmV4cG9ydCBjb25zdCBBUElfVkVSU0lPTl9IRUFERVJfTkFNRSA9ICdYLVN1cGFiYXNlLUFwaS1WZXJzaW9uJztcbmV4cG9ydCBjb25zdCBBUElfVkVSU0lPTlMgPSB7XG4gICAgJzIwMjQtMDEtMDEnOiB7XG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5wYXJzZSgnMjAyNC0wMS0wMVQwMDowMDowMC4wWicpLFxuICAgICAgICBuYW1lOiAnMjAyNC0wMS0wMScsXG4gICAgfSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIiwiaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbidcbmV4cG9ydCBjb25zdCBHT1RSVUVfVVJMID0gJ2h0dHA6Ly9sb2NhbGhvc3Q6OTk5OSdcbmV4cG9ydCBjb25zdCBTVE9SQUdFX0tFWSA9ICdzdXBhYmFzZS5hdXRoLnRva2VuJ1xuZXhwb3J0IGNvbnN0IEFVRElFTkNFID0gJydcbmV4cG9ydCBjb25zdCBERUZBVUxUX0hFQURFUlMgPSB7ICdYLUNsaWVudC1JbmZvJzogYGdvdHJ1ZS1qcy8ke3ZlcnNpb259YCB9XG5leHBvcnQgY29uc3QgRVhQSVJZX01BUkdJTiA9IDEwIC8vIGluIHNlY29uZHNcbmV4cG9ydCBjb25zdCBORVRXT1JLX0ZBSUxVUkUgPSB7XG4gIE1BWF9SRVRSSUVTOiAxMCxcbiAgUkVUUllfSU5URVJWQUw6IDIsIC8vIGluIGRlY2lzZWNvbmRzXG59XG5cbmV4cG9ydCBjb25zdCBBUElfVkVSU0lPTl9IRUFERVJfTkFNRSA9ICdYLVN1cGFiYXNlLUFwaS1WZXJzaW9uJ1xuZXhwb3J0IGNvbnN0IEFQSV9WRVJTSU9OUyA9IHtcbiAgJzIwMjQtMDEtMDEnOiB7XG4gICAgdGltZXN0YW1wOiBEYXRlLnBhcnNlKCcyMDI0LTAxLTAxVDAwOjAwOjAwLjBaJyksXG4gICAgbmFtZTogJzIwMjQtMDEtMDEnLFxuICB9LFxufVxuIiwiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSAnMi42NC40Jztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb24uanMubWFwIiwiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSAnMi42NC40J1xuIiwiaW1wb3J0IHsgQVBJX1ZFUlNJT05fSEVBREVSX05BTUUgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5leHBvcnQgZnVuY3Rpb24gZXhwaXJlc0F0KGV4cGlyZXNJbikge1xuICAgIGNvbnN0IHRpbWVOb3cgPSBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxMDAwKTtcbiAgICByZXR1cm4gdGltZU5vdyArIGV4cGlyZXNJbjtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1dWlkKCkge1xuICAgIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGNvbnN0IHIgPSAoTWF0aC5yYW5kb20oKSAqIDE2KSB8IDAsIHYgPSBjID09ICd4JyA/IHIgOiAociAmIDB4MykgfCAweDg7XG4gICAgICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBpc0Jyb3dzZXIgPSAoKSA9PiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuY29uc3QgbG9jYWxTdG9yYWdlV3JpdGVUZXN0cyA9IHtcbiAgICB0ZXN0ZWQ6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiBmYWxzZSxcbn07XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGxvY2FsU3RvcmFnZSBpcyBzdXBwb3J0ZWQgb24gdGhpcyBicm93c2VyLlxuICovXG5leHBvcnQgY29uc3Qgc3VwcG9ydHNMb2NhbFN0b3JhZ2UgPSAoKSA9PiB7XG4gICAgaWYgKCFpc0Jyb3dzZXIoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2UgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gRE9NIGV4Y2VwdGlvbiB3aGVuIGFjY2Vzc2luZyBgbG9jYWxTdG9yYWdlYFxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzLnRlc3RlZCkge1xuICAgICAgICByZXR1cm4gbG9jYWxTdG9yYWdlV3JpdGVUZXN0cy53cml0YWJsZTtcbiAgICB9XG4gICAgY29uc3QgcmFuZG9tS2V5ID0gYGxzd3QtJHtNYXRoLnJhbmRvbSgpfSR7TWF0aC5yYW5kb20oKX1gO1xuICAgIHRyeSB7XG4gICAgICAgIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlLnNldEl0ZW0ocmFuZG9tS2V5LCByYW5kb21LZXkpO1xuICAgICAgICBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHJhbmRvbUtleSk7XG4gICAgICAgIGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMudGVzdGVkID0gdHJ1ZTtcbiAgICAgICAgbG9jYWxTdG9yYWdlV3JpdGVUZXN0cy53cml0YWJsZSA9IHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGxvY2FsU3RvcmFnZSBjYW4ndCBiZSB3cml0dGVuIHRvXG4gICAgICAgIC8vIGh0dHBzOi8vd3d3LmNocm9taXVtLm9yZy9mb3ItdGVzdGVycy9idWctcmVwb3J0aW5nLWd1aWRlbGluZXMvdW5jYXVnaHQtc2VjdXJpdHllcnJvci1mYWlsZWQtdG8tcmVhZC10aGUtbG9jYWxzdG9yYWdlLXByb3BlcnR5LWZyb20td2luZG93LWFjY2Vzcy1pcy1kZW5pZWQtZm9yLXRoaXMtZG9jdW1lbnRcbiAgICAgICAgbG9jYWxTdG9yYWdlV3JpdGVUZXN0cy50ZXN0ZWQgPSB0cnVlO1xuICAgICAgICBsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzLndyaXRhYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzLndyaXRhYmxlO1xufTtcbi8qKlxuICogRXh0cmFjdHMgcGFyYW1ldGVycyBlbmNvZGVkIGluIHRoZSBVUkwgYm90aCBpbiB0aGUgcXVlcnkgYW5kIGZyYWdtZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VQYXJhbWV0ZXJzRnJvbVVSTChocmVmKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChocmVmKTtcbiAgICBpZiAodXJsLmhhc2ggJiYgdXJsLmhhc2hbMF0gPT09ICcjJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaGFzaFNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXModXJsLmhhc2guc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgICAgIGhhc2hTZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gaGFzaCBpcyBub3QgYSBxdWVyeSBzdHJpbmdcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBzZWFyY2ggcGFyYW1ldGVycyB0YWtlIHByZWNlZGVuY2Ugb3ZlciBoYXNoIHBhcmFtZXRlcnNcbiAgICB1cmwuc2VhcmNoUGFyYW1zLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGNvbnN0IHJlc29sdmVGZXRjaCA9IChjdXN0b21GZXRjaCkgPT4ge1xuICAgIGxldCBfZmV0Y2g7XG4gICAgaWYgKGN1c3RvbUZldGNoKSB7XG4gICAgICAgIF9mZXRjaCA9IGN1c3RvbUZldGNoO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZmV0Y2ggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIF9mZXRjaCA9ICguLi5hcmdzKSA9PiBpbXBvcnQoJ0BzdXBhYmFzZS9ub2RlLWZldGNoJykudGhlbigoeyBkZWZhdWx0OiBmZXRjaCB9KSA9PiBmZXRjaCguLi5hcmdzKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBfZmV0Y2ggPSBmZXRjaDtcbiAgICB9XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiBfZmV0Y2goLi4uYXJncyk7XG59O1xuZXhwb3J0IGNvbnN0IGxvb2tzTGlrZUZldGNoUmVzcG9uc2UgPSAobWF5YmVSZXNwb25zZSkgPT4ge1xuICAgIHJldHVybiAodHlwZW9mIG1heWJlUmVzcG9uc2UgPT09ICdvYmplY3QnICYmXG4gICAgICAgIG1heWJlUmVzcG9uc2UgIT09IG51bGwgJiZcbiAgICAgICAgJ3N0YXR1cycgaW4gbWF5YmVSZXNwb25zZSAmJlxuICAgICAgICAnb2snIGluIG1heWJlUmVzcG9uc2UgJiZcbiAgICAgICAgJ2pzb24nIGluIG1heWJlUmVzcG9uc2UgJiZcbiAgICAgICAgdHlwZW9mIG1heWJlUmVzcG9uc2UuanNvbiA9PT0gJ2Z1bmN0aW9uJyk7XG59O1xuLy8gU3RvcmFnZSBoZWxwZXJzXG5leHBvcnQgY29uc3Qgc2V0SXRlbUFzeW5jID0gYXN5bmMgKHN0b3JhZ2UsIGtleSwgZGF0YSkgPT4ge1xuICAgIGF3YWl0IHN0b3JhZ2Uuc2V0SXRlbShrZXksIEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbn07XG5leHBvcnQgY29uc3QgZ2V0SXRlbUFzeW5jID0gYXN5bmMgKHN0b3JhZ2UsIGtleSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgc3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3QgcmVtb3ZlSXRlbUFzeW5jID0gYXN5bmMgKHN0b3JhZ2UsIGtleSkgPT4ge1xuICAgIGF3YWl0IHN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xufTtcbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVCYXNlNjRVUkwodmFsdWUpIHtcbiAgICBjb25zdCBrZXkgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xuICAgIGxldCBiYXNlNjQgPSAnJztcbiAgICBsZXQgY2hyMSwgY2hyMiwgY2hyMztcbiAgICBsZXQgZW5jMSwgZW5jMiwgZW5jMywgZW5jNDtcbiAgICBsZXQgaSA9IDA7XG4gICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKCctJywgJysnKS5yZXBsYWNlKCdfJywgJy8nKTtcbiAgICB3aGlsZSAoaSA8IHZhbHVlLmxlbmd0aCkge1xuICAgICAgICBlbmMxID0ga2V5LmluZGV4T2YodmFsdWUuY2hhckF0KGkrKykpO1xuICAgICAgICBlbmMyID0ga2V5LmluZGV4T2YodmFsdWUuY2hhckF0KGkrKykpO1xuICAgICAgICBlbmMzID0ga2V5LmluZGV4T2YodmFsdWUuY2hhckF0KGkrKykpO1xuICAgICAgICBlbmM0ID0ga2V5LmluZGV4T2YodmFsdWUuY2hhckF0KGkrKykpO1xuICAgICAgICBjaHIxID0gKGVuYzEgPDwgMikgfCAoZW5jMiA+PiA0KTtcbiAgICAgICAgY2hyMiA9ICgoZW5jMiAmIDE1KSA8PCA0KSB8IChlbmMzID4+IDIpO1xuICAgICAgICBjaHIzID0gKChlbmMzICYgMykgPDwgNikgfCBlbmM0O1xuICAgICAgICBiYXNlNjQgPSBiYXNlNjQgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocjEpO1xuICAgICAgICBpZiAoZW5jMyAhPSA2NCAmJiBjaHIyICE9IDApIHtcbiAgICAgICAgICAgIGJhc2U2NCA9IGJhc2U2NCArIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuYzQgIT0gNjQgJiYgY2hyMyAhPSAwKSB7XG4gICAgICAgICAgICBiYXNlNjQgPSBiYXNlNjQgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocjMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiYXNlNjQ7XG59XG4vKipcbiAqIEEgZGVmZXJyZWQgcmVwcmVzZW50cyBzb21lIGFzeW5jaHJvbm91cyB3b3JrIHRoYXQgaXMgbm90IHlldCBmaW5pc2hlZCwgd2hpY2hcbiAqIG1heSBvciBtYXkgbm90IGN1bG1pbmF0ZSBpbiBhIHZhbHVlLlxuICogVGFrZW4gZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL21pa2Utbm9ydGgvdHlwZXMvYmxvYi9tYXN0ZXIvc3JjL2FzeW5jLnRzXG4gKi9cbmV4cG9ydCBjbGFzcyBEZWZlcnJlZCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXh0cmEtc2VtaVxuICAgICAgICA7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBEZWZlcnJlZC5wcm9taXNlQ29uc3RydWN0b3IoKHJlcywgcmVqKSA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4dHJhLXNlbWlcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZSA9IHJlcztcbiAgICAgICAgICAgIHRoaXMucmVqZWN0ID0gcmVqO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5EZWZlcnJlZC5wcm9taXNlQ29uc3RydWN0b3IgPSBQcm9taXNlO1xuLy8gVGFrZW4gZnJvbTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzg1NTIwMDMvaG93LXRvLWRlY29kZS1qd3QtdG9rZW4taW4tamF2YXNjcmlwdC13aXRob3V0LXVzaW5nLWEtbGlicmFyeVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUpXVFBheWxvYWQodG9rZW4pIHtcbiAgICAvLyBSZWdleCBjaGVja3MgZm9yIGJhc2U2NHVybCBmb3JtYXRcbiAgICBjb25zdCBiYXNlNjRVcmxSZWdleCA9IC9eKFthLXowLTlfLV17NH0pKigkfFthLXowLTlfLV17M309PyR8W2EtejAtOV8tXXsyfSg9PSk/JCkkL2k7XG4gICAgY29uc3QgcGFydHMgPSB0b2tlbi5zcGxpdCgnLicpO1xuICAgIGlmIChwYXJ0cy5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdKV1QgaXMgbm90IHZhbGlkOiBub3QgYSBKV1Qgc3RydWN0dXJlJyk7XG4gICAgfVxuICAgIGlmICghYmFzZTY0VXJsUmVnZXgudGVzdChwYXJ0c1sxXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdKV1QgaXMgbm90IHZhbGlkOiBwYXlsb2FkIGlzIG5vdCBpbiBiYXNlNjR1cmwgZm9ybWF0Jyk7XG4gICAgfVxuICAgIGNvbnN0IGJhc2U2NFVybCA9IHBhcnRzWzFdO1xuICAgIHJldHVybiBKU09OLnBhcnNlKGRlY29kZUJhc2U2NFVSTChiYXNlNjRVcmwpKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBudWxsIGFmdGVyIHNvbWUgdGltZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNsZWVwKHRpbWUpIHtcbiAgICByZXR1cm4gYXdhaXQgbmV3IFByb21pc2UoKGFjY2VwdCkgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGFjY2VwdChudWxsKSwgdGltZSk7XG4gICAgfSk7XG59XG4vKipcbiAqIENvbnZlcnRzIHRoZSBwcm92aWRlZCBhc3luYyBmdW5jdGlvbiBpbnRvIGEgcmV0cnlhYmxlIGZ1bmN0aW9uLiBFYWNoIHJlc3VsdFxuICogb3IgdGhyb3duIGVycm9yIGlzIHNlbnQgdG8gdGhlIGlzUmV0cnlhYmxlIGZ1bmN0aW9uIHdoaWNoIHNob3VsZCByZXR1cm4gdHJ1ZVxuICogaWYgdGhlIGZ1bmN0aW9uIHNob3VsZCBydW4gYWdhaW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXRyeWFibGUoZm4sIGlzUmV0cnlhYmxlKSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChhY2NlcHQsIHJlamVjdCkgPT4ge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4dHJhLXNlbWlcbiAgICAgICAgO1xuICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPCBJbmZpbml0eTsgYXR0ZW1wdCsrKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZm4oYXR0ZW1wdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNSZXRyeWFibGUoYXR0ZW1wdCwgbnVsbCwgcmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXB0KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1JldHJ5YWJsZShhdHRlbXB0LCBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuZnVuY3Rpb24gZGVjMmhleChkZWMpIHtcbiAgICByZXR1cm4gKCcwJyArIGRlYy50b1N0cmluZygxNikpLnN1YnN0cigtMik7XG59XG4vLyBGdW5jdGlvbnMgYmVsb3cgdGFrZW4gZnJvbTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjMzMDk0MDkvY3JlYXRpbmctYS1jb2RlLXZlcmlmaWVyLWFuZC1jaGFsbGVuZ2UtZm9yLXBrY2UtYXV0aC1vbi1zcG90aWZ5LWFwaS1pbi1yZWFjdGpzXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVQS0NFVmVyaWZpZXIoKSB7XG4gICAgY29uc3QgdmVyaWZpZXJMZW5ndGggPSA1NjtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50MzJBcnJheSh2ZXJpZmllckxlbmd0aCk7XG4gICAgaWYgKHR5cGVvZiBjcnlwdG8gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnN0IGNoYXJTZXQgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktLl9+JztcbiAgICAgICAgY29uc3QgY2hhclNldExlbiA9IGNoYXJTZXQubGVuZ3RoO1xuICAgICAgICBsZXQgdmVyaWZpZXIgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJpZmllckxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2ZXJpZmllciArPSBjaGFyU2V0LmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFyU2V0TGVuKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZlcmlmaWVyO1xuICAgIH1cbiAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycmF5KTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShhcnJheSwgZGVjMmhleCkuam9pbignJyk7XG59XG5hc3luYyBmdW5jdGlvbiBzaGEyNTYocmFuZG9tU3RyaW5nKSB7XG4gICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIGNvbnN0IGVuY29kZWREYXRhID0gZW5jb2Rlci5lbmNvZGUocmFuZG9tU3RyaW5nKTtcbiAgICBjb25zdCBoYXNoID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5kaWdlc3QoJ1NIQS0yNTYnLCBlbmNvZGVkRGF0YSk7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShoYXNoKTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShieXRlcylcbiAgICAgICAgLm1hcCgoYykgPT4gU3RyaW5nLmZyb21DaGFyQ29kZShjKSlcbiAgICAgICAgLmpvaW4oJycpO1xufVxuZnVuY3Rpb24gYmFzZTY0dXJsZW5jb2RlKHN0cikge1xuICAgIHJldHVybiBidG9hKHN0cikucmVwbGFjZSgvXFwrL2csICctJykucmVwbGFjZSgvXFwvL2csICdfJykucmVwbGFjZSgvPSskLywgJycpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlUEtDRUNoYWxsZW5nZSh2ZXJpZmllcikge1xuICAgIGNvbnN0IGhhc0NyeXB0b1N1cHBvcnQgPSB0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICB0eXBlb2YgY3J5cHRvLnN1YnRsZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgdHlwZW9mIFRleHRFbmNvZGVyICE9PSAndW5kZWZpbmVkJztcbiAgICBpZiAoIWhhc0NyeXB0b1N1cHBvcnQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdXZWJDcnlwdG8gQVBJIGlzIG5vdCBzdXBwb3J0ZWQuIENvZGUgY2hhbGxlbmdlIG1ldGhvZCB3aWxsIGRlZmF1bHQgdG8gdXNlIHBsYWluIGluc3RlYWQgb2Ygc2hhMjU2LicpO1xuICAgICAgICByZXR1cm4gdmVyaWZpZXI7XG4gICAgfVxuICAgIGNvbnN0IGhhc2hlZCA9IGF3YWl0IHNoYTI1Nih2ZXJpZmllcik7XG4gICAgcmV0dXJuIGJhc2U2NHVybGVuY29kZShoYXNoZWQpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2Qoc3RvcmFnZSwgc3RvcmFnZUtleSwgaXNQYXNzd29yZFJlY292ZXJ5ID0gZmFsc2UpIHtcbiAgICBjb25zdCBjb2RlVmVyaWZpZXIgPSBnZW5lcmF0ZVBLQ0VWZXJpZmllcigpO1xuICAgIGxldCBzdG9yZWRDb2RlVmVyaWZpZXIgPSBjb2RlVmVyaWZpZXI7XG4gICAgaWYgKGlzUGFzc3dvcmRSZWNvdmVyeSkge1xuICAgICAgICBzdG9yZWRDb2RlVmVyaWZpZXIgKz0gJy9QQVNTV09SRF9SRUNPVkVSWSc7XG4gICAgfVxuICAgIGF3YWl0IHNldEl0ZW1Bc3luYyhzdG9yYWdlLCBgJHtzdG9yYWdlS2V5fS1jb2RlLXZlcmlmaWVyYCwgc3RvcmVkQ29kZVZlcmlmaWVyKTtcbiAgICBjb25zdCBjb2RlQ2hhbGxlbmdlID0gYXdhaXQgZ2VuZXJhdGVQS0NFQ2hhbGxlbmdlKGNvZGVWZXJpZmllcik7XG4gICAgY29uc3QgY29kZUNoYWxsZW5nZU1ldGhvZCA9IGNvZGVWZXJpZmllciA9PT0gY29kZUNoYWxsZW5nZSA/ICdwbGFpbicgOiAnczI1Nic7XG4gICAgcmV0dXJuIFtjb2RlQ2hhbGxlbmdlLCBjb2RlQ2hhbGxlbmdlTWV0aG9kXTtcbn1cbi8qKiBQYXJzZXMgdGhlIEFQSSB2ZXJzaW9uIHdoaWNoIGlzIDJZWVktTU0tREQuICovXG5jb25zdCBBUElfVkVSU0lPTl9SRUdFWCA9IC9eMlswLTldezN9LSgwWzEtOV18MVswLTJdKS0oMFsxLTldfDFbMC05XXwyWzAtOV18M1swLTFdKSQvaTtcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVJlc3BvbnNlQVBJVmVyc2lvbihyZXNwb25zZSkge1xuICAgIGNvbnN0IGFwaVZlcnNpb24gPSByZXNwb25zZS5oZWFkZXJzLmdldChBUElfVkVSU0lPTl9IRUFERVJfTkFNRSk7XG4gICAgaWYgKCFhcGlWZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIWFwaVZlcnNpb24ubWF0Y2goQVBJX1ZFUlNJT05fUkVHRVgpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoYCR7YXBpVmVyc2lvbn1UMDA6MDA6MDAuMFpgKTtcbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbHBlcnMuanMubWFwIiwiaW1wb3J0IHsgQVBJX1ZFUlNJT05fSEVBREVSX05BTUUgfSBmcm9tICcuL2NvbnN0YW50cydcbmltcG9ydCB7IFN1cHBvcnRlZFN0b3JhZ2UgfSBmcm9tICcuL3R5cGVzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZXhwaXJlc0F0KGV4cGlyZXNJbjogbnVtYmVyKSB7XG4gIGNvbnN0IHRpbWVOb3cgPSBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxMDAwKVxuICByZXR1cm4gdGltZU5vdyArIGV4cGlyZXNJblxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXVpZCgpIHtcbiAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24gKGMpIHtcbiAgICBjb25zdCByID0gKE1hdGgucmFuZG9tKCkgKiAxNikgfCAwLFxuICAgICAgdiA9IGMgPT0gJ3gnID8gciA6IChyICYgMHgzKSB8IDB4OFxuICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KVxuICB9KVxufVxuXG5leHBvcnQgY29uc3QgaXNCcm93c2VyID0gKCkgPT4gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuXG5jb25zdCBsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzID0ge1xuICB0ZXN0ZWQ6IGZhbHNlLFxuICB3cml0YWJsZTogZmFsc2UsXG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgbG9jYWxTdG9yYWdlIGlzIHN1cHBvcnRlZCBvbiB0aGlzIGJyb3dzZXIuXG4gKi9cbmV4cG9ydCBjb25zdCBzdXBwb3J0c0xvY2FsU3RvcmFnZSA9ICgpID0+IHtcbiAgaWYgKCFpc0Jyb3dzZXIoKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gRE9NIGV4Y2VwdGlvbiB3aGVuIGFjY2Vzc2luZyBgbG9jYWxTdG9yYWdlYFxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMudGVzdGVkKSB7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMud3JpdGFibGVcbiAgfVxuXG4gIGNvbnN0IHJhbmRvbUtleSA9IGBsc3d0LSR7TWF0aC5yYW5kb20oKX0ke01hdGgucmFuZG9tKCl9YFxuXG4gIHRyeSB7XG4gICAgZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShyYW5kb21LZXksIHJhbmRvbUtleSlcbiAgICBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHJhbmRvbUtleSlcblxuICAgIGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMudGVzdGVkID0gdHJ1ZVxuICAgIGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMud3JpdGFibGUgPSB0cnVlXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBsb2NhbFN0b3JhZ2UgY2FuJ3QgYmUgd3JpdHRlbiB0b1xuICAgIC8vIGh0dHBzOi8vd3d3LmNocm9taXVtLm9yZy9mb3ItdGVzdGVycy9idWctcmVwb3J0aW5nLWd1aWRlbGluZXMvdW5jYXVnaHQtc2VjdXJpdHllcnJvci1mYWlsZWQtdG8tcmVhZC10aGUtbG9jYWxzdG9yYWdlLXByb3BlcnR5LWZyb20td2luZG93LWFjY2Vzcy1pcy1kZW5pZWQtZm9yLXRoaXMtZG9jdW1lbnRcblxuICAgIGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMudGVzdGVkID0gdHJ1ZVxuICAgIGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMud3JpdGFibGUgPSBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMud3JpdGFibGVcbn1cblxuLyoqXG4gKiBFeHRyYWN0cyBwYXJhbWV0ZXJzIGVuY29kZWQgaW4gdGhlIFVSTCBib3RoIGluIHRoZSBxdWVyeSBhbmQgZnJhZ21lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVBhcmFtZXRlcnNGcm9tVVJMKGhyZWY6IHN0cmluZykge1xuICBjb25zdCByZXN1bHQ6IHsgW3BhcmFtZXRlcjogc3RyaW5nXTogc3RyaW5nIH0gPSB7fVxuXG4gIGNvbnN0IHVybCA9IG5ldyBVUkwoaHJlZilcblxuICBpZiAodXJsLmhhc2ggJiYgdXJsLmhhc2hbMF0gPT09ICcjJykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBoYXNoU2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh1cmwuaGFzaC5zdWJzdHJpbmcoMSkpXG4gICAgICBoYXNoU2VhcmNoUGFyYW1zLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZVxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgIC8vIGhhc2ggaXMgbm90IGEgcXVlcnkgc3RyaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gc2VhcmNoIHBhcmFtZXRlcnMgdGFrZSBwcmVjZWRlbmNlIG92ZXIgaGFzaCBwYXJhbWV0ZXJzXG4gIHVybC5zZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgIHJlc3VsdFtrZXldID0gdmFsdWVcbiAgfSlcblxuICByZXR1cm4gcmVzdWx0XG59XG5cbnR5cGUgRmV0Y2ggPSB0eXBlb2YgZmV0Y2hcblxuZXhwb3J0IGNvbnN0IHJlc29sdmVGZXRjaCA9IChjdXN0b21GZXRjaD86IEZldGNoKTogRmV0Y2ggPT4ge1xuICBsZXQgX2ZldGNoOiBGZXRjaFxuICBpZiAoY3VzdG9tRmV0Y2gpIHtcbiAgICBfZmV0Y2ggPSBjdXN0b21GZXRjaFxuICB9IGVsc2UgaWYgKHR5cGVvZiBmZXRjaCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBfZmV0Y2ggPSAoLi4uYXJncykgPT5cbiAgICAgIGltcG9ydCgnQHN1cGFiYXNlL25vZGUtZmV0Y2gnIGFzIGFueSkudGhlbigoeyBkZWZhdWx0OiBmZXRjaCB9KSA9PiBmZXRjaCguLi5hcmdzKSlcbiAgfSBlbHNlIHtcbiAgICBfZmV0Y2ggPSBmZXRjaFxuICB9XG4gIHJldHVybiAoLi4uYXJncykgPT4gX2ZldGNoKC4uLmFyZ3MpXG59XG5cbmV4cG9ydCBjb25zdCBsb29rc0xpa2VGZXRjaFJlc3BvbnNlID0gKG1heWJlUmVzcG9uc2U6IHVua25vd24pOiBtYXliZVJlc3BvbnNlIGlzIFJlc3BvbnNlID0+IHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgbWF5YmVSZXNwb25zZSA9PT0gJ29iamVjdCcgJiZcbiAgICBtYXliZVJlc3BvbnNlICE9PSBudWxsICYmXG4gICAgJ3N0YXR1cycgaW4gbWF5YmVSZXNwb25zZSAmJlxuICAgICdvaycgaW4gbWF5YmVSZXNwb25zZSAmJlxuICAgICdqc29uJyBpbiBtYXliZVJlc3BvbnNlICYmXG4gICAgdHlwZW9mIChtYXliZVJlc3BvbnNlIGFzIGFueSkuanNvbiA9PT0gJ2Z1bmN0aW9uJ1xuICApXG59XG5cbi8vIFN0b3JhZ2UgaGVscGVyc1xuZXhwb3J0IGNvbnN0IHNldEl0ZW1Bc3luYyA9IGFzeW5jIChcbiAgc3RvcmFnZTogU3VwcG9ydGVkU3RvcmFnZSxcbiAga2V5OiBzdHJpbmcsXG4gIGRhdGE6IGFueVxuKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGF3YWl0IHN0b3JhZ2Uuc2V0SXRlbShrZXksIEpTT04uc3RyaW5naWZ5KGRhdGEpKVxufVxuXG5leHBvcnQgY29uc3QgZ2V0SXRlbUFzeW5jID0gYXN5bmMgKHN0b3JhZ2U6IFN1cHBvcnRlZFN0b3JhZ2UsIGtleTogc3RyaW5nKTogUHJvbWlzZTx1bmtub3duPiA9PiB7XG4gIGNvbnN0IHZhbHVlID0gYXdhaXQgc3RvcmFnZS5nZXRJdGVtKGtleSlcblxuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpXG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCByZW1vdmVJdGVtQXN5bmMgPSBhc3luYyAoc3RvcmFnZTogU3VwcG9ydGVkU3RvcmFnZSwga2V5OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgYXdhaXQgc3RvcmFnZS5yZW1vdmVJdGVtKGtleSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUJhc2U2NFVSTCh2YWx1ZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3Qga2V5ID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89J1xuICBsZXQgYmFzZTY0ID0gJydcbiAgbGV0IGNocjEsIGNocjIsIGNocjNcbiAgbGV0IGVuYzEsIGVuYzIsIGVuYzMsIGVuYzRcbiAgbGV0IGkgPSAwXG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZSgnLScsICcrJykucmVwbGFjZSgnXycsICcvJylcblxuICB3aGlsZSAoaSA8IHZhbHVlLmxlbmd0aCkge1xuICAgIGVuYzEgPSBrZXkuaW5kZXhPZih2YWx1ZS5jaGFyQXQoaSsrKSlcbiAgICBlbmMyID0ga2V5LmluZGV4T2YodmFsdWUuY2hhckF0KGkrKykpXG4gICAgZW5jMyA9IGtleS5pbmRleE9mKHZhbHVlLmNoYXJBdChpKyspKVxuICAgIGVuYzQgPSBrZXkuaW5kZXhPZih2YWx1ZS5jaGFyQXQoaSsrKSlcbiAgICBjaHIxID0gKGVuYzEgPDwgMikgfCAoZW5jMiA+PiA0KVxuICAgIGNocjIgPSAoKGVuYzIgJiAxNSkgPDwgNCkgfCAoZW5jMyA+PiAyKVxuICAgIGNocjMgPSAoKGVuYzMgJiAzKSA8PCA2KSB8IGVuYzRcbiAgICBiYXNlNjQgPSBiYXNlNjQgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocjEpXG5cbiAgICBpZiAoZW5jMyAhPSA2NCAmJiBjaHIyICE9IDApIHtcbiAgICAgIGJhc2U2NCA9IGJhc2U2NCArIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyMilcbiAgICB9XG4gICAgaWYgKGVuYzQgIT0gNjQgJiYgY2hyMyAhPSAwKSB7XG4gICAgICBiYXNlNjQgPSBiYXNlNjQgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocjMpXG4gICAgfVxuICB9XG4gIHJldHVybiBiYXNlNjRcbn1cblxuLyoqXG4gKiBBIGRlZmVycmVkIHJlcHJlc2VudHMgc29tZSBhc3luY2hyb25vdXMgd29yayB0aGF0IGlzIG5vdCB5ZXQgZmluaXNoZWQsIHdoaWNoXG4gKiBtYXkgb3IgbWF5IG5vdCBjdWxtaW5hdGUgaW4gYSB2YWx1ZS5cbiAqIFRha2VuIGZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9taWtlLW5vcnRoL3R5cGVzL2Jsb2IvbWFzdGVyL3NyYy9hc3luYy50c1xuICovXG5leHBvcnQgY2xhc3MgRGVmZXJyZWQ8VCA9IGFueT4ge1xuICBwdWJsaWMgc3RhdGljIHByb21pc2VDb25zdHJ1Y3RvcjogUHJvbWlzZUNvbnN0cnVjdG9yID0gUHJvbWlzZVxuXG4gIHB1YmxpYyByZWFkb25seSBwcm9taXNlITogUHJvbWlzZUxpa2U8VD5cblxuICBwdWJsaWMgcmVhZG9ubHkgcmVzb2x2ZSE6ICh2YWx1ZT86IFQgfCBQcm9taXNlTGlrZTxUPikgPT4gdm9pZFxuXG4gIHB1YmxpYyByZWFkb25seSByZWplY3QhOiAocmVhc29uPzogYW55KSA9PiBhbnlcblxuICBwdWJsaWMgY29uc3RydWN0b3IoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHRyYS1zZW1pXG4gICAgOyh0aGlzIGFzIGFueSkucHJvbWlzZSA9IG5ldyBEZWZlcnJlZC5wcm9taXNlQ29uc3RydWN0b3IoKHJlcywgcmVqKSA9PiB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4dHJhLXNlbWlcbiAgICAgIDsodGhpcyBhcyBhbnkpLnJlc29sdmUgPSByZXNcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXh0cmEtc2VtaVxuICAgICAgOyh0aGlzIGFzIGFueSkucmVqZWN0ID0gcmVqXG4gICAgfSlcbiAgfVxufVxuXG4vLyBUYWtlbiBmcm9tOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zODU1MjAwMy9ob3ctdG8tZGVjb2RlLWp3dC10b2tlbi1pbi1qYXZhc2NyaXB0LXdpdGhvdXQtdXNpbmctYS1saWJyYXJ5XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlSldUUGF5bG9hZCh0b2tlbjogc3RyaW5nKSB7XG4gIC8vIFJlZ2V4IGNoZWNrcyBmb3IgYmFzZTY0dXJsIGZvcm1hdFxuICBjb25zdCBiYXNlNjRVcmxSZWdleCA9IC9eKFthLXowLTlfLV17NH0pKigkfFthLXowLTlfLV17M309PyR8W2EtejAtOV8tXXsyfSg9PSk/JCkkL2lcblxuICBjb25zdCBwYXJ0cyA9IHRva2VuLnNwbGl0KCcuJylcblxuICBpZiAocGFydHMubGVuZ3RoICE9PSAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdKV1QgaXMgbm90IHZhbGlkOiBub3QgYSBKV1Qgc3RydWN0dXJlJylcbiAgfVxuXG4gIGlmICghYmFzZTY0VXJsUmVnZXgudGVzdChwYXJ0c1sxXSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0pXVCBpcyBub3QgdmFsaWQ6IHBheWxvYWQgaXMgbm90IGluIGJhc2U2NHVybCBmb3JtYXQnKVxuICB9XG5cbiAgY29uc3QgYmFzZTY0VXJsID0gcGFydHNbMV1cbiAgcmV0dXJuIEpTT04ucGFyc2UoZGVjb2RlQmFzZTY0VVJMKGJhc2U2NFVybCkpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBudWxsIGFmdGVyIHNvbWUgdGltZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNsZWVwKHRpbWU6IG51bWJlcik6IFByb21pc2U8bnVsbD4ge1xuICByZXR1cm4gYXdhaXQgbmV3IFByb21pc2UoKGFjY2VwdCkgPT4ge1xuICAgIHNldFRpbWVvdXQoKCkgPT4gYWNjZXB0KG51bGwpLCB0aW1lKVxuICB9KVxufVxuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBwcm92aWRlZCBhc3luYyBmdW5jdGlvbiBpbnRvIGEgcmV0cnlhYmxlIGZ1bmN0aW9uLiBFYWNoIHJlc3VsdFxuICogb3IgdGhyb3duIGVycm9yIGlzIHNlbnQgdG8gdGhlIGlzUmV0cnlhYmxlIGZ1bmN0aW9uIHdoaWNoIHNob3VsZCByZXR1cm4gdHJ1ZVxuICogaWYgdGhlIGZ1bmN0aW9uIHNob3VsZCBydW4gYWdhaW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXRyeWFibGU8VD4oXG4gIGZuOiAoYXR0ZW1wdDogbnVtYmVyKSA9PiBQcm9taXNlPFQ+LFxuICBpc1JldHJ5YWJsZTogKGF0dGVtcHQ6IG51bWJlciwgZXJyb3I6IGFueSB8IG51bGwsIHJlc3VsdD86IFQpID0+IGJvb2xlYW5cbik6IFByb21pc2U8VD4ge1xuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2U8VD4oKGFjY2VwdCwgcmVqZWN0KSA9PiB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHRyYS1zZW1pXG4gICAgOyhhc3luYyAoKSA9PiB7XG4gICAgICBmb3IgKGxldCBhdHRlbXB0ID0gMDsgYXR0ZW1wdCA8IEluZmluaXR5OyBhdHRlbXB0KyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmbihhdHRlbXB0KVxuXG4gICAgICAgICAgaWYgKCFpc1JldHJ5YWJsZShhdHRlbXB0LCBudWxsLCByZXN1bHQpKSB7XG4gICAgICAgICAgICBhY2NlcHQocmVzdWx0KVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgICBpZiAoIWlzUmV0cnlhYmxlKGF0dGVtcHQsIGUpKSB7XG4gICAgICAgICAgICByZWplY3QoZSlcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pKClcbiAgfSlcblxuICByZXR1cm4gcHJvbWlzZVxufVxuXG5mdW5jdGlvbiBkZWMyaGV4KGRlYzogbnVtYmVyKSB7XG4gIHJldHVybiAoJzAnICsgZGVjLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC0yKVxufVxuXG4vLyBGdW5jdGlvbnMgYmVsb3cgdGFrZW4gZnJvbTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjMzMDk0MDkvY3JlYXRpbmctYS1jb2RlLXZlcmlmaWVyLWFuZC1jaGFsbGVuZ2UtZm9yLXBrY2UtYXV0aC1vbi1zcG90aWZ5LWFwaS1pbi1yZWFjdGpzXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVQS0NFVmVyaWZpZXIoKSB7XG4gIGNvbnN0IHZlcmlmaWVyTGVuZ3RoID0gNTZcbiAgY29uc3QgYXJyYXkgPSBuZXcgVWludDMyQXJyYXkodmVyaWZpZXJMZW5ndGgpXG4gIGlmICh0eXBlb2YgY3J5cHRvID09PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnN0IGNoYXJTZXQgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktLl9+J1xuICAgIGNvbnN0IGNoYXJTZXRMZW4gPSBjaGFyU2V0Lmxlbmd0aFxuICAgIGxldCB2ZXJpZmllciA9ICcnXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJpZmllckxlbmd0aDsgaSsrKSB7XG4gICAgICB2ZXJpZmllciArPSBjaGFyU2V0LmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFyU2V0TGVuKSlcbiAgICB9XG4gICAgcmV0dXJuIHZlcmlmaWVyXG4gIH1cbiAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhcnJheSlcbiAgcmV0dXJuIEFycmF5LmZyb20oYXJyYXksIGRlYzJoZXgpLmpvaW4oJycpXG59XG5cbmFzeW5jIGZ1bmN0aW9uIHNoYTI1NihyYW5kb21TdHJpbmc6IHN0cmluZykge1xuICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKClcbiAgY29uc3QgZW5jb2RlZERhdGEgPSBlbmNvZGVyLmVuY29kZShyYW5kb21TdHJpbmcpXG4gIGNvbnN0IGhhc2ggPSBhd2FpdCBjcnlwdG8uc3VidGxlLmRpZ2VzdCgnU0hBLTI1NicsIGVuY29kZWREYXRhKVxuICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGhhc2gpXG5cbiAgcmV0dXJuIEFycmF5LmZyb20oYnl0ZXMpXG4gICAgLm1hcCgoYykgPT4gU3RyaW5nLmZyb21DaGFyQ29kZShjKSlcbiAgICAuam9pbignJylcbn1cblxuZnVuY3Rpb24gYmFzZTY0dXJsZW5jb2RlKHN0cjogc3RyaW5nKSB7XG4gIHJldHVybiBidG9hKHN0cikucmVwbGFjZSgvXFwrL2csICctJykucmVwbGFjZSgvXFwvL2csICdfJykucmVwbGFjZSgvPSskLywgJycpXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVBLQ0VDaGFsbGVuZ2UodmVyaWZpZXI6IHN0cmluZykge1xuICBjb25zdCBoYXNDcnlwdG9TdXBwb3J0ID1cbiAgICB0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBjcnlwdG8uc3VidGxlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBUZXh0RW5jb2RlciAhPT0gJ3VuZGVmaW5lZCdcblxuICBpZiAoIWhhc0NyeXB0b1N1cHBvcnQpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICAnV2ViQ3J5cHRvIEFQSSBpcyBub3Qgc3VwcG9ydGVkLiBDb2RlIGNoYWxsZW5nZSBtZXRob2Qgd2lsbCBkZWZhdWx0IHRvIHVzZSBwbGFpbiBpbnN0ZWFkIG9mIHNoYTI1Ni4nXG4gICAgKVxuICAgIHJldHVybiB2ZXJpZmllclxuICB9XG4gIGNvbnN0IGhhc2hlZCA9IGF3YWl0IHNoYTI1Nih2ZXJpZmllcilcbiAgcmV0dXJuIGJhc2U2NHVybGVuY29kZShoYXNoZWQpXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kKFxuICBzdG9yYWdlOiBTdXBwb3J0ZWRTdG9yYWdlLFxuICBzdG9yYWdlS2V5OiBzdHJpbmcsXG4gIGlzUGFzc3dvcmRSZWNvdmVyeSA9IGZhbHNlXG4pIHtcbiAgY29uc3QgY29kZVZlcmlmaWVyID0gZ2VuZXJhdGVQS0NFVmVyaWZpZXIoKVxuICBsZXQgc3RvcmVkQ29kZVZlcmlmaWVyID0gY29kZVZlcmlmaWVyXG4gIGlmIChpc1Bhc3N3b3JkUmVjb3ZlcnkpIHtcbiAgICBzdG9yZWRDb2RlVmVyaWZpZXIgKz0gJy9QQVNTV09SRF9SRUNPVkVSWSdcbiAgfVxuICBhd2FpdCBzZXRJdGVtQXN5bmMoc3RvcmFnZSwgYCR7c3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmAsIHN0b3JlZENvZGVWZXJpZmllcilcbiAgY29uc3QgY29kZUNoYWxsZW5nZSA9IGF3YWl0IGdlbmVyYXRlUEtDRUNoYWxsZW5nZShjb2RlVmVyaWZpZXIpXG4gIGNvbnN0IGNvZGVDaGFsbGVuZ2VNZXRob2QgPSBjb2RlVmVyaWZpZXIgPT09IGNvZGVDaGFsbGVuZ2UgPyAncGxhaW4nIDogJ3MyNTYnXG4gIHJldHVybiBbY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZF1cbn1cblxuLyoqIFBhcnNlcyB0aGUgQVBJIHZlcnNpb24gd2hpY2ggaXMgMllZWS1NTS1ERC4gKi9cbmNvbnN0IEFQSV9WRVJTSU9OX1JFR0VYID0gL14yWzAtOV17M30tKDBbMS05XXwxWzAtMl0pLSgwWzEtOV18MVswLTldfDJbMC05XXwzWzAtMV0pJC9pXG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVJlc3BvbnNlQVBJVmVyc2lvbihyZXNwb25zZTogUmVzcG9uc2UpIHtcbiAgY29uc3QgYXBpVmVyc2lvbiA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KEFQSV9WRVJTSU9OX0hFQURFUl9OQU1FKVxuXG4gIGlmICghYXBpVmVyc2lvbikge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBpZiAoIWFwaVZlcnNpb24ubWF0Y2goQVBJX1ZFUlNJT05fUkVHRVgpKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGAke2FwaVZlcnNpb259VDAwOjAwOjAwLjBaYClcbiAgICByZXR1cm4gZGF0ZVxuICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG4iLCJleHBvcnQgY2xhc3MgQXV0aEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YXR1cywgY29kZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5fX2lzQXV0aEVycm9yID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0F1dGhFcnJvcic7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0F1dGhFcnJvcihlcnJvcikge1xuICAgIHJldHVybiB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmIGVycm9yICE9PSBudWxsICYmICdfX2lzQXV0aEVycm9yJyBpbiBlcnJvcjtcbn1cbmV4cG9ydCBjbGFzcyBBdXRoQXBpRXJyb3IgZXh0ZW5kcyBBdXRoRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YXR1cywgY29kZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCBzdGF0dXMsIGNvZGUpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQXV0aEFwaUVycm9yJztcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQXV0aEFwaUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGlzQXV0aEVycm9yKGVycm9yKSAmJiBlcnJvci5uYW1lID09PSAnQXV0aEFwaUVycm9yJztcbn1cbmV4cG9ydCBjbGFzcyBBdXRoVW5rbm93bkVycm9yIGV4dGVuZHMgQXV0aEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBvcmlnaW5hbEVycm9yKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQXV0aFVua25vd25FcnJvcic7XG4gICAgICAgIHRoaXMub3JpZ2luYWxFcnJvciA9IG9yaWdpbmFsRXJyb3I7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEN1c3RvbUF1dGhFcnJvciBleHRlbmRzIEF1dGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgbmFtZSwgc3RhdHVzLCBjb2RlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIHN0YXR1cywgY29kZSk7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdBdXRoIHNlc3Npb24gbWlzc2luZyEnLCAnQXV0aFNlc3Npb25NaXNzaW5nRXJyb3InLCA0MDAsIHVuZGVmaW5lZCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ0F1dGggc2Vzc2lvbiBvciB1c2VyIG1pc3NpbmcnLCAnQXV0aEludmFsaWRUb2tlblJlc3BvbnNlRXJyb3InLCA1MDAsIHVuZGVmaW5lZCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEF1dGhJbnZhbGlkQ3JlZGVudGlhbHNFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCAnQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yJywgNDAwLCB1bmRlZmluZWQpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IgZXh0ZW5kcyBDdXN0b21BdXRoRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGRldGFpbHMgPSBudWxsKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsICdBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3InLCA1MDAsIHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuZGV0YWlscyA9IG51bGw7XG4gICAgICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgICAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICAgICAgICBkZXRhaWxzOiB0aGlzLmRldGFpbHMsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEF1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgZGV0YWlscyA9IG51bGwpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgJ0F1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvcicsIDUwMCwgdW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gbnVsbDtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgICAgICAgIGRldGFpbHM6IHRoaXMuZGV0YWlscyxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IgZXh0ZW5kcyBDdXN0b21BdXRoRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YXR1cykge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCAnQXV0aFJldHJ5YWJsZUZldGNoRXJyb3InLCBzdGF0dXMsIHVuZGVmaW5lZCk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gaXNBdXRoRXJyb3IoZXJyb3IpICYmIGVycm9yLm5hbWUgPT09ICdBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcic7XG59XG4vKipcbiAqIFRoaXMgZXJyb3IgaXMgdGhyb3duIG9uIGNlcnRhaW4gbWV0aG9kcyB3aGVuIHRoZSBwYXNzd29yZCB1c2VkIGlzIGRlZW1lZFxuICogd2Vhay4gSW5zcGVjdCB0aGUgcmVhc29ucyB0byBpZGVudGlmeSB3aGF0IHBhc3N3b3JkIHN0cmVuZ3RoIHJ1bGVzIGFyZVxuICogaW5hZGVxdWF0ZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEF1dGhXZWFrUGFzc3dvcmRFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzLCByZWFzb25zKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsICdBdXRoV2Vha1Bhc3N3b3JkRXJyb3InLCBzdGF0dXMsICd3ZWFrX3Bhc3N3b3JkJyk7XG4gICAgICAgIHRoaXMucmVhc29ucyA9IHJlYXNvbnM7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQXV0aFdlYWtQYXNzd29yZEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGlzQXV0aEVycm9yKGVycm9yKSAmJiBlcnJvci5uYW1lID09PSAnQXV0aFdlYWtQYXNzd29yZEVycm9yJztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXAiLCJpbXBvcnQgeyBXZWFrUGFzc3dvcmRSZWFzb25zIH0gZnJvbSAnLi90eXBlcydcbmltcG9ydCB7IEVycm9yQ29kZSB9IGZyb20gJy4vZXJyb3ItY29kZXMnXG5cbmV4cG9ydCBjbGFzcyBBdXRoRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIC8qKlxuICAgKiBFcnJvciBjb2RlIGFzc29jaWF0ZWQgd2l0aCB0aGUgZXJyb3IuIE1vc3QgZXJyb3JzIGNvbWluZyBmcm9tXG4gICAqIEhUVFAgcmVzcG9uc2VzIHdpbGwgaGF2ZSBhIGNvZGUsIHRob3VnaCBzb21lIGVycm9ycyB0aGF0IG9jY3VyXG4gICAqIGJlZm9yZSBhIHJlc3BvbnNlIGlzIHJlY2VpdmVkIHdpbGwgbm90IGhhdmUgb25lIHByZXNlbnQuIEluIHRoYXRcbiAgICogY2FzZSB7QGxpbmsgI3N0YXR1c30gd2lsbCBhbHNvIGJlIHVuZGVmaW5lZC5cbiAgICovXG4gIGNvZGU6IEVycm9yQ29kZSB8IHN0cmluZyB8IHVuZGVmaW5lZFxuXG4gIC8qKiBIVFRQIHN0YXR1cyBjb2RlIHRoYXQgY2F1c2VkIHRoZSBlcnJvci4gKi9cbiAgc3RhdHVzOiBudW1iZXIgfCB1bmRlZmluZWRcblxuICBwcm90ZWN0ZWQgX19pc0F1dGhFcnJvciA9IHRydWVcblxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIHN0YXR1cz86IG51bWJlciwgY29kZT86IHN0cmluZykge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ0F1dGhFcnJvcidcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1c1xuICAgIHRoaXMuY29kZSA9IGNvZGVcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNBdXRoRXJyb3IoZXJyb3I6IHVua25vd24pOiBlcnJvciBpcyBBdXRoRXJyb3Ige1xuICByZXR1cm4gdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiBlcnJvciAhPT0gbnVsbCAmJiAnX19pc0F1dGhFcnJvcicgaW4gZXJyb3Jcbn1cblxuZXhwb3J0IGNsYXNzIEF1dGhBcGlFcnJvciBleHRlbmRzIEF1dGhFcnJvciB7XG4gIHN0YXR1czogbnVtYmVyXG5cbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBzdGF0dXM6IG51bWJlciwgY29kZTogc3RyaW5nIHwgdW5kZWZpbmVkKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgc3RhdHVzLCBjb2RlKVxuICAgIHRoaXMubmFtZSA9ICdBdXRoQXBpRXJyb3InXG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXNcbiAgICB0aGlzLmNvZGUgPSBjb2RlXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQXV0aEFwaUVycm9yKGVycm9yOiB1bmtub3duKTogZXJyb3IgaXMgQXV0aEFwaUVycm9yIHtcbiAgcmV0dXJuIGlzQXV0aEVycm9yKGVycm9yKSAmJiBlcnJvci5uYW1lID09PSAnQXV0aEFwaUVycm9yJ1xufVxuXG5leHBvcnQgY2xhc3MgQXV0aFVua25vd25FcnJvciBleHRlbmRzIEF1dGhFcnJvciB7XG4gIG9yaWdpbmFsRXJyb3I6IHVua25vd25cblxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIG9yaWdpbmFsRXJyb3I6IHVua25vd24pIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdBdXRoVW5rbm93bkVycm9yJ1xuICAgIHRoaXMub3JpZ2luYWxFcnJvciA9IG9yaWdpbmFsRXJyb3JcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQ3VzdG9tQXV0aEVycm9yIGV4dGVuZHMgQXV0aEVycm9yIHtcbiAgbmFtZTogc3RyaW5nXG4gIHN0YXR1czogbnVtYmVyXG5cbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBuYW1lOiBzdHJpbmcsIHN0YXR1czogbnVtYmVyLCBjb2RlOiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgICBzdXBlcihtZXNzYWdlLCBzdGF0dXMsIGNvZGUpXG4gICAgdGhpcy5uYW1lID0gbmFtZVxuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ0F1dGggc2Vzc2lvbiBtaXNzaW5nIScsICdBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcicsIDQwMCwgdW5kZWZpbmVkKVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdBdXRoIHNlc3Npb24gb3IgdXNlciBtaXNzaW5nJywgJ0F1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yJywgNTAwLCB1bmRlZmluZWQpXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEF1dGhJbnZhbGlkQ3JlZGVudGlhbHNFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZykge1xuICAgIHN1cGVyKG1lc3NhZ2UsICdBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3InLCA0MDAsIHVuZGVmaW5lZClcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgZGV0YWlsczogeyBlcnJvcjogc3RyaW5nOyBjb2RlOiBzdHJpbmcgfSB8IG51bGwgPSBudWxsXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgZGV0YWlsczogeyBlcnJvcjogc3RyaW5nOyBjb2RlOiBzdHJpbmcgfSB8IG51bGwgPSBudWxsKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgJ0F1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcicsIDUwMCwgdW5kZWZpbmVkKVxuICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHNcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgIGRldGFpbHM6IHRoaXMuZGV0YWlscyxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEF1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gIGRldGFpbHM6IHsgZXJyb3I6IHN0cmluZzsgY29kZTogc3RyaW5nIH0gfCBudWxsID0gbnVsbFxuXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgZGV0YWlsczogeyBlcnJvcjogc3RyaW5nOyBjb2RlOiBzdHJpbmcgfSB8IG51bGwgPSBudWxsKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgJ0F1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvcicsIDUwMCwgdW5kZWZpbmVkKVxuICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHNcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgIGRldGFpbHM6IHRoaXMuZGV0YWlscyxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEF1dGhSZXRyeWFibGVGZXRjaEVycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBzdGF0dXM6IG51bWJlcikge1xuICAgIHN1cGVyKG1lc3NhZ2UsICdBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcicsIHN0YXR1cywgdW5kZWZpbmVkKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0F1dGhSZXRyeWFibGVGZXRjaEVycm9yKGVycm9yOiB1bmtub3duKTogZXJyb3IgaXMgQXV0aFJldHJ5YWJsZUZldGNoRXJyb3Ige1xuICByZXR1cm4gaXNBdXRoRXJyb3IoZXJyb3IpICYmIGVycm9yLm5hbWUgPT09ICdBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcidcbn1cblxuLyoqXG4gKiBUaGlzIGVycm9yIGlzIHRocm93biBvbiBjZXJ0YWluIG1ldGhvZHMgd2hlbiB0aGUgcGFzc3dvcmQgdXNlZCBpcyBkZWVtZWRcbiAqIHdlYWsuIEluc3BlY3QgdGhlIHJlYXNvbnMgdG8gaWRlbnRpZnkgd2hhdCBwYXNzd29yZCBzdHJlbmd0aCBydWxlcyBhcmVcbiAqIGluYWRlcXVhdGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBBdXRoV2Vha1Bhc3N3b3JkRXJyb3IgZXh0ZW5kcyBDdXN0b21BdXRoRXJyb3Ige1xuICAvKipcbiAgICogUmVhc29ucyB3aHkgdGhlIHBhc3N3b3JkIGlzIGRlZW1lZCB3ZWFrLlxuICAgKi9cbiAgcmVhc29uczogV2Vha1Bhc3N3b3JkUmVhc29uc1tdXG5cbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBzdGF0dXM6IG51bWJlciwgcmVhc29uczogc3RyaW5nW10pIHtcbiAgICBzdXBlcihtZXNzYWdlLCAnQXV0aFdlYWtQYXNzd29yZEVycm9yJywgc3RhdHVzLCAnd2Vha19wYXNzd29yZCcpXG5cbiAgICB0aGlzLnJlYXNvbnMgPSByZWFzb25zXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQXV0aFdlYWtQYXNzd29yZEVycm9yKGVycm9yOiB1bmtub3duKTogZXJyb3IgaXMgQXV0aFdlYWtQYXNzd29yZEVycm9yIHtcbiAgcmV0dXJuIGlzQXV0aEVycm9yKGVycm9yKSAmJiBlcnJvci5uYW1lID09PSAnQXV0aFdlYWtQYXNzd29yZEVycm9yJ1xufVxuIiwiaW1wb3J0IEdvVHJ1ZUFkbWluQXBpIGZyb20gJy4vR29UcnVlQWRtaW5BcGknO1xuaW1wb3J0IHsgREVGQVVMVF9IRUFERVJTLCBFWFBJUllfTUFSR0lOLCBHT1RSVUVfVVJMLCBTVE9SQUdFX0tFWSB9IGZyb20gJy4vbGliL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IsIEF1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvciwgQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yLCBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvciwgQXV0aEludmFsaWRUb2tlblJlc3BvbnNlRXJyb3IsIEF1dGhVbmtub3duRXJyb3IsIGlzQXV0aEFwaUVycm9yLCBpc0F1dGhFcnJvciwgaXNBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvciwgfSBmcm9tICcuL2xpYi9lcnJvcnMnO1xuaW1wb3J0IHsgX3JlcXVlc3QsIF9zZXNzaW9uUmVzcG9uc2UsIF9zZXNzaW9uUmVzcG9uc2VQYXNzd29yZCwgX3VzZXJSZXNwb25zZSwgX3Nzb1Jlc3BvbnNlLCB9IGZyb20gJy4vbGliL2ZldGNoJztcbmltcG9ydCB7IGRlY29kZUpXVFBheWxvYWQsIERlZmVycmVkLCBnZXRJdGVtQXN5bmMsIGlzQnJvd3NlciwgcmVtb3ZlSXRlbUFzeW5jLCByZXNvbHZlRmV0Y2gsIHNldEl0ZW1Bc3luYywgdXVpZCwgcmV0cnlhYmxlLCBzbGVlcCwgc3VwcG9ydHNMb2NhbFN0b3JhZ2UsIHBhcnNlUGFyYW1ldGVyc0Zyb21VUkwsIGdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2QsIH0gZnJvbSAnLi9saWIvaGVscGVycyc7XG5pbXBvcnQgeyBsb2NhbFN0b3JhZ2VBZGFwdGVyLCBtZW1vcnlMb2NhbFN0b3JhZ2VBZGFwdGVyIH0gZnJvbSAnLi9saWIvbG9jYWwtc3RvcmFnZSc7XG5pbXBvcnQgeyBwb2x5ZmlsbEdsb2JhbFRoaXMgfSBmcm9tICcuL2xpYi9wb2x5ZmlsbHMnO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4vbGliL3ZlcnNpb24nO1xuaW1wb3J0IHsgTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IsIG5hdmlnYXRvckxvY2sgfSBmcm9tICcuL2xpYi9sb2Nrcyc7XG5wb2x5ZmlsbEdsb2JhbFRoaXMoKTsgLy8gTWFrZSBcImdsb2JhbFRoaXNcIiBhdmFpbGFibGVcbmNvbnN0IERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgICB1cmw6IEdPVFJVRV9VUkwsXG4gICAgc3RvcmFnZUtleTogU1RPUkFHRV9LRVksXG4gICAgYXV0b1JlZnJlc2hUb2tlbjogdHJ1ZSxcbiAgICBwZXJzaXN0U2Vzc2lvbjogdHJ1ZSxcbiAgICBkZXRlY3RTZXNzaW9uSW5Vcmw6IHRydWUsXG4gICAgaGVhZGVyczogREVGQVVMVF9IRUFERVJTLFxuICAgIGZsb3dUeXBlOiAnaW1wbGljaXQnLFxuICAgIGRlYnVnOiBmYWxzZSxcbiAgICBoYXNDdXN0b21BdXRob3JpemF0aW9uSGVhZGVyOiBmYWxzZSxcbn07XG4vKiogQ3VycmVudCBzZXNzaW9uIHdpbGwgYmUgY2hlY2tlZCBmb3IgcmVmcmVzaCBhdCB0aGlzIGludGVydmFsLiAqL1xuY29uc3QgQVVUT19SRUZSRVNIX1RJQ0tfRFVSQVRJT04gPSAzMCAqIDEwMDA7XG4vKipcbiAqIEEgdG9rZW4gcmVmcmVzaCB3aWxsIGJlIGF0dGVtcHRlZCB0aGlzIG1hbnkgdGlja3MgYmVmb3JlIHRoZSBjdXJyZW50IHNlc3Npb24gZXhwaXJlcy4gKi9cbmNvbnN0IEFVVE9fUkVGUkVTSF9USUNLX1RIUkVTSE9MRCA9IDM7XG5hc3luYyBmdW5jdGlvbiBsb2NrTm9PcChuYW1lLCBhY3F1aXJlVGltZW91dCwgZm4pIHtcbiAgICByZXR1cm4gYXdhaXQgZm4oKTtcbn1cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdvVHJ1ZUNsaWVudCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGNsaWVudCBmb3IgdXNlIGluIHRoZSBicm93c2VyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5tZW1vcnlTdG9yYWdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZUVtaXR0ZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmF1dG9SZWZyZXNoVGlja2VyID0gbnVsbDtcbiAgICAgICAgdGhpcy52aXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogS2VlcHMgdHJhY2sgb2YgdGhlIGFzeW5jIGNsaWVudCBpbml0aWFsaXphdGlvbi5cbiAgICAgICAgICogV2hlbiBudWxsIG9yIG5vdCB5ZXQgcmVzb2x2ZWQgdGhlIGF1dGggc3RhdGUgaXMgYHVua25vd25gXG4gICAgICAgICAqIE9uY2UgcmVzb2x2ZWQgdGhlIHRoZSBhdXRoIHN0YXRlIGlzIGtub3duIGFuZCBpdCdzIHNhdmUgdG8gY2FsbCBhbnkgZnVydGhlciBjbGllbnQgbWV0aG9kcy5cbiAgICAgICAgICogS2VlcCBleHRyYSBjYXJlIHRvIG5ldmVyIHJlamVjdCBvciB0aHJvdyB1bmNhdWdodCBlcnJvcnNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZVByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLmRldGVjdFNlc3Npb25JblVybCA9IHRydWU7XG4gICAgICAgIHRoaXMuaGFzQ3VzdG9tQXV0aG9yaXphdGlvbkhlYWRlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN1cHByZXNzR2V0U2Vzc2lvbldhcm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sb2NrQWNxdWlyZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wZW5kaW5nSW5Mb2NrID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VkIHRvIGJyb2FkY2FzdCBzdGF0ZSBjaGFuZ2UgZXZlbnRzIHRvIG90aGVyIHRhYnMgbGlzdGVuaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5icm9hZGNhc3RDaGFubmVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBjb25zb2xlLmxvZztcbiAgICAgICAgdGhpcy5pbnN0YW5jZUlEID0gR29UcnVlQ2xpZW50Lm5leHRJbnN0YW5jZUlEO1xuICAgICAgICBHb1RydWVDbGllbnQubmV4dEluc3RhbmNlSUQgKz0gMTtcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2VJRCA+IDAgJiYgaXNCcm93c2VyKCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignTXVsdGlwbGUgR29UcnVlQ2xpZW50IGluc3RhbmNlcyBkZXRlY3RlZCBpbiB0aGUgc2FtZSBicm93c2VyIGNvbnRleHQuIEl0IGlzIG5vdCBhbiBlcnJvciwgYnV0IHRoaXMgc2hvdWxkIGJlIGF2b2lkZWQgYXMgaXQgbWF5IHByb2R1Y2UgdW5kZWZpbmVkIGJlaGF2aW9yIHdoZW4gdXNlZCBjb25jdXJyZW50bHkgdW5kZXIgdGhlIHNhbWUgc3RvcmFnZSBrZXkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUyksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmxvZ0RlYnVnTWVzc2FnZXMgPSAhIXNldHRpbmdzLmRlYnVnO1xuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLmRlYnVnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlciA9IHNldHRpbmdzLmRlYnVnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVyc2lzdFNlc3Npb24gPSBzZXR0aW5ncy5wZXJzaXN0U2Vzc2lvbjtcbiAgICAgICAgdGhpcy5zdG9yYWdlS2V5ID0gc2V0dGluZ3Muc3RvcmFnZUtleTtcbiAgICAgICAgdGhpcy5hdXRvUmVmcmVzaFRva2VuID0gc2V0dGluZ3MuYXV0b1JlZnJlc2hUb2tlbjtcbiAgICAgICAgdGhpcy5hZG1pbiA9IG5ldyBHb1RydWVBZG1pbkFwaSh7XG4gICAgICAgICAgICB1cmw6IHNldHRpbmdzLnVybCxcbiAgICAgICAgICAgIGhlYWRlcnM6IHNldHRpbmdzLmhlYWRlcnMsXG4gICAgICAgICAgICBmZXRjaDogc2V0dGluZ3MuZmV0Y2gsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVybCA9IHNldHRpbmdzLnVybDtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gc2V0dGluZ3MuaGVhZGVycztcbiAgICAgICAgdGhpcy5mZXRjaCA9IHJlc29sdmVGZXRjaChzZXR0aW5ncy5mZXRjaCk7XG4gICAgICAgIHRoaXMubG9jayA9IHNldHRpbmdzLmxvY2sgfHwgbG9ja05vT3A7XG4gICAgICAgIHRoaXMuZGV0ZWN0U2Vzc2lvbkluVXJsID0gc2V0dGluZ3MuZGV0ZWN0U2Vzc2lvbkluVXJsO1xuICAgICAgICB0aGlzLmZsb3dUeXBlID0gc2V0dGluZ3MuZmxvd1R5cGU7XG4gICAgICAgIHRoaXMuaGFzQ3VzdG9tQXV0aG9yaXphdGlvbkhlYWRlciA9IHNldHRpbmdzLmhhc0N1c3RvbUF1dGhvcml6YXRpb25IZWFkZXI7XG4gICAgICAgIGlmIChzZXR0aW5ncy5sb2NrKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2sgPSBzZXR0aW5ncy5sb2NrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQnJvd3NlcigpICYmICgoX2EgPSBnbG9iYWxUaGlzID09PSBudWxsIHx8IGdsb2JhbFRoaXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdsb2JhbFRoaXMubmF2aWdhdG9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubG9ja3MpKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2sgPSBuYXZpZ2F0b3JMb2NrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sb2NrID0gbG9ja05vT3A7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZmEgPSB7XG4gICAgICAgICAgICB2ZXJpZnk6IHRoaXMuX3ZlcmlmeS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZW5yb2xsOiB0aGlzLl9lbnJvbGwuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHVuZW5yb2xsOiB0aGlzLl91bmVucm9sbC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgY2hhbGxlbmdlOiB0aGlzLl9jaGFsbGVuZ2UuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGxpc3RGYWN0b3JzOiB0aGlzLl9saXN0RmFjdG9ycy5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgY2hhbGxlbmdlQW5kVmVyaWZ5OiB0aGlzLl9jaGFsbGVuZ2VBbmRWZXJpZnkuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGdldEF1dGhlbnRpY2F0b3JBc3N1cmFuY2VMZXZlbDogdGhpcy5fZ2V0QXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVsLmJpbmQodGhpcyksXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnBlcnNpc3RTZXNzaW9uKSB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3Muc3RvcmFnZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcmFnZSA9IHNldHRpbmdzLnN0b3JhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydHNMb2NhbFN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3JhZ2UgPSBsb2NhbFN0b3JhZ2VBZGFwdGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZW1vcnlTdG9yYWdlID0ge307XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcmFnZSA9IG1lbW9yeUxvY2FsU3RvcmFnZUFkYXB0ZXIodGhpcy5tZW1vcnlTdG9yYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1lbW9yeVN0b3JhZ2UgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZSA9IG1lbW9yeUxvY2FsU3RvcmFnZUFkYXB0ZXIodGhpcy5tZW1vcnlTdG9yYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNCcm93c2VyKCkgJiYgZ2xvYmFsVGhpcy5Ccm9hZGNhc3RDaGFubmVsICYmIHRoaXMucGVyc2lzdFNlc3Npb24gJiYgdGhpcy5zdG9yYWdlS2V5KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0Q2hhbm5lbCA9IG5ldyBnbG9iYWxUaGlzLkJyb2FkY2FzdENoYW5uZWwodGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNyZWF0ZSBhIG5ldyBCcm9hZGNhc3RDaGFubmVsLCBtdWx0aS10YWIgc3RhdGUgY2hhbmdlcyB3aWxsIG5vdCBiZSBhdmFpbGFibGUnLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChfYiA9IHRoaXMuYnJvYWRjYXN0Q2hhbm5lbCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygncmVjZWl2ZWQgYnJvYWRjYXN0IG5vdGlmaWNhdGlvbiBmcm9tIG90aGVyIHRhYiBvciBjbGllbnQnLCBldmVudCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoZXZlbnQuZGF0YS5ldmVudCwgZXZlbnQuZGF0YS5zZXNzaW9uLCBmYWxzZSk7IC8vIGJyb2FkY2FzdCA9IGZhbHNlIHNvIHdlIGRvbid0IGdldCBhbiBlbmRsZXNzIGxvb3Agb2YgbWVzc2FnZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgIH1cbiAgICBfZGVidWcoLi4uYXJncykge1xuICAgICAgICBpZiAodGhpcy5sb2dEZWJ1Z01lc3NhZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlcihgR29UcnVlQ2xpZW50QCR7dGhpcy5pbnN0YW5jZUlEfSAoJHt2ZXJzaW9ufSkgJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9YCwgLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBjbGllbnQgc2Vzc2lvbiBlaXRoZXIgZnJvbSB0aGUgdXJsIG9yIGZyb20gc3RvcmFnZS5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBhdXRvbWF0aWNhbGx5IGNhbGxlZCB3aGVuIGluc3RhbnRpYXRpbmcgdGhlIGNsaWVudCwgYnV0IHNob3VsZCBhbHNvIGJlIGNhbGxlZFxuICAgICAqIG1hbnVhbGx5IHdoZW4gY2hlY2tpbmcgZm9yIGFuIGVycm9yIGZyb20gYW4gYXV0aCByZWRpcmVjdCAob2F1dGgsIG1hZ2ljbGluaywgcGFzc3dvcmQgcmVjb3ZlcnksIGV0YykuXG4gICAgICovXG4gICAgYXN5bmMgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6ZVByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZVByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2luaXRpYWxpemUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSU1QT1JUQU5UOlxuICAgICAqIDEuIE5ldmVyIHRocm93IGluIHRoaXMgbWV0aG9kLCBhcyBpdCBpcyBjYWxsZWQgZnJvbSB0aGUgY29uc3RydWN0b3JcbiAgICAgKiAyLiBOZXZlciByZXR1cm4gYSBzZXNzaW9uIGZyb20gdGhpcyBtZXRob2QgYXMgaXQgd291bGQgYmUgY2FjaGVkIG92ZXJcbiAgICAgKiAgICB0aGUgd2hvbGUgbGlmZXRpbWUgb2YgdGhlIGNsaWVudFxuICAgICAqL1xuICAgIGFzeW5jIF9pbml0aWFsaXplKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaXNQS0NFRmxvdyA9IGlzQnJvd3NlcigpID8gYXdhaXQgdGhpcy5faXNQS0NFRmxvdygpIDogZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19pbml0aWFsaXplKCknLCAnYmVnaW4nLCAnaXMgUEtDRSBmbG93JywgaXNQS0NFRmxvdyk7XG4gICAgICAgICAgICBpZiAoaXNQS0NFRmxvdyB8fCAodGhpcy5kZXRlY3RTZXNzaW9uSW5VcmwgJiYgdGhpcy5faXNJbXBsaWNpdEdyYW50RmxvdygpKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX2dldFNlc3Npb25Gcm9tVVJMKGlzUEtDRUZsb3cpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19pbml0aWFsaXplKCknLCAnZXJyb3IgZGV0ZWN0aW5nIHNlc3Npb24gZnJvbSBVUkwnLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIC8vIGhhY2t5IHdvcmthcm91bmQgdG8ga2VlcCB0aGUgZXhpc3Rpbmcgc2Vzc2lvbiBpZiB0aGVyZSdzIGFuIGVycm9yIHJldHVybmVkIGZyb20gaWRlbnRpdHkgbGlua2luZ1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBvbmNlIGVycm9yIGNvZGVzIGFyZSByZWFkeSwgd2Ugc2hvdWxkIG1hdGNoIGFnYWluc3QgaXQgaW5zdGVhZCBvZiB0aGUgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICBpZiAoKGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5tZXNzYWdlKSA9PT0gJ0lkZW50aXR5IGlzIGFscmVhZHkgbGlua2VkJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5tZXNzYWdlKSA9PT0gJ0lkZW50aXR5IGlzIGFscmVhZHkgbGlua2VkIHRvIGFub3RoZXIgdXNlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGVycm9yIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gZmFpbGVkIGxvZ2luIGF0dGVtcHQgdmlhIHVybCxcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIG9sZCBzZXNzaW9uIGFzIGluIHZlcmlmeU90cCwgc2lnblVwIGFuZCBzaWduSW5XaXRoKlxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9yZW1vdmVTZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2Vzc2lvbiwgcmVkaXJlY3RUeXBlIH0gPSBkYXRhO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2luaXRpYWxpemUoKScsICdkZXRlY3RlZCBzZXNzaW9uIGluIFVSTCcsIHNlc3Npb24sICdyZWRpcmVjdCB0eXBlJywgcmVkaXJlY3RUeXBlKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZGlyZWN0VHlwZSA9PT0gJ3JlY292ZXJ5Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1BBU1NXT1JEX1JFQ09WRVJZJywgc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbm8gbG9naW4gYXR0ZW1wdCB2aWEgY2FsbGJhY2sgdXJsIHRyeSB0byByZWNvdmVyIHNlc3Npb24gZnJvbSBzdG9yYWdlXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9yZWNvdmVyQW5kUmVmcmVzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBlcnJvcjogbmV3IEF1dGhVbmtub3duRXJyb3IoJ1VuZXhwZWN0ZWQgZXJyb3IgZHVyaW5nIGluaXRpYWxpemF0aW9uJywgZXJyb3IpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2hhbmRsZVZpc2liaWxpdHlDaGFuZ2UoKTtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2luaXRpYWxpemUoKScsICdlbmQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGFub255bW91cyB1c2VyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBzZXNzaW9uIHdoZXJlIHRoZSBpc19hbm9ueW1vdXMgY2xhaW0gaW4gdGhlIGFjY2VzcyB0b2tlbiBKV1Qgc2V0IHRvIHRydWVcbiAgICAgKi9cbiAgICBhc3luYyBzaWduSW5Bbm9ueW1vdXNseShjcmVkZW50aWFscykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3NpZ251cGAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiAoX2IgPSAoX2EgPSBjcmVkZW50aWFscyA9PT0gbnVsbCB8fCBjcmVkZW50aWFscyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3JlZGVudGlhbHMub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRhdGEpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHt9LFxuICAgICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiAoX2MgPSBjcmVkZW50aWFscyA9PT0gbnVsbCB8fCBjcmVkZW50aWFscyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3JlZGVudGlhbHMub3B0aW9ucykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlcztcbiAgICAgICAgICAgIGlmIChlcnJvciB8fCAhZGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSBkYXRhLnNlc3Npb247XG4gICAgICAgICAgICBjb25zdCB1c2VyID0gZGF0YS51c2VyO1xuICAgICAgICAgICAgaWYgKGRhdGEuc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKGRhdGEuc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIHNlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyLCBzZXNzaW9uIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHVzZXIuXG4gICAgICpcbiAgICAgKiBCZSBhd2FyZSB0aGF0IGlmIGEgdXNlciBhY2NvdW50IGV4aXN0cyBpbiB0aGUgc3lzdGVtIHlvdSBtYXkgZ2V0IGJhY2sgYW5cbiAgICAgKiBlcnJvciBtZXNzYWdlIHRoYXQgYXR0ZW1wdHMgdG8gaGlkZSB0aGlzIGluZm9ybWF0aW9uIGZyb20gdGhlIHVzZXIuXG4gICAgICogVGhpcyBtZXRob2QgaGFzIHN1cHBvcnQgZm9yIFBLQ0UgdmlhIGVtYWlsIHNpZ251cHMuIFRoZSBQS0NFIGZsb3cgY2Fubm90IGJlIHVzZWQgd2hlbiBhdXRvY29uZmlybSBpcyBlbmFibGVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBsb2dnZWQtaW4gc2Vzc2lvbiBpZiB0aGUgc2VydmVyIGhhcyBcImF1dG9jb25maXJtXCIgT05cbiAgICAgKiBAcmV0dXJucyBBIHVzZXIgaWYgdGhlIHNlcnZlciBoYXMgXCJhdXRvY29uZmlybVwiIE9GRlxuICAgICAqL1xuICAgIGFzeW5jIHNpZ25VcChjcmVkZW50aWFscykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCByZXM7XG4gICAgICAgICAgICBpZiAoJ2VtYWlsJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZW1haWwsIHBhc3N3b3JkLCBvcHRpb25zIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgICAgICBsZXQgY29kZUNoYWxsZW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2VNZXRob2QgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZsb3dUeXBlID09PSAncGtjZScpIHtcbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICBbY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZF0gPSBhd2FpdCBnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vc2lnbnVwYCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIHJlZGlyZWN0VG86IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5lbWFpbFJlZGlyZWN0VG8sXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtYWlsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGF0YSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlX2NoYWxsZW5nZTogY29kZUNoYWxsZW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVfY2hhbGxlbmdlX21ldGhvZDogY29kZUNoYWxsZW5nZU1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgncGhvbmUnIGluIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwaG9uZSwgcGFzc3dvcmQsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzO1xuICAgICAgICAgICAgICAgIHJlcyA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3NpZ251cGAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwaG9uZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhc3N3b3JkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRhdGEpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbDogKF9jID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNoYW5uZWwpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6ICdzbXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB4Zm9ybTogX3Nlc3Npb25SZXNwb25zZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgZWl0aGVyIGFuIGVtYWlsIG9yIHBob25lIG51bWJlciBhbmQgYSBwYXNzd29yZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gcmVzO1xuICAgICAgICAgICAgaWYgKGVycm9yIHx8ICFkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IGRhdGEuc2Vzc2lvbjtcbiAgICAgICAgICAgIGNvbnN0IHVzZXIgPSBkYXRhLnVzZXI7XG4gICAgICAgICAgICBpZiAoZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgc2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXIsIHNlc3Npb24gfSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZyBpbiBhbiBleGlzdGluZyB1c2VyIHdpdGggYW4gZW1haWwgYW5kIHBhc3N3b3JkIG9yIHBob25lIGFuZCBwYXNzd29yZC5cbiAgICAgKlxuICAgICAqIEJlIGF3YXJlIHRoYXQgeW91IG1heSBnZXQgYmFjayBhbiBlcnJvciBtZXNzYWdlIHRoYXQgd2lsbCBub3QgZGlzdGluZ3Vpc2hcbiAgICAgKiBiZXR3ZWVuIHRoZSBjYXNlcyB3aGVyZSB0aGUgYWNjb3VudCBkb2VzIG5vdCBleGlzdCBvciB0aGF0IHRoZVxuICAgICAqIGVtYWlsL3Bob25lIGFuZCBwYXNzd29yZCBjb21iaW5hdGlvbiBpcyB3cm9uZyBvciB0aGF0IHRoZSBhY2NvdW50IGNhbiBvbmx5XG4gICAgICogYmUgYWNjZXNzZWQgdmlhIHNvY2lhbCBsb2dpbi5cbiAgICAgKi9cbiAgICBhc3luYyBzaWduSW5XaXRoUGFzc3dvcmQoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCByZXM7XG4gICAgICAgICAgICBpZiAoJ2VtYWlsJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZW1haWwsIHBhc3N3b3JkLCBvcHRpb25zIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgICAgICByZXMgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS90b2tlbj9ncmFudF90eXBlPXBhc3N3b3JkYCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtYWlsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlUGFzc3dvcmQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgncGhvbmUnIGluIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwaG9uZSwgcGFzc3dvcmQsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzO1xuICAgICAgICAgICAgICAgIHJlcyA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9cGFzc3dvcmRgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGhvbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXNzd29yZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2VQYXNzd29yZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgZWl0aGVyIGFuIGVtYWlsIG9yIHBob25lIG51bWJlciBhbmQgYSBwYXNzd29yZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gcmVzO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghZGF0YSB8fCAhZGF0YS5zZXNzaW9uIHx8ICFkYXRhLnVzZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3I6IG5ldyBBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvcigpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7IHVzZXI6IGRhdGEudXNlciwgc2Vzc2lvbjogZGF0YS5zZXNzaW9uIH0sIChkYXRhLndlYWtfcGFzc3dvcmQgPyB7IHdlYWtQYXNzd29yZDogZGF0YS53ZWFrX3Bhc3N3b3JkIH0gOiBudWxsKSksXG4gICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9nIGluIGFuIGV4aXN0aW5nIHVzZXIgdmlhIGEgdGhpcmQtcGFydHkgcHJvdmlkZXIuXG4gICAgICogVGhpcyBtZXRob2Qgc3VwcG9ydHMgdGhlIFBLQ0UgZmxvdy5cbiAgICAgKi9cbiAgICBhc3luYyBzaWduSW5XaXRoT0F1dGgoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5faGFuZGxlUHJvdmlkZXJTaWduSW4oY3JlZGVudGlhbHMucHJvdmlkZXIsIHtcbiAgICAgICAgICAgIHJlZGlyZWN0VG86IChfYSA9IGNyZWRlbnRpYWxzLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWRpcmVjdFRvLFxuICAgICAgICAgICAgc2NvcGVzOiAoX2IgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2NvcGVzLFxuICAgICAgICAgICAgcXVlcnlQYXJhbXM6IChfYyA9IGNyZWRlbnRpYWxzLm9wdGlvbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5xdWVyeVBhcmFtcyxcbiAgICAgICAgICAgIHNraXBCcm93c2VyUmVkaXJlY3Q6IChfZCA9IGNyZWRlbnRpYWxzLm9wdGlvbnMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5za2lwQnJvd3NlclJlZGlyZWN0LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9nIGluIGFuIGV4aXN0aW5nIHVzZXIgYnkgZXhjaGFuZ2luZyBhbiBBdXRoIENvZGUgaXNzdWVkIGR1cmluZyB0aGUgUEtDRSBmbG93LlxuICAgICAqL1xuICAgIGFzeW5jIGV4Y2hhbmdlQ29kZUZvclNlc3Npb24oYXV0aENvZGUpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXhjaGFuZ2VDb2RlRm9yU2Vzc2lvbihhdXRoQ29kZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBfZXhjaGFuZ2VDb2RlRm9yU2Vzc2lvbihhdXRoQ29kZSkge1xuICAgICAgICBjb25zdCBzdG9yYWdlSXRlbSA9IGF3YWl0IGdldEl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApO1xuICAgICAgICBjb25zdCBbY29kZVZlcmlmaWVyLCByZWRpcmVjdFR5cGVdID0gKHN0b3JhZ2VJdGVtICE9PSBudWxsICYmIHN0b3JhZ2VJdGVtICE9PSB2b2lkIDAgPyBzdG9yYWdlSXRlbSA6ICcnKS5zcGxpdCgnLycpO1xuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS90b2tlbj9ncmFudF90eXBlPXBrY2VgLCB7XG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgYXV0aF9jb2RlOiBhdXRoQ29kZSxcbiAgICAgICAgICAgICAgICBjb2RlX3ZlcmlmaWVyOiBjb2RlVmVyaWZpZXIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByZW1vdmVJdGVtQXN5bmModGhpcy5zdG9yYWdlLCBgJHt0aGlzLnN0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgKTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwsIHJlZGlyZWN0VHlwZTogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFkYXRhIHx8ICFkYXRhLnNlc3Npb24gfHwgIWRhdGEudXNlcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwsIHJlZGlyZWN0VHlwZTogbnVsbCB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgQXV0aEludmFsaWRUb2tlblJlc3BvbnNlRXJyb3IoKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuc2Vzc2lvbikge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBkYXRhLnNlc3Npb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRhdGE6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGF0YSksIHsgcmVkaXJlY3RUeXBlOiByZWRpcmVjdFR5cGUgIT09IG51bGwgJiYgcmVkaXJlY3RUeXBlICE9PSB2b2lkIDAgPyByZWRpcmVjdFR5cGUgOiBudWxsIH0pLCBlcnJvciB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGxvd3Mgc2lnbmluZyBpbiB3aXRoIGFuIE9JREMgSUQgdG9rZW4uIFRoZSBhdXRoZW50aWNhdGlvbiBwcm92aWRlciB1c2VkXG4gICAgICogc2hvdWxkIGJlIGVuYWJsZWQgYW5kIGNvbmZpZ3VyZWQuXG4gICAgICovXG4gICAgYXN5bmMgc2lnbkluV2l0aElkVG9rZW4oY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgb3B0aW9ucywgcHJvdmlkZXIsIHRva2VuLCBhY2Nlc3NfdG9rZW4sIG5vbmNlIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9aWRfdG9rZW5gLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgICAgIGlkX3Rva2VuOiB0b2tlbixcbiAgICAgICAgICAgICAgICAgICAgYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICBub25jZSxcbiAgICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlcztcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWRhdGEgfHwgIWRhdGEuc2Vzc2lvbiB8fCAhZGF0YS51c2VyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgQXV0aEludmFsaWRUb2tlblJlc3BvbnNlRXJyb3IoKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEuc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKGRhdGEuc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIGRhdGEuc2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvciB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9nIGluIGEgdXNlciB1c2luZyBtYWdpY2xpbmsgb3IgYSBvbmUtdGltZSBwYXNzd29yZCAoT1RQKS5cbiAgICAgKlxuICAgICAqIElmIHRoZSBge3sgLkNvbmZpcm1hdGlvblVSTCB9fWAgdmFyaWFibGUgaXMgc3BlY2lmaWVkIGluIHRoZSBlbWFpbCB0ZW1wbGF0ZSwgYSBtYWdpY2xpbmsgd2lsbCBiZSBzZW50LlxuICAgICAqIElmIHRoZSBge3sgLlRva2VuIH19YCB2YXJpYWJsZSBpcyBzcGVjaWZpZWQgaW4gdGhlIGVtYWlsIHRlbXBsYXRlLCBhbiBPVFAgd2lsbCBiZSBzZW50LlxuICAgICAqIElmIHlvdSdyZSB1c2luZyBwaG9uZSBzaWduLWlucywgb25seSBhbiBPVFAgd2lsbCBiZSBzZW50LiBZb3Ugd29uJ3QgYmUgYWJsZSB0byBzZW5kIGEgbWFnaWNsaW5rIGZvciBwaG9uZSBzaWduLWlucy5cbiAgICAgKlxuICAgICAqIEJlIGF3YXJlIHRoYXQgeW91IG1heSBnZXQgYmFjayBhbiBlcnJvciBtZXNzYWdlIHRoYXQgd2lsbCBub3QgZGlzdGluZ3Vpc2hcbiAgICAgKiBiZXR3ZWVuIHRoZSBjYXNlcyB3aGVyZSB0aGUgYWNjb3VudCBkb2VzIG5vdCBleGlzdCBvciwgdGhhdCB0aGUgYWNjb3VudFxuICAgICAqIGNhbiBvbmx5IGJlIGFjY2Vzc2VkIHZpYSBzb2NpYWwgbG9naW4uXG4gICAgICpcbiAgICAgKiBEbyBub3RlIHRoYXQgeW91IHdpbGwgbmVlZCB0byBjb25maWd1cmUgYSBXaGF0c2FwcCBzZW5kZXIgb24gVHdpbGlvXG4gICAgICogaWYgeW91IGFyZSB1c2luZyBwaG9uZSBzaWduIGluIHdpdGggdGhlICd3aGF0c2FwcCcgY2hhbm5lbC4gVGhlIHdoYXRzYXBwXG4gICAgICogY2hhbm5lbCBpcyBub3Qgc3VwcG9ydGVkIG9uIG90aGVyIHByb3ZpZGVyc1xuICAgICAqIGF0IHRoaXMgdGltZS5cbiAgICAgKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBQS0NFIHdoZW4gYW4gZW1haWwgaXMgcGFzc2VkLlxuICAgICAqL1xuICAgIGFzeW5jIHNpZ25JbldpdGhPdHAoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICgnZW1haWwnIGluIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlbWFpbCwgb3B0aW9ucyB9ID0gY3JlZGVudGlhbHM7XG4gICAgICAgICAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlTWV0aG9kID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ3BrY2UnKSB7XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgW2NvZGVDaGFsbGVuZ2UsIGNvZGVDaGFsbGVuZ2VNZXRob2RdID0gYXdhaXQgZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZCh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L290cGAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kYXRhKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZV91c2VyOiAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2hvdWxkQ3JlYXRlVXNlcikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVfY2hhbGxlbmdlOiBjb2RlQ2hhbGxlbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZV9jaGFsbGVuZ2VfbWV0aG9kOiBjb2RlQ2hhbGxlbmdlTWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZW1haWxSZWRpcmVjdFRvLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdwaG9uZScgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHBob25lLCBvcHRpb25zIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9vdHBgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGhvbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiAoX2MgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGF0YSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVfdXNlcjogKF9kID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNob3VsZENyZWF0ZVVzZXIpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsOiAoX2UgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2hhbm5lbCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogJ3NtcycsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsLCBtZXNzYWdlSWQ6IGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS5tZXNzYWdlX2lkIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yKCdZb3UgbXVzdCBwcm92aWRlIGVpdGhlciBhbiBlbWFpbCBvciBwaG9uZSBudW1iZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2cgaW4gYSB1c2VyIGdpdmVuIGEgVXNlciBzdXBwbGllZCBPVFAgb3IgVG9rZW5IYXNoIHJlY2VpdmVkIHRocm91Z2ggbW9iaWxlIG9yIGVtYWlsLlxuICAgICAqL1xuICAgIGFzeW5jIHZlcmlmeU90cChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCByZWRpcmVjdFRvID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgbGV0IGNhcHRjaGFUb2tlbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICgnb3B0aW9ucycgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgcmVkaXJlY3RUbyA9IChfYSA9IHBhcmFtcy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVkaXJlY3RUbztcbiAgICAgICAgICAgICAgICBjYXB0Y2hhVG9rZW4gPSAoX2IgPSBwYXJhbXMub3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhcHRjaGFUb2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3ZlcmlmeWAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpLCB7IGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IGNhcHRjaGFUb2tlbiB9IH0pLFxuICAgICAgICAgICAgICAgIHJlZGlyZWN0VG8sXG4gICAgICAgICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbiBlcnJvciBvY2N1cnJlZCBvbiB0b2tlbiB2ZXJpZmljYXRpb24uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uID0gZGF0YS5zZXNzaW9uO1xuICAgICAgICAgICAgY29uc3QgdXNlciA9IGRhdGEudXNlcjtcbiAgICAgICAgICAgIGlmIChzZXNzaW9uID09PSBudWxsIHx8IHNlc3Npb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlc3Npb24uYWNjZXNzX3Rva2VuKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMocGFyYW1zLnR5cGUgPT0gJ3JlY292ZXJ5JyA/ICdQQVNTV09SRF9SRUNPVkVSWScgOiAnU0lHTkVEX0lOJywgc2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXIsIHNlc3Npb24gfSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIGEgc2luZ2xlLXNpZ24gb24gdXNpbmcgYW4gZW50ZXJwcmlzZSBJZGVudGl0eSBQcm92aWRlci4gQVxuICAgICAqIHN1Y2Nlc3NmdWwgU1NPIGF0dGVtcHQgd2lsbCByZWRpcmVjdCB0aGUgY3VycmVudCBwYWdlIHRvIHRoZSBpZGVudGl0eVxuICAgICAqIHByb3ZpZGVyIGF1dGhvcml6YXRpb24gcGFnZS4gVGhlIHJlZGlyZWN0IFVSTCBpcyBpbXBsZW1lbnRhdGlvbiBhbmQgU1NPXG4gICAgICogcHJvdG9jb2wgc3BlY2lmaWMuXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIHVzZSBpdCBieSBwcm92aWRpbmcgYSBTU08gZG9tYWluLiBUeXBpY2FsbHkgeW91IGNhbiBleHRyYWN0IHRoaXNcbiAgICAgKiBkb21haW4gYnkgYXNraW5nIHVzZXJzIGZvciB0aGVpciBlbWFpbCBhZGRyZXNzLiBJZiB0aGlzIGRvbWFpbiBpc1xuICAgICAqIHJlZ2lzdGVyZWQgb24gdGhlIEF1dGggaW5zdGFuY2UgdGhlIHJlZGlyZWN0IHdpbGwgdXNlIHRoYXQgb3JnYW5pemF0aW9uJ3NcbiAgICAgKiBjdXJyZW50bHkgYWN0aXZlIFNTTyBJZGVudGl0eSBQcm92aWRlciBmb3IgdGhlIGxvZ2luLlxuICAgICAqXG4gICAgICogSWYgeW91IGhhdmUgYnVpbHQgYW4gb3JnYW5pemF0aW9uLXNwZWNpZmljIGxvZ2luIHBhZ2UsIHlvdSBjYW4gdXNlIHRoZVxuICAgICAqIG9yZ2FuaXphdGlvbidzIFNTTyBJZGVudGl0eSBQcm92aWRlciBVVUlEIGRpcmVjdGx5IGluc3RlYWQuXG4gICAgICovXG4gICAgYXN5bmMgc2lnbkluV2l0aFNTTyhwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgY29kZUNoYWxsZW5nZSA9IG51bGw7XG4gICAgICAgICAgICBsZXQgY29kZUNoYWxsZW5nZU1ldGhvZCA9IG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ3BrY2UnKSB7XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIFtjb2RlQ2hhbGxlbmdlLCBjb2RlQ2hhbGxlbmdlTWV0aG9kXSA9IGF3YWl0IGdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2QodGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Nzb2AsIHtcbiAgICAgICAgICAgICAgICBib2R5OiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sICgncHJvdmlkZXJJZCcgaW4gcGFyYW1zID8geyBwcm92aWRlcl9pZDogcGFyYW1zLnByb3ZpZGVySWQgfSA6IG51bGwpKSwgKCdkb21haW4nIGluIHBhcmFtcyA/IHsgZG9tYWluOiBwYXJhbXMuZG9tYWluIH0gOiBudWxsKSksIHsgcmVkaXJlY3RfdG86IChfYiA9IChfYSA9IHBhcmFtcy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVkaXJlY3RUbykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdW5kZWZpbmVkIH0pLCAoKChfYyA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FwdGNoYVRva2VuKVxuICAgICAgICAgICAgICAgICAgICA/IHsgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogcGFyYW1zLm9wdGlvbnMuY2FwdGNoYVRva2VuIH0gfVxuICAgICAgICAgICAgICAgICAgICA6IG51bGwpKSwgeyBza2lwX2h0dHBfcmVkaXJlY3Q6IHRydWUsIGNvZGVfY2hhbGxlbmdlOiBjb2RlQ2hhbGxlbmdlLCBjb2RlX2NoYWxsZW5nZV9tZXRob2Q6IGNvZGVDaGFsbGVuZ2VNZXRob2QgfSksXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHhmb3JtOiBfc3NvUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSByZWF1dGhlbnRpY2F0aW9uIE9UUCB0byB0aGUgdXNlcidzIGVtYWlsIG9yIHBob25lIG51bWJlci5cbiAgICAgKiBSZXF1aXJlcyB0aGUgdXNlciB0byBiZSBzaWduZWQtaW4uXG4gICAgICovXG4gICAgYXN5bmMgcmVhdXRoZW50aWNhdGUoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3JlYXV0aGVudGljYXRlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBfcmVhdXRoZW50aWNhdGUoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiB7IHNlc3Npb24gfSwgZXJyb3I6IHNlc3Npb25FcnJvciwgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBzZXNzaW9uRXJyb3I7XG4gICAgICAgICAgICAgICAgaWYgKCFzZXNzaW9uKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9L3JlYXV0aGVudGljYXRlYCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGp3dDogc2Vzc2lvbi5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2VuZHMgYW4gZXhpc3Rpbmcgc2lnbnVwIGNvbmZpcm1hdGlvbiBlbWFpbCwgZW1haWwgY2hhbmdlIGVtYWlsLCBTTVMgT1RQIG9yIHBob25lIGNoYW5nZSBPVFAuXG4gICAgICovXG4gICAgYXN5bmMgcmVzZW5kKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBlbmRwb2ludCA9IGAke3RoaXMudXJsfS9yZXNlbmRgO1xuICAgICAgICAgICAgaWYgKCdlbWFpbCcgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVtYWlsLCB0eXBlLCBvcHRpb25zIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGVuZHBvaW50LCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1haWwsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZW1haWxSZWRpcmVjdFRvLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoJ3Bob25lJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGhvbmUsIHR5cGUsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgZW5kcG9pbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwaG9uZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsLCBtZXNzYWdlSWQ6IGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS5tZXNzYWdlX2lkIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yKCdZb3UgbXVzdCBwcm92aWRlIGVpdGhlciBhbiBlbWFpbCBvciBwaG9uZSBudW1iZXIgYW5kIGEgdHlwZScpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc2Vzc2lvbiwgcmVmcmVzaGluZyBpdCBpZiBuZWNlc3NhcnkuXG4gICAgICpcbiAgICAgKiBUaGUgc2Vzc2lvbiByZXR1cm5lZCBjYW4gYmUgbnVsbCBpZiB0aGUgc2Vzc2lvbiBpcyBub3QgZGV0ZWN0ZWQgd2hpY2ggY2FuIGhhcHBlbiBpbiB0aGUgZXZlbnQgYSB1c2VyIGlzIG5vdCBzaWduZWQtaW4gb3IgaGFzIGxvZ2dlZCBvdXQuXG4gICAgICpcbiAgICAgKiAqKklNUE9SVEFOVDoqKiBUaGlzIG1ldGhvZCBsb2FkcyB2YWx1ZXMgZGlyZWN0bHkgZnJvbSB0aGUgc3RvcmFnZSBhdHRhY2hlZFxuICAgICAqIHRvIHRoZSBjbGllbnQuIElmIHRoYXQgc3RvcmFnZSBpcyBiYXNlZCBvbiByZXF1ZXN0IGNvb2tpZXMgZm9yIGV4YW1wbGUsXG4gICAgICogdGhlIHZhbHVlcyBpbiBpdCBtYXkgbm90IGJlIGF1dGhlbnRpYyBhbmQgdGhlcmVmb3JlIGl0J3Mgc3Ryb25nbHkgYWR2aXNlZFxuICAgICAqIGFnYWluc3QgdXNpbmcgdGhpcyBtZXRob2QgYW5kIGl0cyByZXN1bHRzIGluIHN1Y2ggY2lyY3Vtc3RhbmNlcy4gQSB3YXJuaW5nXG4gICAgICogd2lsbCBiZSBlbWl0dGVkIGlmIHRoaXMgaXMgZGV0ZWN0ZWQuIFVzZSB7QGxpbmsgI2dldFVzZXIoKX0gaW5zdGVhZC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRTZXNzaW9uKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjcXVpcmVzIGEgZ2xvYmFsIGxvY2sgYmFzZWQgb24gdGhlIHN0b3JhZ2Uga2V5LlxuICAgICAqL1xuICAgIGFzeW5jIF9hY3F1aXJlTG9jayhhY3F1aXJlVGltZW91dCwgZm4pIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfYWNxdWlyZUxvY2snLCAnYmVnaW4nLCBhY3F1aXJlVGltZW91dCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sb2NrQWNxdWlyZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0ID0gdGhpcy5wZW5kaW5nSW5Mb2NrLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMucGVuZGluZ0luTG9ja1t0aGlzLnBlbmRpbmdJbkxvY2subGVuZ3RoIC0gMV1cbiAgICAgICAgICAgICAgICAgICAgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBsYXN0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgZm4oKTtcbiAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0luTG9jay5wdXNoKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGp1c3QgY2FyZSBpZiBpdCBmaW5pc2hlZFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmxvY2soYGxvY2s6JHt0aGlzLnN0b3JhZ2VLZXl9YCwgYWNxdWlyZVRpbWVvdXQsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19hY3F1aXJlTG9jaycsICdsb2NrIGFjcXVpcmVkIGZvciBzdG9yYWdlIGtleScsIHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2NrQWNxdWlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBmbigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdJbkxvY2sucHVzaCgoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGp1c3QgY2FyZSBpZiBpdCBmaW5pc2hlZFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KSgpKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAvLyBrZWVwIGRyYWluaW5nIHRoZSBxdWV1ZSB1bnRpbCB0aGVyZSdzIG5vdGhpbmcgdG8gd2FpdCBvblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5wZW5kaW5nSW5Mb2NrLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2FpdE9uID0gWy4uLnRoaXMucGVuZGluZ0luTG9ja107XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh3YWl0T24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nSW5Mb2NrLnNwbGljZSgwLCB3YWl0T24ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNfYWNxdWlyZUxvY2snLCAnbG9jayByZWxlYXNlZCBmb3Igc3RvcmFnZSBrZXknLCB0aGlzLnN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvY2tBY3F1aXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNfYWNxdWlyZUxvY2snLCAnZW5kJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlIGluc3RlYWQgb2Yge0BsaW5rICNnZXRTZXNzaW9ufSBpbnNpZGUgdGhlIGxpYnJhcnkuIEl0IGlzXG4gICAgICogc2VtYW50aWNhbGx5IHVzdWFsbHkgd2hhdCB5b3Ugd2FudCwgYXMgZ2V0dGluZyBhIHNlc3Npb24gaW52b2x2ZXMgc29tZVxuICAgICAqIHByb2Nlc3NpbmcgYWZ0ZXJ3YXJkcyB0aGF0IHJlcXVpcmVzIG9ubHkgb25lIGNsaWVudCBvcGVyYXRpbmcgb24gdGhlXG4gICAgICogc2Vzc2lvbiBhdCBvbmNlIGFjcm9zcyBtdWx0aXBsZSB0YWJzIG9yIHByb2Nlc3Nlcy5cbiAgICAgKi9cbiAgICBhc3luYyBfdXNlU2Vzc2lvbihmbikge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnI191c2VTZXNzaW9uJywgJ2JlZ2luJyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyB0aGUgdXNlIG9mIF9fbG9hZFNlc3Npb24gaGVyZSBpcyB0aGUgb25seSBjb3JyZWN0IHVzZSBvZiB0aGUgZnVuY3Rpb24hXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9fbG9hZFNlc3Npb24oKTtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBmbihyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNfdXNlU2Vzc2lvbicsICdlbmQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBORVZFUiBVU0UgRElSRUNUTFkhXG4gICAgICpcbiAgICAgKiBBbHdheXMgdXNlIHtAbGluayAjX3VzZVNlc3Npb259LlxuICAgICAqL1xuICAgIGFzeW5jIF9fbG9hZFNlc3Npb24oKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCcjX19sb2FkU2Vzc2lvbigpJywgJ2JlZ2luJyk7XG4gICAgICAgIGlmICghdGhpcy5sb2NrQWNxdWlyZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX19sb2FkU2Vzc2lvbigpJywgJ3VzZWQgb3V0c2lkZSBvZiBhbiBhY3F1aXJlZCBsb2NrIScsIG5ldyBFcnJvcigpLnN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRTZXNzaW9uID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IG1heWJlU2Vzc2lvbiA9IGF3YWl0IGdldEl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI2dldFNlc3Npb24oKScsICdzZXNzaW9uIGZyb20gc3RvcmFnZScsIG1heWJlU2Vzc2lvbik7XG4gICAgICAgICAgICBpZiAobWF5YmVTZXNzaW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzVmFsaWRTZXNzaW9uKG1heWJlU2Vzc2lvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNlc3Npb24gPSBtYXliZVNlc3Npb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI2dldFNlc3Npb24oKScsICdzZXNzaW9uIGZyb20gc3RvcmFnZSBpcyBub3QgdmFsaWQnKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcmVtb3ZlU2Vzc2lvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY3VycmVudFNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb246IG51bGwgfSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhhc0V4cGlyZWQgPSBjdXJyZW50U2Vzc2lvbi5leHBpcmVzX2F0XG4gICAgICAgICAgICAgICAgPyBjdXJyZW50U2Vzc2lvbi5leHBpcmVzX2F0IDw9IERhdGUubm93KCkgLyAxMDAwXG4gICAgICAgICAgICAgICAgOiBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX19sb2FkU2Vzc2lvbigpJywgYHNlc3Npb24gaGFzJHtoYXNFeHBpcmVkID8gJycgOiAnIG5vdCd9IGV4cGlyZWRgLCAnZXhwaXJlc19hdCcsIGN1cnJlbnRTZXNzaW9uLmV4cGlyZXNfYXQpO1xuICAgICAgICAgICAgaWYgKCFoYXNFeHBpcmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RvcmFnZS5pc1NlcnZlcikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3VwcHJlc3NXYXJuaW5nID0gdGhpcy5zdXBwcmVzc0dldFNlc3Npb25XYXJuaW5nO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm94eVNlc3Npb24gPSBuZXcgUHJveHkoY3VycmVudFNlc3Npb24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldDogKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN1cHByZXNzV2FybmluZyAmJiBwcm9wID09PSAndXNlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25seSBzaG93IHdhcm5pbmcgd2hlbiB0aGUgdXNlciBvYmplY3QgaXMgYmVpbmcgYWNjZXNzZWQgZnJvbSB0aGUgc2VydmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVXNpbmcgdGhlIHVzZXIgb2JqZWN0IGFzIHJldHVybmVkIGZyb20gc3VwYWJhc2UuYXV0aC5nZXRTZXNzaW9uKCkgb3IgZnJvbSBzb21lIHN1cGFiYXNlLmF1dGgub25BdXRoU3RhdGVDaGFuZ2UoKSBldmVudHMgY291bGQgYmUgaW5zZWN1cmUhIFRoaXMgdmFsdWUgY29tZXMgZGlyZWN0bHkgZnJvbSB0aGUgc3RvcmFnZSBtZWRpdW0gKHVzdWFsbHkgY29va2llcyBvbiB0aGUgc2VydmVyKSBhbmQgbWFueSBub3QgYmUgYXV0aGVudGljLiBVc2Ugc3VwYWJhc2UuYXV0aC5nZXRVc2VyKCkgaW5zdGVhZCB3aGljaCBhdXRoZW50aWNhdGVzIHRoZSBkYXRhIGJ5IGNvbnRhY3RpbmcgdGhlIFN1cGFiYXNlIEF1dGggc2VydmVyLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdXBwcmVzc1dhcm5pbmcgPSB0cnVlOyAvLyBrZWVwcyB0aGlzIHByb3h5IGluc3RhbmNlIGZyb20gbG9nZ2luZyBhZGRpdGlvbmFsIHdhcm5pbmdzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3VwcHJlc3NHZXRTZXNzaW9uV2FybmluZyA9IHRydWU7IC8vIGtlZXBzIHRoaXMgY2xpZW50J3MgZnV0dXJlIHByb3h5IGluc3RhbmNlcyBmcm9tIHdhcm5pbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZXNzaW9uID0gcHJveHlTZXNzaW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb246IGN1cnJlbnRTZXNzaW9uIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHNlc3Npb24sIGVycm9yIH0gPSBhd2FpdCB0aGlzLl9jYWxsUmVmcmVzaFRva2VuKGN1cnJlbnRTZXNzaW9uLnJlZnJlc2hfdG9rZW4pO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb24gfSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX19sb2FkU2Vzc2lvbigpJywgJ2VuZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgdXNlciBkZXRhaWxzIGlmIHRoZXJlIGlzIGFuIGV4aXN0aW5nIHNlc3Npb24uIFRoaXMgbWV0aG9kXG4gICAgICogcGVyZm9ybXMgYSBuZXR3b3JrIHJlcXVlc3QgdG8gdGhlIFN1cGFiYXNlIEF1dGggc2VydmVyLCBzbyB0aGUgcmV0dXJuZWRcbiAgICAgKiB2YWx1ZSBpcyBhdXRoZW50aWMgYW5kIGNhbiBiZSB1c2VkIHRvIGJhc2UgYXV0aG9yaXphdGlvbiBydWxlcyBvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBqd3QgVGFrZXMgaW4gYW4gb3B0aW9uYWwgYWNjZXNzIHRva2VuIEpXVC4gSWYgbm8gSldUIGlzIHByb3ZpZGVkLCB0aGUgSldUIGZyb20gdGhlIGN1cnJlbnQgc2Vzc2lvbiBpcyB1c2VkLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFVzZXIoand0KSB7XG4gICAgICAgIGlmIChqd3QpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9nZXRVc2VyKGp3dCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9nZXRVc2VyKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBfZ2V0VXNlcihqd3QpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChqd3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS91c2VyYCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGp3dDogand0LFxuICAgICAgICAgICAgICAgICAgICB4Zm9ybTogX3VzZXJSZXNwb25zZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyByZXR1cm5zIGFuIGVycm9yIGlmIHRoZXJlIGlzIG5vIGFjY2Vzc190b2tlbiBvciBjdXN0b20gYXV0aG9yaXphdGlvbiBoZWFkZXJcbiAgICAgICAgICAgICAgICBpZiAoISgoX2EgPSBkYXRhLnNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY2Nlc3NfdG9rZW4pICYmICF0aGlzLmhhc0N1c3RvbUF1dGhvcml6YXRpb25IZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsIH0sIGVycm9yOiBuZXcgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS91c2VyYCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGp3dDogKF9jID0gKF9iID0gZGF0YS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWNjZXNzX3Rva2VuKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIHhmb3JtOiBfdXNlclJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHVzZXIgZGF0YSBmb3IgYSBsb2dnZWQgaW4gdXNlci5cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVVc2VyKGF0dHJpYnV0ZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91cGRhdGVVc2VyKGF0dHJpYnV0ZXMsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgX3VwZGF0ZVVzZXIoYXR0cmlidXRlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBzZXNzaW9uRGF0YSwgZXJyb3I6IHNlc3Npb25FcnJvciB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgc2Vzc2lvbkVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXNlc3Npb25EYXRhLnNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSBzZXNzaW9uRGF0YS5zZXNzaW9uO1xuICAgICAgICAgICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgY29kZUNoYWxsZW5nZU1ldGhvZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmxvd1R5cGUgPT09ICdwa2NlJyAmJiBhdHRyaWJ1dGVzLmVtYWlsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICBbY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZF0gPSBhd2FpdCBnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvcjogdXNlckVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUFVUJywgYCR7dGhpcy51cmx9L3VzZXJgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmVtYWlsUmVkaXJlY3RUbyxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVzKSwgeyBjb2RlX2NoYWxsZW5nZTogY29kZUNoYWxsZW5nZSwgY29kZV9jaGFsbGVuZ2VfbWV0aG9kOiBjb2RlQ2hhbGxlbmdlTWV0aG9kIH0pLFxuICAgICAgICAgICAgICAgICAgICBqd3Q6IHNlc3Npb24uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICB4Zm9ybTogX3VzZXJSZXNwb25zZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAodXNlckVycm9yKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyB1c2VyRXJyb3I7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi51c2VyID0gZGF0YS51c2VyO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKHNlc3Npb24pO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdVU0VSX1VQREFURUQnLCBzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IHNlc3Npb24udXNlciB9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNvZGVzIGEgSldUICh3aXRob3V0IHBlcmZvcm1pbmcgYW55IHZhbGlkYXRpb24pLlxuICAgICAqL1xuICAgIF9kZWNvZGVKV1Qoand0KSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVKV1RQYXlsb2FkKGp3dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNlc3Npb24gZGF0YSBmcm9tIHRoZSBjdXJyZW50IHNlc3Npb24uIElmIHRoZSBjdXJyZW50IHNlc3Npb24gaXMgZXhwaXJlZCwgc2V0U2Vzc2lvbiB3aWxsIHRha2UgY2FyZSBvZiByZWZyZXNoaW5nIGl0IHRvIG9idGFpbiBhIG5ldyBzZXNzaW9uLlxuICAgICAqIElmIHRoZSByZWZyZXNoIHRva2VuIG9yIGFjY2VzcyB0b2tlbiBpbiB0aGUgY3VycmVudCBzZXNzaW9uIGlzIGludmFsaWQsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICAgICAqIEBwYXJhbSBjdXJyZW50U2Vzc2lvbiBUaGUgY3VycmVudCBzZXNzaW9uIHRoYXQgbWluaW1hbGx5IGNvbnRhaW5zIGFuIGFjY2VzcyB0b2tlbiBhbmQgcmVmcmVzaCB0b2tlbi5cbiAgICAgKi9cbiAgICBhc3luYyBzZXRTZXNzaW9uKGN1cnJlbnRTZXNzaW9uKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3NldFNlc3Npb24oY3VycmVudFNlc3Npb24pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgX3NldFNlc3Npb24oY3VycmVudFNlc3Npb24pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghY3VycmVudFNlc3Npb24uYWNjZXNzX3Rva2VuIHx8ICFjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0aW1lTm93ID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgICAgICAgICBsZXQgZXhwaXJlc0F0ID0gdGltZU5vdztcbiAgICAgICAgICAgIGxldCBoYXNFeHBpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBzZXNzaW9uID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBkZWNvZGVKV1RQYXlsb2FkKGN1cnJlbnRTZXNzaW9uLmFjY2Vzc190b2tlbik7XG4gICAgICAgICAgICBpZiAocGF5bG9hZC5leHApIHtcbiAgICAgICAgICAgICAgICBleHBpcmVzQXQgPSBwYXlsb2FkLmV4cDtcbiAgICAgICAgICAgICAgICBoYXNFeHBpcmVkID0gZXhwaXJlc0F0IDw9IHRpbWVOb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzRXhwaXJlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2Vzc2lvbjogcmVmcmVzaGVkU2Vzc2lvbiwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX2NhbGxSZWZyZXNoVG9rZW4oY3VycmVudFNlc3Npb24ucmVmcmVzaF90b2tlbik7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFyZWZyZXNoZWRTZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXNzaW9uID0gcmVmcmVzaGVkU2Vzc2lvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX2dldFVzZXIoY3VycmVudFNlc3Npb24uYWNjZXNzX3Rva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlc3Npb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY2Vzc190b2tlbjogY3VycmVudFNlc3Npb24uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoX3Rva2VuOiBjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICB1c2VyOiBkYXRhLnVzZXIsXG4gICAgICAgICAgICAgICAgICAgIHRva2VuX3R5cGU6ICdiZWFyZXInLFxuICAgICAgICAgICAgICAgICAgICBleHBpcmVzX2luOiBleHBpcmVzQXQgLSB0aW1lTm93LFxuICAgICAgICAgICAgICAgICAgICBleHBpcmVzX2F0OiBleHBpcmVzQXQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgc2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IHNlc3Npb24udXNlciwgc2Vzc2lvbiB9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbjogbnVsbCwgdXNlcjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBzZXNzaW9uLCByZWdhcmRsZXNzIG9mIGV4cGlyeSBzdGF0dXMuXG4gICAgICogVGFrZXMgaW4gYW4gb3B0aW9uYWwgY3VycmVudCBzZXNzaW9uLiBJZiBub3QgcGFzc2VkIGluLCB0aGVuIHJlZnJlc2hTZXNzaW9uKCkgd2lsbCBhdHRlbXB0IHRvIHJldHJpZXZlIGl0IGZyb20gZ2V0U2Vzc2lvbigpLlxuICAgICAqIElmIHRoZSBjdXJyZW50IHNlc3Npb24ncyByZWZyZXNoIHRva2VuIGlzIGludmFsaWQsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICAgICAqIEBwYXJhbSBjdXJyZW50U2Vzc2lvbiBUaGUgY3VycmVudCBzZXNzaW9uLiBJZiBwYXNzZWQgaW4sIGl0IG11c3QgY29udGFpbiBhIHJlZnJlc2ggdG9rZW4uXG4gICAgICovXG4gICAgYXN5bmMgcmVmcmVzaFNlc3Npb24oY3VycmVudFNlc3Npb24pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fcmVmcmVzaFNlc3Npb24oY3VycmVudFNlc3Npb24pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgX3JlZnJlc2hTZXNzaW9uKGN1cnJlbnRTZXNzaW9uKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGlmICghY3VycmVudFNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZXNzaW9uID0gKF9hID0gZGF0YS5zZXNzaW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghKGN1cnJlbnRTZXNzaW9uID09PSBudWxsIHx8IGN1cnJlbnRTZXNzaW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzZXNzaW9uLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fY2FsbFJlZnJlc2hUb2tlbihjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogc2Vzc2lvbi51c2VyLCBzZXNzaW9uIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHNlc3Npb24gZGF0YSBmcm9tIGEgVVJMIHN0cmluZ1xuICAgICAqL1xuICAgIGFzeW5jIF9nZXRTZXNzaW9uRnJvbVVSTChpc1BLQ0VGbG93KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIWlzQnJvd3NlcigpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IoJ05vIGJyb3dzZXIgZGV0ZWN0ZWQuJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ2ltcGxpY2l0JyAmJiAhdGhpcy5faXNJbXBsaWNpdEdyYW50RmxvdygpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcignTm90IGEgdmFsaWQgaW1wbGljaXQgZ3JhbnQgZmxvdyB1cmwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmZsb3dUeXBlID09ICdwa2NlJyAmJiAhaXNQS0NFRmxvdykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoUEtDRUdyYW50Q29kZUV4Y2hhbmdlRXJyb3IoJ05vdCBhIHZhbGlkIFBLQ0UgZmxvdyB1cmwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBwYXJzZVBhcmFtZXRlcnNGcm9tVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgICAgIGlmIChpc1BLQ0VGbG93KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJhbXMuY29kZSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvcignTm8gY29kZSBkZXRlY3RlZC4nKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCB0aGlzLl9leGNoYW5nZUNvZGVGb3JTZXNzaW9uKHBhcmFtcy5jb2RlKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuZGVsZXRlKCdjb2RlJyk7XG4gICAgICAgICAgICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHdpbmRvdy5oaXN0b3J5LnN0YXRlLCAnJywgdXJsLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbjogZGF0YS5zZXNzaW9uLCByZWRpcmVjdFR5cGU6IG51bGwgfSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbXMuZXJyb3IgfHwgcGFyYW1zLmVycm9yX2Rlc2NyaXB0aW9uIHx8IHBhcmFtcy5lcnJvcl9jb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcihwYXJhbXMuZXJyb3JfZGVzY3JpcHRpb24gfHwgJ0Vycm9yIGluIFVSTCB3aXRoIHVuc3BlY2lmaWVkIGVycm9yX2Rlc2NyaXB0aW9uJywge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcjogcGFyYW1zLmVycm9yIHx8ICd1bnNwZWNpZmllZF9lcnJvcicsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IHBhcmFtcy5lcnJvcl9jb2RlIHx8ICd1bnNwZWNpZmllZF9jb2RlJyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgcHJvdmlkZXJfdG9rZW4sIHByb3ZpZGVyX3JlZnJlc2hfdG9rZW4sIGFjY2Vzc190b2tlbiwgcmVmcmVzaF90b2tlbiwgZXhwaXJlc19pbiwgZXhwaXJlc19hdCwgdG9rZW5fdHlwZSwgfSA9IHBhcmFtcztcbiAgICAgICAgICAgIGlmICghYWNjZXNzX3Rva2VuIHx8ICFleHBpcmVzX2luIHx8ICFyZWZyZXNoX3Rva2VuIHx8ICF0b2tlbl90eXBlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcignTm8gc2Vzc2lvbiBkZWZpbmVkIGluIFVSTCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGltZU5vdyA9IE1hdGgucm91bmQoRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgICAgICAgICAgY29uc3QgZXhwaXJlc0luID0gcGFyc2VJbnQoZXhwaXJlc19pbik7XG4gICAgICAgICAgICBsZXQgZXhwaXJlc0F0ID0gdGltZU5vdyArIGV4cGlyZXNJbjtcbiAgICAgICAgICAgIGlmIChleHBpcmVzX2F0KSB7XG4gICAgICAgICAgICAgICAgZXhwaXJlc0F0ID0gcGFyc2VJbnQoZXhwaXJlc19hdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhY3R1YWxseUV4cGlyZXNJbiA9IGV4cGlyZXNBdCAtIHRpbWVOb3c7XG4gICAgICAgICAgICBpZiAoYWN0dWFsbHlFeHBpcmVzSW4gKiAxMDAwIDw9IEFVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBAc3VwYWJhc2UvZ290cnVlLWpzOiBTZXNzaW9uIGFzIHJldHJpZXZlZCBmcm9tIFVSTCBleHBpcmVzIGluICR7YWN0dWFsbHlFeHBpcmVzSW59cywgc2hvdWxkIGhhdmUgYmVlbiBjbG9zZXIgdG8gJHtleHBpcmVzSW59c2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaXNzdWVkQXQgPSBleHBpcmVzQXQgLSBleHBpcmVzSW47XG4gICAgICAgICAgICBpZiAodGltZU5vdyAtIGlzc3VlZEF0ID49IDEyMCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQHN1cGFiYXNlL2dvdHJ1ZS1qczogU2Vzc2lvbiBhcyByZXRyaWV2ZWQgZnJvbSBVUkwgd2FzIGlzc3VlZCBvdmVyIDEyMHMgYWdvLCBVUkwgY291bGQgYmUgc3RhbGUnLCBpc3N1ZWRBdCwgZXhwaXJlc0F0LCB0aW1lTm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRpbWVOb3cgLSBpc3N1ZWRBdCA8IDApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0BzdXBhYmFzZS9nb3RydWUtanM6IFNlc3Npb24gYXMgcmV0cmlldmVkIGZyb20gVVJMIHdhcyBpc3N1ZWQgaW4gdGhlIGZ1dHVyZT8gQ2hlY2sgdGhlIGRldmljZSBjbG9rIGZvciBza2V3JywgaXNzdWVkQXQsIGV4cGlyZXNBdCwgdGltZU5vdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCB0aGlzLl9nZXRVc2VyKGFjY2Vzc190b2tlbik7XG4gICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uID0ge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyX3Rva2VuLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyX3JlZnJlc2hfdG9rZW4sXG4gICAgICAgICAgICAgICAgYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgIGV4cGlyZXNfaW46IGV4cGlyZXNJbixcbiAgICAgICAgICAgICAgICBleHBpcmVzX2F0OiBleHBpcmVzQXQsXG4gICAgICAgICAgICAgICAgcmVmcmVzaF90b2tlbixcbiAgICAgICAgICAgICAgICB0b2tlbl90eXBlLFxuICAgICAgICAgICAgICAgIHVzZXI6IGRhdGEudXNlcixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBSZW1vdmUgdG9rZW5zIGZyb20gVVJMXG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaGFzaCA9ICcnO1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNfZ2V0U2Vzc2lvbkZyb21VUkwoKScsICdjbGVhcmluZyB3aW5kb3cubG9jYXRpb24uaGFzaCcpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBzZXNzaW9uLCByZWRpcmVjdFR5cGU6IHBhcmFtcy50eXBlIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBzZXNzaW9uOiBudWxsLCByZWRpcmVjdFR5cGU6IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgY3VycmVudCBVUkwgY29udGFpbnMgcGFyYW1ldGVycyBnaXZlbiBieSBhbiBpbXBsaWNpdCBvYXV0aCBncmFudCBmbG93IChodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNjc0OS5odG1sI3NlY3Rpb24tNC4yKVxuICAgICAqL1xuICAgIF9pc0ltcGxpY2l0R3JhbnRGbG93KCkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBwYXJzZVBhcmFtZXRlcnNGcm9tVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgcmV0dXJuICEhKGlzQnJvd3NlcigpICYmIChwYXJhbXMuYWNjZXNzX3Rva2VuIHx8IHBhcmFtcy5lcnJvcl9kZXNjcmlwdGlvbikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGN1cnJlbnQgVVJMIGFuZCBiYWNraW5nIHN0b3JhZ2UgY29udGFpbiBwYXJhbWV0ZXJzIGdpdmVuIGJ5IGEgUEtDRSBmbG93XG4gICAgICovXG4gICAgYXN5bmMgX2lzUEtDRUZsb3coKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHBhcnNlUGFyYW1ldGVyc0Zyb21VUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICBjb25zdCBjdXJyZW50U3RvcmFnZUNvbnRlbnQgPSBhd2FpdCBnZXRJdGVtQXN5bmModGhpcy5zdG9yYWdlLCBgJHt0aGlzLnN0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgKTtcbiAgICAgICAgcmV0dXJuICEhKHBhcmFtcy5jb2RlICYmIGN1cnJlbnRTdG9yYWdlQ29udGVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2lkZSBhIGJyb3dzZXIgY29udGV4dCwgYHNpZ25PdXQoKWAgd2lsbCByZW1vdmUgdGhlIGxvZ2dlZCBpbiB1c2VyIGZyb20gdGhlIGJyb3dzZXIgc2Vzc2lvbiBhbmQgbG9nIHRoZW0gb3V0IC0gcmVtb3ZpbmcgYWxsIGl0ZW1zIGZyb20gbG9jYWxzdG9yYWdlIGFuZCB0aGVuIHRyaWdnZXIgYSBgXCJTSUdORURfT1VUXCJgIGV2ZW50LlxuICAgICAqXG4gICAgICogRm9yIHNlcnZlci1zaWRlIG1hbmFnZW1lbnQsIHlvdSBjYW4gcmV2b2tlIGFsbCByZWZyZXNoIHRva2VucyBmb3IgYSB1c2VyIGJ5IHBhc3NpbmcgYSB1c2VyJ3MgSldUIHRocm91Z2ggdG8gYGF1dGguYXBpLnNpZ25PdXQoSldUOiBzdHJpbmcpYC5cbiAgICAgKiBUaGVyZSBpcyBubyB3YXkgdG8gcmV2b2tlIGEgdXNlcidzIGFjY2VzcyB0b2tlbiBqd3QgdW50aWwgaXQgZXhwaXJlcy4gSXQgaXMgcmVjb21tZW5kZWQgdG8gc2V0IGEgc2hvcnRlciBleHBpcnkgb24gdGhlIGp3dCBmb3IgdGhpcyByZWFzb24uXG4gICAgICpcbiAgICAgKiBJZiB1c2luZyBgb3RoZXJzYCBzY29wZSwgbm8gYFNJR05FRF9PVVRgIGV2ZW50IGlzIGZpcmVkIVxuICAgICAqL1xuICAgIGFzeW5jIHNpZ25PdXQob3B0aW9ucyA9IHsgc2NvcGU6ICdnbG9iYWwnIH0pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fc2lnbk91dChvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIF9zaWduT3V0KHsgc2NvcGUgfSA9IHsgc2NvcGU6ICdnbG9iYWwnIH0pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IHNlc3Npb25FcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWNjZXNzVG9rZW4gPSAoX2EgPSBkYXRhLnNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY2Nlc3NfdG9rZW47XG4gICAgICAgICAgICBpZiAoYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCB0aGlzLmFkbWluLnNpZ25PdXQoYWNjZXNzVG9rZW4sIHNjb3BlKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIDQwNHMgc2luY2UgdXNlciBtaWdodCBub3QgZXhpc3QgYW55bW9yZVxuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgNDAxcyBzaW5jZSBhbiBpbnZhbGlkIG9yIGV4cGlyZWQgSldUIHNob3VsZCBzaWduIG91dCB0aGUgY3VycmVudCBzZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgIGlmICghKGlzQXV0aEFwaUVycm9yKGVycm9yKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKGVycm9yLnN0YXR1cyA9PT0gNDA0IHx8IGVycm9yLnN0YXR1cyA9PT0gNDAxIHx8IGVycm9yLnN0YXR1cyA9PT0gNDAzKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGVycm9yIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2NvcGUgIT09ICdvdGhlcnMnKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcmVtb3ZlU2Vzc2lvbigpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHJlbW92ZUl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfT1VUJywgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBlcnJvcjogbnVsbCB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVjZWl2ZSBhIG5vdGlmaWNhdGlvbiBldmVyeSB0aW1lIGFuIGF1dGggZXZlbnQgaGFwcGVucy5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgQSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBpbnZva2VkIHdoZW4gYW4gYXV0aCBldmVudCBoYXBwZW5zLlxuICAgICAqL1xuICAgIG9uQXV0aFN0YXRlQ2hhbmdlKGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGlkID0gdXVpZCgpO1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgdW5zdWJzY3JpYmU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI3Vuc3Vic2NyaWJlKCknLCAnc3RhdGUgY2hhbmdlIGNhbGxiYWNrIHdpdGggaWQgcmVtb3ZlZCcsIGlkKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlRW1pdHRlcnMuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2RlYnVnKCcjb25BdXRoU3RhdGVDaGFuZ2UoKScsICdyZWdpc3RlcmVkIGNhbGxiYWNrIHdpdGggaWQnLCBpZCk7XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VFbWl0dGVycy5zZXQoaWQsIHN1YnNjcmlwdGlvbik7XG4gICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbWl0SW5pdGlhbFNlc3Npb24oaWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgc3Vic2NyaXB0aW9uIH0gfTtcbiAgICB9XG4gICAgYXN5bmMgX2VtaXRJbml0aWFsU2Vzc2lvbihpZCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHsgc2Vzc2lvbiB9LCBlcnJvciwgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIGF3YWl0ICgoX2EgPSB0aGlzLnN0YXRlQ2hhbmdlRW1pdHRlcnMuZ2V0KGlkKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGxiYWNrKCdJTklUSUFMX1NFU1NJT04nLCBzZXNzaW9uKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJ0lOSVRJQUxfU0VTU0lPTicsICdjYWxsYmFjayBpZCcsIGlkLCAnc2Vzc2lvbicsIHNlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGF3YWl0ICgoX2IgPSB0aGlzLnN0YXRlQ2hhbmdlRW1pdHRlcnMuZ2V0KGlkKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGxiYWNrKCdJTklUSUFMX1NFU1NJT04nLCBudWxsKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJ0lOSVRJQUxfU0VTU0lPTicsICdjYWxsYmFjayBpZCcsIGlkLCAnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgcGFzc3dvcmQgcmVzZXQgcmVxdWVzdCB0byBhbiBlbWFpbCBhZGRyZXNzLiBUaGlzIG1ldGhvZCBzdXBwb3J0cyB0aGUgUEtDRSBmbG93LlxuICAgICAqXG4gICAgICogQHBhcmFtIGVtYWlsIFRoZSBlbWFpbCBhZGRyZXNzIG9mIHRoZSB1c2VyLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnJlZGlyZWN0VG8gVGhlIFVSTCB0byBzZW5kIHRoZSB1c2VyIHRvIGFmdGVyIHRoZXkgY2xpY2sgdGhlIHBhc3N3b3JkIHJlc2V0IGxpbmsuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuY2FwdGNoYVRva2VuIFZlcmlmaWNhdGlvbiB0b2tlbiByZWNlaXZlZCB3aGVuIHRoZSB1c2VyIGNvbXBsZXRlcyB0aGUgY2FwdGNoYSBvbiB0aGUgc2l0ZS5cbiAgICAgKi9cbiAgICBhc3luYyByZXNldFBhc3N3b3JkRm9yRW1haWwoZW1haWwsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgY29kZUNoYWxsZW5nZSA9IG51bGw7XG4gICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlTWV0aG9kID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuZmxvd1R5cGUgPT09ICdwa2NlJykge1xuICAgICAgICAgICAgO1xuICAgICAgICAgICAgW2NvZGVDaGFsbGVuZ2UsIGNvZGVDaGFsbGVuZ2VNZXRob2RdID0gYXdhaXQgZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZCh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSwgdHJ1ZSAvLyBpc1Bhc3N3b3JkUmVjb3ZlcnlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9yZWNvdmVyYCwge1xuICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgZW1haWwsXG4gICAgICAgICAgICAgICAgICAgIGNvZGVfY2hhbGxlbmdlOiBjb2RlQ2hhbGxlbmdlLFxuICAgICAgICAgICAgICAgICAgICBjb2RlX2NoYWxsZW5nZV9tZXRob2Q6IGNvZGVDaGFsbGVuZ2VNZXRob2QsXG4gICAgICAgICAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucy5yZWRpcmVjdFRvLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIHRoZSBpZGVudGl0aWVzIGxpbmtlZCB0byBhIHVzZXIuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VXNlcklkZW50aXRpZXMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuZ2V0VXNlcigpO1xuICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBpZGVudGl0aWVzOiAoX2EgPSBkYXRhLnVzZXIuaWRlbnRpdGllcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10gfSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlua3MgYW4gb2F1dGggaWRlbnRpdHkgdG8gYW4gZXhpc3RpbmcgdXNlci5cbiAgICAgKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyB0aGUgUEtDRSBmbG93LlxuICAgICAqL1xuICAgIGFzeW5jIGxpbmtJZGVudGl0eShjcmVkZW50aWFscykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IGF3YWl0IHRoaXMuX2dldFVybEZvclByb3ZpZGVyKGAke3RoaXMudXJsfS91c2VyL2lkZW50aXRpZXMvYXV0aG9yaXplYCwgY3JlZGVudGlhbHMucHJvdmlkZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3RUbzogKF9hID0gY3JlZGVudGlhbHMub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlZGlyZWN0VG8sXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlczogKF9iID0gY3JlZGVudGlhbHMub3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNjb3BlcyxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IChfYyA9IGNyZWRlbnRpYWxzLm9wdGlvbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5xdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgc2tpcEJyb3dzZXJSZWRpcmVjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIHVybCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGp3dDogKF9lID0gKF9kID0gZGF0YS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWNjZXNzX3Rva2VuKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIGlmIChpc0Jyb3dzZXIoKSAmJiAhKChfYSA9IGNyZWRlbnRpYWxzLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5za2lwQnJvd3NlclJlZGlyZWN0KSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24oZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLnVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHByb3ZpZGVyOiBjcmVkZW50aWFscy5wcm92aWRlciwgdXJsOiBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEudXJsIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBwcm92aWRlcjogY3JlZGVudGlhbHMucHJvdmlkZXIsIHVybDogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5saW5rcyBhbiBpZGVudGl0eSBmcm9tIGEgdXNlciBieSBkZWxldGluZyBpdC4gVGhlIHVzZXIgd2lsbCBubyBsb25nZXIgYmUgYWJsZSB0byBzaWduIGluIHdpdGggdGhhdCBpZGVudGl0eSBvbmNlIGl0J3MgdW5saW5rZWQuXG4gICAgICovXG4gICAgYXN5bmMgdW5saW5rSWRlbnRpdHkoaWRlbnRpdHkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnREVMRVRFJywgYCR7dGhpcy51cmx9L3VzZXIvaWRlbnRpdGllcy8ke2lkZW50aXR5LmlkZW50aXR5X2lkfWAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBqd3Q6IChfYiA9IChfYSA9IGRhdGEuc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjY2Vzc190b2tlbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIG5ldyBKV1QuXG4gICAgICogQHBhcmFtIHJlZnJlc2hUb2tlbiBBIHZhbGlkIHJlZnJlc2ggdG9rZW4gdGhhdCB3YXMgcmV0dXJuZWQgb24gbG9naW4uXG4gICAgICovXG4gICAgYXN5bmMgX3JlZnJlc2hBY2Nlc3NUb2tlbihyZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgY29uc3QgZGVidWdOYW1lID0gYCNfcmVmcmVzaEFjY2Vzc1Rva2VuKCR7cmVmcmVzaFRva2VuLnN1YnN0cmluZygwLCA1KX0uLi4pYDtcbiAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnYmVnaW4nKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ZWRBdCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAvLyB3aWxsIGF0dGVtcHQgdG8gcmVmcmVzaCB0aGUgdG9rZW4gd2l0aCBleHBvbmVudGlhbCBiYWNrb2ZmXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcmV0cnlhYmxlKGFzeW5jIChhdHRlbXB0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dGVtcHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHNsZWVwKDIwMCAqIE1hdGgucG93KDIsIGF0dGVtcHQgLSAxKSk7IC8vIDIwMCwgNDAwLCA4MDAsIC4uLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdyZWZyZXNoaW5nIGF0dGVtcHQnLCBhdHRlbXB0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vdG9rZW4/Z3JhbnRfdHlwZT1yZWZyZXNoX3Rva2VuYCwge1xuICAgICAgICAgICAgICAgICAgICBib2R5OiB7IHJlZnJlc2hfdG9rZW46IHJlZnJlc2hUb2tlbiB9LFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgKGF0dGVtcHQsIGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dEJhY2tPZmZJbnRlcnZhbCA9IDIwMCAqIE1hdGgucG93KDIsIGF0dGVtcHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoZXJyb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcihlcnJvcikgJiZcbiAgICAgICAgICAgICAgICAgICAgLy8gcmV0cnlhYmxlIG9ubHkgaWYgdGhlIHJlcXVlc3QgY2FuIGJlIHNlbnQgYmVmb3JlIHRoZSBiYWNrb2ZmIG92ZXJmbG93cyB0aGUgdGljayBkdXJhdGlvblxuICAgICAgICAgICAgICAgICAgICBEYXRlLm5vdygpICsgbmV4dEJhY2tPZmZJbnRlcnZhbCAtIHN0YXJ0ZWRBdCA8IEFVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBzZXNzaW9uOiBudWxsLCB1c2VyOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2VuZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pc1ZhbGlkU2Vzc2lvbihtYXliZVNlc3Npb24pIHtcbiAgICAgICAgY29uc3QgaXNWYWxpZFNlc3Npb24gPSB0eXBlb2YgbWF5YmVTZXNzaW9uID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgbWF5YmVTZXNzaW9uICE9PSBudWxsICYmXG4gICAgICAgICAgICAnYWNjZXNzX3Rva2VuJyBpbiBtYXliZVNlc3Npb24gJiZcbiAgICAgICAgICAgICdyZWZyZXNoX3Rva2VuJyBpbiBtYXliZVNlc3Npb24gJiZcbiAgICAgICAgICAgICdleHBpcmVzX2F0JyBpbiBtYXliZVNlc3Npb247XG4gICAgICAgIHJldHVybiBpc1ZhbGlkU2Vzc2lvbjtcbiAgICB9XG4gICAgYXN5bmMgX2hhbmRsZVByb3ZpZGVyU2lnbkluKHByb3ZpZGVyLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGF3YWl0IHRoaXMuX2dldFVybEZvclByb3ZpZGVyKGAke3RoaXMudXJsfS9hdXRob3JpemVgLCBwcm92aWRlciwge1xuICAgICAgICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucy5yZWRpcmVjdFRvLFxuICAgICAgICAgICAgc2NvcGVzOiBvcHRpb25zLnNjb3BlcyxcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBvcHRpb25zLnF1ZXJ5UGFyYW1zLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfaGFuZGxlUHJvdmlkZXJTaWduSW4oKScsICdwcm92aWRlcicsIHByb3ZpZGVyLCAnb3B0aW9ucycsIG9wdGlvbnMsICd1cmwnLCB1cmwpO1xuICAgICAgICAvLyB0cnkgdG8gb3BlbiBvbiB0aGUgYnJvd3NlclxuICAgICAgICBpZiAoaXNCcm93c2VyKCkgJiYgIW9wdGlvbnMuc2tpcEJyb3dzZXJSZWRpcmVjdCkge1xuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbih1cmwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgcHJvdmlkZXIsIHVybCB9LCBlcnJvcjogbnVsbCB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWNvdmVycyB0aGUgc2Vzc2lvbiBmcm9tIExvY2FsU3RvcmFnZSBhbmQgcmVmcmVzaGVzXG4gICAgICogTm90ZTogdGhpcyBtZXRob2QgaXMgYXN5bmMgdG8gYWNjb21tb2RhdGUgZm9yIEFzeW5jU3RvcmFnZSBlLmcuIGluIFJlYWN0IG5hdGl2ZS5cbiAgICAgKi9cbiAgICBhc3luYyBfcmVjb3ZlckFuZFJlZnJlc2goKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgZGVidWdOYW1lID0gJyNfcmVjb3ZlckFuZFJlZnJlc2goKSc7XG4gICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2JlZ2luJyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50U2Vzc2lvbiA9IGF3YWl0IGdldEl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdzZXNzaW9uIGZyb20gc3RvcmFnZScsIGN1cnJlbnRTZXNzaW9uKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNWYWxpZFNlc3Npb24oY3VycmVudFNlc3Npb24pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnc2Vzc2lvbiBpcyBub3QgdmFsaWQnKTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFNlc3Npb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcmVtb3ZlU2Vzc2lvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0aW1lTm93ID0gTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMTAwMCk7XG4gICAgICAgICAgICBjb25zdCBleHBpcmVzV2l0aE1hcmdpbiA9ICgoX2EgPSBjdXJyZW50U2Vzc2lvbi5leHBpcmVzX2F0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBJbmZpbml0eSkgPCB0aW1lTm93ICsgRVhQSVJZX01BUkdJTjtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgYHNlc3Npb24gaGFzJHtleHBpcmVzV2l0aE1hcmdpbiA/ICcnIDogJyBub3QnfSBleHBpcmVkIHdpdGggbWFyZ2luIG9mICR7RVhQSVJZX01BUkdJTn1zYCk7XG4gICAgICAgICAgICBpZiAoZXhwaXJlc1dpdGhNYXJnaW4pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdXRvUmVmcmVzaFRva2VuICYmIGN1cnJlbnRTZXNzaW9uLnJlZnJlc2hfdG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgdGhpcy5fY2FsbFJlZnJlc2hUb2tlbihjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdyZWZyZXNoIGZhaWxlZCB3aXRoIGEgbm9uLXJldHJ5YWJsZSBlcnJvciwgcmVtb3ZpbmcgdGhlIHNlc3Npb24nLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcmVtb3ZlU2Vzc2lvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbm8gbmVlZCB0byBwZXJzaXN0IGN1cnJlbnRTZXNzaW9uIGFnYWluLCBhcyB3ZSBqdXN0IGxvYWRlZCBpdCBmcm9tXG4gICAgICAgICAgICAgICAgLy8gbG9jYWwgc3RvcmFnZTsgcGVyc2lzdGluZyBpdCBhZ2FpbiBtYXkgb3ZlcndyaXRlIGEgdmFsdWUgc2F2ZWQgYnlcbiAgICAgICAgICAgICAgICAvLyBhbm90aGVyIGNsaWVudCB3aXRoIGFjY2VzcyB0byB0aGUgc2FtZSBsb2NhbCBzdG9yYWdlXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIGN1cnJlbnRTZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlcnJvcicsIGVycik7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlbmQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfY2FsbFJlZnJlc2hUb2tlbihyZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKCFyZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlZnJlc2hpbmcgaXMgYWxyZWFkeSBpbiBwcm9ncmVzc1xuICAgICAgICBpZiAodGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZnJlc2hpbmdEZWZlcnJlZC5wcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlYnVnTmFtZSA9IGAjX2NhbGxSZWZyZXNoVG9rZW4oJHtyZWZyZXNoVG9rZW4uc3Vic3RyaW5nKDAsIDUpfS4uLilgO1xuICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdiZWdpbicpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX3JlZnJlc2hBY2Nlc3NUb2tlbihyZWZyZXNoVG9rZW4pO1xuICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgaWYgKCFkYXRhLnNlc3Npb24pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihkYXRhLnNlc3Npb24pO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1RPS0VOX1JFRlJFU0hFRCcsIGRhdGEuc2Vzc2lvbik7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7IHNlc3Npb246IGRhdGEuc2Vzc2lvbiwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaGluZ0RlZmVycmVkLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7IHNlc3Npb246IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgaWYgKCFpc0F1dGhSZXRyeWFibGVGZXRjaEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9yZW1vdmVTZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfT1VUJywgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMucmVmcmVzaGluZ0RlZmVycmVkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoX2IgPSB0aGlzLnJlZnJlc2hpbmdEZWZlcnJlZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaGluZ0RlZmVycmVkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2VuZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9ub3RpZnlBbGxTdWJzY3JpYmVycyhldmVudCwgc2Vzc2lvbiwgYnJvYWRjYXN0ID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBkZWJ1Z05hbWUgPSBgI19ub3RpZnlBbGxTdWJzY3JpYmVycygke2V2ZW50fSlgO1xuICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdiZWdpbicsIHNlc3Npb24sIGBicm9hZGNhc3QgPSAke2Jyb2FkY2FzdH1gKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJyb2FkY2FzdENoYW5uZWwgJiYgYnJvYWRjYXN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RDaGFubmVsLnBvc3RNZXNzYWdlKHsgZXZlbnQsIHNlc3Npb24gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gQXJyYXkuZnJvbSh0aGlzLnN0YXRlQ2hhbmdlRW1pdHRlcnMudmFsdWVzKCkpLm1hcChhc3luYyAoeCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHguY2FsbGJhY2soZXZlbnQsIHNlc3Npb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXJyb3JzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3JzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3JzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnZW5kJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogc2V0IGN1cnJlbnRTZXNzaW9uIGFuZCBjdXJyZW50VXNlclxuICAgICAqIHByb2Nlc3MgdG8gX3N0YXJ0QXV0b1JlZnJlc2hUb2tlbiBpZiBwb3NzaWJsZVxuICAgICAqL1xuICAgIGFzeW5jIF9zYXZlU2Vzc2lvbihzZXNzaW9uKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCcjX3NhdmVTZXNzaW9uKCknLCBzZXNzaW9uKTtcbiAgICAgICAgLy8gX3NhdmVTZXNzaW9uIGlzIGFsd2F5cyBjYWxsZWQgd2hlbmV2ZXIgYSBuZXcgc2Vzc2lvbiBoYXMgYmVlbiBhY3F1aXJlZFxuICAgICAgICAvLyBzbyB3ZSBjYW4gc2FmZWx5IHN1cHByZXNzIHRoZSB3YXJuaW5nIHJldHVybmVkIGJ5IGZ1dHVyZSBnZXRTZXNzaW9uIGNhbGxzXG4gICAgICAgIHRoaXMuc3VwcHJlc3NHZXRTZXNzaW9uV2FybmluZyA9IHRydWU7XG4gICAgICAgIGF3YWl0IHNldEl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSwgc2Vzc2lvbik7XG4gICAgfVxuICAgIGFzeW5jIF9yZW1vdmVTZXNzaW9uKCkge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnI19yZW1vdmVTZXNzaW9uKCknKTtcbiAgICAgICAgYXdhaXQgcmVtb3ZlSXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbnkgcmVnaXN0ZXJlZCB2aXNpYmlsaXR5Y2hhbmdlIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICoge0BzZWUgI3N0YXJ0QXV0b1JlZnJlc2h9XG4gICAgICoge0BzZWUgI3N0b3BBdXRvUmVmcmVzaH1cbiAgICAgKi9cbiAgICBfcmVtb3ZlVmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjaygpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfcmVtb3ZlVmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjaygpJyk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gdGhpcy52aXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrO1xuICAgICAgICB0aGlzLnZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2sgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrICYmIGlzQnJvd3NlcigpICYmICh3aW5kb3cgPT09IG51bGwgfHwgd2luZG93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcikpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcigncmVtb3ZpbmcgdmlzaWJpbGl0eWNoYW5nZSBjYWxsYmFjayBmYWlsZWQnLCBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBwcml2YXRlIGltcGxlbWVudGF0aW9uIG9mIHtAbGluayAjc3RhcnRBdXRvUmVmcmVzaH0uIFVzZSB0aGlzXG4gICAgICogd2l0aGluIHRoZSBsaWJyYXJ5LlxuICAgICAqL1xuICAgIGFzeW5jIF9zdGFydEF1dG9SZWZyZXNoKCkge1xuICAgICAgICBhd2FpdCB0aGlzLl9zdG9wQXV0b1JlZnJlc2goKTtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfc3RhcnRBdXRvUmVmcmVzaCgpJyk7XG4gICAgICAgIGNvbnN0IHRpY2tlciA9IHNldEludGVydmFsKCgpID0+IHRoaXMuX2F1dG9SZWZyZXNoVG9rZW5UaWNrKCksIEFVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OKTtcbiAgICAgICAgdGhpcy5hdXRvUmVmcmVzaFRpY2tlciA9IHRpY2tlcjtcbiAgICAgICAgaWYgKHRpY2tlciAmJiB0eXBlb2YgdGlja2VyID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdGlja2VyLnVucmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyB0aWNrZXIgaXMgYSBOb2RlSlMgVGltZW91dCBvYmplY3QgdGhhdCBoYXMgYW4gYHVucmVmYCBtZXRob2RcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvdGltZXJzLmh0bWwjdGltZW91dHVucmVmXG4gICAgICAgICAgICAvLyBXaGVuIGF1dG8gcmVmcmVzaCBpcyB1c2VkIGluIE5vZGVKUyAobGlrZSBmb3IgdGVzdGluZykgdGhlXG4gICAgICAgICAgICAvLyBgc2V0SW50ZXJ2YWxgIGlzIHByZXZlbnRpbmcgdGhlIHByb2Nlc3MgZnJvbSBiZWluZyBtYXJrZWQgYXNcbiAgICAgICAgICAgIC8vIGZpbmlzaGVkIGFuZCB0ZXN0cyBydW4gZW5kbGVzc2x5LiBUaGlzIGNhbiBiZSBwcmV2ZW50ZWQgYnkgY2FsbGluZ1xuICAgICAgICAgICAgLy8gYHVucmVmKClgIG9uIHRoZSByZXR1cm5lZCBvYmplY3QuXG4gICAgICAgICAgICB0aWNrZXIudW5yZWYoKTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgRGVubyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIERlbm8udW5yZWZUaW1lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gc2ltaWxhciBsaWtlIGZvciBOb2RlSlMsIGJ1dCB3aXRoIHRoZSBEZW5vIEFQSVxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZW5vLmxhbmQvYXBpQGxhdGVzdD91bnN0YWJsZSZzPURlbm8udW5yZWZUaW1lclxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgRGVuby51bnJlZlRpbWVyKHRpY2tlcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcnVuIHRoZSB0aWNrIGltbWVkaWF0ZWx5LCBidXQgaW4gdGhlIG5leHQgcGFzcyBvZiB0aGUgZXZlbnQgbG9vcCBzbyB0aGF0XG4gICAgICAgIC8vICNfaW5pdGlhbGl6ZSBjYW4gYmUgYWxsb3dlZCB0byBjb21wbGV0ZSB3aXRob3V0IHJlY3Vyc2l2ZWx5IHdhaXRpbmcgb25cbiAgICAgICAgLy8gaXRzZWxmXG4gICAgICAgIHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2F1dG9SZWZyZXNoVG9rZW5UaWNrKCk7XG4gICAgICAgIH0sIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBwcml2YXRlIGltcGxlbWVudGF0aW9uIG9mIHtAbGluayAjc3RvcEF1dG9SZWZyZXNofS4gVXNlIHRoaXNcbiAgICAgKiB3aXRoaW4gdGhlIGxpYnJhcnkuXG4gICAgICovXG4gICAgYXN5bmMgX3N0b3BBdXRvUmVmcmVzaCgpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfc3RvcEF1dG9SZWZyZXNoKCknKTtcbiAgICAgICAgY29uc3QgdGlja2VyID0gdGhpcy5hdXRvUmVmcmVzaFRpY2tlcjtcbiAgICAgICAgdGhpcy5hdXRvUmVmcmVzaFRpY2tlciA9IG51bGw7XG4gICAgICAgIGlmICh0aWNrZXIpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGlja2VyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgYW4gYXV0by1yZWZyZXNoIHByb2Nlc3MgaW4gdGhlIGJhY2tncm91bmQuIFRoZSBzZXNzaW9uIGlzIGNoZWNrZWRcbiAgICAgKiBldmVyeSBmZXcgc2Vjb25kcy4gQ2xvc2UgdG8gdGhlIHRpbWUgb2YgZXhwaXJhdGlvbiBhIHByb2Nlc3MgaXMgc3RhcnRlZCB0b1xuICAgICAqIHJlZnJlc2ggdGhlIHNlc3Npb24uIElmIHJlZnJlc2hpbmcgZmFpbHMgaXQgd2lsbCBiZSByZXRyaWVkIGZvciBhcyBsb25nIGFzXG4gICAgICogbmVjZXNzYXJ5LlxuICAgICAqXG4gICAgICogSWYgeW91IHNldCB0aGUge0BsaW5rIEdvVHJ1ZUNsaWVudE9wdGlvbnMjYXV0b1JlZnJlc2hUb2tlbn0geW91IGRvbid0IG5lZWRcbiAgICAgKiB0byBjYWxsIHRoaXMgZnVuY3Rpb24sIGl0IHdpbGwgYmUgY2FsbGVkIGZvciB5b3UuXG4gICAgICpcbiAgICAgKiBPbiBicm93c2VycyB0aGUgcmVmcmVzaCBwcm9jZXNzIHdvcmtzIG9ubHkgd2hlbiB0aGUgdGFiL3dpbmRvdyBpcyBpbiB0aGVcbiAgICAgKiBmb3JlZ3JvdW5kIHRvIGNvbnNlcnZlIHJlc291cmNlcyBhcyB3ZWxsIGFzIHByZXZlbnQgcmFjZSBjb25kaXRpb25zIGFuZFxuICAgICAqIGZsb29kaW5nIGF1dGggd2l0aCByZXF1ZXN0cy4gSWYgeW91IGNhbGwgdGhpcyBtZXRob2QgYW55IG1hbmFnZWRcbiAgICAgKiB2aXNpYmlsaXR5IGNoYW5nZSBjYWxsYmFjayB3aWxsIGJlIHJlbW92ZWQgYW5kIHlvdSBtdXN0IG1hbmFnZSB2aXNpYmlsaXR5XG4gICAgICogY2hhbmdlcyBvbiB5b3VyIG93bi5cbiAgICAgKlxuICAgICAqIE9uIG5vbi1icm93c2VyIHBsYXRmb3JtcyB0aGUgcmVmcmVzaCBwcm9jZXNzIHdvcmtzICpjb250aW51b3VzbHkqIGluIHRoZVxuICAgICAqIGJhY2tncm91bmQsIHdoaWNoIG1heSBub3QgYmUgZGVzaXJhYmxlLiBZb3Ugc2hvdWxkIGhvb2sgaW50byB5b3VyXG4gICAgICogcGxhdGZvcm0ncyBmb3JlZ3JvdW5kIGluZGljYXRpb24gbWVjaGFuaXNtIGFuZCBjYWxsIHRoZXNlIG1ldGhvZHNcbiAgICAgKiBhcHByb3ByaWF0ZWx5IHRvIGNvbnNlcnZlIHJlc291cmNlcy5cbiAgICAgKlxuICAgICAqIHtAc2VlICNzdG9wQXV0b1JlZnJlc2h9XG4gICAgICovXG4gICAgYXN5bmMgc3RhcnRBdXRvUmVmcmVzaCgpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlVmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjaygpO1xuICAgICAgICBhd2FpdCB0aGlzLl9zdGFydEF1dG9SZWZyZXNoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3BzIGFuIGFjdGl2ZSBhdXRvIHJlZnJlc2ggcHJvY2VzcyBydW5uaW5nIGluIHRoZSBiYWNrZ3JvdW5kIChpZiBhbnkpLlxuICAgICAqXG4gICAgICogSWYgeW91IGNhbGwgdGhpcyBtZXRob2QgYW55IG1hbmFnZWQgdmlzaWJpbGl0eSBjaGFuZ2UgY2FsbGJhY2sgd2lsbCBiZVxuICAgICAqIHJlbW92ZWQgYW5kIHlvdSBtdXN0IG1hbmFnZSB2aXNpYmlsaXR5IGNoYW5nZXMgb24geW91ciBvd24uXG4gICAgICpcbiAgICAgKiBTZWUge0BsaW5rICNzdGFydEF1dG9SZWZyZXNofSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIHN0b3BBdXRvUmVmcmVzaCgpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlVmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjaygpO1xuICAgICAgICBhd2FpdCB0aGlzLl9zdG9wQXV0b1JlZnJlc2goKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUnVucyB0aGUgYXV0byByZWZyZXNoIHRva2VuIHRpY2suXG4gICAgICovXG4gICAgYXN5bmMgX2F1dG9SZWZyZXNoVG9rZW5UaWNrKCkge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnI19hdXRvUmVmcmVzaFRva2VuVGljaygpJywgJ2JlZ2luJyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygwLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHsgc2Vzc2lvbiB9LCB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2Vzc2lvbiB8fCAhc2Vzc2lvbi5yZWZyZXNoX3Rva2VuIHx8ICFzZXNzaW9uLmV4cGlyZXNfYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNfYXV0b1JlZnJlc2hUb2tlblRpY2soKScsICdubyBzZXNzaW9uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2Vzc2lvbiB3aWxsIGV4cGlyZSBpbiB0aGlzIG1hbnkgdGlja3MgKG9yIGhhcyBhbHJlYWR5IGV4cGlyZWQgaWYgPD0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHBpcmVzSW5UaWNrcyA9IE1hdGguZmxvb3IoKHNlc3Npb24uZXhwaXJlc19hdCAqIDEwMDAgLSBub3cpIC8gQVVUT19SRUZSRVNIX1RJQ0tfRFVSQVRJT04pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2F1dG9SZWZyZXNoVG9rZW5UaWNrKCknLCBgYWNjZXNzIHRva2VuIGV4cGlyZXMgaW4gJHtleHBpcmVzSW5UaWNrc30gdGlja3MsIGEgdGljayBsYXN0cyAke0FVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OfW1zLCByZWZyZXNoIHRocmVzaG9sZCBpcyAke0FVVE9fUkVGUkVTSF9USUNLX1RIUkVTSE9MRH0gdGlja3NgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwaXJlc0luVGlja3MgPD0gQVVUT19SRUZSRVNIX1RJQ0tfVEhSRVNIT0xEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2NhbGxSZWZyZXNoVG9rZW4oc2Vzc2lvbi5yZWZyZXNoX3Rva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignQXV0byByZWZyZXNoIHRpY2sgZmFpbGVkIHdpdGggZXJyb3IuIFRoaXMgaXMgbGlrZWx5IGEgdHJhbnNpZW50IGVycm9yLicsIGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19hdXRvUmVmcmVzaFRva2VuVGljaygpJywgJ2VuZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZS5pc0FjcXVpcmVUaW1lb3V0IHx8IGUgaW5zdGFuY2VvZiBMb2NrQWNxdWlyZVRpbWVvdXRFcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCdhdXRvIHJlZnJlc2ggdG9rZW4gdGljayBsb2NrIG5vdCBhdmFpbGFibGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGNhbGxiYWNrcyBvbiB0aGUgYnJvd3NlciAvIHBsYXRmb3JtLCB3aGljaCBpbi10dXJuIHJ1blxuICAgICAqIGFsZ29yaXRobXMgd2hlbiB0aGUgYnJvd3NlciB3aW5kb3cvdGFiIGFyZSBpbiBmb3JlZ3JvdW5kLiBPbiBub24tYnJvd3NlclxuICAgICAqIHBsYXRmb3JtcyBpdCBhc3N1bWVzIGFsd2F5cyBmb3JlZ3JvdW5kLlxuICAgICAqL1xuICAgIGFzeW5jIF9oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKCkge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnI19oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKCknKTtcbiAgICAgICAgaWYgKCFpc0Jyb3dzZXIoKSB8fCAhKHdpbmRvdyA9PT0gbnVsbCB8fCB3aW5kb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXV0b1JlZnJlc2hUb2tlbikge1xuICAgICAgICAgICAgICAgIC8vIGluIG5vbi1icm93c2VyIGVudmlyb25tZW50cyB0aGUgcmVmcmVzaCB0b2tlbiB0aWNrZXIgcnVucyBhbHdheXNcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0QXV0b1JlZnJlc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy52aXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrID0gYXN5bmMgKCkgPT4gYXdhaXQgdGhpcy5fb25WaXNpYmlsaXR5Q2hhbmdlZChmYWxzZSk7XG4gICAgICAgICAgICB3aW5kb3cgPT09IG51bGwgfHwgd2luZG93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIHRoaXMudmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjayk7XG4gICAgICAgICAgICAvLyBub3cgaW1tZWRpYXRlbHkgY2FsbCB0aGUgdmlzYmlsaXR5IGNoYW5nZWQgY2FsbGJhY2sgdG8gc2V0dXAgd2l0aCB0aGVcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgdmlzYmlsaXR5IHN0YXRlXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9vblZpc2liaWxpdHlDaGFuZ2VkKHRydWUpOyAvLyBpbml0aWFsIGNhbGxcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ19oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlJywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIHJlZ2lzdGVyZWQgd2l0aCBgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnKWAuXG4gICAgICovXG4gICAgYXN5bmMgX29uVmlzaWJpbGl0eUNoYW5nZWQoY2FsbGVkRnJvbUluaXRpYWxpemUpIHtcbiAgICAgICAgY29uc3QgbWV0aG9kTmFtZSA9IGAjX29uVmlzaWJpbGl0eUNoYW5nZWQoJHtjYWxsZWRGcm9tSW5pdGlhbGl6ZX0pYDtcbiAgICAgICAgdGhpcy5fZGVidWcobWV0aG9kTmFtZSwgJ3Zpc2liaWxpdHlTdGF0ZScsIGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSk7XG4gICAgICAgIGlmIChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICd2aXNpYmxlJykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXV0b1JlZnJlc2hUb2tlbikge1xuICAgICAgICAgICAgICAgIC8vIGluIGJyb3dzZXIgZW52aXJvbm1lbnRzIHRoZSByZWZyZXNoIHRva2VuIHRpY2tlciBydW5zIG9ubHkgb24gZm9jdXNlZCB0YWJzXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggcHJldmVudHMgcmFjZSBjb25kaXRpb25zXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRBdXRvUmVmcmVzaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjYWxsZWRGcm9tSW5pdGlhbGl6ZSkge1xuICAgICAgICAgICAgICAgIC8vIGNhbGxlZCB3aGVuIHRoZSB2aXNpYmlsaXR5IGhhcyBjaGFuZ2VkLCBpLmUuIHRoZSBicm93c2VyXG4gICAgICAgICAgICAgICAgLy8gdHJhbnNpdGlvbmVkIGZyb20gaGlkZGVuIC0+IHZpc2libGUgc28gd2UgbmVlZCB0byBzZWUgaWYgdGhlIHNlc3Npb25cbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgcmVjb3ZlcmVkIGltbWVkaWF0ZWx5Li4uIGJ1dCB0byBkbyB0aGF0IHdlIG5lZWQgdG8gYWNxdWlyZVxuICAgICAgICAgICAgICAgIC8vIHRoZSBsb2NrIGZpcnN0IGFzeW5jaHJvbm91c2x5XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlICE9PSAndmlzaWJsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKG1ldGhvZE5hbWUsICdhY3F1aXJlZCB0aGUgbG9jayB0byByZWNvdmVyIHRoZSBzZXNzaW9uLCBidXQgdGhlIGJyb3dzZXIgdmlzaWJpbGl0eVN0YXRlIGlzIG5vIGxvbmdlciB2aXNpYmxlLCBhYm9ydGluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmlzaWJpbGl0eSBoYXMgY2hhbmdlZCB3aGlsZSB3YWl0aW5nIGZvciB0aGUgbG9jaywgYWJvcnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyByZWNvdmVyIHRoZSBzZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3JlY292ZXJBbmRSZWZyZXNoKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAnaGlkZGVuJykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXV0b1JlZnJlc2hUb2tlbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BBdXRvUmVmcmVzaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyB0aGUgcmVsZXZhbnQgbG9naW4gVVJMIGZvciBhIHRoaXJkLXBhcnR5IHByb3ZpZGVyLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnJlZGlyZWN0VG8gQSBVUkwgb3IgbW9iaWxlIGFkZHJlc3MgdG8gc2VuZCB0aGUgdXNlciB0byBhZnRlciB0aGV5IGFyZSBjb25maXJtZWQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc2NvcGVzIEEgc3BhY2Utc2VwYXJhdGVkIGxpc3Qgb2Ygc2NvcGVzIGdyYW50ZWQgdG8gdGhlIE9BdXRoIGFwcGxpY2F0aW9uLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnF1ZXJ5UGFyYW1zIEFuIG9iamVjdCBvZiBrZXktdmFsdWUgcGFpcnMgY29udGFpbmluZyBxdWVyeSBwYXJhbWV0ZXJzIGdyYW50ZWQgdG8gdGhlIE9BdXRoIGFwcGxpY2F0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIF9nZXRVcmxGb3JQcm92aWRlcih1cmwsIHByb3ZpZGVyLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHVybFBhcmFtcyA9IFtgcHJvdmlkZXI9JHtlbmNvZGVVUklDb21wb25lbnQocHJvdmlkZXIpfWBdO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJlZGlyZWN0VG8pIHtcbiAgICAgICAgICAgIHVybFBhcmFtcy5wdXNoKGByZWRpcmVjdF90bz0ke2VuY29kZVVSSUNvbXBvbmVudChvcHRpb25zLnJlZGlyZWN0VG8pfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2NvcGVzKSB7XG4gICAgICAgICAgICB1cmxQYXJhbXMucHVzaChgc2NvcGVzPSR7ZW5jb2RlVVJJQ29tcG9uZW50KG9wdGlvbnMuc2NvcGVzKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ3BrY2UnKSB7XG4gICAgICAgICAgICBjb25zdCBbY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZF0gPSBhd2FpdCBnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgICAgIGNvbnN0IGZsb3dQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgICAgICAgICBjb2RlX2NoYWxsZW5nZTogYCR7ZW5jb2RlVVJJQ29tcG9uZW50KGNvZGVDaGFsbGVuZ2UpfWAsXG4gICAgICAgICAgICAgICAgY29kZV9jaGFsbGVuZ2VfbWV0aG9kOiBgJHtlbmNvZGVVUklDb21wb25lbnQoY29kZUNoYWxsZW5nZU1ldGhvZCl9YCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdXJsUGFyYW1zLnB1c2goZmxvd1BhcmFtcy50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMob3B0aW9ucy5xdWVyeVBhcmFtcyk7XG4gICAgICAgICAgICB1cmxQYXJhbXMucHVzaChxdWVyeS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNraXBCcm93c2VyUmVkaXJlY3QpIHtcbiAgICAgICAgICAgIHVybFBhcmFtcy5wdXNoKGBza2lwX2h0dHBfcmVkaXJlY3Q9JHtvcHRpb25zLnNraXBCcm93c2VyUmVkaXJlY3R9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke3VybH0/JHt1cmxQYXJhbXMuam9pbignJicpfWA7XG4gICAgfVxuICAgIGFzeW5jIF91bmVucm9sbChwYXJhbXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBzZXNzaW9uRGF0YSwgZXJyb3I6IHNlc3Npb25FcnJvciB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IHNlc3Npb25FcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0RFTEVURScsIGAke3RoaXMudXJsfS9mYWN0b3JzLyR7cGFyYW1zLmZhY3RvcklkfWAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBqd3Q6IChfYSA9IHNlc3Npb25EYXRhID09PSBudWxsIHx8IHNlc3Npb25EYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXNzaW9uRGF0YS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHtAc2VlIEdvVHJ1ZU1GQUFwaSNlbnJvbGx9XG4gICAgICovXG4gICAgYXN5bmMgX2Vucm9sbChwYXJhbXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogc2Vzc2lvbkRhdGEsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBzZXNzaW9uRXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vZmFjdG9yc2AsIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJpZW5kbHlfbmFtZTogcGFyYW1zLmZyaWVuZGx5TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY3Rvcl90eXBlOiBwYXJhbXMuZmFjdG9yVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzc3VlcjogcGFyYW1zLmlzc3VlcixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBqd3Q6IChfYSA9IHNlc3Npb25EYXRhID09PSBudWxsIHx8IHNlc3Npb25EYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXNzaW9uRGF0YS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKF9iID0gZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLnRvdHApID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5xcl9jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEudG90cC5xcl9jb2RlID0gYGRhdGE6aW1hZ2Uvc3ZnK3htbDt1dGYtOCwke2RhdGEudG90cC5xcl9jb2RlfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICoge0BzZWUgR29UcnVlTUZBQXBpI3ZlcmlmeX1cbiAgICAgKi9cbiAgICBhc3luYyBfdmVyaWZ5KHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogc2Vzc2lvbkRhdGEsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IHNlc3Npb25FcnJvciB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L2ZhY3RvcnMvJHtwYXJhbXMuZmFjdG9ySWR9L3ZlcmlmeWAsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IHsgY29kZTogcGFyYW1zLmNvZGUsIGNoYWxsZW5nZV9pZDogcGFyYW1zLmNoYWxsZW5nZUlkIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBqd3Q6IChfYSA9IHNlc3Npb25EYXRhID09PSBudWxsIHx8IHNlc3Npb25EYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXNzaW9uRGF0YS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKE9iamVjdC5hc3NpZ24oeyBleHBpcmVzX2F0OiBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxMDAwKSArIGRhdGEuZXhwaXJlc19pbiB9LCBkYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdNRkFfQ0hBTExFTkdFX1ZFUklGSUVEJywgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICoge0BzZWUgR29UcnVlTUZBQXBpI2NoYWxsZW5nZX1cbiAgICAgKi9cbiAgICBhc3luYyBfY2hhbGxlbmdlKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogc2Vzc2lvbkRhdGEsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IHNlc3Npb25FcnJvciB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9mYWN0b3JzLyR7cGFyYW1zLmZhY3RvcklkfS9jaGFsbGVuZ2VgLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBqd3Q6IChfYSA9IHNlc3Npb25EYXRhID09PSBudWxsIHx8IHNlc3Npb25EYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXNzaW9uRGF0YS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB7QHNlZSBHb1RydWVNRkFBcGkjY2hhbGxlbmdlQW5kVmVyaWZ5fVxuICAgICAqL1xuICAgIGFzeW5jIF9jaGFsbGVuZ2VBbmRWZXJpZnkocGFyYW1zKSB7XG4gICAgICAgIC8vIGJvdGggX2NoYWxsZW5nZSBhbmQgX3ZlcmlmeSBpbmRlcGVuZGVudGx5IGFjcXVpcmUgdGhlIGxvY2ssIHNvIG5vIG5lZWRcbiAgICAgICAgLy8gdG8gYWNxdWlyZSBpdCBoZXJlXG4gICAgICAgIGNvbnN0IHsgZGF0YTogY2hhbGxlbmdlRGF0YSwgZXJyb3I6IGNoYWxsZW5nZUVycm9yIH0gPSBhd2FpdCB0aGlzLl9jaGFsbGVuZ2Uoe1xuICAgICAgICAgICAgZmFjdG9ySWQ6IHBhcmFtcy5mYWN0b3JJZCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjaGFsbGVuZ2VFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IGNoYWxsZW5nZUVycm9yIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3ZlcmlmeSh7XG4gICAgICAgICAgICBmYWN0b3JJZDogcGFyYW1zLmZhY3RvcklkLFxuICAgICAgICAgICAgY2hhbGxlbmdlSWQ6IGNoYWxsZW5nZURhdGEuaWQsXG4gICAgICAgICAgICBjb2RlOiBwYXJhbXMuY29kZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHtAc2VlIEdvVHJ1ZU1GQUFwaSNsaXN0RmFjdG9yc31cbiAgICAgKi9cbiAgICBhc3luYyBfbGlzdEZhY3RvcnMoKSB7XG4gICAgICAgIC8vIHVzZSAjZ2V0VXNlciBpbnN0ZWFkIG9mICNfZ2V0VXNlciBhcyB0aGUgZm9ybWVyIGFjcXVpcmVzIGEgbG9ja1xuICAgICAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9LCBlcnJvcjogdXNlckVycm9yLCB9ID0gYXdhaXQgdGhpcy5nZXRVc2VyKCk7XG4gICAgICAgIGlmICh1c2VyRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiB1c2VyRXJyb3IgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmYWN0b3JzID0gKHVzZXIgPT09IG51bGwgfHwgdXNlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogdXNlci5mYWN0b3JzKSB8fCBbXTtcbiAgICAgICAgY29uc3QgdG90cCA9IGZhY3RvcnMuZmlsdGVyKChmYWN0b3IpID0+IGZhY3Rvci5mYWN0b3JfdHlwZSA9PT0gJ3RvdHAnICYmIGZhY3Rvci5zdGF0dXMgPT09ICd2ZXJpZmllZCcpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGFsbDogZmFjdG9ycyxcbiAgICAgICAgICAgICAgICB0b3RwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB7QHNlZSBHb1RydWVNRkFBcGkjZ2V0QXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVsfVxuICAgICAqL1xuICAgIGFzeW5jIF9nZXRBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiB7IHNlc3Npb24gfSwgZXJyb3I6IHNlc3Npb25FcnJvciwgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBzZXNzaW9uRXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7IGN1cnJlbnRMZXZlbDogbnVsbCwgbmV4dExldmVsOiBudWxsLCBjdXJyZW50QXV0aGVudGljYXRpb25NZXRob2RzOiBbXSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB0aGlzLl9kZWNvZGVKV1Qoc2Vzc2lvbi5hY2Nlc3NfdG9rZW4pO1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50TGV2ZWwgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChwYXlsb2FkLmFhbCkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBwYXlsb2FkLmFhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IG5leHRMZXZlbCA9IGN1cnJlbnRMZXZlbDtcbiAgICAgICAgICAgICAgICBjb25zdCB2ZXJpZmllZEZhY3RvcnMgPSAoX2IgPSAoX2EgPSBzZXNzaW9uLnVzZXIuZmFjdG9ycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbHRlcigoZmFjdG9yKSA9PiBmYWN0b3Iuc3RhdHVzID09PSAndmVyaWZpZWQnKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW107XG4gICAgICAgICAgICAgICAgaWYgKHZlcmlmaWVkRmFjdG9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRMZXZlbCA9ICdhYWwyJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudEF1dGhlbnRpY2F0aW9uTWV0aG9kcyA9IHBheWxvYWQuYW1yIHx8IFtdO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgY3VycmVudExldmVsLCBuZXh0TGV2ZWwsIGN1cnJlbnRBdXRoZW50aWNhdGlvbk1ldGhvZHMgfSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5Hb1RydWVDbGllbnQubmV4dEluc3RhbmNlSUQgPSAwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R29UcnVlQ2xpZW50LmpzLm1hcCIsImltcG9ydCBHb1RydWVBZG1pbkFwaSBmcm9tICcuL0dvVHJ1ZUFkbWluQXBpJ1xuaW1wb3J0IHsgREVGQVVMVF9IRUFERVJTLCBFWFBJUllfTUFSR0lOLCBHT1RSVUVfVVJMLCBTVE9SQUdFX0tFWSB9IGZyb20gJy4vbGliL2NvbnN0YW50cydcbmltcG9ydCB7XG4gIEF1dGhFcnJvcixcbiAgQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yLFxuICBBdXRoUEtDRUdyYW50Q29kZUV4Y2hhbmdlRXJyb3IsXG4gIEF1dGhJbnZhbGlkQ3JlZGVudGlhbHNFcnJvcixcbiAgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IsXG4gIEF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yLFxuICBBdXRoVW5rbm93bkVycm9yLFxuICBpc0F1dGhBcGlFcnJvcixcbiAgaXNBdXRoRXJyb3IsXG4gIGlzQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IsXG59IGZyb20gJy4vbGliL2Vycm9ycydcbmltcG9ydCB7XG4gIEZldGNoLFxuICBfcmVxdWVzdCxcbiAgX3Nlc3Npb25SZXNwb25zZSxcbiAgX3Nlc3Npb25SZXNwb25zZVBhc3N3b3JkLFxuICBfdXNlclJlc3BvbnNlLFxuICBfc3NvUmVzcG9uc2UsXG59IGZyb20gJy4vbGliL2ZldGNoJ1xuaW1wb3J0IHtcbiAgZGVjb2RlSldUUGF5bG9hZCxcbiAgRGVmZXJyZWQsXG4gIGdldEl0ZW1Bc3luYyxcbiAgaXNCcm93c2VyLFxuICByZW1vdmVJdGVtQXN5bmMsXG4gIHJlc29sdmVGZXRjaCxcbiAgc2V0SXRlbUFzeW5jLFxuICB1dWlkLFxuICByZXRyeWFibGUsXG4gIHNsZWVwLFxuICBzdXBwb3J0c0xvY2FsU3RvcmFnZSxcbiAgcGFyc2VQYXJhbWV0ZXJzRnJvbVVSTCxcbiAgZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZCxcbn0gZnJvbSAnLi9saWIvaGVscGVycydcbmltcG9ydCB7IGxvY2FsU3RvcmFnZUFkYXB0ZXIsIG1lbW9yeUxvY2FsU3RvcmFnZUFkYXB0ZXIgfSBmcm9tICcuL2xpYi9sb2NhbC1zdG9yYWdlJ1xuaW1wb3J0IHsgcG9seWZpbGxHbG9iYWxUaGlzIH0gZnJvbSAnLi9saWIvcG9seWZpbGxzJ1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4vbGliL3ZlcnNpb24nXG5pbXBvcnQgeyBMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciwgbmF2aWdhdG9yTG9jayB9IGZyb20gJy4vbGliL2xvY2tzJ1xuXG5pbXBvcnQgdHlwZSB7XG4gIEF1dGhDaGFuZ2VFdmVudCxcbiAgQXV0aFJlc3BvbnNlLFxuICBBdXRoUmVzcG9uc2VQYXNzd29yZCxcbiAgQXV0aFRva2VuUmVzcG9uc2UsXG4gIEF1dGhUb2tlblJlc3BvbnNlUGFzc3dvcmQsXG4gIEF1dGhPdHBSZXNwb25zZSxcbiAgQ2FsbFJlZnJlc2hUb2tlblJlc3VsdCxcbiAgR29UcnVlQ2xpZW50T3B0aW9ucyxcbiAgSW5pdGlhbGl6ZVJlc3VsdCxcbiAgT0F1dGhSZXNwb25zZSxcbiAgU1NPUmVzcG9uc2UsXG4gIFByb3ZpZGVyLFxuICBTZXNzaW9uLFxuICBTaWduSW5XaXRoSWRUb2tlbkNyZWRlbnRpYWxzLFxuICBTaWduSW5XaXRoT0F1dGhDcmVkZW50aWFscyxcbiAgU2lnbkluV2l0aFBhc3N3b3JkQ3JlZGVudGlhbHMsXG4gIFNpZ25JbldpdGhQYXNzd29yZGxlc3NDcmVkZW50aWFscyxcbiAgU2lnblVwV2l0aFBhc3N3b3JkQ3JlZGVudGlhbHMsXG4gIFNpZ25JbldpdGhTU08sXG4gIFNpZ25PdXQsXG4gIFN1YnNjcmlwdGlvbixcbiAgU3VwcG9ydGVkU3RvcmFnZSxcbiAgVXNlcixcbiAgVXNlckF0dHJpYnV0ZXMsXG4gIFVzZXJSZXNwb25zZSxcbiAgVmVyaWZ5T3RwUGFyYW1zLFxuICBHb1RydWVNRkFBcGksXG4gIE1GQUVucm9sbFBhcmFtcyxcbiAgQXV0aE1GQUVucm9sbFJlc3BvbnNlLFxuICBNRkFDaGFsbGVuZ2VQYXJhbXMsXG4gIEF1dGhNRkFDaGFsbGVuZ2VSZXNwb25zZSxcbiAgTUZBVW5lbnJvbGxQYXJhbXMsXG4gIEF1dGhNRkFVbmVucm9sbFJlc3BvbnNlLFxuICBNRkFWZXJpZnlQYXJhbXMsXG4gIEF1dGhNRkFWZXJpZnlSZXNwb25zZSxcbiAgQXV0aE1GQUxpc3RGYWN0b3JzUmVzcG9uc2UsXG4gIEFNUkVudHJ5LFxuICBBdXRoTUZBR2V0QXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVsUmVzcG9uc2UsXG4gIEF1dGhlbnRpY2F0b3JBc3N1cmFuY2VMZXZlbHMsXG4gIEZhY3RvcixcbiAgTUZBQ2hhbGxlbmdlQW5kVmVyaWZ5UGFyYW1zLFxuICBSZXNlbmRQYXJhbXMsXG4gIEF1dGhGbG93VHlwZSxcbiAgTG9ja0Z1bmMsXG4gIFVzZXJJZGVudGl0eSxcbiAgU2lnbkluQW5vbnltb3VzbHlDcmVkZW50aWFscyxcbn0gZnJvbSAnLi9saWIvdHlwZXMnXG5cbnBvbHlmaWxsR2xvYmFsVGhpcygpIC8vIE1ha2UgXCJnbG9iYWxUaGlzXCIgYXZhaWxhYmxlXG5cbmNvbnN0IERFRkFVTFRfT1BUSU9OUzogT21pdDxSZXF1aXJlZDxHb1RydWVDbGllbnRPcHRpb25zPiwgJ2ZldGNoJyB8ICdzdG9yYWdlJyB8ICdsb2NrJz4gPSB7XG4gIHVybDogR09UUlVFX1VSTCxcbiAgc3RvcmFnZUtleTogU1RPUkFHRV9LRVksXG4gIGF1dG9SZWZyZXNoVG9rZW46IHRydWUsXG4gIHBlcnNpc3RTZXNzaW9uOiB0cnVlLFxuICBkZXRlY3RTZXNzaW9uSW5Vcmw6IHRydWUsXG4gIGhlYWRlcnM6IERFRkFVTFRfSEVBREVSUyxcbiAgZmxvd1R5cGU6ICdpbXBsaWNpdCcsXG4gIGRlYnVnOiBmYWxzZSxcbiAgaGFzQ3VzdG9tQXV0aG9yaXphdGlvbkhlYWRlcjogZmFsc2UsXG59XG5cbi8qKiBDdXJyZW50IHNlc3Npb24gd2lsbCBiZSBjaGVja2VkIGZvciByZWZyZXNoIGF0IHRoaXMgaW50ZXJ2YWwuICovXG5jb25zdCBBVVRPX1JFRlJFU0hfVElDS19EVVJBVElPTiA9IDMwICogMTAwMFxuXG4vKipcbiAqIEEgdG9rZW4gcmVmcmVzaCB3aWxsIGJlIGF0dGVtcHRlZCB0aGlzIG1hbnkgdGlja3MgYmVmb3JlIHRoZSBjdXJyZW50IHNlc3Npb24gZXhwaXJlcy4gKi9cbmNvbnN0IEFVVE9fUkVGUkVTSF9USUNLX1RIUkVTSE9MRCA9IDNcblxuYXN5bmMgZnVuY3Rpb24gbG9ja05vT3A8Uj4obmFtZTogc3RyaW5nLCBhY3F1aXJlVGltZW91dDogbnVtYmVyLCBmbjogKCkgPT4gUHJvbWlzZTxSPik6IFByb21pc2U8Uj4ge1xuICByZXR1cm4gYXdhaXQgZm4oKVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHb1RydWVDbGllbnQge1xuICBwcml2YXRlIHN0YXRpYyBuZXh0SW5zdGFuY2VJRCA9IDBcblxuICBwcml2YXRlIGluc3RhbmNlSUQ6IG51bWJlclxuXG4gIC8qKlxuICAgKiBOYW1lc3BhY2UgZm9yIHRoZSBHb1RydWUgYWRtaW4gbWV0aG9kcy5cbiAgICogVGhlc2UgbWV0aG9kcyBzaG91bGQgb25seSBiZSB1c2VkIGluIGEgdHJ1c3RlZCBzZXJ2ZXItc2lkZSBlbnZpcm9ubWVudC5cbiAgICovXG4gIGFkbWluOiBHb1RydWVBZG1pbkFwaVxuICAvKipcbiAgICogTmFtZXNwYWNlIGZvciB0aGUgTUZBIG1ldGhvZHMuXG4gICAqL1xuICBtZmE6IEdvVHJ1ZU1GQUFwaVxuICAvKipcbiAgICogVGhlIHN0b3JhZ2Uga2V5IHVzZWQgdG8gaWRlbnRpZnkgdGhlIHZhbHVlcyBzYXZlZCBpbiBsb2NhbFN0b3JhZ2VcbiAgICovXG4gIHByb3RlY3RlZCBzdG9yYWdlS2V5OiBzdHJpbmdcblxuICBwcm90ZWN0ZWQgZmxvd1R5cGU6IEF1dGhGbG93VHlwZVxuXG4gIHByb3RlY3RlZCBhdXRvUmVmcmVzaFRva2VuOiBib29sZWFuXG4gIHByb3RlY3RlZCBwZXJzaXN0U2Vzc2lvbjogYm9vbGVhblxuICBwcm90ZWN0ZWQgc3RvcmFnZTogU3VwcG9ydGVkU3RvcmFnZVxuICBwcm90ZWN0ZWQgbWVtb3J5U3RvcmFnZTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSB8IG51bGwgPSBudWxsXG4gIHByb3RlY3RlZCBzdGF0ZUNoYW5nZUVtaXR0ZXJzOiBNYXA8c3RyaW5nLCBTdWJzY3JpcHRpb24+ID0gbmV3IE1hcCgpXG4gIHByb3RlY3RlZCBhdXRvUmVmcmVzaFRpY2tlcjogUmV0dXJuVHlwZTx0eXBlb2Ygc2V0SW50ZXJ2YWw+IHwgbnVsbCA9IG51bGxcbiAgcHJvdGVjdGVkIHZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2s6ICgoKSA9PiBQcm9taXNlPGFueT4pIHwgbnVsbCA9IG51bGxcbiAgcHJvdGVjdGVkIHJlZnJlc2hpbmdEZWZlcnJlZDogRGVmZXJyZWQ8Q2FsbFJlZnJlc2hUb2tlblJlc3VsdD4gfCBudWxsID0gbnVsbFxuICAvKipcbiAgICogS2VlcHMgdHJhY2sgb2YgdGhlIGFzeW5jIGNsaWVudCBpbml0aWFsaXphdGlvbi5cbiAgICogV2hlbiBudWxsIG9yIG5vdCB5ZXQgcmVzb2x2ZWQgdGhlIGF1dGggc3RhdGUgaXMgYHVua25vd25gXG4gICAqIE9uY2UgcmVzb2x2ZWQgdGhlIHRoZSBhdXRoIHN0YXRlIGlzIGtub3duIGFuZCBpdCdzIHNhdmUgdG8gY2FsbCBhbnkgZnVydGhlciBjbGllbnQgbWV0aG9kcy5cbiAgICogS2VlcCBleHRyYSBjYXJlIHRvIG5ldmVyIHJlamVjdCBvciB0aHJvdyB1bmNhdWdodCBlcnJvcnNcbiAgICovXG4gIHByb3RlY3RlZCBpbml0aWFsaXplUHJvbWlzZTogUHJvbWlzZTxJbml0aWFsaXplUmVzdWx0PiB8IG51bGwgPSBudWxsXG4gIHByb3RlY3RlZCBkZXRlY3RTZXNzaW9uSW5VcmwgPSB0cnVlXG4gIHByb3RlY3RlZCB1cmw6IHN0cmluZ1xuICBwcm90ZWN0ZWQgaGVhZGVyczoge1xuICAgIFtrZXk6IHN0cmluZ106IHN0cmluZ1xuICB9XG4gIHByb3RlY3RlZCBoYXNDdXN0b21BdXRob3JpemF0aW9uSGVhZGVyID0gZmFsc2VcbiAgcHJvdGVjdGVkIHN1cHByZXNzR2V0U2Vzc2lvbldhcm5pbmcgPSBmYWxzZVxuICBwcm90ZWN0ZWQgZmV0Y2g6IEZldGNoXG4gIHByb3RlY3RlZCBsb2NrOiBMb2NrRnVuY1xuICBwcm90ZWN0ZWQgbG9ja0FjcXVpcmVkID0gZmFsc2VcbiAgcHJvdGVjdGVkIHBlbmRpbmdJbkxvY2s6IFByb21pc2U8YW55PltdID0gW11cblxuICAvKipcbiAgICogVXNlZCB0byBicm9hZGNhc3Qgc3RhdGUgY2hhbmdlIGV2ZW50cyB0byBvdGhlciB0YWJzIGxpc3RlbmluZy5cbiAgICovXG4gIHByb3RlY3RlZCBicm9hZGNhc3RDaGFubmVsOiBCcm9hZGNhc3RDaGFubmVsIHwgbnVsbCA9IG51bGxcblxuICBwcm90ZWN0ZWQgbG9nRGVidWdNZXNzYWdlczogYm9vbGVhblxuICBwcm90ZWN0ZWQgbG9nZ2VyOiAobWVzc2FnZTogc3RyaW5nLCAuLi5hcmdzOiBhbnlbXSkgPT4gdm9pZCA9IGNvbnNvbGUubG9nXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBjbGllbnQgZm9yIHVzZSBpbiB0aGUgYnJvd3Nlci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IEdvVHJ1ZUNsaWVudE9wdGlvbnMpIHtcbiAgICB0aGlzLmluc3RhbmNlSUQgPSBHb1RydWVDbGllbnQubmV4dEluc3RhbmNlSURcbiAgICBHb1RydWVDbGllbnQubmV4dEluc3RhbmNlSUQgKz0gMVxuXG4gICAgaWYgKHRoaXMuaW5zdGFuY2VJRCA+IDAgJiYgaXNCcm93c2VyKCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ011bHRpcGxlIEdvVHJ1ZUNsaWVudCBpbnN0YW5jZXMgZGV0ZWN0ZWQgaW4gdGhlIHNhbWUgYnJvd3NlciBjb250ZXh0LiBJdCBpcyBub3QgYW4gZXJyb3IsIGJ1dCB0aGlzIHNob3VsZCBiZSBhdm9pZGVkIGFzIGl0IG1heSBwcm9kdWNlIHVuZGVmaW5lZCBiZWhhdmlvciB3aGVuIHVzZWQgY29uY3VycmVudGx5IHVuZGVyIHRoZSBzYW1lIHN0b3JhZ2Uga2V5LidcbiAgICAgIClcbiAgICB9XG5cbiAgICBjb25zdCBzZXR0aW5ncyA9IHsgLi4uREVGQVVMVF9PUFRJT05TLCAuLi5vcHRpb25zIH1cblxuICAgIHRoaXMubG9nRGVidWdNZXNzYWdlcyA9ICEhc2V0dGluZ3MuZGVidWdcbiAgICBpZiAodHlwZW9mIHNldHRpbmdzLmRlYnVnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLmxvZ2dlciA9IHNldHRpbmdzLmRlYnVnXG4gICAgfVxuXG4gICAgdGhpcy5wZXJzaXN0U2Vzc2lvbiA9IHNldHRpbmdzLnBlcnNpc3RTZXNzaW9uXG4gICAgdGhpcy5zdG9yYWdlS2V5ID0gc2V0dGluZ3Muc3RvcmFnZUtleVxuICAgIHRoaXMuYXV0b1JlZnJlc2hUb2tlbiA9IHNldHRpbmdzLmF1dG9SZWZyZXNoVG9rZW5cbiAgICB0aGlzLmFkbWluID0gbmV3IEdvVHJ1ZUFkbWluQXBpKHtcbiAgICAgIHVybDogc2V0dGluZ3MudXJsLFxuICAgICAgaGVhZGVyczogc2V0dGluZ3MuaGVhZGVycyxcbiAgICAgIGZldGNoOiBzZXR0aW5ncy5mZXRjaCxcbiAgICB9KVxuXG4gICAgdGhpcy51cmwgPSBzZXR0aW5ncy51cmxcbiAgICB0aGlzLmhlYWRlcnMgPSBzZXR0aW5ncy5oZWFkZXJzXG4gICAgdGhpcy5mZXRjaCA9IHJlc29sdmVGZXRjaChzZXR0aW5ncy5mZXRjaClcbiAgICB0aGlzLmxvY2sgPSBzZXR0aW5ncy5sb2NrIHx8IGxvY2tOb09wXG4gICAgdGhpcy5kZXRlY3RTZXNzaW9uSW5VcmwgPSBzZXR0aW5ncy5kZXRlY3RTZXNzaW9uSW5VcmxcbiAgICB0aGlzLmZsb3dUeXBlID0gc2V0dGluZ3MuZmxvd1R5cGVcbiAgICB0aGlzLmhhc0N1c3RvbUF1dGhvcml6YXRpb25IZWFkZXIgPSBzZXR0aW5ncy5oYXNDdXN0b21BdXRob3JpemF0aW9uSGVhZGVyXG5cbiAgICBpZiAoc2V0dGluZ3MubG9jaykge1xuICAgICAgdGhpcy5sb2NrID0gc2V0dGluZ3MubG9ja1xuICAgIH0gZWxzZSBpZiAoaXNCcm93c2VyKCkgJiYgZ2xvYmFsVGhpcz8ubmF2aWdhdG9yPy5sb2Nrcykge1xuICAgICAgdGhpcy5sb2NrID0gbmF2aWdhdG9yTG9ja1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvY2sgPSBsb2NrTm9PcFxuICAgIH1cblxuICAgIHRoaXMubWZhID0ge1xuICAgICAgdmVyaWZ5OiB0aGlzLl92ZXJpZnkuYmluZCh0aGlzKSxcbiAgICAgIGVucm9sbDogdGhpcy5fZW5yb2xsLmJpbmQodGhpcyksXG4gICAgICB1bmVucm9sbDogdGhpcy5fdW5lbnJvbGwuYmluZCh0aGlzKSxcbiAgICAgIGNoYWxsZW5nZTogdGhpcy5fY2hhbGxlbmdlLmJpbmQodGhpcyksXG4gICAgICBsaXN0RmFjdG9yczogdGhpcy5fbGlzdEZhY3RvcnMuYmluZCh0aGlzKSxcbiAgICAgIGNoYWxsZW5nZUFuZFZlcmlmeTogdGhpcy5fY2hhbGxlbmdlQW5kVmVyaWZ5LmJpbmQodGhpcyksXG4gICAgICBnZXRBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWw6IHRoaXMuX2dldEF1dGhlbnRpY2F0b3JBc3N1cmFuY2VMZXZlbC5iaW5kKHRoaXMpLFxuICAgIH1cblxuICAgIGlmICh0aGlzLnBlcnNpc3RTZXNzaW9uKSB7XG4gICAgICBpZiAoc2V0dGluZ3Muc3RvcmFnZSkge1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBzZXR0aW5ncy5zdG9yYWdlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc3VwcG9ydHNMb2NhbFN0b3JhZ2UoKSkge1xuICAgICAgICAgIHRoaXMuc3RvcmFnZSA9IGxvY2FsU3RvcmFnZUFkYXB0ZXJcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm1lbW9yeVN0b3JhZ2UgPSB7fVxuICAgICAgICAgIHRoaXMuc3RvcmFnZSA9IG1lbW9yeUxvY2FsU3RvcmFnZUFkYXB0ZXIodGhpcy5tZW1vcnlTdG9yYWdlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWVtb3J5U3RvcmFnZSA9IHt9XG4gICAgICB0aGlzLnN0b3JhZ2UgPSBtZW1vcnlMb2NhbFN0b3JhZ2VBZGFwdGVyKHRoaXMubWVtb3J5U3RvcmFnZSlcbiAgICB9XG5cbiAgICBpZiAoaXNCcm93c2VyKCkgJiYgZ2xvYmFsVGhpcy5Ccm9hZGNhc3RDaGFubmVsICYmIHRoaXMucGVyc2lzdFNlc3Npb24gJiYgdGhpcy5zdG9yYWdlS2V5KSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmJyb2FkY2FzdENoYW5uZWwgPSBuZXcgZ2xvYmFsVGhpcy5Ccm9hZGNhc3RDaGFubmVsKHRoaXMuc3RvcmFnZUtleSlcbiAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICdGYWlsZWQgdG8gY3JlYXRlIGEgbmV3IEJyb2FkY2FzdENoYW5uZWwsIG11bHRpLXRhYiBzdGF0ZSBjaGFuZ2VzIHdpbGwgbm90IGJlIGF2YWlsYWJsZScsXG4gICAgICAgICAgZVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIHRoaXMuYnJvYWRjYXN0Q2hhbm5lbD8uYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICB0aGlzLl9kZWJ1ZygncmVjZWl2ZWQgYnJvYWRjYXN0IG5vdGlmaWNhdGlvbiBmcm9tIG90aGVyIHRhYiBvciBjbGllbnQnLCBldmVudClcblxuICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycyhldmVudC5kYXRhLmV2ZW50LCBldmVudC5kYXRhLnNlc3Npb24sIGZhbHNlKSAvLyBicm9hZGNhc3QgPSBmYWxzZSBzbyB3ZSBkb24ndCBnZXQgYW4gZW5kbGVzcyBsb29wIG9mIG1lc3NhZ2VzXG4gICAgICB9KVxuICAgIH1cblxuICAgIHRoaXMuaW5pdGlhbGl6ZSgpXG4gIH1cblxuICBwcml2YXRlIF9kZWJ1ZyguLi5hcmdzOiBhbnlbXSk6IEdvVHJ1ZUNsaWVudCB7XG4gICAgaWYgKHRoaXMubG9nRGVidWdNZXNzYWdlcykge1xuICAgICAgdGhpcy5sb2dnZXIoXG4gICAgICAgIGBHb1RydWVDbGllbnRAJHt0aGlzLmluc3RhbmNlSUR9ICgke3ZlcnNpb259KSAke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX1gLFxuICAgICAgICAuLi5hcmdzXG4gICAgICApXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgY2xpZW50IHNlc3Npb24gZWl0aGVyIGZyb20gdGhlIHVybCBvciBmcm9tIHN0b3JhZ2UuXG4gICAqIFRoaXMgbWV0aG9kIGlzIGF1dG9tYXRpY2FsbHkgY2FsbGVkIHdoZW4gaW5zdGFudGlhdGluZyB0aGUgY2xpZW50LCBidXQgc2hvdWxkIGFsc28gYmUgY2FsbGVkXG4gICAqIG1hbnVhbGx5IHdoZW4gY2hlY2tpbmcgZm9yIGFuIGVycm9yIGZyb20gYW4gYXV0aCByZWRpcmVjdCAob2F1dGgsIG1hZ2ljbGluaywgcGFzc3dvcmQgcmVjb3ZlcnksIGV0YykuXG4gICAqL1xuICBhc3luYyBpbml0aWFsaXplKCk6IFByb21pc2U8SW5pdGlhbGl6ZVJlc3VsdD4ge1xuICAgIGlmICh0aGlzLmluaXRpYWxpemVQcm9taXNlKSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZVxuICAgIH1cblxuICAgIHRoaXMuaW5pdGlhbGl6ZVByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9pbml0aWFsaXplKClcbiAgICAgIH0pXG4gICAgfSkoKVxuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBJTVBPUlRBTlQ6XG4gICAqIDEuIE5ldmVyIHRocm93IGluIHRoaXMgbWV0aG9kLCBhcyBpdCBpcyBjYWxsZWQgZnJvbSB0aGUgY29uc3RydWN0b3JcbiAgICogMi4gTmV2ZXIgcmV0dXJuIGEgc2Vzc2lvbiBmcm9tIHRoaXMgbWV0aG9kIGFzIGl0IHdvdWxkIGJlIGNhY2hlZCBvdmVyXG4gICAqICAgIHRoZSB3aG9sZSBsaWZldGltZSBvZiB0aGUgY2xpZW50XG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9pbml0aWFsaXplKCk6IFByb21pc2U8SW5pdGlhbGl6ZVJlc3VsdD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBpc1BLQ0VGbG93ID0gaXNCcm93c2VyKCkgPyBhd2FpdCB0aGlzLl9pc1BLQ0VGbG93KCkgOiBmYWxzZVxuICAgICAgdGhpcy5fZGVidWcoJyNfaW5pdGlhbGl6ZSgpJywgJ2JlZ2luJywgJ2lzIFBLQ0UgZmxvdycsIGlzUEtDRUZsb3cpXG5cbiAgICAgIGlmIChpc1BLQ0VGbG93IHx8ICh0aGlzLmRldGVjdFNlc3Npb25JblVybCAmJiB0aGlzLl9pc0ltcGxpY2l0R3JhbnRGbG93KCkpKSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX2dldFNlc3Npb25Gcm9tVVJMKGlzUEtDRUZsb3cpXG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2luaXRpYWxpemUoKScsICdlcnJvciBkZXRlY3Rpbmcgc2Vzc2lvbiBmcm9tIFVSTCcsIGVycm9yKVxuXG4gICAgICAgICAgLy8gaGFja3kgd29ya2Fyb3VuZCB0byBrZWVwIHRoZSBleGlzdGluZyBzZXNzaW9uIGlmIHRoZXJlJ3MgYW4gZXJyb3IgcmV0dXJuZWQgZnJvbSBpZGVudGl0eSBsaW5raW5nXG4gICAgICAgICAgLy8gVE9ETzogb25jZSBlcnJvciBjb2RlcyBhcmUgcmVhZHksIHdlIHNob3VsZCBtYXRjaCBhZ2FpbnN0IGl0IGluc3RlYWQgb2YgdGhlIG1lc3NhZ2VcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBlcnJvcj8ubWVzc2FnZSA9PT0gJ0lkZW50aXR5IGlzIGFscmVhZHkgbGlua2VkJyB8fFxuICAgICAgICAgICAgZXJyb3I/Lm1lc3NhZ2UgPT09ICdJZGVudGl0eSBpcyBhbHJlYWR5IGxpbmtlZCB0byBhbm90aGVyIHVzZXInXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4geyBlcnJvciB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZmFpbGVkIGxvZ2luIGF0dGVtcHQgdmlhIHVybCxcbiAgICAgICAgICAvLyByZW1vdmUgb2xkIHNlc3Npb24gYXMgaW4gdmVyaWZ5T3RwLCBzaWduVXAgYW5kIHNpZ25JbldpdGgqXG4gICAgICAgICAgYXdhaXQgdGhpcy5fcmVtb3ZlU2Vzc2lvbigpXG5cbiAgICAgICAgICByZXR1cm4geyBlcnJvciB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IHNlc3Npb24sIHJlZGlyZWN0VHlwZSB9ID0gZGF0YVxuXG4gICAgICAgIHRoaXMuX2RlYnVnKFxuICAgICAgICAgICcjX2luaXRpYWxpemUoKScsXG4gICAgICAgICAgJ2RldGVjdGVkIHNlc3Npb24gaW4gVVJMJyxcbiAgICAgICAgICBzZXNzaW9uLFxuICAgICAgICAgICdyZWRpcmVjdCB0eXBlJyxcbiAgICAgICAgICByZWRpcmVjdFR5cGVcbiAgICAgICAgKVxuXG4gICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKHNlc3Npb24pXG5cbiAgICAgICAgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgaWYgKHJlZGlyZWN0VHlwZSA9PT0gJ3JlY292ZXJ5Jykge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1BBU1NXT1JEX1JFQ09WRVJZJywgc2Vzc2lvbilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIHNlc3Npb24pXG4gICAgICAgICAgfVxuICAgICAgICB9LCAwKVxuXG4gICAgICAgIHJldHVybiB7IGVycm9yOiBudWxsIH1cbiAgICAgIH1cbiAgICAgIC8vIG5vIGxvZ2luIGF0dGVtcHQgdmlhIGNhbGxiYWNrIHVybCB0cnkgdG8gcmVjb3ZlciBzZXNzaW9uIGZyb20gc3RvcmFnZVxuICAgICAgYXdhaXQgdGhpcy5fcmVjb3ZlckFuZFJlZnJlc2goKVxuICAgICAgcmV0dXJuIHsgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3I6IG5ldyBBdXRoVW5rbm93bkVycm9yKCdVbmV4cGVjdGVkIGVycm9yIGR1cmluZyBpbml0aWFsaXphdGlvbicsIGVycm9yKSxcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgYXdhaXQgdGhpcy5faGFuZGxlVmlzaWJpbGl0eUNoYW5nZSgpXG4gICAgICB0aGlzLl9kZWJ1ZygnI19pbml0aWFsaXplKCknLCAnZW5kJylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBhbm9ueW1vdXMgdXNlci5cbiAgICpcbiAgICogQHJldHVybnMgQSBzZXNzaW9uIHdoZXJlIHRoZSBpc19hbm9ueW1vdXMgY2xhaW0gaW4gdGhlIGFjY2VzcyB0b2tlbiBKV1Qgc2V0IHRvIHRydWVcbiAgICovXG4gIGFzeW5jIHNpZ25JbkFub255bW91c2x5KGNyZWRlbnRpYWxzPzogU2lnbkluQW5vbnltb3VzbHlDcmVkZW50aWFscyk6IFByb21pc2U8QXV0aFJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3NpZ251cGAsIHtcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgZGF0YTogY3JlZGVudGlhbHM/Lm9wdGlvbnM/LmRhdGEgPz8ge30sXG4gICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogY3JlZGVudGlhbHM/Lm9wdGlvbnM/LmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICB9LFxuICAgICAgICB4Zm9ybTogX3Nlc3Npb25SZXNwb25zZSxcbiAgICAgIH0pXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXNcblxuICAgICAgaWYgKGVycm9yIHx8ICFkYXRhKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogZXJyb3IgfVxuICAgICAgfVxuICAgICAgY29uc3Qgc2Vzc2lvbjogU2Vzc2lvbiB8IG51bGwgPSBkYXRhLnNlc3Npb25cbiAgICAgIGNvbnN0IHVzZXI6IFVzZXIgfCBudWxsID0gZGF0YS51c2VyXG5cbiAgICAgIGlmIChkYXRhLnNlc3Npb24pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKVxuICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgc2Vzc2lvbilcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyLCBzZXNzaW9uIH0sIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHVzZXIuXG4gICAqXG4gICAqIEJlIGF3YXJlIHRoYXQgaWYgYSB1c2VyIGFjY291bnQgZXhpc3RzIGluIHRoZSBzeXN0ZW0geW91IG1heSBnZXQgYmFjayBhblxuICAgKiBlcnJvciBtZXNzYWdlIHRoYXQgYXR0ZW1wdHMgdG8gaGlkZSB0aGlzIGluZm9ybWF0aW9uIGZyb20gdGhlIHVzZXIuXG4gICAqIFRoaXMgbWV0aG9kIGhhcyBzdXBwb3J0IGZvciBQS0NFIHZpYSBlbWFpbCBzaWdudXBzLiBUaGUgUEtDRSBmbG93IGNhbm5vdCBiZSB1c2VkIHdoZW4gYXV0b2NvbmZpcm0gaXMgZW5hYmxlZC5cbiAgICpcbiAgICogQHJldHVybnMgQSBsb2dnZWQtaW4gc2Vzc2lvbiBpZiB0aGUgc2VydmVyIGhhcyBcImF1dG9jb25maXJtXCIgT05cbiAgICogQHJldHVybnMgQSB1c2VyIGlmIHRoZSBzZXJ2ZXIgaGFzIFwiYXV0b2NvbmZpcm1cIiBPRkZcbiAgICovXG4gIGFzeW5jIHNpZ25VcChjcmVkZW50aWFsczogU2lnblVwV2l0aFBhc3N3b3JkQ3JlZGVudGlhbHMpOiBQcm9taXNlPEF1dGhSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICBsZXQgcmVzOiBBdXRoUmVzcG9uc2VcbiAgICAgIGlmICgnZW1haWwnIGluIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIGNvbnN0IHsgZW1haWwsIHBhc3N3b3JkLCBvcHRpb25zIH0gPSBjcmVkZW50aWFsc1xuICAgICAgICBsZXQgY29kZUNoYWxsZW5nZTogc3RyaW5nIHwgbnVsbCA9IG51bGxcbiAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2VNZXRob2Q6IHN0cmluZyB8IG51bGwgPSBudWxsXG4gICAgICAgIGlmICh0aGlzLmZsb3dUeXBlID09PSAncGtjZScpIHtcbiAgICAgICAgICA7W2NvZGVDaGFsbGVuZ2UsIGNvZGVDaGFsbGVuZ2VNZXRob2RdID0gYXdhaXQgZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZChcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZSxcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZUtleVxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICByZXMgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9zaWdudXBgLCB7XG4gICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgIHJlZGlyZWN0VG86IG9wdGlvbnM/LmVtYWlsUmVkaXJlY3RUbyxcbiAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICAgIHBhc3N3b3JkLFxuICAgICAgICAgICAgZGF0YTogb3B0aW9ucz8uZGF0YSA/PyB7fSxcbiAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnM/LmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgICAgY29kZV9jaGFsbGVuZ2U6IGNvZGVDaGFsbGVuZ2UsXG4gICAgICAgICAgICBjb2RlX2NoYWxsZW5nZV9tZXRob2Q6IGNvZGVDaGFsbGVuZ2VNZXRob2QsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB4Zm9ybTogX3Nlc3Npb25SZXNwb25zZSxcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAoJ3Bob25lJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICBjb25zdCB7IHBob25lLCBwYXNzd29yZCwgb3B0aW9ucyB9ID0gY3JlZGVudGlhbHNcbiAgICAgICAgcmVzID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vc2lnbnVwYCwge1xuICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICBwaG9uZSxcbiAgICAgICAgICAgIHBhc3N3b3JkLFxuICAgICAgICAgICAgZGF0YTogb3B0aW9ucz8uZGF0YSA/PyB7fSxcbiAgICAgICAgICAgIGNoYW5uZWw6IG9wdGlvbnM/LmNoYW5uZWwgPz8gJ3NtcycsXG4gICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zPy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEF1dGhJbnZhbGlkQ3JlZGVudGlhbHNFcnJvcihcbiAgICAgICAgICAnWW91IG11c3QgcHJvdmlkZSBlaXRoZXIgYW4gZW1haWwgb3IgcGhvbmUgbnVtYmVyIGFuZCBhIHBhc3N3b3JkJ1xuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlc1xuXG4gICAgICBpZiAoZXJyb3IgfHwgIWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNlc3Npb246IFNlc3Npb24gfCBudWxsID0gZGF0YS5zZXNzaW9uXG4gICAgICBjb25zdCB1c2VyOiBVc2VyIHwgbnVsbCA9IGRhdGEudXNlclxuXG4gICAgICBpZiAoZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKGRhdGEuc2Vzc2lvbilcbiAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIHNlc3Npb24pXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlciwgc2Vzc2lvbiB9LCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTG9nIGluIGFuIGV4aXN0aW5nIHVzZXIgd2l0aCBhbiBlbWFpbCBhbmQgcGFzc3dvcmQgb3IgcGhvbmUgYW5kIHBhc3N3b3JkLlxuICAgKlxuICAgKiBCZSBhd2FyZSB0aGF0IHlvdSBtYXkgZ2V0IGJhY2sgYW4gZXJyb3IgbWVzc2FnZSB0aGF0IHdpbGwgbm90IGRpc3Rpbmd1aXNoXG4gICAqIGJldHdlZW4gdGhlIGNhc2VzIHdoZXJlIHRoZSBhY2NvdW50IGRvZXMgbm90IGV4aXN0IG9yIHRoYXQgdGhlXG4gICAqIGVtYWlsL3Bob25lIGFuZCBwYXNzd29yZCBjb21iaW5hdGlvbiBpcyB3cm9uZyBvciB0aGF0IHRoZSBhY2NvdW50IGNhbiBvbmx5XG4gICAqIGJlIGFjY2Vzc2VkIHZpYSBzb2NpYWwgbG9naW4uXG4gICAqL1xuICBhc3luYyBzaWduSW5XaXRoUGFzc3dvcmQoXG4gICAgY3JlZGVudGlhbHM6IFNpZ25JbldpdGhQYXNzd29yZENyZWRlbnRpYWxzXG4gICk6IFByb21pc2U8QXV0aFRva2VuUmVzcG9uc2VQYXNzd29yZD4ge1xuICAgIHRyeSB7XG4gICAgICBsZXQgcmVzOiBBdXRoUmVzcG9uc2VQYXNzd29yZFxuICAgICAgaWYgKCdlbWFpbCcgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgY29uc3QgeyBlbWFpbCwgcGFzc3dvcmQsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzXG4gICAgICAgIHJlcyA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9cGFzc3dvcmRgLCB7XG4gICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgIGVtYWlsLFxuICAgICAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zPy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlUGFzc3dvcmQsXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKCdwaG9uZScgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgY29uc3QgeyBwaG9uZSwgcGFzc3dvcmQsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzXG4gICAgICAgIHJlcyA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9cGFzc3dvcmRgLCB7XG4gICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgIHBob25lLFxuICAgICAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zPy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlUGFzc3dvcmQsXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yKFxuICAgICAgICAgICdZb3UgbXVzdCBwcm92aWRlIGVpdGhlciBhbiBlbWFpbCBvciBwaG9uZSBudW1iZXIgYW5kIGEgcGFzc3dvcmQnXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlc1xuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH0gZWxzZSBpZiAoIWRhdGEgfHwgIWRhdGEuc2Vzc2lvbiB8fCAhZGF0YS51c2VyKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogbmV3IEF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yKCkgfVxuICAgICAgfVxuICAgICAgaWYgKGRhdGEuc2Vzc2lvbikge1xuICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihkYXRhLnNlc3Npb24pXG4gICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBkYXRhLnNlc3Npb24pXG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgdXNlcjogZGF0YS51c2VyLFxuICAgICAgICAgIHNlc3Npb246IGRhdGEuc2Vzc2lvbixcbiAgICAgICAgICAuLi4oZGF0YS53ZWFrX3Bhc3N3b3JkID8geyB3ZWFrUGFzc3dvcmQ6IGRhdGEud2Vha19wYXNzd29yZCB9IDogbnVsbCksXG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yLFxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMb2cgaW4gYW4gZXhpc3RpbmcgdXNlciB2aWEgYSB0aGlyZC1wYXJ0eSBwcm92aWRlci5cbiAgICogVGhpcyBtZXRob2Qgc3VwcG9ydHMgdGhlIFBLQ0UgZmxvdy5cbiAgICovXG4gIGFzeW5jIHNpZ25JbldpdGhPQXV0aChjcmVkZW50aWFsczogU2lnbkluV2l0aE9BdXRoQ3JlZGVudGlhbHMpOiBQcm9taXNlPE9BdXRoUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5faGFuZGxlUHJvdmlkZXJTaWduSW4oY3JlZGVudGlhbHMucHJvdmlkZXIsIHtcbiAgICAgIHJlZGlyZWN0VG86IGNyZWRlbnRpYWxzLm9wdGlvbnM/LnJlZGlyZWN0VG8sXG4gICAgICBzY29wZXM6IGNyZWRlbnRpYWxzLm9wdGlvbnM/LnNjb3BlcyxcbiAgICAgIHF1ZXJ5UGFyYW1zOiBjcmVkZW50aWFscy5vcHRpb25zPy5xdWVyeVBhcmFtcyxcbiAgICAgIHNraXBCcm93c2VyUmVkaXJlY3Q6IGNyZWRlbnRpYWxzLm9wdGlvbnM/LnNraXBCcm93c2VyUmVkaXJlY3QsXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2cgaW4gYW4gZXhpc3RpbmcgdXNlciBieSBleGNoYW5naW5nIGFuIEF1dGggQ29kZSBpc3N1ZWQgZHVyaW5nIHRoZSBQS0NFIGZsb3cuXG4gICAqL1xuICBhc3luYyBleGNoYW5nZUNvZGVGb3JTZXNzaW9uKGF1dGhDb2RlOiBzdHJpbmcpOiBQcm9taXNlPEF1dGhUb2tlblJlc3BvbnNlPiB7XG4gICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZVxuXG4gICAgcmV0dXJuIHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5fZXhjaGFuZ2VDb2RlRm9yU2Vzc2lvbihhdXRoQ29kZSlcbiAgICB9KVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfZXhjaGFuZ2VDb2RlRm9yU2Vzc2lvbihhdXRoQ29kZTogc3RyaW5nKTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YTogeyBzZXNzaW9uOiBTZXNzaW9uOyB1c2VyOiBVc2VyOyByZWRpcmVjdFR5cGU6IHN0cmluZyB8IG51bGwgfVxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwgeyBkYXRhOiB7IHNlc3Npb246IG51bGw7IHVzZXI6IG51bGw7IHJlZGlyZWN0VHlwZTogbnVsbCB9OyBlcnJvcjogQXV0aEVycm9yIH1cbiAgPiB7XG4gICAgY29uc3Qgc3RvcmFnZUl0ZW0gPSBhd2FpdCBnZXRJdGVtQXN5bmModGhpcy5zdG9yYWdlLCBgJHt0aGlzLnN0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgKVxuICAgIGNvbnN0IFtjb2RlVmVyaWZpZXIsIHJlZGlyZWN0VHlwZV0gPSAoKHN0b3JhZ2VJdGVtID8/ICcnKSBhcyBzdHJpbmcpLnNwbGl0KCcvJylcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdChcbiAgICAgIHRoaXMuZmV0Y2gsXG4gICAgICAnUE9TVCcsXG4gICAgICBgJHt0aGlzLnVybH0vdG9rZW4/Z3JhbnRfdHlwZT1wa2NlYCxcbiAgICAgIHtcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgYXV0aF9jb2RlOiBhdXRoQ29kZSxcbiAgICAgICAgICBjb2RlX3ZlcmlmaWVyOiBjb2RlVmVyaWZpZXIsXG4gICAgICAgIH0sXG4gICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgfVxuICAgIClcbiAgICBhd2FpdCByZW1vdmVJdGVtQXN5bmModGhpcy5zdG9yYWdlLCBgJHt0aGlzLnN0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgKVxuICAgIGlmIChlcnJvcikge1xuICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsLCByZWRpcmVjdFR5cGU6IG51bGwgfSwgZXJyb3IgfVxuICAgIH0gZWxzZSBpZiAoIWRhdGEgfHwgIWRhdGEuc2Vzc2lvbiB8fCAhZGF0YS51c2VyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwsIHJlZGlyZWN0VHlwZTogbnVsbCB9LFxuICAgICAgICBlcnJvcjogbmV3IEF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yKCksXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkYXRhLnNlc3Npb24pIHtcbiAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKGRhdGEuc2Vzc2lvbilcbiAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBkYXRhLnNlc3Npb24pXG4gICAgfVxuICAgIHJldHVybiB7IGRhdGE6IHsgLi4uZGF0YSwgcmVkaXJlY3RUeXBlOiByZWRpcmVjdFR5cGUgPz8gbnVsbCB9LCBlcnJvciB9XG4gIH1cblxuICAvKipcbiAgICogQWxsb3dzIHNpZ25pbmcgaW4gd2l0aCBhbiBPSURDIElEIHRva2VuLiBUaGUgYXV0aGVudGljYXRpb24gcHJvdmlkZXIgdXNlZFxuICAgKiBzaG91bGQgYmUgZW5hYmxlZCBhbmQgY29uZmlndXJlZC5cbiAgICovXG4gIGFzeW5jIHNpZ25JbldpdGhJZFRva2VuKGNyZWRlbnRpYWxzOiBTaWduSW5XaXRoSWRUb2tlbkNyZWRlbnRpYWxzKTogUHJvbWlzZTxBdXRoVG9rZW5SZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IG9wdGlvbnMsIHByb3ZpZGVyLCB0b2tlbiwgYWNjZXNzX3Rva2VuLCBub25jZSB9ID0gY3JlZGVudGlhbHNcblxuICAgICAgY29uc3QgcmVzID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vdG9rZW4/Z3JhbnRfdHlwZT1pZF90b2tlbmAsIHtcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgICAgaWRfdG9rZW46IHRva2VuLFxuICAgICAgICAgIGFjY2Vzc190b2tlbixcbiAgICAgICAgICBub25jZSxcbiAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zPy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgfSxcbiAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICB9KVxuXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXNcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfVxuICAgICAgfSBlbHNlIGlmICghZGF0YSB8fCAhZGF0YS5zZXNzaW9uIHx8ICFkYXRhLnVzZXIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSxcbiAgICAgICAgICBlcnJvcjogbmV3IEF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yKCksXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLnNlc3Npb24pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKVxuICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgZGF0YS5zZXNzaW9uKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3IgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMb2cgaW4gYSB1c2VyIHVzaW5nIG1hZ2ljbGluayBvciBhIG9uZS10aW1lIHBhc3N3b3JkIChPVFApLlxuICAgKlxuICAgKiBJZiB0aGUgYHt7IC5Db25maXJtYXRpb25VUkwgfX1gIHZhcmlhYmxlIGlzIHNwZWNpZmllZCBpbiB0aGUgZW1haWwgdGVtcGxhdGUsIGEgbWFnaWNsaW5rIHdpbGwgYmUgc2VudC5cbiAgICogSWYgdGhlIGB7eyAuVG9rZW4gfX1gIHZhcmlhYmxlIGlzIHNwZWNpZmllZCBpbiB0aGUgZW1haWwgdGVtcGxhdGUsIGFuIE9UUCB3aWxsIGJlIHNlbnQuXG4gICAqIElmIHlvdSdyZSB1c2luZyBwaG9uZSBzaWduLWlucywgb25seSBhbiBPVFAgd2lsbCBiZSBzZW50LiBZb3Ugd29uJ3QgYmUgYWJsZSB0byBzZW5kIGEgbWFnaWNsaW5rIGZvciBwaG9uZSBzaWduLWlucy5cbiAgICpcbiAgICogQmUgYXdhcmUgdGhhdCB5b3UgbWF5IGdldCBiYWNrIGFuIGVycm9yIG1lc3NhZ2UgdGhhdCB3aWxsIG5vdCBkaXN0aW5ndWlzaFxuICAgKiBiZXR3ZWVuIHRoZSBjYXNlcyB3aGVyZSB0aGUgYWNjb3VudCBkb2VzIG5vdCBleGlzdCBvciwgdGhhdCB0aGUgYWNjb3VudFxuICAgKiBjYW4gb25seSBiZSBhY2Nlc3NlZCB2aWEgc29jaWFsIGxvZ2luLlxuICAgKlxuICAgKiBEbyBub3RlIHRoYXQgeW91IHdpbGwgbmVlZCB0byBjb25maWd1cmUgYSBXaGF0c2FwcCBzZW5kZXIgb24gVHdpbGlvXG4gICAqIGlmIHlvdSBhcmUgdXNpbmcgcGhvbmUgc2lnbiBpbiB3aXRoIHRoZSAnd2hhdHNhcHAnIGNoYW5uZWwuIFRoZSB3aGF0c2FwcFxuICAgKiBjaGFubmVsIGlzIG5vdCBzdXBwb3J0ZWQgb24gb3RoZXIgcHJvdmlkZXJzXG4gICAqIGF0IHRoaXMgdGltZS5cbiAgICogVGhpcyBtZXRob2Qgc3VwcG9ydHMgUEtDRSB3aGVuIGFuIGVtYWlsIGlzIHBhc3NlZC5cbiAgICovXG4gIGFzeW5jIHNpZ25JbldpdGhPdHAoY3JlZGVudGlhbHM6IFNpZ25JbldpdGhQYXNzd29yZGxlc3NDcmVkZW50aWFscyk6IFByb21pc2U8QXV0aE90cFJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICgnZW1haWwnIGluIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIGNvbnN0IHsgZW1haWwsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzXG4gICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuICAgICAgICBsZXQgY29kZUNoYWxsZW5nZU1ldGhvZDogc3RyaW5nIHwgbnVsbCA9IG51bGxcbiAgICAgICAgaWYgKHRoaXMuZmxvd1R5cGUgPT09ICdwa2NlJykge1xuICAgICAgICAgIDtbY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZF0gPSBhd2FpdCBnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kKFxuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLFxuICAgICAgICAgICAgdGhpcy5zdG9yYWdlS2V5XG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L290cGAsIHtcbiAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgZW1haWwsXG4gICAgICAgICAgICBkYXRhOiBvcHRpb25zPy5kYXRhID8/IHt9LFxuICAgICAgICAgICAgY3JlYXRlX3VzZXI6IG9wdGlvbnM/LnNob3VsZENyZWF0ZVVzZXIgPz8gdHJ1ZSxcbiAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnM/LmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgICAgY29kZV9jaGFsbGVuZ2U6IGNvZGVDaGFsbGVuZ2UsXG4gICAgICAgICAgICBjb2RlX2NoYWxsZW5nZV9tZXRob2Q6IGNvZGVDaGFsbGVuZ2VNZXRob2QsXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zPy5lbWFpbFJlZGlyZWN0VG8sXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9XG4gICAgICBpZiAoJ3Bob25lJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICBjb25zdCB7IHBob25lLCBvcHRpb25zIH0gPSBjcmVkZW50aWFsc1xuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9vdHBgLCB7XG4gICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgIHBob25lLFxuICAgICAgICAgICAgZGF0YTogb3B0aW9ucz8uZGF0YSA/PyB7fSxcbiAgICAgICAgICAgIGNyZWF0ZV91c2VyOiBvcHRpb25zPy5zaG91bGRDcmVhdGVVc2VyID8/IHRydWUsXG4gICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zPy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICAgIGNoYW5uZWw6IG9wdGlvbnM/LmNoYW5uZWwgPz8gJ3NtcycsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsLCBtZXNzYWdlSWQ6IGRhdGE/Lm1lc3NhZ2VfaWQgfSwgZXJyb3IgfVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEF1dGhJbnZhbGlkQ3JlZGVudGlhbHNFcnJvcignWW91IG11c3QgcHJvdmlkZSBlaXRoZXIgYW4gZW1haWwgb3IgcGhvbmUgbnVtYmVyLicpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTG9nIGluIGEgdXNlciBnaXZlbiBhIFVzZXIgc3VwcGxpZWQgT1RQIG9yIFRva2VuSGFzaCByZWNlaXZlZCB0aHJvdWdoIG1vYmlsZSBvciBlbWFpbC5cbiAgICovXG4gIGFzeW5jIHZlcmlmeU90cChwYXJhbXM6IFZlcmlmeU90cFBhcmFtcyk6IFByb21pc2U8QXV0aFJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCByZWRpcmVjdFRvOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWRcbiAgICAgIGxldCBjYXB0Y2hhVG9rZW46IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZFxuICAgICAgaWYgKCdvcHRpb25zJyBpbiBwYXJhbXMpIHtcbiAgICAgICAgcmVkaXJlY3RUbyA9IHBhcmFtcy5vcHRpb25zPy5yZWRpcmVjdFRvXG4gICAgICAgIGNhcHRjaGFUb2tlbiA9IHBhcmFtcy5vcHRpb25zPy5jYXB0Y2hhVG9rZW5cbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3ZlcmlmeWAsIHtcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IGNhcHRjaGFUb2tlbiB9LFxuICAgICAgICB9LFxuICAgICAgICByZWRpcmVjdFRvLFxuICAgICAgICB4Zm9ybTogX3Nlc3Npb25SZXNwb25zZSxcbiAgICAgIH0pXG5cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuXG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbiBlcnJvciBvY2N1cnJlZCBvbiB0b2tlbiB2ZXJpZmljYXRpb24uJylcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2Vzc2lvbjogU2Vzc2lvbiB8IG51bGwgPSBkYXRhLnNlc3Npb25cbiAgICAgIGNvbnN0IHVzZXI6IFVzZXIgPSBkYXRhLnVzZXJcblxuICAgICAgaWYgKHNlc3Npb24/LmFjY2Vzc190b2tlbikge1xuICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihzZXNzaW9uIGFzIFNlc3Npb24pXG4gICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKFxuICAgICAgICAgIHBhcmFtcy50eXBlID09ICdyZWNvdmVyeScgPyAnUEFTU1dPUkRfUkVDT1ZFUlknIDogJ1NJR05FRF9JTicsXG4gICAgICAgICAgc2Vzc2lvblxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlciwgc2Vzc2lvbiB9LCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdHMgYSBzaW5nbGUtc2lnbiBvbiB1c2luZyBhbiBlbnRlcnByaXNlIElkZW50aXR5IFByb3ZpZGVyLiBBXG4gICAqIHN1Y2Nlc3NmdWwgU1NPIGF0dGVtcHQgd2lsbCByZWRpcmVjdCB0aGUgY3VycmVudCBwYWdlIHRvIHRoZSBpZGVudGl0eVxuICAgKiBwcm92aWRlciBhdXRob3JpemF0aW9uIHBhZ2UuIFRoZSByZWRpcmVjdCBVUkwgaXMgaW1wbGVtZW50YXRpb24gYW5kIFNTT1xuICAgKiBwcm90b2NvbCBzcGVjaWZpYy5cbiAgICpcbiAgICogWW91IGNhbiB1c2UgaXQgYnkgcHJvdmlkaW5nIGEgU1NPIGRvbWFpbi4gVHlwaWNhbGx5IHlvdSBjYW4gZXh0cmFjdCB0aGlzXG4gICAqIGRvbWFpbiBieSBhc2tpbmcgdXNlcnMgZm9yIHRoZWlyIGVtYWlsIGFkZHJlc3MuIElmIHRoaXMgZG9tYWluIGlzXG4gICAqIHJlZ2lzdGVyZWQgb24gdGhlIEF1dGggaW5zdGFuY2UgdGhlIHJlZGlyZWN0IHdpbGwgdXNlIHRoYXQgb3JnYW5pemF0aW9uJ3NcbiAgICogY3VycmVudGx5IGFjdGl2ZSBTU08gSWRlbnRpdHkgUHJvdmlkZXIgZm9yIHRoZSBsb2dpbi5cbiAgICpcbiAgICogSWYgeW91IGhhdmUgYnVpbHQgYW4gb3JnYW5pemF0aW9uLXNwZWNpZmljIGxvZ2luIHBhZ2UsIHlvdSBjYW4gdXNlIHRoZVxuICAgKiBvcmdhbml6YXRpb24ncyBTU08gSWRlbnRpdHkgUHJvdmlkZXIgVVVJRCBkaXJlY3RseSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgc2lnbkluV2l0aFNTTyhwYXJhbXM6IFNpZ25JbldpdGhTU08pOiBQcm9taXNlPFNTT1Jlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBjb2RlQ2hhbGxlbmdlOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuICAgICAgbGV0IGNvZGVDaGFsbGVuZ2VNZXRob2Q6IHN0cmluZyB8IG51bGwgPSBudWxsXG4gICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ3BrY2UnKSB7XG4gICAgICAgIDtbY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZF0gPSBhd2FpdCBnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kKFxuICAgICAgICAgIHRoaXMuc3RvcmFnZSxcbiAgICAgICAgICB0aGlzLnN0b3JhZ2VLZXlcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vc3NvYCwge1xuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgLi4uKCdwcm92aWRlcklkJyBpbiBwYXJhbXMgPyB7IHByb3ZpZGVyX2lkOiBwYXJhbXMucHJvdmlkZXJJZCB9IDogbnVsbCksXG4gICAgICAgICAgLi4uKCdkb21haW4nIGluIHBhcmFtcyA/IHsgZG9tYWluOiBwYXJhbXMuZG9tYWluIH0gOiBudWxsKSxcbiAgICAgICAgICByZWRpcmVjdF90bzogcGFyYW1zLm9wdGlvbnM/LnJlZGlyZWN0VG8gPz8gdW5kZWZpbmVkLFxuICAgICAgICAgIC4uLihwYXJhbXM/Lm9wdGlvbnM/LmNhcHRjaGFUb2tlblxuICAgICAgICAgICAgPyB7IGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IHBhcmFtcy5vcHRpb25zLmNhcHRjaGFUb2tlbiB9IH1cbiAgICAgICAgICAgIDogbnVsbCksXG4gICAgICAgICAgc2tpcF9odHRwX3JlZGlyZWN0OiB0cnVlLCAvLyBmZXRjaCBkb2VzIG5vdCBoYW5kbGUgcmVkaXJlY3RzXG4gICAgICAgICAgY29kZV9jaGFsbGVuZ2U6IGNvZGVDaGFsbGVuZ2UsXG4gICAgICAgICAgY29kZV9jaGFsbGVuZ2VfbWV0aG9kOiBjb2RlQ2hhbGxlbmdlTWV0aG9kLFxuICAgICAgICB9LFxuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgIHhmb3JtOiBfc3NvUmVzcG9uc2UsXG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgcmVhdXRoZW50aWNhdGlvbiBPVFAgdG8gdGhlIHVzZXIncyBlbWFpbCBvciBwaG9uZSBudW1iZXIuXG4gICAqIFJlcXVpcmVzIHRoZSB1c2VyIHRvIGJlIHNpZ25lZC1pbi5cbiAgICovXG4gIGFzeW5jIHJlYXV0aGVudGljYXRlKCk6IFByb21pc2U8QXV0aFJlc3BvbnNlPiB7XG4gICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZVxuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fcmVhdXRoZW50aWNhdGUoKVxuICAgIH0pXG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF9yZWF1dGhlbnRpY2F0ZSgpOiBQcm9taXNlPEF1dGhSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBkYXRhOiB7IHNlc3Npb24gfSxcbiAgICAgICAgICBlcnJvcjogc2Vzc2lvbkVycm9yLFxuICAgICAgICB9ID0gcmVzdWx0XG4gICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHRocm93IHNlc3Npb25FcnJvclxuICAgICAgICBpZiAoIXNlc3Npb24pIHRocm93IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpXG5cbiAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS9yZWF1dGhlbnRpY2F0ZWAsIHtcbiAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgand0OiBzZXNzaW9uLmFjY2Vzc190b2tlbixcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlc2VuZHMgYW4gZXhpc3Rpbmcgc2lnbnVwIGNvbmZpcm1hdGlvbiBlbWFpbCwgZW1haWwgY2hhbmdlIGVtYWlsLCBTTVMgT1RQIG9yIHBob25lIGNoYW5nZSBPVFAuXG4gICAqL1xuICBhc3luYyByZXNlbmQoY3JlZGVudGlhbHM6IFJlc2VuZFBhcmFtcyk6IFByb21pc2U8QXV0aE90cFJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGVuZHBvaW50ID0gYCR7dGhpcy51cmx9L3Jlc2VuZGBcbiAgICAgIGlmICgnZW1haWwnIGluIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIGNvbnN0IHsgZW1haWwsIHR5cGUsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzXG4gICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgZW5kcG9pbnQsIHtcbiAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgZW1haWwsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucz8uY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zPy5lbWFpbFJlZGlyZWN0VG8sXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9IGVsc2UgaWYgKCdwaG9uZScgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgY29uc3QgeyBwaG9uZSwgdHlwZSwgb3B0aW9ucyB9ID0gY3JlZGVudGlhbHNcbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBlbmRwb2ludCwge1xuICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICBwaG9uZSxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zPy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwsIG1lc3NhZ2VJZDogZGF0YT8ubWVzc2FnZV9pZCB9LCBlcnJvciB9XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yKFxuICAgICAgICAnWW91IG11c3QgcHJvdmlkZSBlaXRoZXIgYW4gZW1haWwgb3IgcGhvbmUgbnVtYmVyIGFuZCBhIHR5cGUnXG4gICAgICApXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNlc3Npb24sIHJlZnJlc2hpbmcgaXQgaWYgbmVjZXNzYXJ5LlxuICAgKlxuICAgKiBUaGUgc2Vzc2lvbiByZXR1cm5lZCBjYW4gYmUgbnVsbCBpZiB0aGUgc2Vzc2lvbiBpcyBub3QgZGV0ZWN0ZWQgd2hpY2ggY2FuIGhhcHBlbiBpbiB0aGUgZXZlbnQgYSB1c2VyIGlzIG5vdCBzaWduZWQtaW4gb3IgaGFzIGxvZ2dlZCBvdXQuXG4gICAqXG4gICAqICoqSU1QT1JUQU5UOioqIFRoaXMgbWV0aG9kIGxvYWRzIHZhbHVlcyBkaXJlY3RseSBmcm9tIHRoZSBzdG9yYWdlIGF0dGFjaGVkXG4gICAqIHRvIHRoZSBjbGllbnQuIElmIHRoYXQgc3RvcmFnZSBpcyBiYXNlZCBvbiByZXF1ZXN0IGNvb2tpZXMgZm9yIGV4YW1wbGUsXG4gICAqIHRoZSB2YWx1ZXMgaW4gaXQgbWF5IG5vdCBiZSBhdXRoZW50aWMgYW5kIHRoZXJlZm9yZSBpdCdzIHN0cm9uZ2x5IGFkdmlzZWRcbiAgICogYWdhaW5zdCB1c2luZyB0aGlzIG1ldGhvZCBhbmQgaXRzIHJlc3VsdHMgaW4gc3VjaCBjaXJjdW1zdGFuY2VzLiBBIHdhcm5pbmdcbiAgICogd2lsbCBiZSBlbWl0dGVkIGlmIHRoaXMgaXMgZGV0ZWN0ZWQuIFVzZSB7QGxpbmsgI2dldFVzZXIoKX0gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldFNlc3Npb24oKSB7XG4gICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZVxuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgLyoqXG4gICAqIEFjcXVpcmVzIGEgZ2xvYmFsIGxvY2sgYmFzZWQgb24gdGhlIHN0b3JhZ2Uga2V5LlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfYWNxdWlyZUxvY2s8Uj4oYWNxdWlyZVRpbWVvdXQ6IG51bWJlciwgZm46ICgpID0+IFByb21pc2U8Uj4pOiBQcm9taXNlPFI+IHtcbiAgICB0aGlzLl9kZWJ1ZygnI19hY3F1aXJlTG9jaycsICdiZWdpbicsIGFjcXVpcmVUaW1lb3V0KVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLmxvY2tBY3F1aXJlZCkge1xuICAgICAgICBjb25zdCBsYXN0ID0gdGhpcy5wZW5kaW5nSW5Mb2NrLmxlbmd0aFxuICAgICAgICAgID8gdGhpcy5wZW5kaW5nSW5Mb2NrW3RoaXMucGVuZGluZ0luTG9jay5sZW5ndGggLSAxXVxuICAgICAgICAgIDogUHJvbWlzZS5yZXNvbHZlKClcblxuICAgICAgICBjb25zdCByZXN1bHQgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGF3YWl0IGxhc3RcbiAgICAgICAgICByZXR1cm4gYXdhaXQgZm4oKVxuICAgICAgICB9KSgpXG5cbiAgICAgICAgdGhpcy5wZW5kaW5nSW5Mb2NrLnB1c2goXG4gICAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGF3YWl0IHJlc3VsdFxuICAgICAgICAgICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAgICAgICAgIC8vIHdlIGp1c3QgY2FyZSBpZiBpdCBmaW5pc2hlZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKClcbiAgICAgICAgKVxuXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubG9jayhgbG9jazoke3RoaXMuc3RvcmFnZUtleX1gLCBhY3F1aXJlVGltZW91dCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnI19hY3F1aXJlTG9jaycsICdsb2NrIGFjcXVpcmVkIGZvciBzdG9yYWdlIGtleScsIHRoaXMuc3RvcmFnZUtleSlcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMubG9ja0FjcXVpcmVkID0gdHJ1ZVxuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gZm4oKVxuXG4gICAgICAgICAgdGhpcy5wZW5kaW5nSW5Mb2NrLnB1c2goXG4gICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHJlc3VsdFxuICAgICAgICAgICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBqdXN0IGNhcmUgaWYgaXQgZmluaXNoZWRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKVxuICAgICAgICAgIClcblxuICAgICAgICAgIGF3YWl0IHJlc3VsdFxuXG4gICAgICAgICAgLy8ga2VlcCBkcmFpbmluZyB0aGUgcXVldWUgdW50aWwgdGhlcmUncyBub3RoaW5nIHRvIHdhaXQgb25cbiAgICAgICAgICB3aGlsZSAodGhpcy5wZW5kaW5nSW5Mb2NrLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qgd2FpdE9uID0gWy4uLnRoaXMucGVuZGluZ0luTG9ja11cblxuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwod2FpdE9uKVxuXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdJbkxvY2suc3BsaWNlKDAsIHdhaXRPbi5sZW5ndGgpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHJlc3VsdFxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2FjcXVpcmVMb2NrJywgJ2xvY2sgcmVsZWFzZWQgZm9yIHN0b3JhZ2Uga2V5JywgdGhpcy5zdG9yYWdlS2V5KVxuXG4gICAgICAgICAgdGhpcy5sb2NrQWNxdWlyZWQgPSBmYWxzZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLl9kZWJ1ZygnI19hY3F1aXJlTG9jaycsICdlbmQnKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgaW5zdGVhZCBvZiB7QGxpbmsgI2dldFNlc3Npb259IGluc2lkZSB0aGUgbGlicmFyeS4gSXQgaXNcbiAgICogc2VtYW50aWNhbGx5IHVzdWFsbHkgd2hhdCB5b3Ugd2FudCwgYXMgZ2V0dGluZyBhIHNlc3Npb24gaW52b2x2ZXMgc29tZVxuICAgKiBwcm9jZXNzaW5nIGFmdGVyd2FyZHMgdGhhdCByZXF1aXJlcyBvbmx5IG9uZSBjbGllbnQgb3BlcmF0aW5nIG9uIHRoZVxuICAgKiBzZXNzaW9uIGF0IG9uY2UgYWNyb3NzIG11bHRpcGxlIHRhYnMgb3IgcHJvY2Vzc2VzLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfdXNlU2Vzc2lvbjxSPihcbiAgICBmbjogKFxuICAgICAgcmVzdWx0OlxuICAgICAgICB8IHtcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgc2Vzc2lvbjogU2Vzc2lvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgICAgICB9XG4gICAgICAgIHwge1xuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBzZXNzaW9uOiBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvcjogQXV0aEVycm9yXG4gICAgICAgICAgfVxuICAgICAgICB8IHtcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgc2Vzc2lvbjogbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgICAgICB9XG4gICAgKSA9PiBQcm9taXNlPFI+XG4gICk6IFByb21pc2U8Uj4ge1xuICAgIHRoaXMuX2RlYnVnKCcjX3VzZVNlc3Npb24nLCAnYmVnaW4nKVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIHRoZSB1c2Ugb2YgX19sb2FkU2Vzc2lvbiBoZXJlIGlzIHRoZSBvbmx5IGNvcnJlY3QgdXNlIG9mIHRoZSBmdW5jdGlvbiFcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX19sb2FkU2Vzc2lvbigpXG5cbiAgICAgIHJldHVybiBhd2FpdCBmbihyZXN1bHQpXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuX2RlYnVnKCcjX3VzZVNlc3Npb24nLCAnZW5kJylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTkVWRVIgVVNFIERJUkVDVExZIVxuICAgKlxuICAgKiBBbHdheXMgdXNlIHtAbGluayAjX3VzZVNlc3Npb259LlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfX2xvYWRTZXNzaW9uKCk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBzZXNzaW9uOiBTZXNzaW9uXG4gICAgICAgIH1cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHNlc3Npb246IG51bGxcbiAgICAgICAgfVxuICAgICAgICBlcnJvcjogQXV0aEVycm9yXG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBzZXNzaW9uOiBudWxsXG4gICAgICAgIH1cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgPiB7XG4gICAgdGhpcy5fZGVidWcoJyNfX2xvYWRTZXNzaW9uKCknLCAnYmVnaW4nKVxuXG4gICAgaWYgKCF0aGlzLmxvY2tBY3F1aXJlZCkge1xuICAgICAgdGhpcy5fZGVidWcoJyNfX2xvYWRTZXNzaW9uKCknLCAndXNlZCBvdXRzaWRlIG9mIGFuIGFjcXVpcmVkIGxvY2shJywgbmV3IEVycm9yKCkuc3RhY2spXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGxldCBjdXJyZW50U2Vzc2lvbjogU2Vzc2lvbiB8IG51bGwgPSBudWxsXG5cbiAgICAgIGNvbnN0IG1heWJlU2Vzc2lvbiA9IGF3YWl0IGdldEl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSlcblxuICAgICAgdGhpcy5fZGVidWcoJyNnZXRTZXNzaW9uKCknLCAnc2Vzc2lvbiBmcm9tIHN0b3JhZ2UnLCBtYXliZVNlc3Npb24pXG5cbiAgICAgIGlmIChtYXliZVNlc3Npb24gIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzVmFsaWRTZXNzaW9uKG1heWJlU2Vzc2lvbikpIHtcbiAgICAgICAgICBjdXJyZW50U2Vzc2lvbiA9IG1heWJlU2Vzc2lvblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2RlYnVnKCcjZ2V0U2Vzc2lvbigpJywgJ3Nlc3Npb24gZnJvbSBzdG9yYWdlIGlzIG5vdCB2YWxpZCcpXG4gICAgICAgICAgYXdhaXQgdGhpcy5fcmVtb3ZlU2Vzc2lvbigpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFjdXJyZW50U2Vzc2lvbikge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb246IG51bGwgfSwgZXJyb3I6IG51bGwgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBoYXNFeHBpcmVkID0gY3VycmVudFNlc3Npb24uZXhwaXJlc19hdFxuICAgICAgICA/IGN1cnJlbnRTZXNzaW9uLmV4cGlyZXNfYXQgPD0gRGF0ZS5ub3coKSAvIDEwMDBcbiAgICAgICAgOiBmYWxzZVxuXG4gICAgICB0aGlzLl9kZWJ1ZyhcbiAgICAgICAgJyNfX2xvYWRTZXNzaW9uKCknLFxuICAgICAgICBgc2Vzc2lvbiBoYXMke2hhc0V4cGlyZWQgPyAnJyA6ICcgbm90J30gZXhwaXJlZGAsXG4gICAgICAgICdleHBpcmVzX2F0JyxcbiAgICAgICAgY3VycmVudFNlc3Npb24uZXhwaXJlc19hdFxuICAgICAgKVxuXG4gICAgICBpZiAoIWhhc0V4cGlyZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RvcmFnZS5pc1NlcnZlcikge1xuICAgICAgICAgIGxldCBzdXBwcmVzc1dhcm5pbmcgPSB0aGlzLnN1cHByZXNzR2V0U2Vzc2lvbldhcm5pbmdcbiAgICAgICAgICBjb25zdCBwcm94eVNlc3Npb246IFNlc3Npb24gPSBuZXcgUHJveHkoY3VycmVudFNlc3Npb24sIHtcbiAgICAgICAgICAgIGdldDogKHRhcmdldDogYW55LCBwcm9wOiBzdHJpbmcsIHJlY2VpdmVyOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgaWYgKCFzdXBwcmVzc1dhcm5pbmcgJiYgcHJvcCA9PT0gJ3VzZXInKSB7XG4gICAgICAgICAgICAgICAgLy8gb25seSBzaG93IHdhcm5pbmcgd2hlbiB0aGUgdXNlciBvYmplY3QgaXMgYmVpbmcgYWNjZXNzZWQgZnJvbSB0aGUgc2VydmVyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgJ1VzaW5nIHRoZSB1c2VyIG9iamVjdCBhcyByZXR1cm5lZCBmcm9tIHN1cGFiYXNlLmF1dGguZ2V0U2Vzc2lvbigpIG9yIGZyb20gc29tZSBzdXBhYmFzZS5hdXRoLm9uQXV0aFN0YXRlQ2hhbmdlKCkgZXZlbnRzIGNvdWxkIGJlIGluc2VjdXJlISBUaGlzIHZhbHVlIGNvbWVzIGRpcmVjdGx5IGZyb20gdGhlIHN0b3JhZ2UgbWVkaXVtICh1c3VhbGx5IGNvb2tpZXMgb24gdGhlIHNlcnZlcikgYW5kIG1hbnkgbm90IGJlIGF1dGhlbnRpYy4gVXNlIHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpIGluc3RlYWQgd2hpY2ggYXV0aGVudGljYXRlcyB0aGUgZGF0YSBieSBjb250YWN0aW5nIHRoZSBTdXBhYmFzZSBBdXRoIHNlcnZlci4nXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHN1cHByZXNzV2FybmluZyA9IHRydWUgLy8ga2VlcHMgdGhpcyBwcm94eSBpbnN0YW5jZSBmcm9tIGxvZ2dpbmcgYWRkaXRpb25hbCB3YXJuaW5nc1xuICAgICAgICAgICAgICAgIHRoaXMuc3VwcHJlc3NHZXRTZXNzaW9uV2FybmluZyA9IHRydWUgLy8ga2VlcHMgdGhpcyBjbGllbnQncyBmdXR1cmUgcHJveHkgaW5zdGFuY2VzIGZyb20gd2FybmluZ1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9KVxuICAgICAgICAgIGN1cnJlbnRTZXNzaW9uID0gcHJveHlTZXNzaW9uXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb246IGN1cnJlbnRTZXNzaW9uIH0sIGVycm9yOiBudWxsIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBzZXNzaW9uLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fY2FsbFJlZnJlc2hUb2tlbihjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuKVxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbiB9LCBlcnJvcjogbnVsbCB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuX2RlYnVnKCcjX19sb2FkU2Vzc2lvbigpJywgJ2VuZCcpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgdXNlciBkZXRhaWxzIGlmIHRoZXJlIGlzIGFuIGV4aXN0aW5nIHNlc3Npb24uIFRoaXMgbWV0aG9kXG4gICAqIHBlcmZvcm1zIGEgbmV0d29yayByZXF1ZXN0IHRvIHRoZSBTdXBhYmFzZSBBdXRoIHNlcnZlciwgc28gdGhlIHJldHVybmVkXG4gICAqIHZhbHVlIGlzIGF1dGhlbnRpYyBhbmQgY2FuIGJlIHVzZWQgdG8gYmFzZSBhdXRob3JpemF0aW9uIHJ1bGVzIG9uLlxuICAgKlxuICAgKiBAcGFyYW0gand0IFRha2VzIGluIGFuIG9wdGlvbmFsIGFjY2VzcyB0b2tlbiBKV1QuIElmIG5vIEpXVCBpcyBwcm92aWRlZCwgdGhlIEpXVCBmcm9tIHRoZSBjdXJyZW50IHNlc3Npb24gaXMgdXNlZC5cbiAgICovXG4gIGFzeW5jIGdldFVzZXIoand0Pzogc3RyaW5nKTogUHJvbWlzZTxVc2VyUmVzcG9uc2U+IHtcbiAgICBpZiAoand0KSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fZ2V0VXNlcihqd3QpXG4gICAgfVxuXG4gICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZVxuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9nZXRVc2VyKClcbiAgICB9KVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfZ2V0VXNlcihqd3Q/OiBzdHJpbmcpOiBQcm9taXNlPFVzZXJSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoand0KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9L3VzZXJgLCB7XG4gICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgIGp3dDogand0LFxuICAgICAgICAgIHhmb3JtOiBfdXNlclJlc3BvbnNlLFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlc3VsdFxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV0dXJucyBhbiBlcnJvciBpZiB0aGVyZSBpcyBubyBhY2Nlc3NfdG9rZW4gb3IgY3VzdG9tIGF1dGhvcml6YXRpb24gaGVhZGVyXG4gICAgICAgIGlmICghZGF0YS5zZXNzaW9uPy5hY2Nlc3NfdG9rZW4gJiYgIXRoaXMuaGFzQ3VzdG9tQXV0aG9yaXphdGlvbkhlYWRlcikge1xuICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCB9LCBlcnJvcjogbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKCkgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdHRVQnLCBgJHt0aGlzLnVybH0vdXNlcmAsIHtcbiAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgand0OiBkYXRhLnNlc3Npb24/LmFjY2Vzc190b2tlbiA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgeGZvcm06IF91c2VyUmVzcG9uc2UsXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdXNlciBkYXRhIGZvciBhIGxvZ2dlZCBpbiB1c2VyLlxuICAgKi9cbiAgYXN5bmMgdXBkYXRlVXNlcihcbiAgICBhdHRyaWJ1dGVzOiBVc2VyQXR0cmlidXRlcyxcbiAgICBvcHRpb25zOiB7XG4gICAgICBlbWFpbFJlZGlyZWN0VG8/OiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgICB9ID0ge31cbiAgKTogUHJvbWlzZTxVc2VyUmVzcG9uc2U+IHtcbiAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlXG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91cGRhdGVVc2VyKGF0dHJpYnV0ZXMsIG9wdGlvbnMpXG4gICAgfSlcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBfdXBkYXRlVXNlcihcbiAgICBhdHRyaWJ1dGVzOiBVc2VyQXR0cmlidXRlcyxcbiAgICBvcHRpb25zOiB7XG4gICAgICBlbWFpbFJlZGlyZWN0VG8/OiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgICB9ID0ge31cbiAgKTogUHJvbWlzZTxVc2VyUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICBjb25zdCB7IGRhdGE6IHNlc3Npb25EYXRhLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0gPSByZXN1bHRcbiAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgIHRocm93IHNlc3Npb25FcnJvclxuICAgICAgICB9XG4gICAgICAgIGlmICghc2Vzc2lvbkRhdGEuc2Vzc2lvbikge1xuICAgICAgICAgIHRocm93IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpXG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2Vzc2lvbjogU2Vzc2lvbiA9IHNlc3Npb25EYXRhLnNlc3Npb25cbiAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2U6IHN0cmluZyB8IG51bGwgPSBudWxsXG4gICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlTWV0aG9kOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ3BrY2UnICYmIGF0dHJpYnV0ZXMuZW1haWwgIT0gbnVsbCkge1xuICAgICAgICAgIDtbY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZF0gPSBhd2FpdCBnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kKFxuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLFxuICAgICAgICAgICAgdGhpcy5zdG9yYWdlS2V5XG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvcjogdXNlckVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUFVUJywgYCR7dGhpcy51cmx9L3VzZXJgLCB7XG4gICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgIHJlZGlyZWN0VG86IG9wdGlvbnM/LmVtYWlsUmVkaXJlY3RUbyxcbiAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAuLi5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgY29kZV9jaGFsbGVuZ2U6IGNvZGVDaGFsbGVuZ2UsXG4gICAgICAgICAgICBjb2RlX2NoYWxsZW5nZV9tZXRob2Q6IGNvZGVDaGFsbGVuZ2VNZXRob2QsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBqd3Q6IHNlc3Npb24uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgIHhmb3JtOiBfdXNlclJlc3BvbnNlLFxuICAgICAgICB9KVxuICAgICAgICBpZiAodXNlckVycm9yKSB0aHJvdyB1c2VyRXJyb3JcbiAgICAgICAgc2Vzc2lvbi51c2VyID0gZGF0YS51c2VyIGFzIFVzZXJcbiAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oc2Vzc2lvbilcbiAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1VTRVJfVVBEQVRFRCcsIHNlc3Npb24pXG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogc2Vzc2lvbi51c2VyIH0sIGVycm9yOiBudWxsIH1cbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlcyBhIEpXVCAod2l0aG91dCBwZXJmb3JtaW5nIGFueSB2YWxpZGF0aW9uKS5cbiAgICovXG4gIHByaXZhdGUgX2RlY29kZUpXVChqd3Q6IHN0cmluZyk6IHtcbiAgICBleHA/OiBudW1iZXJcbiAgICBhYWw/OiBBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWxzIHwgbnVsbFxuICAgIGFtcj86IEFNUkVudHJ5W10gfCBudWxsXG4gIH0ge1xuICAgIHJldHVybiBkZWNvZGVKV1RQYXlsb2FkKGp3dClcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzZXNzaW9uIGRhdGEgZnJvbSB0aGUgY3VycmVudCBzZXNzaW9uLiBJZiB0aGUgY3VycmVudCBzZXNzaW9uIGlzIGV4cGlyZWQsIHNldFNlc3Npb24gd2lsbCB0YWtlIGNhcmUgb2YgcmVmcmVzaGluZyBpdCB0byBvYnRhaW4gYSBuZXcgc2Vzc2lvbi5cbiAgICogSWYgdGhlIHJlZnJlc2ggdG9rZW4gb3IgYWNjZXNzIHRva2VuIGluIHRoZSBjdXJyZW50IHNlc3Npb24gaXMgaW52YWxpZCwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gICAqIEBwYXJhbSBjdXJyZW50U2Vzc2lvbiBUaGUgY3VycmVudCBzZXNzaW9uIHRoYXQgbWluaW1hbGx5IGNvbnRhaW5zIGFuIGFjY2VzcyB0b2tlbiBhbmQgcmVmcmVzaCB0b2tlbi5cbiAgICovXG4gIGFzeW5jIHNldFNlc3Npb24oY3VycmVudFNlc3Npb246IHtcbiAgICBhY2Nlc3NfdG9rZW46IHN0cmluZ1xuICAgIHJlZnJlc2hfdG9rZW46IHN0cmluZ1xuICB9KTogUHJvbWlzZTxBdXRoUmVzcG9uc2U+IHtcbiAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlXG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9zZXRTZXNzaW9uKGN1cnJlbnRTZXNzaW9uKVxuICAgIH0pXG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgX3NldFNlc3Npb24oY3VycmVudFNlc3Npb246IHtcbiAgICBhY2Nlc3NfdG9rZW46IHN0cmluZ1xuICAgIHJlZnJlc2hfdG9rZW46IHN0cmluZ1xuICB9KTogUHJvbWlzZTxBdXRoUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFjdXJyZW50U2Vzc2lvbi5hY2Nlc3NfdG9rZW4gfHwgIWN1cnJlbnRTZXNzaW9uLnJlZnJlc2hfdG9rZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKClcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGltZU5vdyA9IERhdGUubm93KCkgLyAxMDAwXG4gICAgICBsZXQgZXhwaXJlc0F0ID0gdGltZU5vd1xuICAgICAgbGV0IGhhc0V4cGlyZWQgPSB0cnVlXG4gICAgICBsZXQgc2Vzc2lvbjogU2Vzc2lvbiB8IG51bGwgPSBudWxsXG4gICAgICBjb25zdCBwYXlsb2FkID0gZGVjb2RlSldUUGF5bG9hZChjdXJyZW50U2Vzc2lvbi5hY2Nlc3NfdG9rZW4pXG4gICAgICBpZiAocGF5bG9hZC5leHApIHtcbiAgICAgICAgZXhwaXJlc0F0ID0gcGF5bG9hZC5leHBcbiAgICAgICAgaGFzRXhwaXJlZCA9IGV4cGlyZXNBdCA8PSB0aW1lTm93XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNFeHBpcmVkKSB7XG4gICAgICAgIGNvbnN0IHsgc2Vzc2lvbjogcmVmcmVzaGVkU2Vzc2lvbiwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX2NhbGxSZWZyZXNoVG9rZW4oXG4gICAgICAgICAgY3VycmVudFNlc3Npb24ucmVmcmVzaF90b2tlblxuICAgICAgICApXG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogZXJyb3IgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZWZyZXNoZWRTZXNzaW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBudWxsIH1cbiAgICAgICAgfVxuICAgICAgICBzZXNzaW9uID0gcmVmcmVzaGVkU2Vzc2lvblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fZ2V0VXNlcihjdXJyZW50U2Vzc2lvbi5hY2Nlc3NfdG9rZW4pXG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHRocm93IGVycm9yXG4gICAgICAgIH1cbiAgICAgICAgc2Vzc2lvbiA9IHtcbiAgICAgICAgICBhY2Nlc3NfdG9rZW46IGN1cnJlbnRTZXNzaW9uLmFjY2Vzc190b2tlbixcbiAgICAgICAgICByZWZyZXNoX3Rva2VuOiBjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuLFxuICAgICAgICAgIHVzZXI6IGRhdGEudXNlcixcbiAgICAgICAgICB0b2tlbl90eXBlOiAnYmVhcmVyJyxcbiAgICAgICAgICBleHBpcmVzX2luOiBleHBpcmVzQXQgLSB0aW1lTm93LFxuICAgICAgICAgIGV4cGlyZXNfYXQ6IGV4cGlyZXNBdCxcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihzZXNzaW9uKVxuICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgc2Vzc2lvbilcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBzZXNzaW9uLnVzZXIsIHNlc3Npb24gfSwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbjogbnVsbCwgdXNlcjogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgc2Vzc2lvbiwgcmVnYXJkbGVzcyBvZiBleHBpcnkgc3RhdHVzLlxuICAgKiBUYWtlcyBpbiBhbiBvcHRpb25hbCBjdXJyZW50IHNlc3Npb24uIElmIG5vdCBwYXNzZWQgaW4sIHRoZW4gcmVmcmVzaFNlc3Npb24oKSB3aWxsIGF0dGVtcHQgdG8gcmV0cmlldmUgaXQgZnJvbSBnZXRTZXNzaW9uKCkuXG4gICAqIElmIHRoZSBjdXJyZW50IHNlc3Npb24ncyByZWZyZXNoIHRva2VuIGlzIGludmFsaWQsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICAgKiBAcGFyYW0gY3VycmVudFNlc3Npb24gVGhlIGN1cnJlbnQgc2Vzc2lvbi4gSWYgcGFzc2VkIGluLCBpdCBtdXN0IGNvbnRhaW4gYSByZWZyZXNoIHRva2VuLlxuICAgKi9cbiAgYXN5bmMgcmVmcmVzaFNlc3Npb24oY3VycmVudFNlc3Npb24/OiB7IHJlZnJlc2hfdG9rZW46IHN0cmluZyB9KTogUHJvbWlzZTxBdXRoUmVzcG9uc2U+IHtcbiAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlXG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9yZWZyZXNoU2Vzc2lvbihjdXJyZW50U2Vzc2lvbilcbiAgICB9KVxuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIF9yZWZyZXNoU2Vzc2lvbihjdXJyZW50U2Vzc2lvbj86IHtcbiAgICByZWZyZXNoX3Rva2VuOiBzdHJpbmdcbiAgfSk6IFByb21pc2U8QXV0aFJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgaWYgKCFjdXJyZW50U2Vzc2lvbikge1xuICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlc3VsdFxuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdXJyZW50U2Vzc2lvbiA9IGRhdGEuc2Vzc2lvbiA/PyB1bmRlZmluZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY3VycmVudFNlc3Npb24/LnJlZnJlc2hfdG9rZW4pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBzZXNzaW9uLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fY2FsbFJlZnJlc2hUb2tlbihjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuKVxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3I6IGVycm9yIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogbnVsbCB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IHNlc3Npb24udXNlciwgc2Vzc2lvbiB9LCBlcnJvcjogbnVsbCB9XG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHNlc3Npb24gZGF0YSBmcm9tIGEgVVJMIHN0cmluZ1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfZ2V0U2Vzc2lvbkZyb21VUkwoaXNQS0NFRmxvdzogYm9vbGVhbik6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHsgc2Vzc2lvbjogU2Vzc2lvbjsgcmVkaXJlY3RUeXBlOiBzdHJpbmcgfCBudWxsIH1cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHsgZGF0YTogeyBzZXNzaW9uOiBudWxsOyByZWRpcmVjdFR5cGU6IG51bGwgfTsgZXJyb3I6IEF1dGhFcnJvciB9XG4gID4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIWlzQnJvd3NlcigpKSB0aHJvdyBuZXcgQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yKCdObyBicm93c2VyIGRldGVjdGVkLicpXG4gICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ2ltcGxpY2l0JyAmJiAhdGhpcy5faXNJbXBsaWNpdEdyYW50RmxvdygpKSB7XG4gICAgICAgIHRocm93IG5ldyBBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IoJ05vdCBhIHZhbGlkIGltcGxpY2l0IGdyYW50IGZsb3cgdXJsLicpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZmxvd1R5cGUgPT0gJ3BrY2UnICYmICFpc1BLQ0VGbG93KSB7XG4gICAgICAgIHRocm93IG5ldyBBdXRoUEtDRUdyYW50Q29kZUV4Y2hhbmdlRXJyb3IoJ05vdCBhIHZhbGlkIFBLQ0UgZmxvdyB1cmwuJylcbiAgICAgIH1cblxuICAgICAgY29uc3QgcGFyYW1zID0gcGFyc2VQYXJhbWV0ZXJzRnJvbVVSTCh3aW5kb3cubG9jYXRpb24uaHJlZilcblxuICAgICAgaWYgKGlzUEtDRUZsb3cpIHtcbiAgICAgICAgaWYgKCFwYXJhbXMuY29kZSkgdGhyb3cgbmV3IEF1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvcignTm8gY29kZSBkZXRlY3RlZC4nKVxuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCB0aGlzLl9leGNoYW5nZUNvZGVGb3JTZXNzaW9uKHBhcmFtcy5jb2RlKVxuICAgICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG5cbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTCh3aW5kb3cubG9jYXRpb24uaHJlZilcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5kZWxldGUoJ2NvZGUnKVxuXG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSh3aW5kb3cuaGlzdG9yeS5zdGF0ZSwgJycsIHVybC50b1N0cmluZygpKVxuXG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbjogZGF0YS5zZXNzaW9uLCByZWRpcmVjdFR5cGU6IG51bGwgfSwgZXJyb3I6IG51bGwgfVxuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLmVycm9yIHx8IHBhcmFtcy5lcnJvcl9kZXNjcmlwdGlvbiB8fCBwYXJhbXMuZXJyb3JfY29kZSkge1xuICAgICAgICB0aHJvdyBuZXcgQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yKFxuICAgICAgICAgIHBhcmFtcy5lcnJvcl9kZXNjcmlwdGlvbiB8fCAnRXJyb3IgaW4gVVJMIHdpdGggdW5zcGVjaWZpZWQgZXJyb3JfZGVzY3JpcHRpb24nLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVycm9yOiBwYXJhbXMuZXJyb3IgfHwgJ3Vuc3BlY2lmaWVkX2Vycm9yJyxcbiAgICAgICAgICAgIGNvZGU6IHBhcmFtcy5lcnJvcl9jb2RlIHx8ICd1bnNwZWNpZmllZF9jb2RlJyxcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgY29uc3Qge1xuICAgICAgICBwcm92aWRlcl90b2tlbixcbiAgICAgICAgcHJvdmlkZXJfcmVmcmVzaF90b2tlbixcbiAgICAgICAgYWNjZXNzX3Rva2VuLFxuICAgICAgICByZWZyZXNoX3Rva2VuLFxuICAgICAgICBleHBpcmVzX2luLFxuICAgICAgICBleHBpcmVzX2F0LFxuICAgICAgICB0b2tlbl90eXBlLFxuICAgICAgfSA9IHBhcmFtc1xuXG4gICAgICBpZiAoIWFjY2Vzc190b2tlbiB8fCAhZXhwaXJlc19pbiB8fCAhcmVmcmVzaF90b2tlbiB8fCAhdG9rZW5fdHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yKCdObyBzZXNzaW9uIGRlZmluZWQgaW4gVVJMJylcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGltZU5vdyA9IE1hdGgucm91bmQoRGF0ZS5ub3coKSAvIDEwMDApXG4gICAgICBjb25zdCBleHBpcmVzSW4gPSBwYXJzZUludChleHBpcmVzX2luKVxuICAgICAgbGV0IGV4cGlyZXNBdCA9IHRpbWVOb3cgKyBleHBpcmVzSW5cblxuICAgICAgaWYgKGV4cGlyZXNfYXQpIHtcbiAgICAgICAgZXhwaXJlc0F0ID0gcGFyc2VJbnQoZXhwaXJlc19hdClcbiAgICAgIH1cblxuICAgICAgY29uc3QgYWN0dWFsbHlFeHBpcmVzSW4gPSBleHBpcmVzQXQgLSB0aW1lTm93XG4gICAgICBpZiAoYWN0dWFsbHlFeHBpcmVzSW4gKiAxMDAwIDw9IEFVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBgQHN1cGFiYXNlL2dvdHJ1ZS1qczogU2Vzc2lvbiBhcyByZXRyaWV2ZWQgZnJvbSBVUkwgZXhwaXJlcyBpbiAke2FjdHVhbGx5RXhwaXJlc0lufXMsIHNob3VsZCBoYXZlIGJlZW4gY2xvc2VyIHRvICR7ZXhwaXJlc0lufXNgXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXNzdWVkQXQgPSBleHBpcmVzQXQgLSBleHBpcmVzSW5cbiAgICAgIGlmICh0aW1lTm93IC0gaXNzdWVkQXQgPj0gMTIwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAnQHN1cGFiYXNlL2dvdHJ1ZS1qczogU2Vzc2lvbiBhcyByZXRyaWV2ZWQgZnJvbSBVUkwgd2FzIGlzc3VlZCBvdmVyIDEyMHMgYWdvLCBVUkwgY291bGQgYmUgc3RhbGUnLFxuICAgICAgICAgIGlzc3VlZEF0LFxuICAgICAgICAgIGV4cGlyZXNBdCxcbiAgICAgICAgICB0aW1lTm93XG4gICAgICAgIClcbiAgICAgIH0gZWxzZSBpZiAodGltZU5vdyAtIGlzc3VlZEF0IDwgMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgJ0BzdXBhYmFzZS9nb3RydWUtanM6IFNlc3Npb24gYXMgcmV0cmlldmVkIGZyb20gVVJMIHdhcyBpc3N1ZWQgaW4gdGhlIGZ1dHVyZT8gQ2hlY2sgdGhlIGRldmljZSBjbG9rIGZvciBza2V3JyxcbiAgICAgICAgICBpc3N1ZWRBdCxcbiAgICAgICAgICBleHBpcmVzQXQsXG4gICAgICAgICAgdGltZU5vd1xuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX2dldFVzZXIoYWNjZXNzX3Rva2VuKVxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuXG4gICAgICBjb25zdCBzZXNzaW9uOiBTZXNzaW9uID0ge1xuICAgICAgICBwcm92aWRlcl90b2tlbixcbiAgICAgICAgcHJvdmlkZXJfcmVmcmVzaF90b2tlbixcbiAgICAgICAgYWNjZXNzX3Rva2VuLFxuICAgICAgICBleHBpcmVzX2luOiBleHBpcmVzSW4sXG4gICAgICAgIGV4cGlyZXNfYXQ6IGV4cGlyZXNBdCxcbiAgICAgICAgcmVmcmVzaF90b2tlbixcbiAgICAgICAgdG9rZW5fdHlwZSxcbiAgICAgICAgdXNlcjogZGF0YS51c2VyLFxuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgdG9rZW5zIGZyb20gVVJMXG4gICAgICB3aW5kb3cubG9jYXRpb24uaGFzaCA9ICcnXG4gICAgICB0aGlzLl9kZWJ1ZygnI19nZXRTZXNzaW9uRnJvbVVSTCgpJywgJ2NsZWFyaW5nIHdpbmRvdy5sb2NhdGlvbi5oYXNoJylcblxuICAgICAgcmV0dXJuIHsgZGF0YTogeyBzZXNzaW9uLCByZWRpcmVjdFR5cGU6IHBhcmFtcy50eXBlIH0sIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb246IG51bGwsIHJlZGlyZWN0VHlwZTogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgY3VycmVudCBVUkwgY29udGFpbnMgcGFyYW1ldGVycyBnaXZlbiBieSBhbiBpbXBsaWNpdCBvYXV0aCBncmFudCBmbG93IChodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNjc0OS5odG1sI3NlY3Rpb24tNC4yKVxuICAgKi9cbiAgcHJpdmF0ZSBfaXNJbXBsaWNpdEdyYW50RmxvdygpOiBib29sZWFuIHtcbiAgICBjb25zdCBwYXJhbXMgPSBwYXJzZVBhcmFtZXRlcnNGcm9tVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxuXG4gICAgcmV0dXJuICEhKGlzQnJvd3NlcigpICYmIChwYXJhbXMuYWNjZXNzX3Rva2VuIHx8IHBhcmFtcy5lcnJvcl9kZXNjcmlwdGlvbikpXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IFVSTCBhbmQgYmFja2luZyBzdG9yYWdlIGNvbnRhaW4gcGFyYW1ldGVycyBnaXZlbiBieSBhIFBLQ0UgZmxvd1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfaXNQS0NFRmxvdygpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCBwYXJhbXMgPSBwYXJzZVBhcmFtZXRlcnNGcm9tVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxuXG4gICAgY29uc3QgY3VycmVudFN0b3JhZ2VDb250ZW50ID0gYXdhaXQgZ2V0SXRlbUFzeW5jKFxuICAgICAgdGhpcy5zdG9yYWdlLFxuICAgICAgYCR7dGhpcy5zdG9yYWdlS2V5fS1jb2RlLXZlcmlmaWVyYFxuICAgIClcblxuICAgIHJldHVybiAhIShwYXJhbXMuY29kZSAmJiBjdXJyZW50U3RvcmFnZUNvbnRlbnQpXG4gIH1cblxuICAvKipcbiAgICogSW5zaWRlIGEgYnJvd3NlciBjb250ZXh0LCBgc2lnbk91dCgpYCB3aWxsIHJlbW92ZSB0aGUgbG9nZ2VkIGluIHVzZXIgZnJvbSB0aGUgYnJvd3NlciBzZXNzaW9uIGFuZCBsb2cgdGhlbSBvdXQgLSByZW1vdmluZyBhbGwgaXRlbXMgZnJvbSBsb2NhbHN0b3JhZ2UgYW5kIHRoZW4gdHJpZ2dlciBhIGBcIlNJR05FRF9PVVRcImAgZXZlbnQuXG4gICAqXG4gICAqIEZvciBzZXJ2ZXItc2lkZSBtYW5hZ2VtZW50LCB5b3UgY2FuIHJldm9rZSBhbGwgcmVmcmVzaCB0b2tlbnMgZm9yIGEgdXNlciBieSBwYXNzaW5nIGEgdXNlcidzIEpXVCB0aHJvdWdoIHRvIGBhdXRoLmFwaS5zaWduT3V0KEpXVDogc3RyaW5nKWAuXG4gICAqIFRoZXJlIGlzIG5vIHdheSB0byByZXZva2UgYSB1c2VyJ3MgYWNjZXNzIHRva2VuIGp3dCB1bnRpbCBpdCBleHBpcmVzLiBJdCBpcyByZWNvbW1lbmRlZCB0byBzZXQgYSBzaG9ydGVyIGV4cGlyeSBvbiB0aGUgand0IGZvciB0aGlzIHJlYXNvbi5cbiAgICpcbiAgICogSWYgdXNpbmcgYG90aGVyc2Agc2NvcGUsIG5vIGBTSUdORURfT1VUYCBldmVudCBpcyBmaXJlZCFcbiAgICovXG4gIGFzeW5jIHNpZ25PdXQob3B0aW9uczogU2lnbk91dCA9IHsgc2NvcGU6ICdnbG9iYWwnIH0pOiBQcm9taXNlPHsgZXJyb3I6IEF1dGhFcnJvciB8IG51bGwgfT4ge1xuICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2VcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3NpZ25PdXQob3B0aW9ucylcbiAgICB9KVxuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIF9zaWduT3V0KFxuICAgIHsgc2NvcGUgfTogU2lnbk91dCA9IHsgc2NvcGU6ICdnbG9iYWwnIH1cbiAgKTogUHJvbWlzZTx7IGVycm9yOiBBdXRoRXJyb3IgfCBudWxsIH0+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSA9IHJlc3VsdFxuICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICByZXR1cm4geyBlcnJvcjogc2Vzc2lvbkVycm9yIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gZGF0YS5zZXNzaW9uPy5hY2Nlc3NfdG9rZW5cbiAgICAgIGlmIChhY2Nlc3NUb2tlbikge1xuICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCB0aGlzLmFkbWluLnNpZ25PdXQoYWNjZXNzVG9rZW4sIHNjb3BlKVxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAvLyBpZ25vcmUgNDA0cyBzaW5jZSB1c2VyIG1pZ2h0IG5vdCBleGlzdCBhbnltb3JlXG4gICAgICAgICAgLy8gaWdub3JlIDQwMXMgc2luY2UgYW4gaW52YWxpZCBvciBleHBpcmVkIEpXVCBzaG91bGQgc2lnbiBvdXQgdGhlIGN1cnJlbnQgc2Vzc2lvblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICEoXG4gICAgICAgICAgICAgIGlzQXV0aEFwaUVycm9yKGVycm9yKSAmJlxuICAgICAgICAgICAgICAoZXJyb3Iuc3RhdHVzID09PSA0MDQgfHwgZXJyb3Iuc3RhdHVzID09PSA0MDEgfHwgZXJyb3Iuc3RhdHVzID09PSA0MDMpXG4gICAgICAgICAgICApXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4geyBlcnJvciB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2NvcGUgIT09ICdvdGhlcnMnKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3JlbW92ZVNlc3Npb24oKVxuICAgICAgICBhd2FpdCByZW1vdmVJdGVtQXN5bmModGhpcy5zdG9yYWdlLCBgJHt0aGlzLnN0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgKVxuICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX09VVCcsIG51bGwpXG4gICAgICB9XG4gICAgICByZXR1cm4geyBlcnJvcjogbnVsbCB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNlaXZlIGEgbm90aWZpY2F0aW9uIGV2ZXJ5IHRpbWUgYW4gYXV0aCBldmVudCBoYXBwZW5zLlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgQSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBpbnZva2VkIHdoZW4gYW4gYXV0aCBldmVudCBoYXBwZW5zLlxuICAgKi9cbiAgb25BdXRoU3RhdGVDaGFuZ2UoXG4gICAgY2FsbGJhY2s6IChldmVudDogQXV0aENoYW5nZUV2ZW50LCBzZXNzaW9uOiBTZXNzaW9uIHwgbnVsbCkgPT4gdm9pZCB8IFByb21pc2U8dm9pZD5cbiAgKToge1xuICAgIGRhdGE6IHsgc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb24gfVxuICB9IHtcbiAgICBjb25zdCBpZDogc3RyaW5nID0gdXVpZCgpXG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb24gPSB7XG4gICAgICBpZCxcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgdW5zdWJzY3JpYmU6ICgpID0+IHtcbiAgICAgICAgdGhpcy5fZGVidWcoJyN1bnN1YnNjcmliZSgpJywgJ3N0YXRlIGNoYW5nZSBjYWxsYmFjayB3aXRoIGlkIHJlbW92ZWQnLCBpZClcblxuICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlRW1pdHRlcnMuZGVsZXRlKGlkKVxuICAgICAgfSxcbiAgICB9XG5cbiAgICB0aGlzLl9kZWJ1ZygnI29uQXV0aFN0YXRlQ2hhbmdlKCknLCAncmVnaXN0ZXJlZCBjYWxsYmFjayB3aXRoIGlkJywgaWQpXG5cbiAgICB0aGlzLnN0YXRlQ2hhbmdlRW1pdHRlcnMuc2V0KGlkLCBzdWJzY3JpcHRpb24pXG4gICAgOyhhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlXG5cbiAgICAgIGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2VtaXRJbml0aWFsU2Vzc2lvbihpZClcbiAgICAgIH0pXG4gICAgfSkoKVxuXG4gICAgcmV0dXJuIHsgZGF0YTogeyBzdWJzY3JpcHRpb24gfSB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF9lbWl0SW5pdGlhbFNlc3Npb24oaWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBkYXRhOiB7IHNlc3Npb24gfSxcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgfSA9IHJlc3VsdFxuICAgICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG5cbiAgICAgICAgYXdhaXQgdGhpcy5zdGF0ZUNoYW5nZUVtaXR0ZXJzLmdldChpZCk/LmNhbGxiYWNrKCdJTklUSUFMX1NFU1NJT04nLCBzZXNzaW9uKVxuICAgICAgICB0aGlzLl9kZWJ1ZygnSU5JVElBTF9TRVNTSU9OJywgJ2NhbGxiYWNrIGlkJywgaWQsICdzZXNzaW9uJywgc2Vzc2lvbilcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBhd2FpdCB0aGlzLnN0YXRlQ2hhbmdlRW1pdHRlcnMuZ2V0KGlkKT8uY2FsbGJhY2soJ0lOSVRJQUxfU0VTU0lPTicsIG51bGwpXG4gICAgICAgIHRoaXMuX2RlYnVnKCdJTklUSUFMX1NFU1NJT04nLCAnY2FsbGJhY2sgaWQnLCBpZCwgJ2Vycm9yJywgZXJyKVxuICAgICAgICBjb25zb2xlLmVycm9yKGVycilcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgcGFzc3dvcmQgcmVzZXQgcmVxdWVzdCB0byBhbiBlbWFpbCBhZGRyZXNzLiBUaGlzIG1ldGhvZCBzdXBwb3J0cyB0aGUgUEtDRSBmbG93LlxuICAgKlxuICAgKiBAcGFyYW0gZW1haWwgVGhlIGVtYWlsIGFkZHJlc3Mgb2YgdGhlIHVzZXIuXG4gICAqIEBwYXJhbSBvcHRpb25zLnJlZGlyZWN0VG8gVGhlIFVSTCB0byBzZW5kIHRoZSB1c2VyIHRvIGFmdGVyIHRoZXkgY2xpY2sgdGhlIHBhc3N3b3JkIHJlc2V0IGxpbmsuXG4gICAqIEBwYXJhbSBvcHRpb25zLmNhcHRjaGFUb2tlbiBWZXJpZmljYXRpb24gdG9rZW4gcmVjZWl2ZWQgd2hlbiB0aGUgdXNlciBjb21wbGV0ZXMgdGhlIGNhcHRjaGEgb24gdGhlIHNpdGUuXG4gICAqL1xuICBhc3luYyByZXNldFBhc3N3b3JkRm9yRW1haWwoXG4gICAgZW1haWw6IHN0cmluZyxcbiAgICBvcHRpb25zOiB7XG4gICAgICByZWRpcmVjdFRvPzogc3RyaW5nXG4gICAgICBjYXB0Y2hhVG9rZW4/OiBzdHJpbmdcbiAgICB9ID0ge31cbiAgKTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YToge31cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHsgZGF0YTogbnVsbDsgZXJyb3I6IEF1dGhFcnJvciB9XG4gID4ge1xuICAgIGxldCBjb2RlQ2hhbGxlbmdlOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuICAgIGxldCBjb2RlQ2hhbGxlbmdlTWV0aG9kOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuXG4gICAgaWYgKHRoaXMuZmxvd1R5cGUgPT09ICdwa2NlJykge1xuICAgICAgO1tjb2RlQ2hhbGxlbmdlLCBjb2RlQ2hhbGxlbmdlTWV0aG9kXSA9IGF3YWl0IGdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2QoXG4gICAgICAgIHRoaXMuc3RvcmFnZSxcbiAgICAgICAgdGhpcy5zdG9yYWdlS2V5LFxuICAgICAgICB0cnVlIC8vIGlzUGFzc3dvcmRSZWNvdmVyeVxuICAgICAgKVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3JlY292ZXJgLCB7XG4gICAgICAgIGJvZHk6IHtcbiAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICBjb2RlX2NoYWxsZW5nZTogY29kZUNoYWxsZW5nZSxcbiAgICAgICAgICBjb2RlX2NoYWxsZW5nZV9tZXRob2Q6IGNvZGVDaGFsbGVuZ2VNZXRob2QsXG4gICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgfSxcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zLnJlZGlyZWN0VG8sXG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbGwgdGhlIGlkZW50aXRpZXMgbGlua2VkIHRvIGEgdXNlci5cbiAgICovXG4gIGFzeW5jIGdldFVzZXJJZGVudGl0aWVzKCk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBpZGVudGl0aWVzOiBVc2VySWRlbnRpdHlbXVxuICAgICAgICB9XG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7IGRhdGE6IG51bGw7IGVycm9yOiBBdXRoRXJyb3IgfVxuICA+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5nZXRVc2VyKClcbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcbiAgICAgIHJldHVybiB7IGRhdGE6IHsgaWRlbnRpdGllczogZGF0YS51c2VyLmlkZW50aXRpZXMgPz8gW10gfSwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBMaW5rcyBhbiBvYXV0aCBpZGVudGl0eSB0byBhbiBleGlzdGluZyB1c2VyLlxuICAgKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyB0aGUgUEtDRSBmbG93LlxuICAgKi9cbiAgYXN5bmMgbGlua0lkZW50aXR5KGNyZWRlbnRpYWxzOiBTaWduSW5XaXRoT0F1dGhDcmVkZW50aWFscyk6IFByb21pc2U8T0F1dGhSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gcmVzdWx0XG4gICAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcbiAgICAgICAgY29uc3QgdXJsOiBzdHJpbmcgPSBhd2FpdCB0aGlzLl9nZXRVcmxGb3JQcm92aWRlcihcbiAgICAgICAgICBgJHt0aGlzLnVybH0vdXNlci9pZGVudGl0aWVzL2F1dGhvcml6ZWAsXG4gICAgICAgICAgY3JlZGVudGlhbHMucHJvdmlkZXIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgcmVkaXJlY3RUbzogY3JlZGVudGlhbHMub3B0aW9ucz8ucmVkaXJlY3RUbyxcbiAgICAgICAgICAgIHNjb3BlczogY3JlZGVudGlhbHMub3B0aW9ucz8uc2NvcGVzLFxuICAgICAgICAgICAgcXVlcnlQYXJhbXM6IGNyZWRlbnRpYWxzLm9wdGlvbnM/LnF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgc2tpcEJyb3dzZXJSZWRpcmVjdDogdHJ1ZSxcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdHRVQnLCB1cmwsIHtcbiAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgand0OiBkYXRhLnNlc3Npb24/LmFjY2Vzc190b2tlbiA/PyB1bmRlZmluZWQsXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuICAgICAgaWYgKGlzQnJvd3NlcigpICYmICFjcmVkZW50aWFscy5vcHRpb25zPy5za2lwQnJvd3NlclJlZGlyZWN0KSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24oZGF0YT8udXJsKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZGF0YTogeyBwcm92aWRlcjogY3JlZGVudGlhbHMucHJvdmlkZXIsIHVybDogZGF0YT8udXJsIH0sIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHByb3ZpZGVyOiBjcmVkZW50aWFscy5wcm92aWRlciwgdXJsOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVubGlua3MgYW4gaWRlbnRpdHkgZnJvbSBhIHVzZXIgYnkgZGVsZXRpbmcgaXQuIFRoZSB1c2VyIHdpbGwgbm8gbG9uZ2VyIGJlIGFibGUgdG8gc2lnbiBpbiB3aXRoIHRoYXQgaWRlbnRpdHkgb25jZSBpdCdzIHVubGlua2VkLlxuICAgKi9cbiAgYXN5bmMgdW5saW5rSWRlbnRpdHkoaWRlbnRpdHk6IFVzZXJJZGVudGl0eSk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHt9XG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7IGRhdGE6IG51bGw7IGVycm9yOiBBdXRoRXJyb3IgfVxuICA+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXN1bHRcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QoXG4gICAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgICAnREVMRVRFJyxcbiAgICAgICAgICBgJHt0aGlzLnVybH0vdXNlci9pZGVudGl0aWVzLyR7aWRlbnRpdHkuaWRlbnRpdHlfaWR9YCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBqd3Q6IGRhdGEuc2Vzc2lvbj8uYWNjZXNzX3Rva2VuID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgbmV3IEpXVC5cbiAgICogQHBhcmFtIHJlZnJlc2hUb2tlbiBBIHZhbGlkIHJlZnJlc2ggdG9rZW4gdGhhdCB3YXMgcmV0dXJuZWQgb24gbG9naW4uXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9yZWZyZXNoQWNjZXNzVG9rZW4ocmVmcmVzaFRva2VuOiBzdHJpbmcpOiBQcm9taXNlPEF1dGhSZXNwb25zZT4ge1xuICAgIGNvbnN0IGRlYnVnTmFtZSA9IGAjX3JlZnJlc2hBY2Nlc3NUb2tlbigke3JlZnJlc2hUb2tlbi5zdWJzdHJpbmcoMCwgNSl9Li4uKWBcbiAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdiZWdpbicpXG5cbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RhcnRlZEF0ID0gRGF0ZS5ub3coKVxuXG4gICAgICAvLyB3aWxsIGF0dGVtcHQgdG8gcmVmcmVzaCB0aGUgdG9rZW4gd2l0aCBleHBvbmVudGlhbCBiYWNrb2ZmXG4gICAgICByZXR1cm4gYXdhaXQgcmV0cnlhYmxlKFxuICAgICAgICBhc3luYyAoYXR0ZW1wdCkgPT4ge1xuICAgICAgICAgIGlmIChhdHRlbXB0ID4gMCkge1xuICAgICAgICAgICAgYXdhaXQgc2xlZXAoMjAwICogTWF0aC5wb3coMiwgYXR0ZW1wdCAtIDEpKSAvLyAyMDAsIDQwMCwgODAwLCAuLi5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdyZWZyZXNoaW5nIGF0dGVtcHQnLCBhdHRlbXB0KVxuXG4gICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9cmVmcmVzaF90b2tlbmAsIHtcbiAgICAgICAgICAgIGJvZHk6IHsgcmVmcmVzaF90b2tlbjogcmVmcmVzaFRva2VuIH0sXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICB4Zm9ybTogX3Nlc3Npb25SZXNwb25zZSxcbiAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICAoYXR0ZW1wdCwgZXJyb3IpID0+IHtcbiAgICAgICAgICBjb25zdCBuZXh0QmFja09mZkludGVydmFsID0gMjAwICogTWF0aC5wb3coMiwgYXR0ZW1wdClcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgZXJyb3IgJiZcbiAgICAgICAgICAgIGlzQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IoZXJyb3IpICYmXG4gICAgICAgICAgICAvLyByZXRyeWFibGUgb25seSBpZiB0aGUgcmVxdWVzdCBjYW4gYmUgc2VudCBiZWZvcmUgdGhlIGJhY2tvZmYgb3ZlcmZsb3dzIHRoZSB0aWNrIGR1cmF0aW9uXG4gICAgICAgICAgICBEYXRlLm5vdygpICsgbmV4dEJhY2tPZmZJbnRlcnZhbCAtIHN0YXJ0ZWRBdCA8IEFVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICApXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2Vycm9yJywgZXJyb3IpXG5cbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBzZXNzaW9uOiBudWxsLCB1c2VyOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2VuZCcpXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfaXNWYWxpZFNlc3Npb24obWF5YmVTZXNzaW9uOiB1bmtub3duKTogbWF5YmVTZXNzaW9uIGlzIFNlc3Npb24ge1xuICAgIGNvbnN0IGlzVmFsaWRTZXNzaW9uID1cbiAgICAgIHR5cGVvZiBtYXliZVNlc3Npb24gPT09ICdvYmplY3QnICYmXG4gICAgICBtYXliZVNlc3Npb24gIT09IG51bGwgJiZcbiAgICAgICdhY2Nlc3NfdG9rZW4nIGluIG1heWJlU2Vzc2lvbiAmJlxuICAgICAgJ3JlZnJlc2hfdG9rZW4nIGluIG1heWJlU2Vzc2lvbiAmJlxuICAgICAgJ2V4cGlyZXNfYXQnIGluIG1heWJlU2Vzc2lvblxuXG4gICAgcmV0dXJuIGlzVmFsaWRTZXNzaW9uXG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF9oYW5kbGVQcm92aWRlclNpZ25JbihcbiAgICBwcm92aWRlcjogUHJvdmlkZXIsXG4gICAgb3B0aW9uczoge1xuICAgICAgcmVkaXJlY3RUbz86IHN0cmluZ1xuICAgICAgc2NvcGVzPzogc3RyaW5nXG4gICAgICBxdWVyeVBhcmFtcz86IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH1cbiAgICAgIHNraXBCcm93c2VyUmVkaXJlY3Q/OiBib29sZWFuXG4gICAgfVxuICApIHtcbiAgICBjb25zdCB1cmw6IHN0cmluZyA9IGF3YWl0IHRoaXMuX2dldFVybEZvclByb3ZpZGVyKGAke3RoaXMudXJsfS9hdXRob3JpemVgLCBwcm92aWRlciwge1xuICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucy5yZWRpcmVjdFRvLFxuICAgICAgc2NvcGVzOiBvcHRpb25zLnNjb3BlcyxcbiAgICAgIHF1ZXJ5UGFyYW1zOiBvcHRpb25zLnF1ZXJ5UGFyYW1zLFxuICAgIH0pXG5cbiAgICB0aGlzLl9kZWJ1ZygnI19oYW5kbGVQcm92aWRlclNpZ25JbigpJywgJ3Byb3ZpZGVyJywgcHJvdmlkZXIsICdvcHRpb25zJywgb3B0aW9ucywgJ3VybCcsIHVybClcblxuICAgIC8vIHRyeSB0byBvcGVuIG9uIHRoZSBicm93c2VyXG4gICAgaWYgKGlzQnJvd3NlcigpICYmICFvcHRpb25zLnNraXBCcm93c2VyUmVkaXJlY3QpIHtcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24odXJsKVxuICAgIH1cblxuICAgIHJldHVybiB7IGRhdGE6IHsgcHJvdmlkZXIsIHVybCB9LCBlcnJvcjogbnVsbCB9XG4gIH1cblxuICAvKipcbiAgICogUmVjb3ZlcnMgdGhlIHNlc3Npb24gZnJvbSBMb2NhbFN0b3JhZ2UgYW5kIHJlZnJlc2hlc1xuICAgKiBOb3RlOiB0aGlzIG1ldGhvZCBpcyBhc3luYyB0byBhY2NvbW1vZGF0ZSBmb3IgQXN5bmNTdG9yYWdlIGUuZy4gaW4gUmVhY3QgbmF0aXZlLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfcmVjb3ZlckFuZFJlZnJlc2goKSB7XG4gICAgY29uc3QgZGVidWdOYW1lID0gJyNfcmVjb3ZlckFuZFJlZnJlc2goKSdcbiAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdiZWdpbicpXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgY3VycmVudFNlc3Npb24gPSBhd2FpdCBnZXRJdGVtQXN5bmModGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkpXG4gICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdzZXNzaW9uIGZyb20gc3RvcmFnZScsIGN1cnJlbnRTZXNzaW9uKVxuXG4gICAgICBpZiAoIXRoaXMuX2lzVmFsaWRTZXNzaW9uKGN1cnJlbnRTZXNzaW9uKSkge1xuICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdzZXNzaW9uIGlzIG5vdCB2YWxpZCcpXG4gICAgICAgIGlmIChjdXJyZW50U2Vzc2lvbiAhPT0gbnVsbCkge1xuICAgICAgICAgIGF3YWl0IHRoaXMuX3JlbW92ZVNlc3Npb24oKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRpbWVOb3cgPSBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxMDAwKVxuICAgICAgY29uc3QgZXhwaXJlc1dpdGhNYXJnaW4gPSAoY3VycmVudFNlc3Npb24uZXhwaXJlc19hdCA/PyBJbmZpbml0eSkgPCB0aW1lTm93ICsgRVhQSVJZX01BUkdJTlxuXG4gICAgICB0aGlzLl9kZWJ1ZyhcbiAgICAgICAgZGVidWdOYW1lLFxuICAgICAgICBgc2Vzc2lvbiBoYXMke2V4cGlyZXNXaXRoTWFyZ2luID8gJycgOiAnIG5vdCd9IGV4cGlyZWQgd2l0aCBtYXJnaW4gb2YgJHtFWFBJUllfTUFSR0lOfXNgXG4gICAgICApXG5cbiAgICAgIGlmIChleHBpcmVzV2l0aE1hcmdpbikge1xuICAgICAgICBpZiAodGhpcy5hdXRvUmVmcmVzaFRva2VuICYmIGN1cnJlbnRTZXNzaW9uLnJlZnJlc2hfdG9rZW4pIHtcbiAgICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCB0aGlzLl9jYWxsUmVmcmVzaFRva2VuKGN1cnJlbnRTZXNzaW9uLnJlZnJlc2hfdG9rZW4pXG5cbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpXG5cbiAgICAgICAgICAgIGlmICghaXNBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgdGhpcy5fZGVidWcoXG4gICAgICAgICAgICAgICAgZGVidWdOYW1lLFxuICAgICAgICAgICAgICAgICdyZWZyZXNoIGZhaWxlZCB3aXRoIGEgbm9uLXJldHJ5YWJsZSBlcnJvciwgcmVtb3ZpbmcgdGhlIHNlc3Npb24nLFxuICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcmVtb3ZlU2Vzc2lvbigpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBubyBuZWVkIHRvIHBlcnNpc3QgY3VycmVudFNlc3Npb24gYWdhaW4sIGFzIHdlIGp1c3QgbG9hZGVkIGl0IGZyb21cbiAgICAgICAgLy8gbG9jYWwgc3RvcmFnZTsgcGVyc2lzdGluZyBpdCBhZ2FpbiBtYXkgb3ZlcndyaXRlIGEgdmFsdWUgc2F2ZWQgYnlcbiAgICAgICAgLy8gYW5vdGhlciBjbGllbnQgd2l0aCBhY2Nlc3MgdG8gdGhlIHNhbWUgbG9jYWwgc3RvcmFnZVxuICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgY3VycmVudFNlc3Npb24pXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlcnJvcicsIGVycilcblxuICAgICAgY29uc29sZS5lcnJvcihlcnIpXG4gICAgICByZXR1cm5cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnZW5kJylcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF9jYWxsUmVmcmVzaFRva2VuKHJlZnJlc2hUb2tlbjogc3RyaW5nKTogUHJvbWlzZTxDYWxsUmVmcmVzaFRva2VuUmVzdWx0PiB7XG4gICAgaWYgKCFyZWZyZXNoVG9rZW4pIHtcbiAgICAgIHRocm93IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpXG4gICAgfVxuXG4gICAgLy8gcmVmcmVzaGluZyBpcyBhbHJlYWR5IGluIHByb2dyZXNzXG4gICAgaWYgKHRoaXMucmVmcmVzaGluZ0RlZmVycmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQucHJvbWlzZVxuICAgIH1cblxuICAgIGNvbnN0IGRlYnVnTmFtZSA9IGAjX2NhbGxSZWZyZXNoVG9rZW4oJHtyZWZyZXNoVG9rZW4uc3Vic3RyaW5nKDAsIDUpfS4uLilgXG5cbiAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdiZWdpbicpXG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQ8Q2FsbFJlZnJlc2hUb2tlblJlc3VsdD4oKVxuXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCB0aGlzLl9yZWZyZXNoQWNjZXNzVG9rZW4ocmVmcmVzaFRva2VuKVxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuICAgICAgaWYgKCFkYXRhLnNlc3Npb24pIHRocm93IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpXG5cbiAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKGRhdGEuc2Vzc2lvbilcbiAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdUT0tFTl9SRUZSRVNIRUQnLCBkYXRhLnNlc3Npb24pXG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHsgc2Vzc2lvbjogZGF0YS5zZXNzaW9uLCBlcnJvcjogbnVsbCB9XG5cbiAgICAgIHRoaXMucmVmcmVzaGluZ0RlZmVycmVkLnJlc29sdmUocmVzdWx0KVxuXG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2Vycm9yJywgZXJyb3IpXG5cbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0geyBzZXNzaW9uOiBudWxsLCBlcnJvciB9XG5cbiAgICAgICAgaWYgKCFpc0F1dGhSZXRyeWFibGVGZXRjaEVycm9yKGVycm9yKSkge1xuICAgICAgICAgIGF3YWl0IHRoaXMuX3JlbW92ZVNlc3Npb24oKVxuICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfT1VUJywgbnVsbClcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVmcmVzaGluZ0RlZmVycmVkPy5yZXNvbHZlKHJlc3VsdClcblxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVmcmVzaGluZ0RlZmVycmVkPy5yZWplY3QoZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLnJlZnJlc2hpbmdEZWZlcnJlZCA9IG51bGxcbiAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2VuZCcpXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfbm90aWZ5QWxsU3Vic2NyaWJlcnMoXG4gICAgZXZlbnQ6IEF1dGhDaGFuZ2VFdmVudCxcbiAgICBzZXNzaW9uOiBTZXNzaW9uIHwgbnVsbCxcbiAgICBicm9hZGNhc3QgPSB0cnVlXG4gICkge1xuICAgIGNvbnN0IGRlYnVnTmFtZSA9IGAjX25vdGlmeUFsbFN1YnNjcmliZXJzKCR7ZXZlbnR9KWBcbiAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdiZWdpbicsIHNlc3Npb24sIGBicm9hZGNhc3QgPSAke2Jyb2FkY2FzdH1gKVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLmJyb2FkY2FzdENoYW5uZWwgJiYgYnJvYWRjYXN0KSB7XG4gICAgICAgIHRoaXMuYnJvYWRjYXN0Q2hhbm5lbC5wb3N0TWVzc2FnZSh7IGV2ZW50LCBzZXNzaW9uIH0pXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGVycm9yczogYW55W10gPSBbXVxuICAgICAgY29uc3QgcHJvbWlzZXMgPSBBcnJheS5mcm9tKHRoaXMuc3RhdGVDaGFuZ2VFbWl0dGVycy52YWx1ZXMoKSkubWFwKGFzeW5jICh4KSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgeC5jYWxsYmFjayhldmVudCwgc2Vzc2lvbilcbiAgICAgICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goZSlcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpXG5cbiAgICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVycm9ycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3JzW2ldKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgZXJyb3JzWzBdXG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2VuZCcpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHNldCBjdXJyZW50U2Vzc2lvbiBhbmQgY3VycmVudFVzZXJcbiAgICogcHJvY2VzcyB0byBfc3RhcnRBdXRvUmVmcmVzaFRva2VuIGlmIHBvc3NpYmxlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9zYXZlU2Vzc2lvbihzZXNzaW9uOiBTZXNzaW9uKSB7XG4gICAgdGhpcy5fZGVidWcoJyNfc2F2ZVNlc3Npb24oKScsIHNlc3Npb24pXG4gICAgLy8gX3NhdmVTZXNzaW9uIGlzIGFsd2F5cyBjYWxsZWQgd2hlbmV2ZXIgYSBuZXcgc2Vzc2lvbiBoYXMgYmVlbiBhY3F1aXJlZFxuICAgIC8vIHNvIHdlIGNhbiBzYWZlbHkgc3VwcHJlc3MgdGhlIHdhcm5pbmcgcmV0dXJuZWQgYnkgZnV0dXJlIGdldFNlc3Npb24gY2FsbHNcbiAgICB0aGlzLnN1cHByZXNzR2V0U2Vzc2lvbldhcm5pbmcgPSB0cnVlXG4gICAgYXdhaXQgc2V0SXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5LCBzZXNzaW9uKVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfcmVtb3ZlU2Vzc2lvbigpIHtcbiAgICB0aGlzLl9kZWJ1ZygnI19yZW1vdmVTZXNzaW9uKCknKVxuXG4gICAgYXdhaXQgcmVtb3ZlSXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW55IHJlZ2lzdGVyZWQgdmlzaWJpbGl0eWNoYW5nZSBjYWxsYmFjay5cbiAgICpcbiAgICoge0BzZWUgI3N0YXJ0QXV0b1JlZnJlc2h9XG4gICAqIHtAc2VlICNzdG9wQXV0b1JlZnJlc2h9XG4gICAqL1xuICBwcml2YXRlIF9yZW1vdmVWaXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX2RlYnVnKCcjX3JlbW92ZVZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2soKScpXG5cbiAgICBjb25zdCBjYWxsYmFjayA9IHRoaXMudmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFja1xuICAgIHRoaXMudmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjayA9IG51bGxcblxuICAgIHRyeSB7XG4gICAgICBpZiAoY2FsbGJhY2sgJiYgaXNCcm93c2VyKCkgJiYgd2luZG93Py5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgY2FsbGJhY2spXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcigncmVtb3ZpbmcgdmlzaWJpbGl0eWNoYW5nZSBjYWxsYmFjayBmYWlsZWQnLCBlKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHRoZSBwcml2YXRlIGltcGxlbWVudGF0aW9uIG9mIHtAbGluayAjc3RhcnRBdXRvUmVmcmVzaH0uIFVzZSB0aGlzXG4gICAqIHdpdGhpbiB0aGUgbGlicmFyeS5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX3N0YXJ0QXV0b1JlZnJlc2goKSB7XG4gICAgYXdhaXQgdGhpcy5fc3RvcEF1dG9SZWZyZXNoKClcblxuICAgIHRoaXMuX2RlYnVnKCcjX3N0YXJ0QXV0b1JlZnJlc2goKScpXG5cbiAgICBjb25zdCB0aWNrZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLl9hdXRvUmVmcmVzaFRva2VuVGljaygpLCBBVVRPX1JFRlJFU0hfVElDS19EVVJBVElPTilcbiAgICB0aGlzLmF1dG9SZWZyZXNoVGlja2VyID0gdGlja2VyXG5cbiAgICBpZiAodGlja2VyICYmIHR5cGVvZiB0aWNrZXIgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0aWNrZXIudW5yZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIHRpY2tlciBpcyBhIE5vZGVKUyBUaW1lb3V0IG9iamVjdCB0aGF0IGhhcyBhbiBgdW5yZWZgIG1ldGhvZFxuICAgICAgLy8gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS90aW1lcnMuaHRtbCN0aW1lb3V0dW5yZWZcbiAgICAgIC8vIFdoZW4gYXV0byByZWZyZXNoIGlzIHVzZWQgaW4gTm9kZUpTIChsaWtlIGZvciB0ZXN0aW5nKSB0aGVcbiAgICAgIC8vIGBzZXRJbnRlcnZhbGAgaXMgcHJldmVudGluZyB0aGUgcHJvY2VzcyBmcm9tIGJlaW5nIG1hcmtlZCBhc1xuICAgICAgLy8gZmluaXNoZWQgYW5kIHRlc3RzIHJ1biBlbmRsZXNzbHkuIFRoaXMgY2FuIGJlIHByZXZlbnRlZCBieSBjYWxsaW5nXG4gICAgICAvLyBgdW5yZWYoKWAgb24gdGhlIHJldHVybmVkIG9iamVjdC5cbiAgICAgIHRpY2tlci51bnJlZigpXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgRGVubyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIERlbm8udW5yZWZUaW1lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gc2ltaWxhciBsaWtlIGZvciBOb2RlSlMsIGJ1dCB3aXRoIHRoZSBEZW5vIEFQSVxuICAgICAgLy8gaHR0cHM6Ly9kZW5vLmxhbmQvYXBpQGxhdGVzdD91bnN0YWJsZSZzPURlbm8udW5yZWZUaW1lclxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgRGVuby51bnJlZlRpbWVyKHRpY2tlcilcbiAgICB9XG5cbiAgICAvLyBydW4gdGhlIHRpY2sgaW1tZWRpYXRlbHksIGJ1dCBpbiB0aGUgbmV4dCBwYXNzIG9mIHRoZSBldmVudCBsb29wIHNvIHRoYXRcbiAgICAvLyAjX2luaXRpYWxpemUgY2FuIGJlIGFsbG93ZWQgdG8gY29tcGxldGUgd2l0aG91dCByZWN1cnNpdmVseSB3YWl0aW5nIG9uXG4gICAgLy8gaXRzZWxmXG4gICAgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlXG4gICAgICBhd2FpdCB0aGlzLl9hdXRvUmVmcmVzaFRva2VuVGljaygpXG4gICAgfSwgMClcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHRoZSBwcml2YXRlIGltcGxlbWVudGF0aW9uIG9mIHtAbGluayAjc3RvcEF1dG9SZWZyZXNofS4gVXNlIHRoaXNcbiAgICogd2l0aGluIHRoZSBsaWJyYXJ5LlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfc3RvcEF1dG9SZWZyZXNoKCkge1xuICAgIHRoaXMuX2RlYnVnKCcjX3N0b3BBdXRvUmVmcmVzaCgpJylcblxuICAgIGNvbnN0IHRpY2tlciA9IHRoaXMuYXV0b1JlZnJlc2hUaWNrZXJcbiAgICB0aGlzLmF1dG9SZWZyZXNoVGlja2VyID0gbnVsbFxuXG4gICAgaWYgKHRpY2tlcikge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aWNrZXIpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyBhbiBhdXRvLXJlZnJlc2ggcHJvY2VzcyBpbiB0aGUgYmFja2dyb3VuZC4gVGhlIHNlc3Npb24gaXMgY2hlY2tlZFxuICAgKiBldmVyeSBmZXcgc2Vjb25kcy4gQ2xvc2UgdG8gdGhlIHRpbWUgb2YgZXhwaXJhdGlvbiBhIHByb2Nlc3MgaXMgc3RhcnRlZCB0b1xuICAgKiByZWZyZXNoIHRoZSBzZXNzaW9uLiBJZiByZWZyZXNoaW5nIGZhaWxzIGl0IHdpbGwgYmUgcmV0cmllZCBmb3IgYXMgbG9uZyBhc1xuICAgKiBuZWNlc3NhcnkuXG4gICAqXG4gICAqIElmIHlvdSBzZXQgdGhlIHtAbGluayBHb1RydWVDbGllbnRPcHRpb25zI2F1dG9SZWZyZXNoVG9rZW59IHlvdSBkb24ndCBuZWVkXG4gICAqIHRvIGNhbGwgdGhpcyBmdW5jdGlvbiwgaXQgd2lsbCBiZSBjYWxsZWQgZm9yIHlvdS5cbiAgICpcbiAgICogT24gYnJvd3NlcnMgdGhlIHJlZnJlc2ggcHJvY2VzcyB3b3JrcyBvbmx5IHdoZW4gdGhlIHRhYi93aW5kb3cgaXMgaW4gdGhlXG4gICAqIGZvcmVncm91bmQgdG8gY29uc2VydmUgcmVzb3VyY2VzIGFzIHdlbGwgYXMgcHJldmVudCByYWNlIGNvbmRpdGlvbnMgYW5kXG4gICAqIGZsb29kaW5nIGF1dGggd2l0aCByZXF1ZXN0cy4gSWYgeW91IGNhbGwgdGhpcyBtZXRob2QgYW55IG1hbmFnZWRcbiAgICogdmlzaWJpbGl0eSBjaGFuZ2UgY2FsbGJhY2sgd2lsbCBiZSByZW1vdmVkIGFuZCB5b3UgbXVzdCBtYW5hZ2UgdmlzaWJpbGl0eVxuICAgKiBjaGFuZ2VzIG9uIHlvdXIgb3duLlxuICAgKlxuICAgKiBPbiBub24tYnJvd3NlciBwbGF0Zm9ybXMgdGhlIHJlZnJlc2ggcHJvY2VzcyB3b3JrcyAqY29udGludW91c2x5KiBpbiB0aGVcbiAgICogYmFja2dyb3VuZCwgd2hpY2ggbWF5IG5vdCBiZSBkZXNpcmFibGUuIFlvdSBzaG91bGQgaG9vayBpbnRvIHlvdXJcbiAgICogcGxhdGZvcm0ncyBmb3JlZ3JvdW5kIGluZGljYXRpb24gbWVjaGFuaXNtIGFuZCBjYWxsIHRoZXNlIG1ldGhvZHNcbiAgICogYXBwcm9wcmlhdGVseSB0byBjb25zZXJ2ZSByZXNvdXJjZXMuXG4gICAqXG4gICAqIHtAc2VlICNzdG9wQXV0b1JlZnJlc2h9XG4gICAqL1xuICBhc3luYyBzdGFydEF1dG9SZWZyZXNoKCkge1xuICAgIHRoaXMuX3JlbW92ZVZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2soKVxuICAgIGF3YWl0IHRoaXMuX3N0YXJ0QXV0b1JlZnJlc2goKVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3BzIGFuIGFjdGl2ZSBhdXRvIHJlZnJlc2ggcHJvY2VzcyBydW5uaW5nIGluIHRoZSBiYWNrZ3JvdW5kIChpZiBhbnkpLlxuICAgKlxuICAgKiBJZiB5b3UgY2FsbCB0aGlzIG1ldGhvZCBhbnkgbWFuYWdlZCB2aXNpYmlsaXR5IGNoYW5nZSBjYWxsYmFjayB3aWxsIGJlXG4gICAqIHJlbW92ZWQgYW5kIHlvdSBtdXN0IG1hbmFnZSB2aXNpYmlsaXR5IGNoYW5nZXMgb24geW91ciBvd24uXG4gICAqXG4gICAqIFNlZSB7QGxpbmsgI3N0YXJ0QXV0b1JlZnJlc2h9IGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBhc3luYyBzdG9wQXV0b1JlZnJlc2goKSB7XG4gICAgdGhpcy5fcmVtb3ZlVmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjaygpXG4gICAgYXdhaXQgdGhpcy5fc3RvcEF1dG9SZWZyZXNoKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW5zIHRoZSBhdXRvIHJlZnJlc2ggdG9rZW4gdGljay5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX2F1dG9SZWZyZXNoVG9rZW5UaWNrKCkge1xuICAgIHRoaXMuX2RlYnVnKCcjX2F1dG9SZWZyZXNoVG9rZW5UaWNrKCknLCAnYmVnaW4nKVxuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKDAsIGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpXG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgZGF0YTogeyBzZXNzaW9uIH0sXG4gICAgICAgICAgICAgIH0gPSByZXN1bHRcblxuICAgICAgICAgICAgICBpZiAoIXNlc3Npb24gfHwgIXNlc3Npb24ucmVmcmVzaF90b2tlbiB8fCAhc2Vzc2lvbi5leHBpcmVzX2F0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNfYXV0b1JlZnJlc2hUb2tlblRpY2soKScsICdubyBzZXNzaW9uJylcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIHNlc3Npb24gd2lsbCBleHBpcmUgaW4gdGhpcyBtYW55IHRpY2tzIChvciBoYXMgYWxyZWFkeSBleHBpcmVkIGlmIDw9IDApXG4gICAgICAgICAgICAgIGNvbnN0IGV4cGlyZXNJblRpY2tzID0gTWF0aC5mbG9vcihcbiAgICAgICAgICAgICAgICAoc2Vzc2lvbi5leHBpcmVzX2F0ICogMTAwMCAtIG5vdykgLyBBVVRPX1JFRlJFU0hfVElDS19EVVJBVElPTlxuICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgICAgdGhpcy5fZGVidWcoXG4gICAgICAgICAgICAgICAgJyNfYXV0b1JlZnJlc2hUb2tlblRpY2soKScsXG4gICAgICAgICAgICAgICAgYGFjY2VzcyB0b2tlbiBleHBpcmVzIGluICR7ZXhwaXJlc0luVGlja3N9IHRpY2tzLCBhIHRpY2sgbGFzdHMgJHtBVVRPX1JFRlJFU0hfVElDS19EVVJBVElPTn1tcywgcmVmcmVzaCB0aHJlc2hvbGQgaXMgJHtBVVRPX1JFRlJFU0hfVElDS19USFJFU0hPTER9IHRpY2tzYFxuICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgICAgaWYgKGV4cGlyZXNJblRpY2tzIDw9IEFVVE9fUkVGUkVTSF9USUNLX1RIUkVTSE9MRCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2NhbGxSZWZyZXNoVG9rZW4oc2Vzc2lvbi5yZWZyZXNoX3Rva2VuKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgJ0F1dG8gcmVmcmVzaCB0aWNrIGZhaWxlZCB3aXRoIGVycm9yLiBUaGlzIGlzIGxpa2VseSBhIHRyYW5zaWVudCBlcnJvci4nLFxuICAgICAgICAgICAgICBlXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2F1dG9SZWZyZXNoVG9rZW5UaWNrKCknLCAnZW5kJylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgIGlmIChlLmlzQWNxdWlyZVRpbWVvdXQgfHwgZSBpbnN0YW5jZW9mIExvY2tBY3F1aXJlVGltZW91dEVycm9yKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCdhdXRvIHJlZnJlc2ggdG9rZW4gdGljayBsb2NrIG5vdCBhdmFpbGFibGUnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgY2FsbGJhY2tzIG9uIHRoZSBicm93c2VyIC8gcGxhdGZvcm0sIHdoaWNoIGluLXR1cm4gcnVuXG4gICAqIGFsZ29yaXRobXMgd2hlbiB0aGUgYnJvd3NlciB3aW5kb3cvdGFiIGFyZSBpbiBmb3JlZ3JvdW5kLiBPbiBub24tYnJvd3NlclxuICAgKiBwbGF0Zm9ybXMgaXQgYXNzdW1lcyBhbHdheXMgZm9yZWdyb3VuZC5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX2hhbmRsZVZpc2liaWxpdHlDaGFuZ2UoKSB7XG4gICAgdGhpcy5fZGVidWcoJyNfaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSgpJylcblxuICAgIGlmICghaXNCcm93c2VyKCkgfHwgIXdpbmRvdz8uYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgaWYgKHRoaXMuYXV0b1JlZnJlc2hUb2tlbikge1xuICAgICAgICAvLyBpbiBub24tYnJvd3NlciBlbnZpcm9ubWVudHMgdGhlIHJlZnJlc2ggdG9rZW4gdGlja2VyIHJ1bnMgYWx3YXlzXG4gICAgICAgIHRoaXMuc3RhcnRBdXRvUmVmcmVzaCgpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB0aGlzLnZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2sgPSBhc3luYyAoKSA9PiBhd2FpdCB0aGlzLl9vblZpc2liaWxpdHlDaGFuZ2VkKGZhbHNlKVxuXG4gICAgICB3aW5kb3c/LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCB0aGlzLnZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2spXG5cbiAgICAgIC8vIG5vdyBpbW1lZGlhdGVseSBjYWxsIHRoZSB2aXNiaWxpdHkgY2hhbmdlZCBjYWxsYmFjayB0byBzZXR1cCB3aXRoIHRoZVxuICAgICAgLy8gY3VycmVudCB2aXNiaWxpdHkgc3RhdGVcbiAgICAgIGF3YWl0IHRoaXMuX29uVmlzaWJpbGl0eUNoYW5nZWQodHJ1ZSkgLy8gaW5pdGlhbCBjYWxsXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ19oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlJywgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIHJlZ2lzdGVyZWQgd2l0aCBgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnKWAuXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9vblZpc2liaWxpdHlDaGFuZ2VkKGNhbGxlZEZyb21Jbml0aWFsaXplOiBib29sZWFuKSB7XG4gICAgY29uc3QgbWV0aG9kTmFtZSA9IGAjX29uVmlzaWJpbGl0eUNoYW5nZWQoJHtjYWxsZWRGcm9tSW5pdGlhbGl6ZX0pYFxuICAgIHRoaXMuX2RlYnVnKG1ldGhvZE5hbWUsICd2aXNpYmlsaXR5U3RhdGUnLCBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUpXG5cbiAgICBpZiAoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAndmlzaWJsZScpIHtcbiAgICAgIGlmICh0aGlzLmF1dG9SZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgLy8gaW4gYnJvd3NlciBlbnZpcm9ubWVudHMgdGhlIHJlZnJlc2ggdG9rZW4gdGlja2VyIHJ1bnMgb25seSBvbiBmb2N1c2VkIHRhYnNcbiAgICAgICAgLy8gd2hpY2ggcHJldmVudHMgcmFjZSBjb25kaXRpb25zXG4gICAgICAgIHRoaXMuX3N0YXJ0QXV0b1JlZnJlc2goKVxuICAgICAgfVxuXG4gICAgICBpZiAoIWNhbGxlZEZyb21Jbml0aWFsaXplKSB7XG4gICAgICAgIC8vIGNhbGxlZCB3aGVuIHRoZSB2aXNpYmlsaXR5IGhhcyBjaGFuZ2VkLCBpLmUuIHRoZSBicm93c2VyXG4gICAgICAgIC8vIHRyYW5zaXRpb25lZCBmcm9tIGhpZGRlbiAtPiB2aXNpYmxlIHNvIHdlIG5lZWQgdG8gc2VlIGlmIHRoZSBzZXNzaW9uXG4gICAgICAgIC8vIHNob3VsZCBiZSByZWNvdmVyZWQgaW1tZWRpYXRlbHkuLi4gYnV0IHRvIGRvIHRoYXQgd2UgbmVlZCB0byBhY3F1aXJlXG4gICAgICAgIC8vIHRoZSBsb2NrIGZpcnN0IGFzeW5jaHJvbm91c2x5XG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2VcblxuICAgICAgICBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGlmIChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgIT09ICd2aXNpYmxlJykge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoXG4gICAgICAgICAgICAgIG1ldGhvZE5hbWUsXG4gICAgICAgICAgICAgICdhY3F1aXJlZCB0aGUgbG9jayB0byByZWNvdmVyIHRoZSBzZXNzaW9uLCBidXQgdGhlIGJyb3dzZXIgdmlzaWJpbGl0eVN0YXRlIGlzIG5vIGxvbmdlciB2aXNpYmxlLCBhYm9ydGluZydcbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgLy8gdmlzaWJpbGl0eSBoYXMgY2hhbmdlZCB3aGlsZSB3YWl0aW5nIGZvciB0aGUgbG9jaywgYWJvcnRcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHJlY292ZXIgdGhlIHNlc3Npb25cbiAgICAgICAgICBhd2FpdCB0aGlzLl9yZWNvdmVyQW5kUmVmcmVzaCgpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICdoaWRkZW4nKSB7XG4gICAgICBpZiAodGhpcy5hdXRvUmVmcmVzaFRva2VuKSB7XG4gICAgICAgIHRoaXMuX3N0b3BBdXRvUmVmcmVzaCgpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB0aGUgcmVsZXZhbnQgbG9naW4gVVJMIGZvciBhIHRoaXJkLXBhcnR5IHByb3ZpZGVyLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5yZWRpcmVjdFRvIEEgVVJMIG9yIG1vYmlsZSBhZGRyZXNzIHRvIHNlbmQgdGhlIHVzZXIgdG8gYWZ0ZXIgdGhleSBhcmUgY29uZmlybWVkLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5zY29wZXMgQSBzcGFjZS1zZXBhcmF0ZWQgbGlzdCBvZiBzY29wZXMgZ3JhbnRlZCB0byB0aGUgT0F1dGggYXBwbGljYXRpb24uXG4gICAqIEBwYXJhbSBvcHRpb25zLnF1ZXJ5UGFyYW1zIEFuIG9iamVjdCBvZiBrZXktdmFsdWUgcGFpcnMgY29udGFpbmluZyBxdWVyeSBwYXJhbWV0ZXJzIGdyYW50ZWQgdG8gdGhlIE9BdXRoIGFwcGxpY2F0aW9uLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfZ2V0VXJsRm9yUHJvdmlkZXIoXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgcHJvdmlkZXI6IFByb3ZpZGVyLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIHJlZGlyZWN0VG8/OiBzdHJpbmdcbiAgICAgIHNjb3Blcz86IHN0cmluZ1xuICAgICAgcXVlcnlQYXJhbXM/OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9XG4gICAgICBza2lwQnJvd3NlclJlZGlyZWN0PzogYm9vbGVhblxuICAgIH1cbiAgKSB7XG4gICAgY29uc3QgdXJsUGFyYW1zOiBzdHJpbmdbXSA9IFtgcHJvdmlkZXI9JHtlbmNvZGVVUklDb21wb25lbnQocHJvdmlkZXIpfWBdXG4gICAgaWYgKG9wdGlvbnM/LnJlZGlyZWN0VG8pIHtcbiAgICAgIHVybFBhcmFtcy5wdXNoKGByZWRpcmVjdF90bz0ke2VuY29kZVVSSUNvbXBvbmVudChvcHRpb25zLnJlZGlyZWN0VG8pfWApXG4gICAgfVxuICAgIGlmIChvcHRpb25zPy5zY29wZXMpIHtcbiAgICAgIHVybFBhcmFtcy5wdXNoKGBzY29wZXM9JHtlbmNvZGVVUklDb21wb25lbnQob3B0aW9ucy5zY29wZXMpfWApXG4gICAgfVxuICAgIGlmICh0aGlzLmZsb3dUeXBlID09PSAncGtjZScpIHtcbiAgICAgIGNvbnN0IFtjb2RlQ2hhbGxlbmdlLCBjb2RlQ2hhbGxlbmdlTWV0aG9kXSA9IGF3YWl0IGdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2QoXG4gICAgICAgIHRoaXMuc3RvcmFnZSxcbiAgICAgICAgdGhpcy5zdG9yYWdlS2V5XG4gICAgICApXG5cbiAgICAgIGNvbnN0IGZsb3dQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgY29kZV9jaGFsbGVuZ2U6IGAke2VuY29kZVVSSUNvbXBvbmVudChjb2RlQ2hhbGxlbmdlKX1gLFxuICAgICAgICBjb2RlX2NoYWxsZW5nZV9tZXRob2Q6IGAke2VuY29kZVVSSUNvbXBvbmVudChjb2RlQ2hhbGxlbmdlTWV0aG9kKX1gLFxuICAgICAgfSlcbiAgICAgIHVybFBhcmFtcy5wdXNoKGZsb3dQYXJhbXMudG9TdHJpbmcoKSlcbiAgICB9XG4gICAgaWYgKG9wdGlvbnM/LnF1ZXJ5UGFyYW1zKSB7XG4gICAgICBjb25zdCBxdWVyeSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMob3B0aW9ucy5xdWVyeVBhcmFtcylcbiAgICAgIHVybFBhcmFtcy5wdXNoKHF1ZXJ5LnRvU3RyaW5nKCkpXG4gICAgfVxuICAgIGlmIChvcHRpb25zPy5za2lwQnJvd3NlclJlZGlyZWN0KSB7XG4gICAgICB1cmxQYXJhbXMucHVzaChgc2tpcF9odHRwX3JlZGlyZWN0PSR7b3B0aW9ucy5za2lwQnJvd3NlclJlZGlyZWN0fWApXG4gICAgfVxuXG4gICAgcmV0dXJuIGAke3VybH0/JHt1cmxQYXJhbXMuam9pbignJicpfWBcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX3VuZW5yb2xsKHBhcmFtczogTUZBVW5lbnJvbGxQYXJhbXMpOiBQcm9taXNlPEF1dGhNRkFVbmVucm9sbFJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgY29uc3QgeyBkYXRhOiBzZXNzaW9uRGF0YSwgZXJyb3I6IHNlc3Npb25FcnJvciB9ID0gcmVzdWx0XG4gICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogc2Vzc2lvbkVycm9yIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnREVMRVRFJywgYCR7dGhpcy51cmx9L2ZhY3RvcnMvJHtwYXJhbXMuZmFjdG9ySWR9YCwge1xuICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICBqd3Q6IHNlc3Npb25EYXRhPy5zZXNzaW9uPy5hY2Nlc3NfdG9rZW4sXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIEdvVHJ1ZU1GQUFwaSNlbnJvbGx9XG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9lbnJvbGwocGFyYW1zOiBNRkFFbnJvbGxQYXJhbXMpOiBQcm9taXNlPEF1dGhNRkFFbnJvbGxSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZGF0YTogc2Vzc2lvbkRhdGEsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSA9IHJlc3VsdFxuICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IHNlc3Npb25FcnJvciB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9mYWN0b3JzYCwge1xuICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgIGZyaWVuZGx5X25hbWU6IHBhcmFtcy5mcmllbmRseU5hbWUsXG4gICAgICAgICAgICBmYWN0b3JfdHlwZTogcGFyYW1zLmZhY3RvclR5cGUsXG4gICAgICAgICAgICBpc3N1ZXI6IHBhcmFtcy5pc3N1ZXIsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgand0OiBzZXNzaW9uRGF0YT8uc2Vzc2lvbj8uYWNjZXNzX3Rva2VuLFxuICAgICAgICB9KVxuXG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhPy50b3RwPy5xcl9jb2RlKSB7XG4gICAgICAgICAgZGF0YS50b3RwLnFyX2NvZGUgPSBgZGF0YTppbWFnZS9zdmcreG1sO3V0Zi04LCR7ZGF0YS50b3RwLnFyX2NvZGV9YFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfVxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiB7QHNlZSBHb1RydWVNRkFBcGkjdmVyaWZ5fVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfdmVyaWZ5KHBhcmFtczogTUZBVmVyaWZ5UGFyYW1zKTogUHJvbWlzZTxBdXRoTUZBVmVyaWZ5UmVzcG9uc2U+IHtcbiAgICByZXR1cm4gdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICBjb25zdCB7IGRhdGE6IHNlc3Npb25EYXRhLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0gPSByZXN1bHRcbiAgICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogc2Vzc2lvbkVycm9yIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdChcbiAgICAgICAgICAgIHRoaXMuZmV0Y2gsXG4gICAgICAgICAgICAnUE9TVCcsXG4gICAgICAgICAgICBgJHt0aGlzLnVybH0vZmFjdG9ycy8ke3BhcmFtcy5mYWN0b3JJZH0vdmVyaWZ5YCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgYm9keTogeyBjb2RlOiBwYXJhbXMuY29kZSwgY2hhbGxlbmdlX2lkOiBwYXJhbXMuY2hhbGxlbmdlSWQgfSxcbiAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICBqd3Q6IHNlc3Npb25EYXRhPy5zZXNzaW9uPy5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKHtcbiAgICAgICAgICAgIGV4cGlyZXNfYXQ6IE1hdGgucm91bmQoRGF0ZS5ub3coKSAvIDEwMDApICsgZGF0YS5leHBpcmVzX2luLFxuICAgICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICB9KVxuICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdNRkFfQ0hBTExFTkdFX1ZFUklGSUVEJywgZGF0YSlcblxuICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yIH1cbiAgICAgICAgfSlcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIEdvVHJ1ZU1GQUFwaSNjaGFsbGVuZ2V9XG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9jaGFsbGVuZ2UocGFyYW1zOiBNRkFDaGFsbGVuZ2VQYXJhbXMpOiBQcm9taXNlPEF1dGhNRkFDaGFsbGVuZ2VSZXNwb25zZT4ge1xuICAgIHJldHVybiB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgZGF0YTogc2Vzc2lvbkRhdGEsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSA9IHJlc3VsdFxuICAgICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBzZXNzaW9uRXJyb3IgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdChcbiAgICAgICAgICAgIHRoaXMuZmV0Y2gsXG4gICAgICAgICAgICAnUE9TVCcsXG4gICAgICAgICAgICBgJHt0aGlzLnVybH0vZmFjdG9ycy8ke3BhcmFtcy5mYWN0b3JJZH0vY2hhbGxlbmdlYCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICBqd3Q6IHNlc3Npb25EYXRhPy5zZXNzaW9uPy5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuICAgICAgICB9KVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICoge0BzZWUgR29UcnVlTUZBQXBpI2NoYWxsZW5nZUFuZFZlcmlmeX1cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX2NoYWxsZW5nZUFuZFZlcmlmeShcbiAgICBwYXJhbXM6IE1GQUNoYWxsZW5nZUFuZFZlcmlmeVBhcmFtc1xuICApOiBQcm9taXNlPEF1dGhNRkFWZXJpZnlSZXNwb25zZT4ge1xuICAgIC8vIGJvdGggX2NoYWxsZW5nZSBhbmQgX3ZlcmlmeSBpbmRlcGVuZGVudGx5IGFjcXVpcmUgdGhlIGxvY2ssIHNvIG5vIG5lZWRcbiAgICAvLyB0byBhY3F1aXJlIGl0IGhlcmVcblxuICAgIGNvbnN0IHsgZGF0YTogY2hhbGxlbmdlRGF0YSwgZXJyb3I6IGNoYWxsZW5nZUVycm9yIH0gPSBhd2FpdCB0aGlzLl9jaGFsbGVuZ2Uoe1xuICAgICAgZmFjdG9ySWQ6IHBhcmFtcy5mYWN0b3JJZCxcbiAgICB9KVxuICAgIGlmIChjaGFsbGVuZ2VFcnJvcikge1xuICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IGNoYWxsZW5nZUVycm9yIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fdmVyaWZ5KHtcbiAgICAgIGZhY3RvcklkOiBwYXJhbXMuZmFjdG9ySWQsXG4gICAgICBjaGFsbGVuZ2VJZDogY2hhbGxlbmdlRGF0YS5pZCxcbiAgICAgIGNvZGU6IHBhcmFtcy5jb2RlLFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICoge0BzZWUgR29UcnVlTUZBQXBpI2xpc3RGYWN0b3JzfVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfbGlzdEZhY3RvcnMoKTogUHJvbWlzZTxBdXRoTUZBTGlzdEZhY3RvcnNSZXNwb25zZT4ge1xuICAgIC8vIHVzZSAjZ2V0VXNlciBpbnN0ZWFkIG9mICNfZ2V0VXNlciBhcyB0aGUgZm9ybWVyIGFjcXVpcmVzIGEgbG9ja1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGE6IHsgdXNlciB9LFxuICAgICAgZXJyb3I6IHVzZXJFcnJvcixcbiAgICB9ID0gYXdhaXQgdGhpcy5nZXRVc2VyKClcbiAgICBpZiAodXNlckVycm9yKSB7XG4gICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogdXNlckVycm9yIH1cbiAgICB9XG5cbiAgICBjb25zdCBmYWN0b3JzID0gdXNlcj8uZmFjdG9ycyB8fCBbXVxuICAgIGNvbnN0IHRvdHAgPSBmYWN0b3JzLmZpbHRlcihcbiAgICAgIChmYWN0b3IpID0+IGZhY3Rvci5mYWN0b3JfdHlwZSA9PT0gJ3RvdHAnICYmIGZhY3Rvci5zdGF0dXMgPT09ICd2ZXJpZmllZCdcbiAgICApXG5cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YToge1xuICAgICAgICBhbGw6IGZhY3RvcnMsXG4gICAgICAgIHRvdHAsXG4gICAgICB9LFxuICAgICAgZXJyb3I6IG51bGwsXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIEdvVHJ1ZU1GQUFwaSNnZXRBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWx9XG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9nZXRBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWwoKTogUHJvbWlzZTxBdXRoTUZBR2V0QXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVsUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGRhdGE6IHsgc2Vzc2lvbiB9LFxuICAgICAgICAgIGVycm9yOiBzZXNzaW9uRXJyb3IsXG4gICAgICAgIH0gPSByZXN1bHRcbiAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBzZXNzaW9uRXJyb3IgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiB7IGN1cnJlbnRMZXZlbDogbnVsbCwgbmV4dExldmVsOiBudWxsLCBjdXJyZW50QXV0aGVudGljYXRpb25NZXRob2RzOiBbXSB9LFxuICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHRoaXMuX2RlY29kZUpXVChzZXNzaW9uLmFjY2Vzc190b2tlbilcblxuICAgICAgICBsZXQgY3VycmVudExldmVsOiBBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWxzIHwgbnVsbCA9IG51bGxcblxuICAgICAgICBpZiAocGF5bG9hZC5hYWwpIHtcbiAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBwYXlsb2FkLmFhbFxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG5leHRMZXZlbDogQXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVscyB8IG51bGwgPSBjdXJyZW50TGV2ZWxcblxuICAgICAgICBjb25zdCB2ZXJpZmllZEZhY3RvcnMgPVxuICAgICAgICAgIHNlc3Npb24udXNlci5mYWN0b3JzPy5maWx0ZXIoKGZhY3RvcjogRmFjdG9yKSA9PiBmYWN0b3Iuc3RhdHVzID09PSAndmVyaWZpZWQnKSA/PyBbXVxuXG4gICAgICAgIGlmICh2ZXJpZmllZEZhY3RvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIG5leHRMZXZlbCA9ICdhYWwyJ1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY3VycmVudEF1dGhlbnRpY2F0aW9uTWV0aG9kcyA9IHBheWxvYWQuYW1yIHx8IFtdXG5cbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBjdXJyZW50TGV2ZWwsIG5leHRMZXZlbCwgY3VycmVudEF1dGhlbnRpY2F0aW9uTWV0aG9kcyB9LCBlcnJvcjogbnVsbCB9XG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cbiIsImltcG9ydCB7IHN1cHBvcnRzTG9jYWxTdG9yYWdlIH0gZnJvbSAnLi9oZWxwZXJzJztcbi8qKlxuICogUHJvdmlkZXMgc2FmZSBhY2Nlc3MgdG8gdGhlIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlIHByb3BlcnR5LlxuICovXG5leHBvcnQgY29uc3QgbG9jYWxTdG9yYWdlQWRhcHRlciA9IHtcbiAgICBnZXRJdGVtOiAoa2V5KSA9PiB7XG4gICAgICAgIGlmICghc3VwcG9ydHNMb2NhbFN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICB9LFxuICAgIHNldEl0ZW06IChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICghc3VwcG9ydHNMb2NhbFN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG4gICAgfSxcbiAgICByZW1vdmVJdGVtOiAoa2V5KSA9PiB7XG4gICAgICAgIGlmICghc3VwcG9ydHNMb2NhbFN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICB9LFxufTtcbi8qKlxuICogUmV0dXJucyBhIGxvY2FsU3RvcmFnZS1saWtlIG9iamVjdCB0aGF0IHN0b3JlcyB0aGUga2V5LXZhbHVlIHBhaXJzIGluXG4gKiBtZW1vcnkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZW1vcnlMb2NhbFN0b3JhZ2VBZGFwdGVyKHN0b3JlID0ge30pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXRJdGVtOiAoa2V5KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3RvcmVba2V5XSB8fCBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBzZXRJdGVtOiAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgc3RvcmVba2V5XSA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmVJdGVtOiAoa2V5KSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgc3RvcmVba2V5XTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jYWwtc3RvcmFnZS5qcy5tYXAiLCJpbXBvcnQgeyBzdXBwb3J0c0xvY2FsU3RvcmFnZSB9IGZyb20gJy4vaGVscGVycydcbmltcG9ydCB7IFN1cHBvcnRlZFN0b3JhZ2UgfSBmcm9tICcuL3R5cGVzJ1xuXG4vKipcbiAqIFByb3ZpZGVzIHNhZmUgYWNjZXNzIHRvIHRoZSBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZSBwcm9wZXJ0eS5cbiAqL1xuZXhwb3J0IGNvbnN0IGxvY2FsU3RvcmFnZUFkYXB0ZXI6IFN1cHBvcnRlZFN0b3JhZ2UgPSB7XG4gIGdldEl0ZW06IChrZXkpID0+IHtcbiAgICBpZiAoIXN1cHBvcnRzTG9jYWxTdG9yYWdlKCkpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgcmV0dXJuIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KVxuICB9LFxuICBzZXRJdGVtOiAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgIGlmICghc3VwcG9ydHNMb2NhbFN0b3JhZ2UoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKVxuICB9LFxuICByZW1vdmVJdGVtOiAoa2V5KSA9PiB7XG4gICAgaWYgKCFzdXBwb3J0c0xvY2FsU3RvcmFnZSgpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSlcbiAgfSxcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgbG9jYWxTdG9yYWdlLWxpa2Ugb2JqZWN0IHRoYXQgc3RvcmVzIHRoZSBrZXktdmFsdWUgcGFpcnMgaW5cbiAqIG1lbW9yeS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lbW9yeUxvY2FsU3RvcmFnZUFkYXB0ZXIoc3RvcmU6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7fSk6IFN1cHBvcnRlZFN0b3JhZ2Uge1xuICByZXR1cm4ge1xuICAgIGdldEl0ZW06IChrZXkpID0+IHtcbiAgICAgIHJldHVybiBzdG9yZVtrZXldIHx8IG51bGxcbiAgICB9LFxuXG4gICAgc2V0SXRlbTogKGtleSwgdmFsdWUpID0+IHtcbiAgICAgIHN0b3JlW2tleV0gPSB2YWx1ZVxuICAgIH0sXG5cbiAgICByZW1vdmVJdGVtOiAoa2V5KSA9PiB7XG4gICAgICBkZWxldGUgc3RvcmVba2V5XVxuICAgIH0sXG4gIH1cbn1cbiIsIi8qKlxuICogaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2dsb2JhbHRoaXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBvbHlmaWxsR2xvYmFsVGhpcygpIHtcbiAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKVxuICAgICAgICByZXR1cm47XG4gICAgdHJ5IHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdC5wcm90b3R5cGUsICdfX21hZ2ljX18nLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yICdBbGxvdyBhY2Nlc3MgdG8gbWFnaWMnXG4gICAgICAgIF9fbWFnaWNfXy5nbG9iYWxUaGlzID0gX19tYWdpY19fO1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yICdBbGxvdyBhY2Nlc3MgdG8gbWFnaWMnXG4gICAgICAgIGRlbGV0ZSBPYmplY3QucHJvdG90eXBlLl9fbWFnaWNfXztcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAnQWxsb3cgYWNjZXNzIHRvIGdsb2JhbHMnXG4gICAgICAgICAgICBzZWxmLmdsb2JhbFRoaXMgPSBzZWxmO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG9seWZpbGxzLmpzLm1hcCIsIi8qKlxuICogaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2dsb2JhbHRoaXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBvbHlmaWxsR2xvYmFsVGhpcygpIHtcbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuXG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdC5wcm90b3R5cGUsICdfX21hZ2ljX18nLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH0sXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgfSlcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yICdBbGxvdyBhY2Nlc3MgdG8gbWFnaWMnXG4gICAgX19tYWdpY19fLmdsb2JhbFRoaXMgPSBfX21hZ2ljX19cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yICdBbGxvdyBhY2Nlc3MgdG8gbWFnaWMnXG4gICAgZGVsZXRlIE9iamVjdC5wcm90b3R5cGUuX19tYWdpY19fXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yICdBbGxvdyBhY2Nlc3MgdG8gZ2xvYmFscydcbiAgICAgIHNlbGYuZ2xvYmFsVGhpcyA9IHNlbGZcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IHN1cHBvcnRzTG9jYWxTdG9yYWdlIH0gZnJvbSAnLi9oZWxwZXJzJztcbi8qKlxuICogQGV4cGVyaW1lbnRhbFxuICovXG5leHBvcnQgY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIC8qKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBkZWJ1ZzogISEoZ2xvYmFsVGhpcyAmJlxuICAgICAgICBzdXBwb3J0c0xvY2FsU3RvcmFnZSgpICYmXG4gICAgICAgIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlICYmXG4gICAgICAgIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3N1cGFiYXNlLmdvdHJ1ZS1qcy5sb2Nrcy5kZWJ1ZycpID09PSAndHJ1ZScpLFxufTtcbi8qKlxuICogQW4gZXJyb3IgdGhyb3duIHdoZW4gYSBsb2NrIGNhbm5vdCBiZSBhY3F1aXJlZCBhZnRlciBzb21lIGFtb3VudCBvZiB0aW1lLlxuICpcbiAqIFVzZSB0aGUge0BsaW5rICNpc0FjcXVpcmVUaW1lb3V0fSBwcm9wZXJ0eSBpbnN0ZWFkIG9mIGNoZWNraW5nIHdpdGggYGluc3RhbmNlb2ZgLlxuICovXG5leHBvcnQgY2xhc3MgTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5pc0FjcXVpcmVUaW1lb3V0ID0gdHJ1ZTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgTmF2aWdhdG9yTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IgZXh0ZW5kcyBMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciB7XG59XG4vKipcbiAqIEltcGxlbWVudHMgYSBnbG9iYWwgZXhjbHVzaXZlIGxvY2sgdXNpbmcgdGhlIE5hdmlnYXRvciBMb2NrTWFuYWdlciBBUEkuIEl0XG4gKiBpcyBhdmFpbGFibGUgb24gYWxsIGJyb3dzZXJzIHJlbGVhc2VkIGFmdGVyIDIwMjItMDMtMTUgd2l0aCBTYWZhcmkgYmVpbmcgdGhlXG4gKiBsYXN0IG9uZSB0byByZWxlYXNlIHN1cHBvcnQuIElmIHRoZSBBUEkgaXMgbm90IGF2YWlsYWJsZSwgdGhpcyBmdW5jdGlvbiB3aWxsXG4gKiB0aHJvdy4gTWFrZSBzdXJlIHlvdSBjaGVjayBhdmFpbGFibGlsaXR5IGJlZm9yZSBjb25maWd1cmluZyB7QGxpbmtcbiAqIEdvVHJ1ZUNsaWVudH0uXG4gKlxuICogWW91IGNhbiB0dXJuIG9uIGRlYnVnZ2luZyBieSBzZXR0aW5nIHRoZSBgc3VwYWJhc2UuZ290cnVlLWpzLmxvY2tzLmRlYnVnYFxuICogbG9jYWwgc3RvcmFnZSBpdGVtIHRvIGB0cnVlYC5cbiAqXG4gKiBJbnRlcm5hbHM6XG4gKlxuICogU2luY2UgdGhlIExvY2tNYW5hZ2VyIEFQSSBkb2VzIG5vdCBwcmVzZXJ2ZSBzdGFjayB0cmFjZXMgZm9yIHRoZSBhc3luY1xuICogZnVuY3Rpb24gcGFzc2VkIGluIHRoZSBgcmVxdWVzdGAgbWV0aG9kLCBhIHRyaWNrIGlzIHVzZWQgd2hlcmUgYWNxdWlyaW5nIHRoZVxuICogbG9jayByZWxlYXNlcyBhIHByZXZpb3VzbHkgc3RhcnRlZCBwcm9taXNlIHRvIHJ1biB0aGUgb3BlcmF0aW9uIGluIHRoZSBgZm5gXG4gKiBmdW5jdGlvbi4gVGhlIGxvY2sgd2FpdHMgZm9yIHRoYXQgcHJvbWlzZSB0byBmaW5pc2ggKHdpdGggb3Igd2l0aG91dCBlcnJvciksXG4gKiB3aGlsZSB0aGUgZnVuY3Rpb24gd2lsbCBmaW5hbGx5IHdhaXQgZm9yIHRoZSByZXN1bHQgYW55d2F5LlxuICpcbiAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIGxvY2sgdG8gYmUgYWNxdWlyZWQuXG4gKiBAcGFyYW0gYWNxdWlyZVRpbWVvdXQgSWYgbmVnYXRpdmUsIG5vIHRpbWVvdXQuIElmIDAgYW4gZXJyb3IgaXMgdGhyb3duIGlmXG4gKiAgICAgICAgICAgICAgICAgICAgICAgdGhlIGxvY2sgY2FuJ3QgYmUgYWNxdWlyZWQgd2l0aG91dCB3YWl0aW5nLiBJZiBwb3NpdGl2ZSwgdGhlIGxvY2sgYWNxdWlyZVxuICogICAgICAgICAgICAgICAgICAgICAgIHdpbGwgdGltZSBvdXQgYWZ0ZXIgc28gbWFueSBtaWxsaXNlY29uZHMuIEFuIGVycm9yIGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgYSB0aW1lb3V0IGlmIGl0IGhhcyBgaXNBY3F1aXJlVGltZW91dGAgc2V0IHRvIHRydWUuXG4gKiBAcGFyYW0gZm4gVGhlIG9wZXJhdGlvbiB0byBydW4gb25jZSB0aGUgbG9jayBpcyBhY3F1aXJlZC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG5hdmlnYXRvckxvY2sobmFtZSwgYWNxdWlyZVRpbWVvdXQsIGZuKSB7XG4gICAgaWYgKGludGVybmFscy5kZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZygnQHN1cGFiYXNlL2dvdHJ1ZS1qczogbmF2aWdhdG9yTG9jazogYWNxdWlyZSBsb2NrJywgbmFtZSwgYWNxdWlyZVRpbWVvdXQpO1xuICAgIH1cbiAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgZ2xvYmFsVGhpcy5BYm9ydENvbnRyb2xsZXIoKTtcbiAgICBpZiAoYWNxdWlyZVRpbWVvdXQgPiAwKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgICBpZiAoaW50ZXJuYWxzLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0BzdXBhYmFzZS9nb3RydWUtanM6IG5hdmlnYXRvckxvY2sgYWNxdWlyZSB0aW1lZCBvdXQnLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgYWNxdWlyZVRpbWVvdXQpO1xuICAgIH1cbiAgICAvLyBNRE4gYXJ0aWNsZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0xvY2tNYW5hZ2VyL3JlcXVlc3RcbiAgICByZXR1cm4gYXdhaXQgZ2xvYmFsVGhpcy5uYXZpZ2F0b3IubG9ja3MucmVxdWVzdChuYW1lLCBhY3F1aXJlVGltZW91dCA9PT0gMFxuICAgICAgICA/IHtcbiAgICAgICAgICAgIG1vZGU6ICdleGNsdXNpdmUnLFxuICAgICAgICAgICAgaWZBdmFpbGFibGU6IHRydWUsXG4gICAgICAgIH1cbiAgICAgICAgOiB7XG4gICAgICAgICAgICBtb2RlOiAnZXhjbHVzaXZlJyxcbiAgICAgICAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgfSwgYXN5bmMgKGxvY2spID0+IHtcbiAgICAgICAgaWYgKGxvY2spIHtcbiAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQHN1cGFiYXNlL2dvdHJ1ZS1qczogbmF2aWdhdG9yTG9jazogYWNxdWlyZWQnLCBuYW1lLCBsb2NrLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgZm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0BzdXBhYmFzZS9nb3RydWUtanM6IG5hdmlnYXRvckxvY2s6IHJlbGVhc2VkJywgbmFtZSwgbG9jay5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoYWNxdWlyZVRpbWVvdXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJuYWxzLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdAc3VwYWJhc2UvZ290cnVlLWpzOiBuYXZpZ2F0b3JMb2NrOiBub3QgaW1tZWRpYXRlbHkgYXZhaWxhYmxlJywgbmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOYXZpZ2F0b3JMb2NrQWNxdWlyZVRpbWVvdXRFcnJvcihgQWNxdWlyaW5nIGFuIGV4Y2x1c2l2ZSBOYXZpZ2F0b3IgTG9ja01hbmFnZXIgbG9jayBcIiR7bmFtZX1cIiBpbW1lZGlhdGVseSBmYWlsZWRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdsb2JhbFRoaXMubmF2aWdhdG9yLmxvY2tzLnF1ZXJ5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQHN1cGFiYXNlL2dvdHJ1ZS1qczogTmF2aWdhdG9yIExvY2tNYW5hZ2VyIHN0YXRlJywgSlNPTi5zdHJpbmdpZnkocmVzdWx0LCBudWxsLCAnICAnKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQHN1cGFiYXNlL2dvdHJ1ZS1qczogRXJyb3Igd2hlbiBxdWVyeWluZyBOYXZpZ2F0b3IgTG9ja01hbmFnZXIgc3RhdGUnLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBCcm93c2VyIGlzIG5vdCBmb2xsb3dpbmcgdGhlIE5hdmlnYXRvciBMb2NrTWFuYWdlciBzcGVjLCBpdFxuICAgICAgICAgICAgICAgIC8vIHJldHVybmVkIGEgbnVsbCBsb2NrIHdoZW4gd2UgZGlkbid0IHVzZSBpZkF2YWlsYWJsZS4gU28gd2UgY2FuXG4gICAgICAgICAgICAgICAgLy8gcHJldGVuZCB0aGUgbG9jayBpcyBhY3F1aXJlZCBpbiB0aGUgbmFtZSBvZiBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICAgICAgLy8gYW5kIHVzZXIgZXhwZXJpZW5jZSBhbmQganVzdCBydW4gdGhlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQHN1cGFiYXNlL2dvdHJ1ZS1qczogTmF2aWdhdG9yIExvY2tNYW5hZ2VyIHJldHVybmVkIGEgbnVsbCBsb2NrIHdoZW4gdXNpbmcgI3JlcXVlc3Qgd2l0aG91dCBpZkF2YWlsYWJsZSBzZXQgdG8gdHJ1ZSwgaXQgYXBwZWFycyB0aGlzIGJyb3dzZXIgaXMgbm90IGZvbGxvd2luZyB0aGUgTG9ja01hbmFnZXIgc3BlYyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTG9ja01hbmFnZXIvcmVxdWVzdCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBmbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2Nrcy5qcy5tYXAiLCJpbXBvcnQgeyBzdXBwb3J0c0xvY2FsU3RvcmFnZSB9IGZyb20gJy4vaGVscGVycydcblxuLyoqXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbmV4cG9ydCBjb25zdCBpbnRlcm5hbHMgPSB7XG4gIC8qKlxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqL1xuICBkZWJ1ZzogISEoXG4gICAgZ2xvYmFsVGhpcyAmJlxuICAgIHN1cHBvcnRzTG9jYWxTdG9yYWdlKCkgJiZcbiAgICBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZSAmJlxuICAgIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3N1cGFiYXNlLmdvdHJ1ZS1qcy5sb2Nrcy5kZWJ1ZycpID09PSAndHJ1ZSdcbiAgKSxcbn1cblxuLyoqXG4gKiBBbiBlcnJvciB0aHJvd24gd2hlbiBhIGxvY2sgY2Fubm90IGJlIGFjcXVpcmVkIGFmdGVyIHNvbWUgYW1vdW50IG9mIHRpbWUuXG4gKlxuICogVXNlIHRoZSB7QGxpbmsgI2lzQWNxdWlyZVRpbWVvdXR9IHByb3BlcnR5IGluc3RlYWQgb2YgY2hlY2tpbmcgd2l0aCBgaW5zdGFuY2VvZmAuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgcHVibGljIHJlYWRvbmx5IGlzQWNxdWlyZVRpbWVvdXQgPSB0cnVlXG5cbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTmF2aWdhdG9yTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IgZXh0ZW5kcyBMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciB7fVxuXG4vKipcbiAqIEltcGxlbWVudHMgYSBnbG9iYWwgZXhjbHVzaXZlIGxvY2sgdXNpbmcgdGhlIE5hdmlnYXRvciBMb2NrTWFuYWdlciBBUEkuIEl0XG4gKiBpcyBhdmFpbGFibGUgb24gYWxsIGJyb3dzZXJzIHJlbGVhc2VkIGFmdGVyIDIwMjItMDMtMTUgd2l0aCBTYWZhcmkgYmVpbmcgdGhlXG4gKiBsYXN0IG9uZSB0byByZWxlYXNlIHN1cHBvcnQuIElmIHRoZSBBUEkgaXMgbm90IGF2YWlsYWJsZSwgdGhpcyBmdW5jdGlvbiB3aWxsXG4gKiB0aHJvdy4gTWFrZSBzdXJlIHlvdSBjaGVjayBhdmFpbGFibGlsaXR5IGJlZm9yZSBjb25maWd1cmluZyB7QGxpbmtcbiAqIEdvVHJ1ZUNsaWVudH0uXG4gKlxuICogWW91IGNhbiB0dXJuIG9uIGRlYnVnZ2luZyBieSBzZXR0aW5nIHRoZSBgc3VwYWJhc2UuZ290cnVlLWpzLmxvY2tzLmRlYnVnYFxuICogbG9jYWwgc3RvcmFnZSBpdGVtIHRvIGB0cnVlYC5cbiAqXG4gKiBJbnRlcm5hbHM6XG4gKlxuICogU2luY2UgdGhlIExvY2tNYW5hZ2VyIEFQSSBkb2VzIG5vdCBwcmVzZXJ2ZSBzdGFjayB0cmFjZXMgZm9yIHRoZSBhc3luY1xuICogZnVuY3Rpb24gcGFzc2VkIGluIHRoZSBgcmVxdWVzdGAgbWV0aG9kLCBhIHRyaWNrIGlzIHVzZWQgd2hlcmUgYWNxdWlyaW5nIHRoZVxuICogbG9jayByZWxlYXNlcyBhIHByZXZpb3VzbHkgc3RhcnRlZCBwcm9taXNlIHRvIHJ1biB0aGUgb3BlcmF0aW9uIGluIHRoZSBgZm5gXG4gKiBmdW5jdGlvbi4gVGhlIGxvY2sgd2FpdHMgZm9yIHRoYXQgcHJvbWlzZSB0byBmaW5pc2ggKHdpdGggb3Igd2l0aG91dCBlcnJvciksXG4gKiB3aGlsZSB0aGUgZnVuY3Rpb24gd2lsbCBmaW5hbGx5IHdhaXQgZm9yIHRoZSByZXN1bHQgYW55d2F5LlxuICpcbiAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIGxvY2sgdG8gYmUgYWNxdWlyZWQuXG4gKiBAcGFyYW0gYWNxdWlyZVRpbWVvdXQgSWYgbmVnYXRpdmUsIG5vIHRpbWVvdXQuIElmIDAgYW4gZXJyb3IgaXMgdGhyb3duIGlmXG4gKiAgICAgICAgICAgICAgICAgICAgICAgdGhlIGxvY2sgY2FuJ3QgYmUgYWNxdWlyZWQgd2l0aG91dCB3YWl0aW5nLiBJZiBwb3NpdGl2ZSwgdGhlIGxvY2sgYWNxdWlyZVxuICogICAgICAgICAgICAgICAgICAgICAgIHdpbGwgdGltZSBvdXQgYWZ0ZXIgc28gbWFueSBtaWxsaXNlY29uZHMuIEFuIGVycm9yIGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgYSB0aW1lb3V0IGlmIGl0IGhhcyBgaXNBY3F1aXJlVGltZW91dGAgc2V0IHRvIHRydWUuXG4gKiBAcGFyYW0gZm4gVGhlIG9wZXJhdGlvbiB0byBydW4gb25jZSB0aGUgbG9jayBpcyBhY3F1aXJlZC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG5hdmlnYXRvckxvY2s8Uj4oXG4gIG5hbWU6IHN0cmluZyxcbiAgYWNxdWlyZVRpbWVvdXQ6IG51bWJlcixcbiAgZm46ICgpID0+IFByb21pc2U8Uj5cbik6IFByb21pc2U8Uj4ge1xuICBpZiAoaW50ZXJuYWxzLmRlYnVnKSB7XG4gICAgY29uc29sZS5sb2coJ0BzdXBhYmFzZS9nb3RydWUtanM6IG5hdmlnYXRvckxvY2s6IGFjcXVpcmUgbG9jaycsIG5hbWUsIGFjcXVpcmVUaW1lb3V0KVxuICB9XG5cbiAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IGdsb2JhbFRoaXMuQWJvcnRDb250cm9sbGVyKClcblxuICBpZiAoYWNxdWlyZVRpbWVvdXQgPiAwKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKVxuICAgICAgaWYgKGludGVybmFscy5kZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZygnQHN1cGFiYXNlL2dvdHJ1ZS1qczogbmF2aWdhdG9yTG9jayBhY3F1aXJlIHRpbWVkIG91dCcsIG5hbWUpXG4gICAgICB9XG4gICAgfSwgYWNxdWlyZVRpbWVvdXQpXG4gIH1cblxuICAvLyBNRE4gYXJ0aWNsZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0xvY2tNYW5hZ2VyL3JlcXVlc3RcblxuICByZXR1cm4gYXdhaXQgZ2xvYmFsVGhpcy5uYXZpZ2F0b3IubG9ja3MucmVxdWVzdChcbiAgICBuYW1lLFxuICAgIGFjcXVpcmVUaW1lb3V0ID09PSAwXG4gICAgICA/IHtcbiAgICAgICAgICBtb2RlOiAnZXhjbHVzaXZlJyxcbiAgICAgICAgICBpZkF2YWlsYWJsZTogdHJ1ZSxcbiAgICAgICAgfVxuICAgICAgOiB7XG4gICAgICAgICAgbW9kZTogJ2V4Y2x1c2l2ZScsXG4gICAgICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICB9LFxuICAgIGFzeW5jIChsb2NrKSA9PiB7XG4gICAgICBpZiAobG9jaykge1xuICAgICAgICBpZiAoaW50ZXJuYWxzLmRlYnVnKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ0BzdXBhYmFzZS9nb3RydWUtanM6IG5hdmlnYXRvckxvY2s6IGFjcXVpcmVkJywgbmFtZSwgbG9jay5uYW1lKVxuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gYXdhaXQgZm4oKVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChpbnRlcm5hbHMuZGVidWcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdAc3VwYWJhc2UvZ290cnVlLWpzOiBuYXZpZ2F0b3JMb2NrOiByZWxlYXNlZCcsIG5hbWUsIGxvY2submFtZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChhY3F1aXJlVGltZW91dCA9PT0gMCkge1xuICAgICAgICAgIGlmIChpbnRlcm5hbHMuZGVidWcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdAc3VwYWJhc2UvZ290cnVlLWpzOiBuYXZpZ2F0b3JMb2NrOiBub3QgaW1tZWRpYXRlbHkgYXZhaWxhYmxlJywgbmFtZSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aHJvdyBuZXcgTmF2aWdhdG9yTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IoXG4gICAgICAgICAgICBgQWNxdWlyaW5nIGFuIGV4Y2x1c2l2ZSBOYXZpZ2F0b3IgTG9ja01hbmFnZXIgbG9jayBcIiR7bmFtZX1cIiBpbW1lZGlhdGVseSBmYWlsZWRgXG4gICAgICAgICAgKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpbnRlcm5hbHMuZGVidWcpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdsb2JhbFRoaXMubmF2aWdhdG9yLmxvY2tzLnF1ZXJ5KClcblxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICAnQHN1cGFiYXNlL2dvdHJ1ZS1qczogTmF2aWdhdG9yIExvY2tNYW5hZ2VyIHN0YXRlJyxcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShyZXN1bHQsIG51bGwsICcgICcpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgJ0BzdXBhYmFzZS9nb3RydWUtanM6IEVycm9yIHdoZW4gcXVlcnlpbmcgTmF2aWdhdG9yIExvY2tNYW5hZ2VyIHN0YXRlJyxcbiAgICAgICAgICAgICAgICBlXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBCcm93c2VyIGlzIG5vdCBmb2xsb3dpbmcgdGhlIE5hdmlnYXRvciBMb2NrTWFuYWdlciBzcGVjLCBpdFxuICAgICAgICAgIC8vIHJldHVybmVkIGEgbnVsbCBsb2NrIHdoZW4gd2UgZGlkbid0IHVzZSBpZkF2YWlsYWJsZS4gU28gd2UgY2FuXG4gICAgICAgICAgLy8gcHJldGVuZCB0aGUgbG9jayBpcyBhY3F1aXJlZCBpbiB0aGUgbmFtZSBvZiBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgLy8gYW5kIHVzZXIgZXhwZXJpZW5jZSBhbmQganVzdCBydW4gdGhlIGZ1bmN0aW9uLlxuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICdAc3VwYWJhc2UvZ290cnVlLWpzOiBOYXZpZ2F0b3IgTG9ja01hbmFnZXIgcmV0dXJuZWQgYSBudWxsIGxvY2sgd2hlbiB1c2luZyAjcmVxdWVzdCB3aXRob3V0IGlmQXZhaWxhYmxlIHNldCB0byB0cnVlLCBpdCBhcHBlYXJzIHRoaXMgYnJvd3NlciBpcyBub3QgZm9sbG93aW5nIHRoZSBMb2NrTWFuYWdlciBzcGVjIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Mb2NrTWFuYWdlci9yZXF1ZXN0J1xuICAgICAgICAgIClcblxuICAgICAgICAgIHJldHVybiBhd2FpdCBmbigpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIClcbn1cbiIsImltcG9ydCBHb1RydWVBZG1pbkFwaSBmcm9tICcuL0dvVHJ1ZUFkbWluQXBpJztcbmNvbnN0IEF1dGhBZG1pbkFwaSA9IEdvVHJ1ZUFkbWluQXBpO1xuZXhwb3J0IGRlZmF1bHQgQXV0aEFkbWluQXBpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXV0aEFkbWluQXBpLmpzLm1hcCIsImltcG9ydCBHb1RydWVBZG1pbkFwaSBmcm9tICcuL0dvVHJ1ZUFkbWluQXBpJ1xuXG5jb25zdCBBdXRoQWRtaW5BcGkgPSBHb1RydWVBZG1pbkFwaVxuXG5leHBvcnQgZGVmYXVsdCBBdXRoQWRtaW5BcGlcbiIsImltcG9ydCBHb1RydWVDbGllbnQgZnJvbSAnLi9Hb1RydWVDbGllbnQnO1xuY29uc3QgQXV0aENsaWVudCA9IEdvVHJ1ZUNsaWVudDtcbmV4cG9ydCBkZWZhdWx0IEF1dGhDbGllbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BdXRoQ2xpZW50LmpzLm1hcCIsImltcG9ydCBHb1RydWVDbGllbnQgZnJvbSAnLi9Hb1RydWVDbGllbnQnXG5cbmNvbnN0IEF1dGhDbGllbnQgPSBHb1RydWVDbGllbnRcblxuZXhwb3J0IGRlZmF1bHQgQXV0aENsaWVudFxuIiwiaW1wb3J0IHsgQXV0aEVycm9yIH0gZnJvbSAnLi9lcnJvcnMnXG5pbXBvcnQgeyBGZXRjaCB9IGZyb20gJy4vZmV0Y2gnXG5cbi8qKiBPbmUgb2YgdGhlIHByb3ZpZGVycyBzdXBwb3J0ZWQgYnkgR29UcnVlLiAqL1xuZXhwb3J0IHR5cGUgUHJvdmlkZXIgPVxuICB8ICdhcHBsZSdcbiAgfCAnYXp1cmUnXG4gIHwgJ2JpdGJ1Y2tldCdcbiAgfCAnZGlzY29yZCdcbiAgfCAnZmFjZWJvb2snXG4gIHwgJ2ZpZ21hJ1xuICB8ICdnaXRodWInXG4gIHwgJ2dpdGxhYidcbiAgfCAnZ29vZ2xlJ1xuICB8ICdrYWthbydcbiAgfCAna2V5Y2xvYWsnXG4gIHwgJ2xpbmtlZGluJ1xuICB8ICdsaW5rZWRpbl9vaWRjJ1xuICB8ICdub3Rpb24nXG4gIHwgJ3NsYWNrJ1xuICB8ICdzbGFja19vaWRjJ1xuICB8ICdzcG90aWZ5J1xuICB8ICd0d2l0Y2gnXG4gIHwgJ3R3aXR0ZXInXG4gIHwgJ3dvcmtvcydcbiAgfCAnem9vbSdcbiAgfCAnZmx5J1xuXG5leHBvcnQgdHlwZSBBdXRoQ2hhbmdlRXZlbnRNRkEgPSAnTUZBX0NIQUxMRU5HRV9WRVJJRklFRCdcblxuZXhwb3J0IHR5cGUgQXV0aENoYW5nZUV2ZW50ID1cbiAgfCAnSU5JVElBTF9TRVNTSU9OJ1xuICB8ICdQQVNTV09SRF9SRUNPVkVSWSdcbiAgfCAnU0lHTkVEX0lOJ1xuICB8ICdTSUdORURfT1VUJ1xuICB8ICdUT0tFTl9SRUZSRVNIRUQnXG4gIHwgJ1VTRVJfVVBEQVRFRCdcbiAgfCBBdXRoQ2hhbmdlRXZlbnRNRkFcblxuLyoqXG4gKiBQcm92aWRlIHlvdXIgb3duIGdsb2JhbCBsb2NrIGltcGxlbWVudGF0aW9uIGluc3RlYWQgb2YgdGhlIGRlZmF1bHRcbiAqIGltcGxlbWVudGF0aW9uLiBUaGUgZnVuY3Rpb24gc2hvdWxkIGFjcXVpcmUgYSBsb2NrIGZvciB0aGUgZHVyYXRpb24gb2YgdGhlXG4gKiBgZm5gIGFzeW5jIGZ1bmN0aW9uLCBzdWNoIHRoYXQgbm8gb3RoZXIgY2xpZW50IGluc3RhbmNlcyB3aWxsIGJlIGFibGUgdG9cbiAqIGhvbGQgaXQgYXQgdGhlIHNhbWUgdGltZS5cbiAqXG4gKiBAZXhwZXJpbWVudGFsXG4gKlxuICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgbG9jayB0byBiZSBhY3F1aXJlZC5cbiAqIEBwYXJhbSBhY3F1aXJlVGltZW91dCBJZiBuZWdhdGl2ZSwgbm8gdGltZW91dCBzaG91bGQgb2NjdXIuIElmIHBvc2l0aXZlIGl0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkIHRocm93IGFuIEVycm9yIHdpdGggYW4gYGlzQWNxdWlyZVRpbWVvdXRgXG4gKiAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkgc2V0IHRvIHRydWUgaWYgdGhlIG9wZXJhdGlvbiBmYWlscyB0byBiZVxuICogICAgICAgICAgICAgICAgICAgICAgIGFjcXVpcmVkIGFmdGVyIHRoaXMgbXVjaCB0aW1lIChtcykuXG4gKiBAcGFyYW0gZm4gVGhlIG9wZXJhdGlvbiB0byBleGVjdXRlIHdoZW4gdGhlIGxvY2sgaXMgYWNxdWlyZWQuXG4gKi9cbmV4cG9ydCB0eXBlIExvY2tGdW5jID0gPFI+KG5hbWU6IHN0cmluZywgYWNxdWlyZVRpbWVvdXQ6IG51bWJlciwgZm46ICgpID0+IFByb21pc2U8Uj4pID0+IFByb21pc2U8Uj5cblxuZXhwb3J0IHR5cGUgR29UcnVlQ2xpZW50T3B0aW9ucyA9IHtcbiAgLyogVGhlIFVSTCBvZiB0aGUgR29UcnVlIHNlcnZlci4gKi9cbiAgdXJsPzogc3RyaW5nXG4gIC8qIEFueSBhZGRpdGlvbmFsIGhlYWRlcnMgdG8gc2VuZCB0byB0aGUgR29UcnVlIHNlcnZlci4gKi9cbiAgaGVhZGVycz86IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH1cbiAgLyogT3B0aW9uYWwga2V5IG5hbWUgdXNlZCBmb3Igc3RvcmluZyB0b2tlbnMgaW4gbG9jYWwgc3RvcmFnZS4gKi9cbiAgc3RvcmFnZUtleT86IHN0cmluZ1xuICAvKiBTZXQgdG8gXCJ0cnVlXCIgaWYgeW91IHdhbnQgdG8gYXV0b21hdGljYWxseSBkZXRlY3RzIE9BdXRoIGdyYW50cyBpbiB0aGUgVVJMIGFuZCBzaWducyBpbiB0aGUgdXNlci4gKi9cbiAgZGV0ZWN0U2Vzc2lvbkluVXJsPzogYm9vbGVhblxuICAvKiBTZXQgdG8gXCJ0cnVlXCIgaWYgeW91IHdhbnQgdG8gYXV0b21hdGljYWxseSByZWZyZXNoIHRoZSB0b2tlbiBiZWZvcmUgZXhwaXJpbmcuICovXG4gIGF1dG9SZWZyZXNoVG9rZW4/OiBib29sZWFuXG4gIC8qIFNldCB0byBcInRydWVcIiBpZiB5b3Ugd2FudCB0byBhdXRvbWF0aWNhbGx5IHNhdmUgdGhlIHVzZXIgc2Vzc2lvbiBpbnRvIGxvY2FsIHN0b3JhZ2UuIElmIHNldCB0byBmYWxzZSwgc2Vzc2lvbiB3aWxsIGp1c3QgYmUgc2F2ZWQgaW4gbWVtb3J5LiAqL1xuICBwZXJzaXN0U2Vzc2lvbj86IGJvb2xlYW5cbiAgLyogUHJvdmlkZSB5b3VyIG93biBsb2NhbCBzdG9yYWdlIGltcGxlbWVudGF0aW9uIHRvIHVzZSBpbnN0ZWFkIG9mIHRoZSBicm93c2VyJ3MgbG9jYWwgc3RvcmFnZS4gKi9cbiAgc3RvcmFnZT86IFN1cHBvcnRlZFN0b3JhZ2VcbiAgLyogQSBjdXN0b20gZmV0Y2ggaW1wbGVtZW50YXRpb24uICovXG4gIGZldGNoPzogRmV0Y2hcbiAgLyogSWYgc2V0IHRvICdwa2NlJyBQS0NFIGZsb3cuIERlZmF1bHRzIHRvIHRoZSAnaW1wbGljaXQnIGZsb3cgb3RoZXJ3aXNlICovXG4gIGZsb3dUeXBlPzogQXV0aEZsb3dUeXBlXG4gIC8qIElmIGRlYnVnIG1lc3NhZ2VzIGFyZSBlbWl0dGVkLiBDYW4gYmUgdXNlZCB0byBpbnNwZWN0IHRoZSBiZWhhdmlvciBvZiB0aGUgbGlicmFyeS4gSWYgc2V0IHRvIGEgZnVuY3Rpb24sIHRoZSBwcm92aWRlZCBmdW5jdGlvbiB3aWxsIGJlIHVzZWQgaW5zdGVhZCBvZiBgY29uc29sZS5sb2coKWAgdG8gcGVyZm9ybSB0aGUgbG9nZ2luZy4gKi9cbiAgZGVidWc/OiBib29sZWFuIHwgKChtZXNzYWdlOiBzdHJpbmcsIC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkKVxuICAvKipcbiAgICogUHJvdmlkZSB5b3VyIG93biBsb2NraW5nIG1lY2hhbmlzbSBiYXNlZCBvbiB0aGUgZW52aXJvbm1lbnQuIEJ5IGRlZmF1bHQgbm8gbG9ja2luZyBpcyBkb25lIGF0IHRoaXMgdGltZS5cbiAgICpcbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKi9cbiAgbG9jaz86IExvY2tGdW5jXG4gIC8qKlxuICAgKiBTZXQgdG8gXCJ0cnVlXCIgaWYgdGhlcmUgaXMgYSBjdXN0b20gYXV0aG9yaXphdGlvbiBoZWFkZXIgc2V0IGdsb2JhbGx5LlxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqL1xuICBoYXNDdXN0b21BdXRob3JpemF0aW9uSGVhZGVyPzogYm9vbGVhblxufVxuXG5leHBvcnQgdHlwZSBXZWFrUGFzc3dvcmRSZWFzb25zID0gJ2xlbmd0aCcgfCAnY2hhcmFjdGVycycgfCAncHduZWQnIHwgc3RyaW5nXG5leHBvcnQgdHlwZSBXZWFrUGFzc3dvcmQgPSB7XG4gIHJlYXNvbnM6IFdlYWtQYXNzd29yZFJlYXNvbnNbXVxuICBtZXNzYWdlOiBzdHJpbmdcbn1cblxuZXhwb3J0IHR5cGUgQXV0aFJlc3BvbnNlID1cbiAgfCB7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIHVzZXI6IFVzZXIgfCBudWxsXG4gICAgICAgIHNlc3Npb246IFNlc3Npb24gfCBudWxsXG4gICAgICB9XG4gICAgICBlcnJvcjogbnVsbFxuICAgIH1cbiAgfCB7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIHVzZXI6IG51bGxcbiAgICAgICAgc2Vzc2lvbjogbnVsbFxuICAgICAgfVxuICAgICAgZXJyb3I6IEF1dGhFcnJvclxuICAgIH1cblxuZXhwb3J0IHR5cGUgQXV0aFJlc3BvbnNlUGFzc3dvcmQgPVxuICB8IHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgdXNlcjogVXNlciB8IG51bGxcbiAgICAgICAgc2Vzc2lvbjogU2Vzc2lvbiB8IG51bGxcbiAgICAgICAgd2Vha19wYXNzd29yZD86IFdlYWtQYXNzd29yZCB8IG51bGxcbiAgICAgIH1cbiAgICAgIGVycm9yOiBudWxsXG4gICAgfVxuICB8IHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgdXNlcjogbnVsbFxuICAgICAgICBzZXNzaW9uOiBudWxsXG4gICAgICB9XG4gICAgICBlcnJvcjogQXV0aEVycm9yXG4gICAgfVxuXG4vKipcbiAqIEF1dGhPdHBSZXNwb25zZSBpcyByZXR1cm5lZCB3aGVuIE9UUCBpcyB1c2VkLlxuICpcbiAqIHtAc2VlIEF1dGhSZXNwb25zZX1cbiAqL1xuZXhwb3J0IHR5cGUgQXV0aE90cFJlc3BvbnNlID1cbiAgfCB7XG4gICAgICBkYXRhOiB7IHVzZXI6IG51bGw7IHNlc3Npb246IG51bGw7IG1lc3NhZ2VJZD86IHN0cmluZyB8IG51bGwgfVxuICAgICAgZXJyb3I6IG51bGxcbiAgICB9XG4gIHwge1xuICAgICAgZGF0YTogeyB1c2VyOiBudWxsOyBzZXNzaW9uOiBudWxsOyBtZXNzYWdlSWQ/OiBzdHJpbmcgfCBudWxsIH1cbiAgICAgIGVycm9yOiBBdXRoRXJyb3JcbiAgICB9XG5cbmV4cG9ydCB0eXBlIEF1dGhUb2tlblJlc3BvbnNlID1cbiAgfCB7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIHVzZXI6IFVzZXJcbiAgICAgICAgc2Vzc2lvbjogU2Vzc2lvblxuICAgICAgfVxuICAgICAgZXJyb3I6IG51bGxcbiAgICB9XG4gIHwge1xuICAgICAgZGF0YToge1xuICAgICAgICB1c2VyOiBudWxsXG4gICAgICAgIHNlc3Npb246IG51bGxcbiAgICAgIH1cbiAgICAgIGVycm9yOiBBdXRoRXJyb3JcbiAgICB9XG5cbmV4cG9ydCB0eXBlIEF1dGhUb2tlblJlc3BvbnNlUGFzc3dvcmQgPVxuICB8IHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgdXNlcjogVXNlclxuICAgICAgICBzZXNzaW9uOiBTZXNzaW9uXG4gICAgICAgIHdlYWtQYXNzd29yZD86IFdlYWtQYXNzd29yZFxuICAgICAgfVxuICAgICAgZXJyb3I6IG51bGxcbiAgICB9XG4gIHwge1xuICAgICAgZGF0YToge1xuICAgICAgICB1c2VyOiBudWxsXG4gICAgICAgIHNlc3Npb246IG51bGxcbiAgICAgICAgd2Vha1Bhc3N3b3JkPzogbnVsbFxuICAgICAgfVxuICAgICAgZXJyb3I6IEF1dGhFcnJvclxuICAgIH1cblxuZXhwb3J0IHR5cGUgT0F1dGhSZXNwb25zZSA9XG4gIHwge1xuICAgICAgZGF0YToge1xuICAgICAgICBwcm92aWRlcjogUHJvdmlkZXJcbiAgICAgICAgdXJsOiBzdHJpbmdcbiAgICAgIH1cbiAgICAgIGVycm9yOiBudWxsXG4gICAgfVxuICB8IHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgcHJvdmlkZXI6IFByb3ZpZGVyXG4gICAgICAgIHVybDogbnVsbFxuICAgICAgfVxuICAgICAgZXJyb3I6IEF1dGhFcnJvclxuICAgIH1cblxuZXhwb3J0IHR5cGUgU1NPUmVzcG9uc2UgPVxuICB8IHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVSTCB0byBvcGVuIGluIGEgYnJvd3NlciB3aGljaCB3aWxsIGNvbXBsZXRlIHRoZSBzaWduLWluIGZsb3cgYnlcbiAgICAgICAgICogdGFraW5nIHRoZSB1c2VyIHRvIHRoZSBpZGVudGl0eSBwcm92aWRlcidzIGF1dGhlbnRpY2F0aW9uIGZsb3cuXG4gICAgICAgICAqXG4gICAgICAgICAqIE9uIGJyb3dzZXJzIHlvdSBjYW4gc2V0IHRoZSBVUkwgdG8gYHdpbmRvdy5sb2NhdGlvbi5ocmVmYCB0byB0YWtlXG4gICAgICAgICAqIHRoZSB1c2VyIHRvIHRoZSBhdXRoZW50aWNhdGlvbiBmbG93LlxuICAgICAgICAgKi9cbiAgICAgICAgdXJsOiBzdHJpbmdcbiAgICAgIH1cbiAgICAgIGVycm9yOiBudWxsXG4gICAgfVxuICB8IHtcbiAgICAgIGRhdGE6IG51bGxcbiAgICAgIGVycm9yOiBBdXRoRXJyb3JcbiAgICB9XG5cbmV4cG9ydCB0eXBlIFVzZXJSZXNwb25zZSA9XG4gIHwge1xuICAgICAgZGF0YToge1xuICAgICAgICB1c2VyOiBVc2VyXG4gICAgICB9XG4gICAgICBlcnJvcjogbnVsbFxuICAgIH1cbiAgfCB7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIHVzZXI6IG51bGxcbiAgICAgIH1cbiAgICAgIGVycm9yOiBBdXRoRXJyb3JcbiAgICB9XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2Vzc2lvbiB7XG4gIC8qKlxuICAgKiBUaGUgb2F1dGggcHJvdmlkZXIgdG9rZW4uIElmIHByZXNlbnQsIHRoaXMgY2FuIGJlIHVzZWQgdG8gbWFrZSBleHRlcm5hbCBBUEkgcmVxdWVzdHMgdG8gdGhlIG9hdXRoIHByb3ZpZGVyIHVzZWQuXG4gICAqL1xuICBwcm92aWRlcl90b2tlbj86IHN0cmluZyB8IG51bGxcbiAgLyoqXG4gICAqIFRoZSBvYXV0aCBwcm92aWRlciByZWZyZXNoIHRva2VuLiBJZiBwcmVzZW50LCB0aGlzIGNhbiBiZSB1c2VkIHRvIHJlZnJlc2ggdGhlIHByb3ZpZGVyX3Rva2VuIHZpYSB0aGUgb2F1dGggcHJvdmlkZXIncyBBUEkuXG4gICAqIE5vdCBhbGwgb2F1dGggcHJvdmlkZXJzIHJldHVybiBhIHByb3ZpZGVyIHJlZnJlc2ggdG9rZW4uIElmIHRoZSBwcm92aWRlcl9yZWZyZXNoX3Rva2VuIGlzIG1pc3NpbmcsIHBsZWFzZSByZWZlciB0byB0aGUgb2F1dGggcHJvdmlkZXIncyBkb2N1bWVudGF0aW9uIGZvciBpbmZvcm1hdGlvbiBvbiBob3cgdG8gb2J0YWluIHRoZSBwcm92aWRlciByZWZyZXNoIHRva2VuLlxuICAgKi9cbiAgcHJvdmlkZXJfcmVmcmVzaF90b2tlbj86IHN0cmluZyB8IG51bGxcbiAgLyoqXG4gICAqIFRoZSBhY2Nlc3MgdG9rZW4gand0LiBJdCBpcyByZWNvbW1lbmRlZCB0byBzZXQgdGhlIEpXVF9FWFBJUlkgdG8gYSBzaG9ydGVyIGV4cGlyeSB2YWx1ZS5cbiAgICovXG4gIGFjY2Vzc190b2tlbjogc3RyaW5nXG4gIC8qKlxuICAgKiBBIG9uZS10aW1lIHVzZWQgcmVmcmVzaCB0b2tlbiB0aGF0IG5ldmVyIGV4cGlyZXMuXG4gICAqL1xuICByZWZyZXNoX3Rva2VuOiBzdHJpbmdcbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyB1bnRpbCB0aGUgdG9rZW4gZXhwaXJlcyAoc2luY2UgaXQgd2FzIGlzc3VlZCkuIFJldHVybmVkIHdoZW4gYSBsb2dpbiBpcyBjb25maXJtZWQuXG4gICAqL1xuICBleHBpcmVzX2luOiBudW1iZXJcbiAgLyoqXG4gICAqIEEgdGltZXN0YW1wIG9mIHdoZW4gdGhlIHRva2VuIHdpbGwgZXhwaXJlLiBSZXR1cm5lZCB3aGVuIGEgbG9naW4gaXMgY29uZmlybWVkLlxuICAgKi9cbiAgZXhwaXJlc19hdD86IG51bWJlclxuICB0b2tlbl90eXBlOiBzdHJpbmdcbiAgdXNlcjogVXNlclxufVxuXG4vKipcbiAqIEFuIGF1dGhlbnRpY2F0aW9uIG1ldGhvcmQgcmVmZXJlbmNlIChBTVIpIGVudHJ5LlxuICpcbiAqIEFuIGVudHJ5IGRlc2lnbmF0ZXMgd2hhdCBtZXRob2Qgd2FzIHVzZWQgYnkgdGhlIHVzZXIgdG8gdmVyaWZ5IHRoZWlyXG4gKiBpZGVudGl0eSBhbmQgYXQgd2hhdCB0aW1lLlxuICpcbiAqIEBzZWUge0BsaW5rIEdvVHJ1ZU1GQUFwaSNnZXRBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWx9LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFNUkVudHJ5IHtcbiAgLyoqIEF1dGhlbnRpY2F0aW9uIG1ldGhvZCBuYW1lLiAqL1xuICBtZXRob2Q6ICdwYXNzd29yZCcgfCAnb3RwJyB8ICdvYXV0aCcgfCAnbWZhL3RvdHAnIHwgc3RyaW5nXG5cbiAgLyoqXG4gICAqIFRpbWVzdGFtcCB3aGVuIHRoZSBtZXRob2Qgd2FzIHN1Y2Nlc3NmdWxseSB1c2VkLiBSZXByZXNlbnRzIG51bWJlciBvZlxuICAgKiBzZWNvbmRzIHNpbmNlIDFzdCBKYW51YXJ5IDE5NzAgKFVOSVggZXBvY2gpIGluIFVUQy5cbiAgICovXG4gIHRpbWVzdGFtcDogbnVtYmVyXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlcklkZW50aXR5IHtcbiAgaWQ6IHN0cmluZ1xuICB1c2VyX2lkOiBzdHJpbmdcbiAgaWRlbnRpdHlfZGF0YT86IHtcbiAgICBba2V5OiBzdHJpbmddOiBhbnlcbiAgfVxuICBpZGVudGl0eV9pZDogc3RyaW5nXG4gIHByb3ZpZGVyOiBzdHJpbmdcbiAgY3JlYXRlZF9hdD86IHN0cmluZ1xuICBsYXN0X3NpZ25faW5fYXQ/OiBzdHJpbmdcbiAgdXBkYXRlZF9hdD86IHN0cmluZ1xufVxuXG4vKipcbiAqIEEgTUZBIGZhY3Rvci5cbiAqXG4gKiBAc2VlIHtAbGluayBHb1RydWVNRkFBcGkjZW5yb2xsfVxuICogQHNlZSB7QGxpbmsgR29UcnVlTUZBQXBpI2xpc3RGYWN0b3JzfVxuICogQHNlZSB7QGxpbmsgR29UcnVlTUZBQWRtaW5BcGkjbGlzdEZhY3RvcnN9XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRmFjdG9yIHtcbiAgLyoqIElEIG9mIHRoZSBmYWN0b3IuICovXG4gIGlkOiBzdHJpbmdcblxuICAvKiogRnJpZW5kbHkgbmFtZSBvZiB0aGUgZmFjdG9yLCB1c2VmdWwgdG8gZGlzYW1iaWd1YXRlIGJldHdlZW4gbXVsdGlwbGUgZmFjdG9ycy4gKi9cbiAgZnJpZW5kbHlfbmFtZT86IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBUeXBlIG9mIGZhY3Rvci4gT25seSBgdG90cGAgc3VwcG9ydGVkIHdpdGggdGhpcyB2ZXJzaW9uIGJ1dCBtYXkgY2hhbmdlIGluXG4gICAqIGZ1dHVyZSB2ZXJzaW9ucy5cbiAgICovXG4gIGZhY3Rvcl90eXBlOiAndG90cCcgfCBzdHJpbmdcblxuICAvKiogRmFjdG9yJ3Mgc3RhdHVzLiAqL1xuICBzdGF0dXM6ICd2ZXJpZmllZCcgfCAndW52ZXJpZmllZCdcblxuICBjcmVhdGVkX2F0OiBzdHJpbmdcbiAgdXBkYXRlZF9hdDogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlckFwcE1ldGFkYXRhIHtcbiAgcHJvdmlkZXI/OiBzdHJpbmdcbiAgW2tleTogc3RyaW5nXTogYW55XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlck1ldGFkYXRhIHtcbiAgW2tleTogc3RyaW5nXTogYW55XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlciB7XG4gIGlkOiBzdHJpbmdcbiAgYXBwX21ldGFkYXRhOiBVc2VyQXBwTWV0YWRhdGFcbiAgdXNlcl9tZXRhZGF0YTogVXNlck1ldGFkYXRhXG4gIGF1ZDogc3RyaW5nXG4gIGNvbmZpcm1hdGlvbl9zZW50X2F0Pzogc3RyaW5nXG4gIHJlY292ZXJ5X3NlbnRfYXQ/OiBzdHJpbmdcbiAgZW1haWxfY2hhbmdlX3NlbnRfYXQ/OiBzdHJpbmdcbiAgbmV3X2VtYWlsPzogc3RyaW5nXG4gIG5ld19waG9uZT86IHN0cmluZ1xuICBpbnZpdGVkX2F0Pzogc3RyaW5nXG4gIGFjdGlvbl9saW5rPzogc3RyaW5nXG4gIGVtYWlsPzogc3RyaW5nXG4gIHBob25lPzogc3RyaW5nXG4gIGNyZWF0ZWRfYXQ6IHN0cmluZ1xuICBjb25maXJtZWRfYXQ/OiBzdHJpbmdcbiAgZW1haWxfY29uZmlybWVkX2F0Pzogc3RyaW5nXG4gIHBob25lX2NvbmZpcm1lZF9hdD86IHN0cmluZ1xuICBsYXN0X3NpZ25faW5fYXQ/OiBzdHJpbmdcbiAgcm9sZT86IHN0cmluZ1xuICB1cGRhdGVkX2F0Pzogc3RyaW5nXG4gIGlkZW50aXRpZXM/OiBVc2VySWRlbnRpdHlbXVxuICBpc19hbm9ueW1vdXM/OiBib29sZWFuXG4gIGZhY3RvcnM/OiBGYWN0b3JbXVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZXJBdHRyaWJ1dGVzIHtcbiAgLyoqXG4gICAqIFRoZSB1c2VyJ3MgZW1haWwuXG4gICAqL1xuICBlbWFpbD86IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBUaGUgdXNlcidzIHBob25lLlxuICAgKi9cbiAgcGhvbmU/OiBzdHJpbmdcblxuICAvKipcbiAgICogVGhlIHVzZXIncyBwYXNzd29yZC5cbiAgICovXG4gIHBhc3N3b3JkPzogc3RyaW5nXG5cbiAgLyoqXG4gICAqIFRoZSBub25jZSBzZW50IGZvciByZWF1dGhlbnRpY2F0aW9uIGlmIHRoZSB1c2VyJ3MgcGFzc3dvcmQgaXMgdG8gYmUgdXBkYXRlZC5cbiAgICpcbiAgICogQ2FsbCByZWF1dGhlbnRpY2F0ZSgpIHRvIG9idGFpbiB0aGUgbm9uY2UgZmlyc3QuXG4gICAqL1xuICBub25jZT86IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBBIGN1c3RvbSBkYXRhIG9iamVjdCB0byBzdG9yZSB0aGUgdXNlcidzIG1ldGFkYXRhLiBUaGlzIG1hcHMgdG8gdGhlIGBhdXRoLnVzZXJzLnJhd191c2VyX21ldGFfZGF0YWAgY29sdW1uLlxuICAgKlxuICAgKiBUaGUgYGRhdGFgIHNob3VsZCBiZSBhIEpTT04gb2JqZWN0IHRoYXQgaW5jbHVkZXMgdXNlci1zcGVjaWZpYyBpbmZvLCBzdWNoIGFzIHRoZWlyIGZpcnN0IGFuZCBsYXN0IG5hbWUuXG4gICAqXG4gICAqL1xuICBkYXRhPzogb2JqZWN0XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWRtaW5Vc2VyQXR0cmlidXRlcyBleHRlbmRzIE9taXQ8VXNlckF0dHJpYnV0ZXMsICdkYXRhJz4ge1xuICAvKipcbiAgICogQSBjdXN0b20gZGF0YSBvYmplY3QgdG8gc3RvcmUgdGhlIHVzZXIncyBtZXRhZGF0YS4gVGhpcyBtYXBzIHRvIHRoZSBgYXV0aC51c2Vycy5yYXdfdXNlcl9tZXRhX2RhdGFgIGNvbHVtbi5cbiAgICpcbiAgICpcbiAgICogVGhlIGB1c2VyX21ldGFkYXRhYCBzaG91bGQgYmUgYSBKU09OIG9iamVjdCB0aGF0IGluY2x1ZGVzIHVzZXItc3BlY2lmaWMgaW5mbywgc3VjaCBhcyB0aGVpciBmaXJzdCBhbmQgbGFzdCBuYW1lLlxuICAgKlxuICAgKiBOb3RlOiBXaGVuIHVzaW5nIHRoZSBHb1RydWVBZG1pbkFwaSBhbmQgd2FudGluZyB0byBtb2RpZnkgYSB1c2VyJ3MgbWV0YWRhdGEsXG4gICAqIHRoaXMgYXR0cmlidXRlIGlzIHVzZWQgaW5zdGVhZCBvZiBVc2VyQXR0cmlidXRlcyBkYXRhLlxuICAgKlxuICAgKi9cbiAgdXNlcl9tZXRhZGF0YT86IG9iamVjdFxuXG4gIC8qKlxuICAgKiBBIGN1c3RvbSBkYXRhIG9iamVjdCB0byBzdG9yZSB0aGUgdXNlcidzIGFwcGxpY2F0aW9uIHNwZWNpZmljIG1ldGFkYXRhLiBUaGlzIG1hcHMgdG8gdGhlIGBhdXRoLnVzZXJzLmFwcF9tZXRhZGF0YWAgY29sdW1uLlxuICAgKlxuICAgKiBPbmx5IGEgc2VydmljZSByb2xlIGNhbiBtb2RpZnkuXG4gICAqXG4gICAqIFRoZSBgYXBwX21ldGFkYXRhYCBzaG91bGQgYmUgYSBKU09OIG9iamVjdCB0aGF0IGluY2x1ZGVzIGFwcC1zcGVjaWZpYyBpbmZvLCBzdWNoIGFzIGlkZW50aXR5IHByb3ZpZGVycywgcm9sZXMsIGFuZCBvdGhlclxuICAgKiBhY2Nlc3MgY29udHJvbCBpbmZvcm1hdGlvbi5cbiAgICovXG4gIGFwcF9tZXRhZGF0YT86IG9iamVjdFxuXG4gIC8qKlxuICAgKiBDb25maXJtcyB0aGUgdXNlcidzIGVtYWlsIGFkZHJlc3MgaWYgc2V0IHRvIHRydWUuXG4gICAqXG4gICAqIE9ubHkgYSBzZXJ2aWNlIHJvbGUgY2FuIG1vZGlmeS5cbiAgICovXG4gIGVtYWlsX2NvbmZpcm0/OiBib29sZWFuXG5cbiAgLyoqXG4gICAqIENvbmZpcm1zIHRoZSB1c2VyJ3MgcGhvbmUgbnVtYmVyIGlmIHNldCB0byB0cnVlLlxuICAgKlxuICAgKiBPbmx5IGEgc2VydmljZSByb2xlIGNhbiBtb2RpZnkuXG4gICAqL1xuICBwaG9uZV9jb25maXJtPzogYm9vbGVhblxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGhvdyBsb25nIGEgdXNlciBpcyBiYW5uZWQgZm9yLlxuICAgKlxuICAgKiBUaGUgZm9ybWF0IGZvciB0aGUgYmFuIGR1cmF0aW9uIGZvbGxvd3MgYSBzdHJpY3Qgc2VxdWVuY2Ugb2YgZGVjaW1hbCBudW1iZXJzIHdpdGggYSB1bml0IHN1ZmZpeC5cbiAgICogVmFsaWQgdGltZSB1bml0cyBhcmUgXCJuc1wiLCBcInVzXCIgKG9yIFwiwrVzXCIpLCBcIm1zXCIsIFwic1wiLCBcIm1cIiwgXCJoXCIuXG4gICAqXG4gICAqIEZvciBleGFtcGxlLCBzb21lIHBvc3NpYmxlIGR1cmF0aW9ucyBpbmNsdWRlOiAnMzAwbXMnLCAnMmg0NW0nLlxuICAgKlxuICAgKiBTZXR0aW5nIHRoZSBiYW4gZHVyYXRpb24gdG8gJ25vbmUnIGxpZnRzIHRoZSBiYW4gb24gdGhlIHVzZXIuXG4gICAqL1xuICBiYW5fZHVyYXRpb24/OiBzdHJpbmcgfCAnbm9uZSdcblxuICAvKipcbiAgICogVGhlIGByb2xlYCBjbGFpbSBzZXQgaW4gdGhlIHVzZXIncyBhY2Nlc3MgdG9rZW4gSldULlxuICAgKlxuICAgKiBXaGVuIGEgdXNlciBzaWducyB1cCwgdGhpcyByb2xlIGlzIHNldCB0byBgYXV0aGVudGljYXRlZGAgYnkgZGVmYXVsdC4gWW91IHNob3VsZCBvbmx5IG1vZGlmeSB0aGUgYHJvbGVgIGlmIHlvdSBuZWVkIHRvIHByb3Zpc2lvbiBzZXZlcmFsIGxldmVscyBvZiBhZG1pbiBhY2Nlc3MgdGhhdCBoYXZlIGRpZmZlcmVudCBwZXJtaXNzaW9ucyBvbiBpbmRpdmlkdWFsIGNvbHVtbnMgaW4geW91ciBkYXRhYmFzZS5cbiAgICpcbiAgICogU2V0dGluZyB0aGlzIHJvbGUgdG8gYHNlcnZpY2Vfcm9sZWAgaXMgbm90IHJlY29tbWVuZGVkIGFzIGl0IGdyYW50cyB0aGUgdXNlciBhZG1pbiBwcml2aWxlZ2VzLlxuICAgKi9cbiAgcm9sZT86IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBUaGUgYHBhc3N3b3JkX2hhc2hgIGZvciB0aGUgdXNlcidzIHBhc3N3b3JkLlxuICAgKlxuICAgKiBBbGxvd3MgeW91IHRvIHNwZWNpZnkgYSBwYXNzd29yZCBoYXNoIGZvciB0aGUgdXNlci4gVGhpcyBpcyB1c2VmdWwgZm9yIG1pZ3JhdGluZyBhIHVzZXIncyBwYXNzd29yZCBoYXNoIGZyb20gYW5vdGhlciBzZXJ2aWNlLlxuICAgKlxuICAgKiBTdXBwb3J0cyBiY3J5cHQgYW5kIGFyZ29uMiBwYXNzd29yZCBoYXNoZXMuXG4gICAqL1xuICBwYXNzd29yZF9oYXNoPzogc3RyaW5nXG5cbiAgLyoqXG4gICAqIFRoZSBgaWRgIGZvciB0aGUgdXNlci5cbiAgICpcbiAgICogQWxsb3dzIHlvdSB0byBvdmVyd3JpdGUgdGhlIGRlZmF1bHQgYGlkYCBzZXQgZm9yIHRoZSB1c2VyLlxuICAgKi9cbiAgaWQ/OiBzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdWJzY3JpcHRpb24ge1xuICAvKipcbiAgICogVGhlIHN1YnNjcmliZXIgVVVJRC4gVGhpcyB3aWxsIGJlIHNldCBieSB0aGUgY2xpZW50LlxuICAgKi9cbiAgaWQ6IHN0cmluZ1xuICAvKipcbiAgICogVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZXZlcnkgdGltZSB0aGVyZSBpcyBhbiBldmVudC4gZWc6IChldmVudE5hbWUpID0+IHt9XG4gICAqL1xuICBjYWxsYmFjazogKGV2ZW50OiBBdXRoQ2hhbmdlRXZlbnQsIHNlc3Npb246IFNlc3Npb24gfCBudWxsKSA9PiB2b2lkXG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lci5cbiAgICovXG4gIHVuc3Vic2NyaWJlOiAoKSA9PiB2b2lkXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXBkYXRhYmxlRmFjdG9yQXR0cmlidXRlcyB7XG4gIGZyaWVuZGx5TmFtZTogc3RyaW5nXG59XG5cbmV4cG9ydCB0eXBlIFNpZ25JbkFub255bW91c2x5Q3JlZGVudGlhbHMgPSB7XG4gIG9wdGlvbnM/OiB7XG4gICAgLyoqXG4gICAgICogQSBjdXN0b20gZGF0YSBvYmplY3QgdG8gc3RvcmUgdGhlIHVzZXIncyBtZXRhZGF0YS4gVGhpcyBtYXBzIHRvIHRoZSBgYXV0aC51c2Vycy5yYXdfdXNlcl9tZXRhX2RhdGFgIGNvbHVtbi5cbiAgICAgKlxuICAgICAqIFRoZSBgZGF0YWAgc2hvdWxkIGJlIGEgSlNPTiBvYmplY3QgdGhhdCBpbmNsdWRlcyB1c2VyLXNwZWNpZmljIGluZm8sIHN1Y2ggYXMgdGhlaXIgZmlyc3QgYW5kIGxhc3QgbmFtZS5cbiAgICAgKi9cbiAgICBkYXRhPzogb2JqZWN0XG4gICAgLyoqIFZlcmlmaWNhdGlvbiB0b2tlbiByZWNlaXZlZCB3aGVuIHRoZSB1c2VyIGNvbXBsZXRlcyB0aGUgY2FwdGNoYSBvbiB0aGUgc2l0ZS4gKi9cbiAgICBjYXB0Y2hhVG9rZW4/OiBzdHJpbmdcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBTaWduVXBXaXRoUGFzc3dvcmRDcmVkZW50aWFscyA9XG4gIHwge1xuICAgICAgLyoqIFRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcy4gKi9cbiAgICAgIGVtYWlsOiBzdHJpbmdcbiAgICAgIC8qKiBUaGUgdXNlcidzIHBhc3N3b3JkLiAqL1xuICAgICAgcGFzc3dvcmQ6IHN0cmluZ1xuICAgICAgb3B0aW9ucz86IHtcbiAgICAgICAgLyoqIFRoZSByZWRpcmVjdCB1cmwgZW1iZWRkZWQgaW4gdGhlIGVtYWlsIGxpbmsgKi9cbiAgICAgICAgZW1haWxSZWRpcmVjdFRvPzogc3RyaW5nXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGN1c3RvbSBkYXRhIG9iamVjdCB0byBzdG9yZSB0aGUgdXNlcidzIG1ldGFkYXRhLiBUaGlzIG1hcHMgdG8gdGhlIGBhdXRoLnVzZXJzLnJhd191c2VyX21ldGFfZGF0YWAgY29sdW1uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgYGRhdGFgIHNob3VsZCBiZSBhIEpTT04gb2JqZWN0IHRoYXQgaW5jbHVkZXMgdXNlci1zcGVjaWZpYyBpbmZvLCBzdWNoIGFzIHRoZWlyIGZpcnN0IGFuZCBsYXN0IG5hbWUuXG4gICAgICAgICAqL1xuICAgICAgICBkYXRhPzogb2JqZWN0XG4gICAgICAgIC8qKiBWZXJpZmljYXRpb24gdG9rZW4gcmVjZWl2ZWQgd2hlbiB0aGUgdXNlciBjb21wbGV0ZXMgdGhlIGNhcHRjaGEgb24gdGhlIHNpdGUuICovXG4gICAgICAgIGNhcHRjaGFUb2tlbj86IHN0cmluZ1xuICAgICAgfVxuICAgIH1cbiAgfCB7XG4gICAgICAvKiogVGhlIHVzZXIncyBwaG9uZSBudW1iZXIuICovXG4gICAgICBwaG9uZTogc3RyaW5nXG4gICAgICAvKiogVGhlIHVzZXIncyBwYXNzd29yZC4gKi9cbiAgICAgIHBhc3N3b3JkOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM/OiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGN1c3RvbSBkYXRhIG9iamVjdCB0byBzdG9yZSB0aGUgdXNlcidzIG1ldGFkYXRhLiBUaGlzIG1hcHMgdG8gdGhlIGBhdXRoLnVzZXJzLnJhd191c2VyX21ldGFfZGF0YWAgY29sdW1uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgYGRhdGFgIHNob3VsZCBiZSBhIEpTT04gb2JqZWN0IHRoYXQgaW5jbHVkZXMgdXNlci1zcGVjaWZpYyBpbmZvLCBzdWNoIGFzIHRoZWlyIGZpcnN0IGFuZCBsYXN0IG5hbWUuXG4gICAgICAgICAqL1xuICAgICAgICBkYXRhPzogb2JqZWN0XG4gICAgICAgIC8qKiBWZXJpZmljYXRpb24gdG9rZW4gcmVjZWl2ZWQgd2hlbiB0aGUgdXNlciBjb21wbGV0ZXMgdGhlIGNhcHRjaGEgb24gdGhlIHNpdGUuIFJlcXVpcmVzIGEgY29uZmlndXJlZCBXaGF0c0FwcCBzZW5kZXIgb24gVHdpbGlvICovXG4gICAgICAgIGNhcHRjaGFUb2tlbj86IHN0cmluZ1xuICAgICAgICAvKiogTWVzc2FnaW5nIGNoYW5uZWwgdG8gdXNlIChlLmcuIHdoYXRzYXBwIG9yIHNtcykgKi9cbiAgICAgICAgY2hhbm5lbD86ICdzbXMnIHwgJ3doYXRzYXBwJ1xuICAgICAgfVxuICAgIH1cbmV4cG9ydCB0eXBlIFNpZ25JbldpdGhQYXNzd29yZENyZWRlbnRpYWxzID1cbiAgfCB7XG4gICAgICAvKiogVGhlIHVzZXIncyBlbWFpbCBhZGRyZXNzLiAqL1xuICAgICAgZW1haWw6IHN0cmluZ1xuICAgICAgLyoqIFRoZSB1c2VyJ3MgcGFzc3dvcmQuICovXG4gICAgICBwYXNzd29yZDogc3RyaW5nXG4gICAgICBvcHRpb25zPzoge1xuICAgICAgICAvKiogVmVyaWZpY2F0aW9uIHRva2VuIHJlY2VpdmVkIHdoZW4gdGhlIHVzZXIgY29tcGxldGVzIHRoZSBjYXB0Y2hhIG9uIHRoZSBzaXRlLiAqL1xuICAgICAgICBjYXB0Y2hhVG9rZW4/OiBzdHJpbmdcbiAgICAgIH1cbiAgICB9XG4gIHwge1xuICAgICAgLyoqIFRoZSB1c2VyJ3MgcGhvbmUgbnVtYmVyLiAqL1xuICAgICAgcGhvbmU6IHN0cmluZ1xuICAgICAgLyoqIFRoZSB1c2VyJ3MgcGFzc3dvcmQuICovXG4gICAgICBwYXNzd29yZDogc3RyaW5nXG4gICAgICBvcHRpb25zPzoge1xuICAgICAgICAvKiogVmVyaWZpY2F0aW9uIHRva2VuIHJlY2VpdmVkIHdoZW4gdGhlIHVzZXIgY29tcGxldGVzIHRoZSBjYXB0Y2hhIG9uIHRoZSBzaXRlLiAqL1xuICAgICAgICBjYXB0Y2hhVG9rZW4/OiBzdHJpbmdcbiAgICAgIH1cbiAgICB9XG5cbmV4cG9ydCB0eXBlIFNpZ25JbldpdGhQYXNzd29yZGxlc3NDcmVkZW50aWFscyA9XG4gIHwge1xuICAgICAgLyoqIFRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcy4gKi9cbiAgICAgIGVtYWlsOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM/OiB7XG4gICAgICAgIC8qKiBUaGUgcmVkaXJlY3QgdXJsIGVtYmVkZGVkIGluIHRoZSBlbWFpbCBsaW5rICovXG4gICAgICAgIGVtYWlsUmVkaXJlY3RUbz86IHN0cmluZ1xuICAgICAgICAvKiogSWYgc2V0IHRvIGZhbHNlLCB0aGlzIG1ldGhvZCB3aWxsIG5vdCBjcmVhdGUgYSBuZXcgdXNlci4gRGVmYXVsdHMgdG8gdHJ1ZS4gKi9cbiAgICAgICAgc2hvdWxkQ3JlYXRlVXNlcj86IGJvb2xlYW5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY3VzdG9tIGRhdGEgb2JqZWN0IHRvIHN0b3JlIHRoZSB1c2VyJ3MgbWV0YWRhdGEuIFRoaXMgbWFwcyB0byB0aGUgYGF1dGgudXNlcnMucmF3X3VzZXJfbWV0YV9kYXRhYCBjb2x1bW4uXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBgZGF0YWAgc2hvdWxkIGJlIGEgSlNPTiBvYmplY3QgdGhhdCBpbmNsdWRlcyB1c2VyLXNwZWNpZmljIGluZm8sIHN1Y2ggYXMgdGhlaXIgZmlyc3QgYW5kIGxhc3QgbmFtZS5cbiAgICAgICAgICovXG4gICAgICAgIGRhdGE/OiBvYmplY3RcbiAgICAgICAgLyoqIFZlcmlmaWNhdGlvbiB0b2tlbiByZWNlaXZlZCB3aGVuIHRoZSB1c2VyIGNvbXBsZXRlcyB0aGUgY2FwdGNoYSBvbiB0aGUgc2l0ZS4gKi9cbiAgICAgICAgY2FwdGNoYVRva2VuPzogc3RyaW5nXG4gICAgICB9XG4gICAgfVxuICB8IHtcbiAgICAgIC8qKiBUaGUgdXNlcidzIHBob25lIG51bWJlci4gKi9cbiAgICAgIHBob25lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM/OiB7XG4gICAgICAgIC8qKiBJZiBzZXQgdG8gZmFsc2UsIHRoaXMgbWV0aG9kIHdpbGwgbm90IGNyZWF0ZSBhIG5ldyB1c2VyLiBEZWZhdWx0cyB0byB0cnVlLiAqL1xuICAgICAgICBzaG91bGRDcmVhdGVVc2VyPzogYm9vbGVhblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBjdXN0b20gZGF0YSBvYmplY3QgdG8gc3RvcmUgdGhlIHVzZXIncyBtZXRhZGF0YS4gVGhpcyBtYXBzIHRvIHRoZSBgYXV0aC51c2Vycy5yYXdfdXNlcl9tZXRhX2RhdGFgIGNvbHVtbi5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGBkYXRhYCBzaG91bGQgYmUgYSBKU09OIG9iamVjdCB0aGF0IGluY2x1ZGVzIHVzZXItc3BlY2lmaWMgaW5mbywgc3VjaCBhcyB0aGVpciBmaXJzdCBhbmQgbGFzdCBuYW1lLlxuICAgICAgICAgKi9cbiAgICAgICAgZGF0YT86IG9iamVjdFxuICAgICAgICAvKiogVmVyaWZpY2F0aW9uIHRva2VuIHJlY2VpdmVkIHdoZW4gdGhlIHVzZXIgY29tcGxldGVzIHRoZSBjYXB0Y2hhIG9uIHRoZSBzaXRlLiAqL1xuICAgICAgICBjYXB0Y2hhVG9rZW4/OiBzdHJpbmdcbiAgICAgICAgLyoqIE1lc3NhZ2luZyBjaGFubmVsIHRvIHVzZSAoZS5nLiB3aGF0c2FwcCBvciBzbXMpICovXG4gICAgICAgIGNoYW5uZWw/OiAnc21zJyB8ICd3aGF0c2FwcCdcbiAgICAgIH1cbiAgICB9XG5cbmV4cG9ydCB0eXBlIEF1dGhGbG93VHlwZSA9ICdpbXBsaWNpdCcgfCAncGtjZSdcbmV4cG9ydCB0eXBlIFNpZ25JbldpdGhPQXV0aENyZWRlbnRpYWxzID0ge1xuICAvKiogT25lIG9mIHRoZSBwcm92aWRlcnMgc3VwcG9ydGVkIGJ5IEdvVHJ1ZS4gKi9cbiAgcHJvdmlkZXI6IFByb3ZpZGVyXG4gIG9wdGlvbnM/OiB7XG4gICAgLyoqIEEgVVJMIHRvIHNlbmQgdGhlIHVzZXIgdG8gYWZ0ZXIgdGhleSBhcmUgY29uZmlybWVkLiAqL1xuICAgIHJlZGlyZWN0VG8/OiBzdHJpbmdcbiAgICAvKiogQSBzcGFjZS1zZXBhcmF0ZWQgbGlzdCBvZiBzY29wZXMgZ3JhbnRlZCB0byB0aGUgT0F1dGggYXBwbGljYXRpb24uICovXG4gICAgc2NvcGVzPzogc3RyaW5nXG4gICAgLyoqIEFuIG9iamVjdCBvZiBxdWVyeSBwYXJhbXMgKi9cbiAgICBxdWVyeVBhcmFtcz86IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH1cbiAgICAvKiogSWYgc2V0IHRvIHRydWUgZG9lcyBub3QgaW1tZWRpYXRlbHkgcmVkaXJlY3QgdGhlIGN1cnJlbnQgYnJvd3NlciBjb250ZXh0IHRvIHZpc2l0IHRoZSBPQXV0aCBhdXRob3JpemF0aW9uIHBhZ2UgZm9yIHRoZSBwcm92aWRlci4gKi9cbiAgICBza2lwQnJvd3NlclJlZGlyZWN0PzogYm9vbGVhblxuICB9XG59XG5cbmV4cG9ydCB0eXBlIFNpZ25JbldpdGhJZFRva2VuQ3JlZGVudGlhbHMgPSB7XG4gIC8qKiBQcm92aWRlciBuYW1lIG9yIE9JREMgYGlzc2AgdmFsdWUgaWRlbnRpZnlpbmcgd2hpY2ggcHJvdmlkZXIgc2hvdWxkIGJlIHVzZWQgdG8gdmVyaWZ5IHRoZSBwcm92aWRlZCB0b2tlbi4gU3VwcG9ydGVkIG5hbWVzOiBgZ29vZ2xlYCwgYGFwcGxlYCwgYGF6dXJlYCwgYGZhY2Vib29rYCwgYGtleWNsb2FrYCAoZGVwcmVjYXRlZCkuICovXG4gIHByb3ZpZGVyOiAnZ29vZ2xlJyB8ICdhcHBsZScgfCAnYXp1cmUnIHwgJ2ZhY2Vib29rJyB8IHN0cmluZ1xuICAvKiogT0lEQyBJRCB0b2tlbiBpc3N1ZWQgYnkgdGhlIHNwZWNpZmllZCBwcm92aWRlci4gVGhlIGBpc3NgIGNsYWltIGluIHRoZSBJRCB0b2tlbiBtdXN0IG1hdGNoIHRoZSBzdXBwbGllZCBwcm92aWRlci4gU29tZSBJRCB0b2tlbnMgY29udGFpbiBhbiBgYXRfaGFzaGAgd2hpY2ggcmVxdWlyZSB0aGF0IHlvdSBwcm92aWRlIGFuIGBhY2Nlc3NfdG9rZW5gIHZhbHVlIHRvIGJlIGFjY2VwdGVkIHByb3Blcmx5LiBJZiB0aGUgdG9rZW4gY29udGFpbnMgYSBgbm9uY2VgIGNsYWltIHlvdSBtdXN0IHN1cHBseSB0aGUgbm9uY2UgdXNlZCB0byBvYnRhaW4gdGhlIElEIHRva2VuLiAqL1xuICB0b2tlbjogc3RyaW5nXG4gIC8qKiBJZiB0aGUgSUQgdG9rZW4gY29udGFpbnMgYW4gYGF0X2hhc2hgIGNsYWltLCB0aGVuIHRoZSBoYXNoIG9mIHRoaXMgdmFsdWUgaXMgY29tcGFyZWQgdG8gdGhlIHZhbHVlIGluIHRoZSBJRCB0b2tlbi4gKi9cbiAgYWNjZXNzX3Rva2VuPzogc3RyaW5nXG4gIC8qKiBJZiB0aGUgSUQgdG9rZW4gY29udGFpbnMgYSBgbm9uY2VgIGNsYWltLCB0aGVuIHRoZSBoYXNoIG9mIHRoaXMgdmFsdWUgaXMgY29tcGFyZWQgdG8gdGhlIHZhbHVlIGluIHRoZSBJRCB0b2tlbi4gKi9cbiAgbm9uY2U/OiBzdHJpbmdcbiAgb3B0aW9ucz86IHtcbiAgICAvKiogVmVyaWZpY2F0aW9uIHRva2VuIHJlY2VpdmVkIHdoZW4gdGhlIHVzZXIgY29tcGxldGVzIHRoZSBjYXB0Y2hhIG9uIHRoZSBzaXRlLiAqL1xuICAgIGNhcHRjaGFUb2tlbj86IHN0cmluZ1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIFZlcmlmeU90cFBhcmFtcyA9IFZlcmlmeU1vYmlsZU90cFBhcmFtcyB8IFZlcmlmeUVtYWlsT3RwUGFyYW1zIHwgVmVyaWZ5VG9rZW5IYXNoUGFyYW1zXG5leHBvcnQgaW50ZXJmYWNlIFZlcmlmeU1vYmlsZU90cFBhcmFtcyB7XG4gIC8qKiBUaGUgdXNlcidzIHBob25lIG51bWJlci4gKi9cbiAgcGhvbmU6IHN0cmluZ1xuICAvKiogVGhlIG90cCBzZW50IHRvIHRoZSB1c2VyJ3MgcGhvbmUgbnVtYmVyLiAqL1xuICB0b2tlbjogc3RyaW5nXG4gIC8qKiBUaGUgdXNlcidzIHZlcmlmaWNhdGlvbiB0eXBlLiAqL1xuICB0eXBlOiBNb2JpbGVPdHBUeXBlXG4gIG9wdGlvbnM/OiB7XG4gICAgLyoqIEEgVVJMIHRvIHNlbmQgdGhlIHVzZXIgdG8gYWZ0ZXIgdGhleSBhcmUgY29uZmlybWVkLiAqL1xuICAgIHJlZGlyZWN0VG8/OiBzdHJpbmdcblxuICAgIC8qKlxuICAgICAqIFZlcmlmaWNhdGlvbiB0b2tlbiByZWNlaXZlZCB3aGVuIHRoZSB1c2VyIGNvbXBsZXRlcyB0aGUgY2FwdGNoYSBvbiB0aGUgc2l0ZS5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgY2FwdGNoYVRva2VuPzogc3RyaW5nXG4gIH1cbn1cbmV4cG9ydCBpbnRlcmZhY2UgVmVyaWZ5RW1haWxPdHBQYXJhbXMge1xuICAvKiogVGhlIHVzZXIncyBlbWFpbCBhZGRyZXNzLiAqL1xuICBlbWFpbDogc3RyaW5nXG4gIC8qKiBUaGUgb3RwIHNlbnQgdG8gdGhlIHVzZXIncyBlbWFpbCBhZGRyZXNzLiAqL1xuICB0b2tlbjogc3RyaW5nXG4gIC8qKiBUaGUgdXNlcidzIHZlcmlmaWNhdGlvbiB0eXBlLiAqL1xuICB0eXBlOiBFbWFpbE90cFR5cGVcbiAgb3B0aW9ucz86IHtcbiAgICAvKiogQSBVUkwgdG8gc2VuZCB0aGUgdXNlciB0byBhZnRlciB0aGV5IGFyZSBjb25maXJtZWQuICovXG4gICAgcmVkaXJlY3RUbz86IHN0cmluZ1xuXG4gICAgLyoqIFZlcmlmaWNhdGlvbiB0b2tlbiByZWNlaXZlZCB3aGVuIHRoZSB1c2VyIGNvbXBsZXRlcyB0aGUgY2FwdGNoYSBvbiB0aGUgc2l0ZS5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgY2FwdGNoYVRva2VuPzogc3RyaW5nXG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBWZXJpZnlUb2tlbkhhc2hQYXJhbXMge1xuICAvKiogVGhlIHRva2VuIGhhc2ggdXNlZCBpbiBhbiBlbWFpbCBsaW5rICovXG4gIHRva2VuX2hhc2g6IHN0cmluZ1xuXG4gIC8qKiBUaGUgdXNlcidzIHZlcmlmaWNhdGlvbiB0eXBlLiAqL1xuICB0eXBlOiBFbWFpbE90cFR5cGVcbn1cblxuZXhwb3J0IHR5cGUgTW9iaWxlT3RwVHlwZSA9ICdzbXMnIHwgJ3Bob25lX2NoYW5nZSdcbmV4cG9ydCB0eXBlIEVtYWlsT3RwVHlwZSA9ICdzaWdudXAnIHwgJ2ludml0ZScgfCAnbWFnaWNsaW5rJyB8ICdyZWNvdmVyeScgfCAnZW1haWxfY2hhbmdlJyB8ICdlbWFpbCdcblxuZXhwb3J0IHR5cGUgUmVzZW5kUGFyYW1zID1cbiAgfCB7XG4gICAgICB0eXBlOiBFeHRyYWN0PEVtYWlsT3RwVHlwZSwgJ3NpZ251cCcgfCAnZW1haWxfY2hhbmdlJz5cbiAgICAgIGVtYWlsOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM/OiB7XG4gICAgICAgIC8qKiBBIFVSTCB0byBzZW5kIHRoZSB1c2VyIHRvIGFmdGVyIHRoZXkgaGF2ZSBzaWduZWQtaW4uICovXG4gICAgICAgIGVtYWlsUmVkaXJlY3RUbz86IHN0cmluZ1xuICAgICAgICAvKiogVmVyaWZpY2F0aW9uIHRva2VuIHJlY2VpdmVkIHdoZW4gdGhlIHVzZXIgY29tcGxldGVzIHRoZSBjYXB0Y2hhIG9uIHRoZSBzaXRlLiAqL1xuICAgICAgICBjYXB0Y2hhVG9rZW4/OiBzdHJpbmdcbiAgICAgIH1cbiAgICB9XG4gIHwge1xuICAgICAgdHlwZTogRXh0cmFjdDxNb2JpbGVPdHBUeXBlLCAnc21zJyB8ICdwaG9uZV9jaGFuZ2UnPlxuICAgICAgcGhvbmU6IHN0cmluZ1xuICAgICAgb3B0aW9ucz86IHtcbiAgICAgICAgLyoqIFZlcmlmaWNhdGlvbiB0b2tlbiByZWNlaXZlZCB3aGVuIHRoZSB1c2VyIGNvbXBsZXRlcyB0aGUgY2FwdGNoYSBvbiB0aGUgc2l0ZS4gKi9cbiAgICAgICAgY2FwdGNoYVRva2VuPzogc3RyaW5nXG4gICAgICB9XG4gICAgfVxuXG5leHBvcnQgdHlwZSBTaWduSW5XaXRoU1NPID1cbiAgfCB7XG4gICAgICAvKiogVVVJRCBvZiB0aGUgU1NPIHByb3ZpZGVyIHRvIGludm9rZSBzaW5nbGUtc2lnbiBvbiB0by4gKi9cbiAgICAgIHByb3ZpZGVySWQ6IHN0cmluZ1xuXG4gICAgICBvcHRpb25zPzoge1xuICAgICAgICAvKiogQSBVUkwgdG8gc2VuZCB0aGUgdXNlciB0byBhZnRlciB0aGV5IGhhdmUgc2lnbmVkLWluLiAqL1xuICAgICAgICByZWRpcmVjdFRvPzogc3RyaW5nXG4gICAgICAgIC8qKiBWZXJpZmljYXRpb24gdG9rZW4gcmVjZWl2ZWQgd2hlbiB0aGUgdXNlciBjb21wbGV0ZXMgdGhlIGNhcHRjaGEgb24gdGhlIHNpdGUuICovXG4gICAgICAgIGNhcHRjaGFUb2tlbj86IHN0cmluZ1xuICAgICAgfVxuICAgIH1cbiAgfCB7XG4gICAgICAvKiogRG9tYWluIG5hbWUgb2YgdGhlIG9yZ2FuaXphdGlvbiBmb3Igd2hpY2ggdG8gaW52b2tlIHNpbmdsZS1zaWduIG9uLiAqL1xuICAgICAgZG9tYWluOiBzdHJpbmdcblxuICAgICAgb3B0aW9ucz86IHtcbiAgICAgICAgLyoqIEEgVVJMIHRvIHNlbmQgdGhlIHVzZXIgdG8gYWZ0ZXIgdGhleSBoYXZlIHNpZ25lZC1pbi4gKi9cbiAgICAgICAgcmVkaXJlY3RUbz86IHN0cmluZ1xuICAgICAgICAvKiogVmVyaWZpY2F0aW9uIHRva2VuIHJlY2VpdmVkIHdoZW4gdGhlIHVzZXIgY29tcGxldGVzIHRoZSBjYXB0Y2hhIG9uIHRoZSBzaXRlLiAqL1xuICAgICAgICBjYXB0Y2hhVG9rZW4/OiBzdHJpbmdcbiAgICAgIH1cbiAgICB9XG5cbmV4cG9ydCB0eXBlIEdlbmVyYXRlU2lnbnVwTGlua1BhcmFtcyA9IHtcbiAgdHlwZTogJ3NpZ251cCdcbiAgZW1haWw6IHN0cmluZ1xuICBwYXNzd29yZDogc3RyaW5nXG4gIG9wdGlvbnM/OiBQaWNrPEdlbmVyYXRlTGlua09wdGlvbnMsICdkYXRhJyB8ICdyZWRpcmVjdFRvJz5cbn1cblxuZXhwb3J0IHR5cGUgR2VuZXJhdGVJbnZpdGVPck1hZ2ljbGlua1BhcmFtcyA9IHtcbiAgdHlwZTogJ2ludml0ZScgfCAnbWFnaWNsaW5rJ1xuICAvKiogVGhlIHVzZXIncyBlbWFpbCAqL1xuICBlbWFpbDogc3RyaW5nXG4gIG9wdGlvbnM/OiBQaWNrPEdlbmVyYXRlTGlua09wdGlvbnMsICdkYXRhJyB8ICdyZWRpcmVjdFRvJz5cbn1cblxuZXhwb3J0IHR5cGUgR2VuZXJhdGVSZWNvdmVyeUxpbmtQYXJhbXMgPSB7XG4gIHR5cGU6ICdyZWNvdmVyeSdcbiAgLyoqIFRoZSB1c2VyJ3MgZW1haWwgKi9cbiAgZW1haWw6IHN0cmluZ1xuICBvcHRpb25zPzogUGljazxHZW5lcmF0ZUxpbmtPcHRpb25zLCAncmVkaXJlY3RUbyc+XG59XG5cbmV4cG9ydCB0eXBlIEdlbmVyYXRlRW1haWxDaGFuZ2VMaW5rUGFyYW1zID0ge1xuICB0eXBlOiAnZW1haWxfY2hhbmdlX2N1cnJlbnQnIHwgJ2VtYWlsX2NoYW5nZV9uZXcnXG4gIC8qKiBUaGUgdXNlcidzIGVtYWlsICovXG4gIGVtYWlsOiBzdHJpbmdcbiAgLyoqXG4gICAqIFRoZSB1c2VyJ3MgbmV3IGVtYWlsLiBPbmx5IHJlcXVpcmVkIGlmIHR5cGUgaXMgJ2VtYWlsX2NoYW5nZV9jdXJyZW50JyBvciAnZW1haWxfY2hhbmdlX25ldycuXG4gICAqL1xuICBuZXdFbWFpbDogc3RyaW5nXG4gIG9wdGlvbnM/OiBQaWNrPEdlbmVyYXRlTGlua09wdGlvbnMsICdyZWRpcmVjdFRvJz5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBHZW5lcmF0ZUxpbmtPcHRpb25zIHtcbiAgLyoqXG4gICAqIEEgY3VzdG9tIGRhdGEgb2JqZWN0IHRvIHN0b3JlIHRoZSB1c2VyJ3MgbWV0YWRhdGEuIFRoaXMgbWFwcyB0byB0aGUgYGF1dGgudXNlcnMucmF3X3VzZXJfbWV0YV9kYXRhYCBjb2x1bW4uXG4gICAqXG4gICAqIFRoZSBgZGF0YWAgc2hvdWxkIGJlIGEgSlNPTiBvYmplY3QgdGhhdCBpbmNsdWRlcyB1c2VyLXNwZWNpZmljIGluZm8sIHN1Y2ggYXMgdGhlaXIgZmlyc3QgYW5kIGxhc3QgbmFtZS5cbiAgICovXG4gIGRhdGE/OiBvYmplY3RcbiAgLyoqIFRoZSBVUkwgd2hpY2ggd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgZW1haWwgbGluayBnZW5lcmF0ZWQuICovXG4gIHJlZGlyZWN0VG8/OiBzdHJpbmdcbn1cblxuZXhwb3J0IHR5cGUgR2VuZXJhdGVMaW5rUGFyYW1zID1cbiAgfCBHZW5lcmF0ZVNpZ251cExpbmtQYXJhbXNcbiAgfCBHZW5lcmF0ZUludml0ZU9yTWFnaWNsaW5rUGFyYW1zXG4gIHwgR2VuZXJhdGVSZWNvdmVyeUxpbmtQYXJhbXNcbiAgfCBHZW5lcmF0ZUVtYWlsQ2hhbmdlTGlua1BhcmFtc1xuXG5leHBvcnQgdHlwZSBHZW5lcmF0ZUxpbmtSZXNwb25zZSA9XG4gIHwge1xuICAgICAgZGF0YToge1xuICAgICAgICBwcm9wZXJ0aWVzOiBHZW5lcmF0ZUxpbmtQcm9wZXJ0aWVzXG4gICAgICAgIHVzZXI6IFVzZXJcbiAgICAgIH1cbiAgICAgIGVycm9yOiBudWxsXG4gICAgfVxuICB8IHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgcHJvcGVydGllczogbnVsbFxuICAgICAgICB1c2VyOiBudWxsXG4gICAgICB9XG4gICAgICBlcnJvcjogQXV0aEVycm9yXG4gICAgfVxuXG4vKiogVGhlIHByb3BlcnRpZXMgcmVsYXRlZCB0byB0aGUgZW1haWwgbGluayBnZW5lcmF0ZWQgICovXG5leHBvcnQgdHlwZSBHZW5lcmF0ZUxpbmtQcm9wZXJ0aWVzID0ge1xuICAvKipcbiAgICogVGhlIGVtYWlsIGxpbmsgdG8gc2VuZCB0byB0aGUgdXNlci5cbiAgICogVGhlIGFjdGlvbl9saW5rIGZvbGxvd3MgdGhlIGZvbGxvd2luZyBmb3JtYXQ6IGF1dGgvdjEvdmVyaWZ5P3R5cGU9e3ZlcmlmaWNhdGlvbl90eXBlfSZ0b2tlbj17aGFzaGVkX3Rva2VufSZyZWRpcmVjdF90bz17cmVkaXJlY3RfdG99XG4gICAqICovXG4gIGFjdGlvbl9saW5rOiBzdHJpbmdcbiAgLyoqXG4gICAqIFRoZSByYXcgZW1haWwgT1RQLlxuICAgKiBZb3Ugc2hvdWxkIHNlbmQgdGhpcyBpbiB0aGUgZW1haWwgaWYgeW91IHdhbnQgeW91ciB1c2VycyB0byB2ZXJpZnkgdXNpbmcgYW4gT1RQIGluc3RlYWQgb2YgdGhlIGFjdGlvbiBsaW5rLlxuICAgKiAqL1xuICBlbWFpbF9vdHA6IHN0cmluZ1xuICAvKipcbiAgICogVGhlIGhhc2hlZCB0b2tlbiBhcHBlbmRlZCB0byB0aGUgYWN0aW9uIGxpbmsuXG4gICAqICovXG4gIGhhc2hlZF90b2tlbjogc3RyaW5nXG4gIC8qKiBUaGUgVVJMIGFwcGVuZGVkIHRvIHRoZSBhY3Rpb24gbGluay4gKi9cbiAgcmVkaXJlY3RfdG86IHN0cmluZ1xuICAvKiogVGhlIHZlcmlmaWNhdGlvbiB0eXBlIHRoYXQgdGhlIGVtYWlsIGxpbmsgaXMgYXNzb2NpYXRlZCB0by4gKi9cbiAgdmVyaWZpY2F0aW9uX3R5cGU6IEdlbmVyYXRlTGlua1R5cGVcbn1cblxuZXhwb3J0IHR5cGUgR2VuZXJhdGVMaW5rVHlwZSA9XG4gIHwgJ3NpZ251cCdcbiAgfCAnaW52aXRlJ1xuICB8ICdtYWdpY2xpbmsnXG4gIHwgJ3JlY292ZXJ5J1xuICB8ICdlbWFpbF9jaGFuZ2VfY3VycmVudCdcbiAgfCAnZW1haWxfY2hhbmdlX25ldydcblxuZXhwb3J0IHR5cGUgTUZBRW5yb2xsUGFyYW1zID0ge1xuICAvKiogVGhlIHR5cGUgb2YgZmFjdG9yIGJlaW5nIGVucm9sbGVkLiAqL1xuICBmYWN0b3JUeXBlOiAndG90cCdcbiAgLyoqIERvbWFpbiB3aGljaCB0aGUgdXNlciBpcyBlbnJvbGxlZCB3aXRoLiAqL1xuICBpc3N1ZXI/OiBzdHJpbmdcbiAgLyoqIEh1bWFuIHJlYWRhYmxlIG5hbWUgYXNzaWduZWQgdG8gdGhlIGZhY3Rvci4gKi9cbiAgZnJpZW5kbHlOYW1lPzogc3RyaW5nXG59XG5cbmV4cG9ydCB0eXBlIE1GQVVuZW5yb2xsUGFyYW1zID0ge1xuICAvKiogSUQgb2YgdGhlIGZhY3RvciBiZWluZyB1bmVucm9sbGVkLiAqL1xuICBmYWN0b3JJZDogc3RyaW5nXG59XG5cbmV4cG9ydCB0eXBlIE1GQVZlcmlmeVBhcmFtcyA9IHtcbiAgLyoqIElEIG9mIHRoZSBmYWN0b3IgYmVpbmcgdmVyaWZpZWQuIFJldHVybmVkIGluIGVucm9sbCgpLiAqL1xuICBmYWN0b3JJZDogc3RyaW5nXG5cbiAgLyoqIElEIG9mIHRoZSBjaGFsbGVuZ2UgYmVpbmcgdmVyaWZpZWQuIFJldHVybmVkIGluIGNoYWxsZW5nZSgpLiAqL1xuICBjaGFsbGVuZ2VJZDogc3RyaW5nXG5cbiAgLyoqIFZlcmlmaWNhdGlvbiBjb2RlIHByb3ZpZGVkIGJ5IHRoZSB1c2VyLiAqL1xuICBjb2RlOiBzdHJpbmdcbn1cblxuZXhwb3J0IHR5cGUgTUZBQ2hhbGxlbmdlUGFyYW1zID0ge1xuICAvKiogSUQgb2YgdGhlIGZhY3RvciB0byBiZSBjaGFsbGVuZ2VkLiBSZXR1cm5lZCBpbiBlbnJvbGwoKS4gKi9cbiAgZmFjdG9ySWQ6IHN0cmluZ1xufVxuXG5leHBvcnQgdHlwZSBNRkFDaGFsbGVuZ2VBbmRWZXJpZnlQYXJhbXMgPSB7XG4gIC8qKiBJRCBvZiB0aGUgZmFjdG9yIGJlaW5nIHZlcmlmaWVkLiBSZXR1cm5lZCBpbiBlbnJvbGwoKS4gKi9cbiAgZmFjdG9ySWQ6IHN0cmluZ1xuICAvKiogVmVyaWZpY2F0aW9uIGNvZGUgcHJvdmlkZWQgYnkgdGhlIHVzZXIuICovXG4gIGNvZGU6IHN0cmluZ1xufVxuXG5leHBvcnQgdHlwZSBBdXRoTUZBVmVyaWZ5UmVzcG9uc2UgPVxuICB8IHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgLyoqIE5ldyBhY2Nlc3MgdG9rZW4gKEpXVCkgYWZ0ZXIgc3VjY2Vzc2Z1bCB2ZXJpZmljYXRpb24uICovXG4gICAgICAgIGFjY2Vzc190b2tlbjogc3RyaW5nXG5cbiAgICAgICAgLyoqIFR5cGUgb2YgdG9rZW4sIHR5cGljYWxseSBgQmVhcmVyYC4gKi9cbiAgICAgICAgdG9rZW5fdHlwZTogc3RyaW5nXG5cbiAgICAgICAgLyoqIE51bWJlciBvZiBzZWNvbmRzIGluIHdoaWNoIHRoZSBhY2Nlc3MgdG9rZW4gd2lsbCBleHBpcmUuICovXG4gICAgICAgIGV4cGlyZXNfaW46IG51bWJlclxuXG4gICAgICAgIC8qKiBSZWZyZXNoIHRva2VuIHlvdSBjYW4gdXNlIHRvIG9idGFpbiBuZXcgYWNjZXNzIHRva2VucyB3aGVuIGV4cGlyZWQuICovXG4gICAgICAgIHJlZnJlc2hfdG9rZW46IHN0cmluZ1xuXG4gICAgICAgIC8qKiBVcGRhdGVkIHVzZXIgcHJvZmlsZS4gKi9cbiAgICAgICAgdXNlcjogVXNlclxuICAgICAgfVxuICAgICAgZXJyb3I6IG51bGxcbiAgICB9XG4gIHwge1xuICAgICAgZGF0YTogbnVsbFxuICAgICAgZXJyb3I6IEF1dGhFcnJvclxuICAgIH1cblxuZXhwb3J0IHR5cGUgQXV0aE1GQUVucm9sbFJlc3BvbnNlID1cbiAgfCB7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIC8qKiBJRCBvZiB0aGUgZmFjdG9yIHRoYXQgd2FzIGp1c3QgZW5yb2xsZWQgKGluIGFuIHVudmVyaWZpZWQgc3RhdGUpLiAqL1xuICAgICAgICBpZDogc3RyaW5nXG5cbiAgICAgICAgLyoqIFR5cGUgb2YgTUZBIGZhY3Rvci4gT25seSBgdG90cGAgc3VwcG9ydGVkIGZvciBub3cuICovXG4gICAgICAgIHR5cGU6ICd0b3RwJ1xuXG4gICAgICAgIC8qKiBUT1RQIGVucm9sbG1lbnQgaW5mb3JtYXRpb24uICovXG4gICAgICAgIHRvdHA6IHtcbiAgICAgICAgICAvKiogQ29udGFpbnMgYSBRUiBjb2RlIGVuY29kaW5nIHRoZSBhdXRoZW50aWNhdG9yIFVSSS4gWW91IGNhblxuICAgICAgICAgICAqIGNvbnZlcnQgaXQgdG8gYSBVUkwgYnkgcHJlcGVuZGluZyBgZGF0YTppbWFnZS9zdmcreG1sO3V0Zi04LGAgdG9cbiAgICAgICAgICAgKiB0aGUgdmFsdWUuIEF2b2lkIGxvZ2dpbmcgdGhpcyB2YWx1ZSB0byB0aGUgY29uc29sZS4gKi9cbiAgICAgICAgICBxcl9jb2RlOiBzdHJpbmdcblxuICAgICAgICAgIC8qKiBUaGUgVE9UUCBzZWNyZXQgKGFsc28gZW5jb2RlZCBpbiB0aGUgUVIgY29kZSkuIFNob3cgdGhpcyBzZWNyZXRcbiAgICAgICAgICAgKiBpbiBhIHBhc3N3b3JkLXN0eWxlIGZpZWxkIHRvIHRoZSB1c2VyLCBpbiBjYXNlIHRoZXkgYXJlIHVuYWJsZSB0b1xuICAgICAgICAgICAqIHNjYW4gdGhlIFFSIGNvZGUuIEF2b2lkIGxvZ2dpbmcgdGhpcyB2YWx1ZSB0byB0aGUgY29uc29sZS4gKi9cbiAgICAgICAgICBzZWNyZXQ6IHN0cmluZ1xuXG4gICAgICAgICAgLyoqIFRoZSBhdXRoZW50aWNhdG9yIFVSSSBlbmNvZGVkIHdpdGhpbiB0aGUgUVIgY29kZSwgc2hvdWxkIHlvdSBuZWVkXG4gICAgICAgICAgICogdG8gdXNlIGl0LiBBdm9pZCBsb2dnaW4gdGhpcyB2YWx1ZSB0byB0aGUgY29uc29sZS4gKi9cbiAgICAgICAgICB1cmk6IHN0cmluZ1xuICAgICAgICB9XG4gICAgICAgIC8qKiBGcmllbmRseSBuYW1lIG9mIHRoZSBmYWN0b3IsIHVzZWZ1bCBmb3IgZGlzdGluZ3Vpc2hpbmcgYmV0d2VlbiBmYWN0b3JzICoqL1xuICAgICAgICBmcmllbmRseV9uYW1lPzogc3RyaW5nXG4gICAgICB9XG4gICAgICBlcnJvcjogbnVsbFxuICAgIH1cbiAgfCB7XG4gICAgICBkYXRhOiBudWxsXG4gICAgICBlcnJvcjogQXV0aEVycm9yXG4gICAgfVxuXG5leHBvcnQgdHlwZSBBdXRoTUZBVW5lbnJvbGxSZXNwb25zZSA9XG4gIHwge1xuICAgICAgZGF0YToge1xuICAgICAgICAvKiogSUQgb2YgdGhlIGZhY3RvciB0aGF0IHdhcyBzdWNjZXNzZnVsbHkgdW5lbnJvbGxlZC4gKi9cbiAgICAgICAgaWQ6IHN0cmluZ1xuICAgICAgfVxuICAgICAgZXJyb3I6IG51bGxcbiAgICB9XG4gIHwgeyBkYXRhOiBudWxsOyBlcnJvcjogQXV0aEVycm9yIH1cblxuZXhwb3J0IHR5cGUgQXV0aE1GQUNoYWxsZW5nZVJlc3BvbnNlID1cbiAgfCB7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIC8qKiBJRCBvZiB0aGUgbmV3bHkgY3JlYXRlZCBjaGFsbGVuZ2UuICovXG4gICAgICAgIGlkOiBzdHJpbmdcblxuICAgICAgICAvKiogVGltZXN0YW1wIGluIFVOSVggc2Vjb25kcyB3aGVuIHRoaXMgY2hhbGxlbmdlIHdpbGwgbm8gbG9uZ2VyIGJlIHVzYWJsZS4gKi9cbiAgICAgICAgZXhwaXJlc19hdDogbnVtYmVyXG4gICAgICB9XG4gICAgICBlcnJvcjogbnVsbFxuICAgIH1cbiAgfCB7IGRhdGE6IG51bGw7IGVycm9yOiBBdXRoRXJyb3IgfVxuXG5leHBvcnQgdHlwZSBBdXRoTUZBTGlzdEZhY3RvcnNSZXNwb25zZSA9XG4gIHwge1xuICAgICAgZGF0YToge1xuICAgICAgICAvKiogQWxsIGF2YWlsYWJsZSBmYWN0b3JzICh2ZXJpZmllZCBhbmQgdW52ZXJpZmllZCkuICovXG4gICAgICAgIGFsbDogRmFjdG9yW11cblxuICAgICAgICAvKiogT25seSB2ZXJpZmllZCBUT1RQIGZhY3RvcnMuIChBIHN1YnNldCBvZiBgYWxsYC4pICovXG4gICAgICAgIHRvdHA6IEZhY3RvcltdXG4gICAgICB9XG4gICAgICBlcnJvcjogbnVsbFxuICAgIH1cbiAgfCB7IGRhdGE6IG51bGw7IGVycm9yOiBBdXRoRXJyb3IgfVxuXG5leHBvcnQgdHlwZSBBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWxzID0gJ2FhbDEnIHwgJ2FhbDInXG5cbmV4cG9ydCB0eXBlIEF1dGhNRkFHZXRBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWxSZXNwb25zZSA9XG4gIHwge1xuICAgICAgZGF0YToge1xuICAgICAgICAvKiogQ3VycmVudCBBQUwgbGV2ZWwgb2YgdGhlIHNlc3Npb24uICovXG4gICAgICAgIGN1cnJlbnRMZXZlbDogQXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVscyB8IG51bGxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTmV4dCBwb3NzaWJsZSBBQUwgbGV2ZWwgZm9yIHRoZSBzZXNzaW9uLiBJZiB0aGUgbmV4dCBsZXZlbCBpcyBoaWdoZXJcbiAgICAgICAgICogdGhhbiB0aGUgY3VycmVudCBvbmUsIHRoZSB1c2VyIHNob3VsZCBnbyB0aHJvdWdoIE1GQS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHNlZSB7QGxpbmsgR29UcnVlTUZBQXBpI2NoYWxsZW5nZX1cbiAgICAgICAgICovXG4gICAgICAgIG5leHRMZXZlbDogQXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVscyB8IG51bGxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBsaXN0IG9mIGFsbCBhdXRoZW50aWNhdGlvbiBtZXRob2RzIGF0dGFjaGVkIHRvIHRoaXMgc2Vzc2lvbi4gVXNlXG4gICAgICAgICAqIHRoZSBpbmZvcm1hdGlvbiBoZXJlIHRvIGRldGVjdCB0aGUgbGFzdCB0aW1lIGEgdXNlciB2ZXJpZmllZCBhXG4gICAgICAgICAqIGZhY3RvciwgZm9yIGV4YW1wbGUgaWYgaW1wbGVtZW50aW5nIGEgc3RlcC11cCBzY2VuYXJpby5cbiAgICAgICAgICovXG4gICAgICAgIGN1cnJlbnRBdXRoZW50aWNhdGlvbk1ldGhvZHM6IEFNUkVudHJ5W11cbiAgICAgIH1cbiAgICAgIGVycm9yOiBudWxsXG4gICAgfVxuICB8IHsgZGF0YTogbnVsbDsgZXJyb3I6IEF1dGhFcnJvciB9XG5cbi8qKlxuICogQ29udGFpbnMgdGhlIGZ1bGwgbXVsdGktZmFjdG9yIGF1dGhlbnRpY2F0aW9uIEFQSS5cbiAqXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgR29UcnVlTUZBQXBpIHtcbiAgLyoqXG4gICAqIFN0YXJ0cyB0aGUgZW5yb2xsbWVudCBwcm9jZXNzIGZvciBhIG5ldyBNdWx0aS1GYWN0b3IgQXV0aGVudGljYXRpb24gKE1GQSlcbiAgICogZmFjdG9yLiBUaGlzIG1ldGhvZCBjcmVhdGVzIGEgbmV3IGB1bnZlcmlmaWVkYCBmYWN0b3IuXG4gICAqIFRvIHZlcmlmeSBhIGZhY3RvciwgcHJlc2VudCB0aGUgUVIgY29kZSBvciBzZWNyZXQgdG8gdGhlIHVzZXIgYW5kIGFzayB0aGVtIHRvIGFkZCBpdCB0byB0aGVpclxuICAgKiBhdXRoZW50aWNhdG9yIGFwcC5cbiAgICogVGhlIHVzZXIgaGFzIHRvIGVudGVyIHRoZSBjb2RlIGZyb20gdGhlaXIgYXV0aGVudGljYXRvciBhcHAgdG8gdmVyaWZ5IGl0LlxuICAgKlxuICAgKiBVcG9uIHZlcmlmeWluZyBhIGZhY3RvciwgYWxsIG90aGVyIHNlc3Npb25zIGFyZSBsb2dnZWQgb3V0IGFuZCB0aGUgY3VycmVudCBzZXNzaW9uJ3MgYXV0aGVudGljYXRvciBsZXZlbCBpcyBwcm9tb3RlZCB0byBgYWFsMmAuXG4gICAqXG4gICAqL1xuICBlbnJvbGwocGFyYW1zOiBNRkFFbnJvbGxQYXJhbXMpOiBQcm9taXNlPEF1dGhNRkFFbnJvbGxSZXNwb25zZT5cblxuICAvKipcbiAgICogUHJlcGFyZXMgYSBjaGFsbGVuZ2UgdXNlZCB0byB2ZXJpZnkgdGhhdCBhIHVzZXIgaGFzIGFjY2VzcyB0byBhIE1GQVxuICAgKiBmYWN0b3IuXG4gICAqL1xuICBjaGFsbGVuZ2UocGFyYW1zOiBNRkFDaGFsbGVuZ2VQYXJhbXMpOiBQcm9taXNlPEF1dGhNRkFDaGFsbGVuZ2VSZXNwb25zZT5cblxuICAvKipcbiAgICogVmVyaWZpZXMgYSBjb2RlIGFnYWluc3QgYSBjaGFsbGVuZ2UuIFRoZSB2ZXJpZmljYXRpb24gY29kZSBpc1xuICAgKiBwcm92aWRlZCBieSB0aGUgdXNlciBieSBlbnRlcmluZyBhIGNvZGUgc2VlbiBpbiB0aGVpciBhdXRoZW50aWNhdG9yIGFwcC5cbiAgICovXG4gIHZlcmlmeShwYXJhbXM6IE1GQVZlcmlmeVBhcmFtcyk6IFByb21pc2U8QXV0aE1GQVZlcmlmeVJlc3BvbnNlPlxuXG4gIC8qKlxuICAgKiBVbmVucm9sbCByZW1vdmVzIGEgTUZBIGZhY3Rvci5cbiAgICogQSB1c2VyIGhhcyB0byBoYXZlIGFuIGBhYWwyYCBhdXRoZW50aWNhdG9yIGxldmVsIGluIG9yZGVyIHRvIHVuZW5yb2xsIGEgYHZlcmlmaWVkYCBmYWN0b3IuXG4gICAqL1xuICB1bmVucm9sbChwYXJhbXM6IE1GQVVuZW5yb2xsUGFyYW1zKTogUHJvbWlzZTxBdXRoTUZBVW5lbnJvbGxSZXNwb25zZT5cblxuICAvKipcbiAgICogSGVscGVyIG1ldGhvZCB3aGljaCBjcmVhdGVzIGEgY2hhbGxlbmdlIGFuZCBpbW1lZGlhdGVseSB1c2VzIHRoZSBnaXZlbiBjb2RlIHRvIHZlcmlmeSBhZ2FpbnN0IGl0IHRoZXJlYWZ0ZXIuIFRoZSB2ZXJpZmljYXRpb24gY29kZSBpc1xuICAgKiBwcm92aWRlZCBieSB0aGUgdXNlciBieSBlbnRlcmluZyBhIGNvZGUgc2VlbiBpbiB0aGVpciBhdXRoZW50aWNhdG9yIGFwcC5cbiAgICovXG4gIGNoYWxsZW5nZUFuZFZlcmlmeShwYXJhbXM6IE1GQUNoYWxsZW5nZUFuZFZlcmlmeVBhcmFtcyk6IFByb21pc2U8QXV0aE1GQVZlcmlmeVJlc3BvbnNlPlxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIE1GQSBmYWN0b3JzIGVuYWJsZWQgZm9yIHRoaXMgdXNlci5cbiAgICpcbiAgICogQHNlZSB7QGxpbmsgR29UcnVlTUZBQXBpI2Vucm9sbH1cbiAgICogQHNlZSB7QGxpbmsgR29UcnVlTUZBQXBpI2dldEF1dGhlbnRpY2F0b3JBc3N1cmFuY2VMZXZlbH1cbiAgICogQHNlZSB7QGxpbmsgR29UcnVlQ2xpZW50I2dldFVzZXJ9XG4gICAqXG4gICAqL1xuICBsaXN0RmFjdG9ycygpOiBQcm9taXNlPEF1dGhNRkFMaXN0RmFjdG9yc1Jlc3BvbnNlPlxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBBdXRoZW50aWNhdG9yIEFzc3VyYW5jZSBMZXZlbCAoQUFMKSBmb3IgdGhlIGFjdGl2ZSBzZXNzaW9uLlxuICAgKlxuICAgKiAtIGBhYWwxYCAob3IgYG51bGxgKSBtZWFucyB0aGF0IHRoZSB1c2VyJ3MgaWRlbnRpdHkgaGFzIGJlZW4gdmVyaWZpZWQgb25seVxuICAgKiB3aXRoIGEgY29udmVudGlvbmFsIGxvZ2luIChlbWFpbCtwYXNzd29yZCwgT1RQLCBtYWdpYyBsaW5rLCBzb2NpYWwgbG9naW4sXG4gICAqIGV0Yy4pLlxuICAgKiAtIGBhYWwyYCBtZWFucyB0aGF0IHRoZSB1c2VyJ3MgaWRlbnRpdHkgaGFzIGJlZW4gdmVyaWZpZWQgYm90aCB3aXRoIGEgY29udmVudGlvbmFsIGxvZ2luIGFuZCBhdCBsZWFzdCBvbmUgTUZBIGZhY3Rvci5cbiAgICpcbiAgICogQWx0aG91Z2ggdGhpcyBtZXRob2QgcmV0dXJucyBhIHByb21pc2UsIGl0J3MgZmFpcmx5IHF1aWNrIChtaWNyb3NlY29uZHMpXG4gICAqIGFuZCByYXJlbHkgdXNlcyB0aGUgbmV0d29yay4gWW91IGNhbiB1c2UgdGhpcyB0byBjaGVjayB3aGV0aGVyIHRoZSBjdXJyZW50XG4gICAqIHVzZXIgbmVlZHMgdG8gYmUgc2hvd24gYSBzY3JlZW4gdG8gdmVyaWZ5IHRoZWlyIE1GQSBmYWN0b3JzLlxuICAgKlxuICAgKi9cbiAgZ2V0QXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVsKCk6IFByb21pc2U8QXV0aE1GQUdldEF1dGhlbnRpY2F0b3JBc3N1cmFuY2VMZXZlbFJlc3BvbnNlPlxufVxuXG4vKipcbiAqIEBleHBlcm1lbnRhbFxuICovXG5leHBvcnQgdHlwZSBBdXRoTUZBQWRtaW5EZWxldGVGYWN0b3JSZXNwb25zZSA9XG4gIHwge1xuICAgICAgZGF0YToge1xuICAgICAgICAvKiogSUQgb2YgdGhlIGZhY3RvciB0aGF0IHdhcyBzdWNjZXNzZnVsbHkgZGVsZXRlZC4gKi9cbiAgICAgICAgaWQ6IHN0cmluZ1xuICAgICAgfVxuICAgICAgZXJyb3I6IG51bGxcbiAgICB9XG4gIHwgeyBkYXRhOiBudWxsOyBlcnJvcjogQXV0aEVycm9yIH1cblxuLyoqXG4gKiBAZXhwZXJtZW50YWxcbiAqL1xuZXhwb3J0IHR5cGUgQXV0aE1GQUFkbWluRGVsZXRlRmFjdG9yUGFyYW1zID0ge1xuICAvKiogSUQgb2YgdGhlIE1GQSBmYWN0b3IgdG8gZGVsZXRlLiAqL1xuICBpZDogc3RyaW5nXG5cbiAgLyoqIElEIG9mIHRoZSB1c2VyIHdob3NlIGZhY3RvciBpcyBiZWluZyBkZWxldGVkLiAqL1xuICB1c2VySWQ6IHN0cmluZ1xufVxuXG4vKipcbiAqIEBleHBlcm1lbnRhbFxuICovXG5leHBvcnQgdHlwZSBBdXRoTUZBQWRtaW5MaXN0RmFjdG9yc1Jlc3BvbnNlID1cbiAgfCB7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIC8qKiBBbGwgZmFjdG9ycyBhdHRhY2hlZCB0byB0aGUgdXNlci4gKi9cbiAgICAgICAgZmFjdG9yczogRmFjdG9yW11cbiAgICAgIH1cbiAgICAgIGVycm9yOiBudWxsXG4gICAgfVxuICB8IHsgZGF0YTogbnVsbDsgZXJyb3I6IEF1dGhFcnJvciB9XG5cbi8qKlxuICogQGV4cGVybWVudGFsXG4gKi9cbmV4cG9ydCB0eXBlIEF1dGhNRkFBZG1pbkxpc3RGYWN0b3JzUGFyYW1zID0ge1xuICAvKiogSUQgb2YgdGhlIHVzZXIuICovXG4gIHVzZXJJZDogc3RyaW5nXG59XG5cbi8qKlxuICogQ29udGFpbnMgdGhlIGZ1bGwgbXVsdGktZmFjdG9yIGF1dGhlbnRpY2F0aW9uIGFkbWluaXN0cmF0aW9uIEFQSS5cbiAqXG4gKiBAZXhwZXJtZW50YWxcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBHb1RydWVBZG1pbk1GQUFwaSB7XG4gIC8qKlxuICAgKiBMaXN0cyBhbGwgZmFjdG9ycyBhc3NvY2lhdGVkIHRvIGEgdXNlci5cbiAgICpcbiAgICovXG4gIGxpc3RGYWN0b3JzKHBhcmFtczogQXV0aE1GQUFkbWluTGlzdEZhY3RvcnNQYXJhbXMpOiBQcm9taXNlPEF1dGhNRkFBZG1pbkxpc3RGYWN0b3JzUmVzcG9uc2U+XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgYSBmYWN0b3Igb24gYSB1c2VyLiBUaGlzIHdpbGwgbG9nIHRoZSB1c2VyIG91dCBvZiBhbGwgYWN0aXZlXG4gICAqIHNlc3Npb25zIGlmIHRoZSBkZWxldGVkIGZhY3RvciB3YXMgdmVyaWZpZWQuXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIEdvVHJ1ZU1GQUFwaSN1bmVucm9sbH1cbiAgICpcbiAgICogQGV4cGVybWVudGFsXG4gICAqL1xuICBkZWxldGVGYWN0b3IocGFyYW1zOiBBdXRoTUZBQWRtaW5EZWxldGVGYWN0b3JQYXJhbXMpOiBQcm9taXNlPEF1dGhNRkFBZG1pbkRlbGV0ZUZhY3RvclJlc3BvbnNlPlxufVxuXG50eXBlIEFueUZ1bmN0aW9uID0gKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnlcbnR5cGUgTWF5YmVQcm9taXNpZnk8VD4gPSBUIHwgUHJvbWlzZTxUPlxuXG50eXBlIFByb21pc2lmeU1ldGhvZHM8VD4gPSB7XG4gIFtLIGluIGtleW9mIFRdOiBUW0tdIGV4dGVuZHMgQW55RnVuY3Rpb25cbiAgICA/ICguLi5hcmdzOiBQYXJhbWV0ZXJzPFRbS10+KSA9PiBNYXliZVByb21pc2lmeTxSZXR1cm5UeXBlPFRbS10+PlxuICAgIDogVFtLXVxufVxuXG5leHBvcnQgdHlwZSBTdXBwb3J0ZWRTdG9yYWdlID0gUHJvbWlzaWZ5TWV0aG9kczxcbiAgUGljazxTdG9yYWdlLCAnZ2V0SXRlbScgfCAnc2V0SXRlbScgfCAncmVtb3ZlSXRlbSc+XG4+ICYge1xuICAvKipcbiAgICogSWYgc2V0IHRvIGB0cnVlYCBzaWduYWxzIHRvIHRoZSBsaWJyYXJ5IHRoYXQgdGhlIHN0b3JhZ2UgbWVkaXVtIGlzIHVzZWRcbiAgICogb24gYSBzZXJ2ZXIgYW5kIHRoZSB2YWx1ZXMgbWF5IG5vdCBiZSBhdXRoZW50aWMsIHN1Y2ggYXMgcmVhZGluZyBmcm9tXG4gICAqIHJlcXVlc3QgY29va2llcy4gSW1wbGVtZW50YXRpb25zIHNob3VsZCBub3Qgc2V0IHRoaXMgdG8gdHJ1ZSBpZiB0aGUgY2xpZW50XG4gICAqIGlzIHVzZWQgb24gYSBzZXJ2ZXIgdGhhdCByZWFkcyBzdG9yYWdlIGluZm9ybWF0aW9uIGZyb20gYXV0aGVudGljYXRlZFxuICAgKiBzb3VyY2VzLCBzdWNoIGFzIGEgc2VjdXJlIGRhdGFiYXNlIG9yIGZpbGUuXG4gICAqL1xuICBpc1NlcnZlcj86IGJvb2xlYW5cbn1cblxuZXhwb3J0IHR5cGUgSW5pdGlhbGl6ZVJlc3VsdCA9IHsgZXJyb3I6IEF1dGhFcnJvciB8IG51bGwgfVxuXG5leHBvcnQgdHlwZSBDYWxsUmVmcmVzaFRva2VuUmVzdWx0ID1cbiAgfCB7XG4gICAgICBzZXNzaW9uOiBTZXNzaW9uXG4gICAgICBlcnJvcjogbnVsbFxuICAgIH1cbiAgfCB7XG4gICAgICBzZXNzaW9uOiBudWxsXG4gICAgICBlcnJvcjogQXV0aEVycm9yXG4gICAgfVxuXG5leHBvcnQgdHlwZSBQYWdpbmF0aW9uID0ge1xuICBba2V5OiBzdHJpbmddOiBhbnlcbiAgbmV4dFBhZ2U6IG51bWJlciB8IG51bGxcbiAgbGFzdFBhZ2U6IG51bWJlclxuICB0b3RhbDogbnVtYmVyXG59XG5cbmV4cG9ydCB0eXBlIFBhZ2VQYXJhbXMgPSB7XG4gIC8qKiBUaGUgcGFnZSBudW1iZXIgKi9cbiAgcGFnZT86IG51bWJlclxuICAvKiogTnVtYmVyIG9mIGl0ZW1zIHJldHVybmVkIHBlciBwYWdlICovXG4gIHBlclBhZ2U/OiBudW1iZXJcbn1cblxuZXhwb3J0IHR5cGUgU2lnbk91dCA9IHtcbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hpY2ggc2Vzc2lvbnMgc2hvdWxkIGJlXG4gICAqIGxvZ2dlZCBvdXQuIEdsb2JhbCBtZWFucyBhbGxcbiAgICogc2Vzc2lvbnMgYnkgdGhpcyBhY2NvdW50LiBMb2NhbFxuICAgKiBtZWFucyBvbmx5IHRoaXMgc2Vzc2lvbi4gT3RoZXJzXG4gICAqIG1lYW5zIGFsbCBvdGhlciBzZXNzaW9ucyBleGNlcHQgdGhlXG4gICAqIGN1cnJlbnQgb25lLiBXaGVuIHVzaW5nIG90aGVycyxcbiAgICogdGhlcmUgaXMgbm8gc2lnbi1vdXQgZXZlbnQgZmlyZWQgb25cbiAgICogdGhlIGN1cnJlbnQgc2Vzc2lvbiFcbiAgICovXG4gIHNjb3BlPzogJ2dsb2JhbCcgfCAnbG9jYWwnIHwgJ290aGVycydcbn1cbiIsImltcG9ydCB7IFN0b3JhZ2UgfSBmcm9tIFwiQHBsYXNtb2hxL3N0b3JhZ2VcIlxuXG5leHBvcnQgY29uc3QgbG9jYWxTdG9yYWdlID0gKCkgPT5cbiAgbmV3IFN0b3JhZ2Uoe1xuICAgIGFyZWE6IFwibG9jYWxcIlxuICB9KVxuXG5leHBvcnQgY29uc3QgZ2VuZXJhdGVSYW5kb21JRCA9IChsZW5ndGg6IG51bWJlciA9IDIwKSA9PiB7XG4gIGNvbnN0IGNoYXJhY3RlcnMgPVxuICAgIFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODlcIlxuICBsZXQgcmVzdWx0ID0gXCJcIlxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0ICs9IGNoYXJhY3RlcnMuY2hhckF0KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoYXJhY3RlcnMubGVuZ3RoKSlcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmV4cG9ydCBjb25zdCBlcnJvck1lc3NhZ2UgPSAoZXJyOiBhbnksIGZhbGxiYWNrPzogc3RyaW5nKSA9PlxuICB0eXBlb2YgZXJyID09PSBcInN0cmluZ1wiID8gZXJyIDogZmFsbGJhY2sgPz8gXCJTb21ldGhpbmcgd2VudCB3cm9uZ1wiXG5cbmV4cG9ydCBjb25zdCBnZXRIb3N0bmFtZVdpdGhvdXRTdWJkb21haW4gPSAodXJsOiBzdHJpbmcpID0+IHtcbiAgY29uc3QgbXVsdGlQYXJ0VExEcyA9IFtcbiAgICBcImNvLnVrXCIsXG4gICAgXCJnb3YudWtcIixcbiAgICBcImFjLnVrXCIsXG4gICAgXCJjb20uYXVcIixcbiAgICBcImVkdS5hdVwiLFxuICAgIFwiZ292LmF1XCIsXG4gICAgXCJjby5qcFwiLFxuICAgIFwib3IuanBcIixcbiAgICBcImNvLmluXCIsXG4gICAgXCJuZXQuaW5cIlxuICBdXG4gIGNvbnN0IGhvc3RuYW1lID0gbmV3IFVSTCh1cmwpLmhvc3RuYW1lXG4gIGNvbnN0IHBhcnRzID0gaG9zdG5hbWUuc3BsaXQoXCIuXCIpXG5cbiAgY29uc3QgbWF0Y2hUTEQgPSBtdWx0aVBhcnRUTERzLmZpbmQoKHRsZCkgPT4gaG9zdG5hbWUuZW5kc1dpdGgodGxkKSlcbiAgaWYgKG1hdGNoVExEKSB7XG4gICAgcmV0dXJuIHBhcnRzLnNsaWNlKC1tYXRjaFRMRC5zcGxpdChcIi5cIikubGVuZ3RoIC0gMSkuam9pbihcIi5cIilcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5sZW5ndGggPD0gMiA/IGhvc3RuYW1lIDogcGFydHMuc2xpY2UoLTIpLmpvaW4oXCIuXCIpXG59XG4iLCJpbXBvcnQgeSBmcm9tXCJwaWZ5XCI7dmFyIGw9KCk9Pnt0cnl7bGV0IGU9KGdsb2JhbFRoaXMubmF2aWdhdG9yPy51c2VyQWdlbnQpLm1hdGNoKC8ob3BlcmF8Y2hyb21lfHNhZmFyaXxmaXJlZm94fG1zaWV8dHJpZGVudCg/PVxcLykpXFwvP1xccyooXFxkKykvaSl8fFtdO2lmKGVbMV09PT1cIkNocm9tZVwiKXJldHVybiBwYXJzZUludChlWzJdKTwxMDB8fGdsb2JhbFRoaXMuY2hyb21lLnJ1bnRpbWU/LmdldE1hbmlmZXN0KCk/Lm1hbmlmZXN0X3ZlcnNpb249PT0yfWNhdGNoe3JldHVybiExfXJldHVybiExfTt2YXIgbz1jbGFzc3sjcjsjZTtnZXQgcHJpbWFyeUNsaWVudCgpe3JldHVybiB0aGlzLiNlfSN0O2dldCBzZWNvbmRhcnlDbGllbnQoKXtyZXR1cm4gdGhpcy4jdH0jYTtnZXQgYXJlYSgpe3JldHVybiB0aGlzLiNhfWdldCBoYXNXZWJBcGkoKXt0cnl7cmV0dXJuIHR5cGVvZiB3aW5kb3c8XCJ1XCImJiEhd2luZG93LmxvY2FsU3RvcmFnZX1jYXRjaChlKXtyZXR1cm4gY29uc29sZS5lcnJvcihlKSwhMX19I3M9bmV3IE1hcDsjaTtnZXQgY29waWVkS2V5U2V0KCl7cmV0dXJuIHRoaXMuI2l9aXNDb3BpZWQ9ZT0+dGhpcy5oYXNXZWJBcGkmJih0aGlzLmFsbENvcGllZHx8dGhpcy5jb3BpZWRLZXlTZXQuaGFzKGUpKTsjbj0hMTtnZXQgYWxsQ29waWVkKCl7cmV0dXJuIHRoaXMuI259Z2V0RXh0U3RvcmFnZUFwaT0oKT0+Z2xvYmFsVGhpcy5icm93c2VyPy5zdG9yYWdlfHxnbG9iYWxUaGlzLmNocm9tZT8uc3RvcmFnZTtnZXQgaGFzRXh0ZW5zaW9uQXBpKCl7dHJ5e3JldHVybiEhdGhpcy5nZXRFeHRTdG9yYWdlQXBpKCl9Y2F0Y2goZSl7cmV0dXJuIGNvbnNvbGUuZXJyb3IoZSksITF9fWlzV2F0Y2hTdXBwb3J0ZWQ9KCk9PnRoaXMuaGFzRXh0ZW5zaW9uQXBpO2tleU5hbWVzcGFjZT1cIlwiO2lzVmFsaWRLZXk9ZT0+ZS5zdGFydHNXaXRoKHRoaXMua2V5TmFtZXNwYWNlKTtnZXROYW1lc3BhY2VkS2V5PWU9PmAke3RoaXMua2V5TmFtZXNwYWNlfSR7ZX1gO2dldFVubmFtZXNwYWNlZEtleT1lPT5lLnNsaWNlKHRoaXMua2V5TmFtZXNwYWNlLmxlbmd0aCk7c2VyZGU9e3NlcmlhbGl6ZXI6SlNPTi5zdHJpbmdpZnksZGVzZXJpYWxpemVyOkpTT04ucGFyc2V9O2NvbnN0cnVjdG9yKHthcmVhOmU9XCJzeW5jXCIsYWxsQ29waWVkOnQ9ITEsY29waWVkS2V5TGlzdDpzPVtdLHNlcmRlOnI9e319PXt9KXt0aGlzLnNldENvcGllZEtleVNldChzKSx0aGlzLiNhPWUsdGhpcy4jbj10LHRoaXMuc2VyZGU9ey4uLnRoaXMuc2VyZGUsLi4ucn07dHJ5e3RoaXMuaGFzV2ViQXBpJiYodHx8cy5sZW5ndGg+MCkmJih0aGlzLiN0PXdpbmRvdy5sb2NhbFN0b3JhZ2UpfWNhdGNoe310cnl7dGhpcy5oYXNFeHRlbnNpb25BcGkmJih0aGlzLiNyPXRoaXMuZ2V0RXh0U3RvcmFnZUFwaSgpLGwoKT90aGlzLiNlPXkodGhpcy4jclt0aGlzLmFyZWFdLHtleGNsdWRlOltcImdldEJ5dGVzSW5Vc2VcIl0sZXJyb3JGaXJzdDohMX0pOnRoaXMuI2U9dGhpcy4jclt0aGlzLmFyZWFdKX1jYXRjaHt9fXNldENvcGllZEtleVNldChlKXt0aGlzLiNpPW5ldyBTZXQoZSl9cmF3R2V0QWxsPSgpPT50aGlzLiNlPy5nZXQoKTtnZXRBbGw9YXN5bmMoKT0+e2xldCBlPWF3YWl0IHRoaXMucmF3R2V0QWxsKCk7cmV0dXJuIE9iamVjdC5lbnRyaWVzKGUpLmZpbHRlcigoW3RdKT0+dGhpcy5pc1ZhbGlkS2V5KHQpKS5yZWR1Y2UoKHQsW3Mscl0pPT4odFt0aGlzLmdldFVubmFtZXNwYWNlZEtleShzKV09cix0KSx7fSl9O2NvcHk9YXN5bmMgZT0+e2xldCB0PWU9PT12b2lkIDA7aWYoIXQmJiF0aGlzLmNvcGllZEtleVNldC5oYXMoZSl8fCF0aGlzLmFsbENvcGllZHx8IXRoaXMuaGFzRXh0ZW5zaW9uQXBpKXJldHVybiExO2xldCBzPXRoaXMuYWxsQ29waWVkP2F3YWl0IHRoaXMucmF3R2V0QWxsKCk6YXdhaXQgdGhpcy4jZS5nZXQoKHQ/Wy4uLnRoaXMuY29waWVkS2V5U2V0XTpbZV0pLm1hcCh0aGlzLmdldE5hbWVzcGFjZWRLZXkpKTtpZighcylyZXR1cm4hMTtsZXQgcj0hMTtmb3IobGV0IGEgaW4gcyl7bGV0IGk9c1thXSxuPXRoaXMuI3Q/LmdldEl0ZW0oYSk7dGhpcy4jdD8uc2V0SXRlbShhLGkpLHJ8fD1pIT09bn1yZXR1cm4gcn07cmF3R2V0PWFzeW5jIGU9PnRoaXMuaGFzRXh0ZW5zaW9uQXBpPyhhd2FpdCB0aGlzLiNlLmdldChlKSlbZV06dGhpcy5pc0NvcGllZChlKT90aGlzLiN0Py5nZXRJdGVtKGUpOm51bGw7cmF3U2V0PWFzeW5jKGUsdCk9Pih0aGlzLmlzQ29waWVkKGUpJiZ0aGlzLiN0Py5zZXRJdGVtKGUsdCksdGhpcy5oYXNFeHRlbnNpb25BcGkmJmF3YWl0IHRoaXMuI2Uuc2V0KHtbZV06dH0pLG51bGwpO2NsZWFyPWFzeW5jKGU9ITEpPT57ZSYmdGhpcy4jdD8uY2xlYXIoKSxhd2FpdCB0aGlzLiNlLmNsZWFyKCl9O3Jhd1JlbW92ZT1hc3luYyBlPT57dGhpcy5pc0NvcGllZChlKSYmdGhpcy4jdD8ucmVtb3ZlSXRlbShlKSx0aGlzLmhhc0V4dGVuc2lvbkFwaSYmYXdhaXQgdGhpcy4jZS5yZW1vdmUoZSl9O3JlbW92ZUFsbD1hc3luYygpPT57bGV0IGU9YXdhaXQgdGhpcy5nZXRBbGwoKSx0PU9iamVjdC5rZXlzKGUpO2F3YWl0IFByb21pc2UuYWxsKHQubWFwKHRoaXMucmVtb3ZlKSl9O3dhdGNoPWU9PntsZXQgdD10aGlzLmlzV2F0Y2hTdXBwb3J0ZWQoKTtyZXR1cm4gdCYmdGhpcy4jbyhlKSx0fTsjbz1lPT57Zm9yKGxldCB0IGluIGUpe2xldCBzPXRoaXMuZ2V0TmFtZXNwYWNlZEtleSh0KSxyPXRoaXMuI3MuZ2V0KHMpPy5jYWxsYmFja1NldHx8bmV3IFNldDtpZihyLmFkZChlW3RdKSxyLnNpemU+MSljb250aW51ZTtsZXQgYT0oaSxuKT0+e2lmKG4hPT10aGlzLmFyZWF8fCFpW3NdKXJldHVybjtsZXQgaD10aGlzLiNzLmdldChzKTtpZighaCl0aHJvdyBuZXcgRXJyb3IoYFN0b3JhZ2UgY29tbXMgZG9lcyBub3QgZXhpc3QgZm9yIG5zS2V5OiAke3N9YCk7UHJvbWlzZS5hbGwoW3RoaXMucGFyc2VWYWx1ZShpW3NdLm5ld1ZhbHVlKSx0aGlzLnBhcnNlVmFsdWUoaVtzXS5vbGRWYWx1ZSldKS50aGVuKChbcCxkXSk9Pntmb3IobGV0IG0gb2YgaC5jYWxsYmFja1NldCltKHtuZXdWYWx1ZTpwLG9sZFZhbHVlOmR9LG4pfSl9O3RoaXMuI3Iub25DaGFuZ2VkLmFkZExpc3RlbmVyKGEpLHRoaXMuI3Muc2V0KHMse2NhbGxiYWNrU2V0OnIsbGlzdGVuZXI6YX0pfX07dW53YXRjaD1lPT57bGV0IHQ9dGhpcy5pc1dhdGNoU3VwcG9ydGVkKCk7cmV0dXJuIHQmJnRoaXMuI2MoZSksdH07I2MoZSl7Zm9yKGxldCB0IGluIGUpe2xldCBzPXRoaXMuZ2V0TmFtZXNwYWNlZEtleSh0KSxyPWVbdF0sYT10aGlzLiNzLmdldChzKTthJiYoYS5jYWxsYmFja1NldC5kZWxldGUociksYS5jYWxsYmFja1NldC5zaXplPT09MCYmKHRoaXMuI3MuZGVsZXRlKHMpLHRoaXMuI3Iub25DaGFuZ2VkLnJlbW92ZUxpc3RlbmVyKGEubGlzdGVuZXIpKSl9fXVud2F0Y2hBbGw9KCk9PnRoaXMuI2goKTsjaCgpe3RoaXMuI3MuZm9yRWFjaCgoe2xpc3RlbmVyOmV9KT0+dGhpcy4jci5vbkNoYW5nZWQucmVtb3ZlTGlzdGVuZXIoZSkpLHRoaXMuI3MuY2xlYXIoKX1hc3luYyBnZXRJdGVtKGUpe3JldHVybiB0aGlzLmdldChlKX1hc3luYyBzZXRJdGVtKGUsdCl7YXdhaXQgdGhpcy5zZXQoZSx0KX1hc3luYyByZW1vdmVJdGVtKGUpe3JldHVybiB0aGlzLnJlbW92ZShlKX19LGc9Y2xhc3MgZXh0ZW5kcyBve2dldD1hc3luYyBlPT57bGV0IHQ9dGhpcy5nZXROYW1lc3BhY2VkS2V5KGUpLHM9YXdhaXQgdGhpcy5yYXdHZXQodCk7cmV0dXJuIHRoaXMucGFyc2VWYWx1ZShzKX07c2V0PWFzeW5jKGUsdCk9PntsZXQgcz10aGlzLmdldE5hbWVzcGFjZWRLZXkoZSkscj10aGlzLnNlcmRlLnNlcmlhbGl6ZXIodCk7cmV0dXJuIHRoaXMucmF3U2V0KHMscil9O3JlbW92ZT1hc3luYyBlPT57bGV0IHQ9dGhpcy5nZXROYW1lc3BhY2VkS2V5KGUpO3JldHVybiB0aGlzLnJhd1JlbW92ZSh0KX07c2V0TmFtZXNwYWNlPWU9Pnt0aGlzLmtleU5hbWVzcGFjZT1lfTtwYXJzZVZhbHVlPWFzeW5jIGU9Pnt0cnl7aWYoZSE9PXZvaWQgMClyZXR1cm4gdGhpcy5zZXJkZS5kZXNlcmlhbGl6ZXIoZSl9Y2F0Y2godCl7Y29uc29sZS5lcnJvcih0KX19fTtleHBvcnR7byBhcyBCYXNlU3RvcmFnZSxnIGFzIFN0b3JhZ2V9O1xuIiwiY29uc3QgcHJvY2Vzc0Z1bmN0aW9uID0gKGZ1bmN0aW9uXywgb3B0aW9ucywgcHJveHksIHVud3JhcHBlZCkgPT4gZnVuY3Rpb24gKC4uLmFyZ3VtZW50c18pIHtcblx0Y29uc3QgUCA9IG9wdGlvbnMucHJvbWlzZU1vZHVsZTtcblxuXHRyZXR1cm4gbmV3IFAoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdGlmIChvcHRpb25zLm11bHRpQXJncykge1xuXHRcdFx0YXJndW1lbnRzXy5wdXNoKCguLi5yZXN1bHQpID0+IHtcblx0XHRcdFx0aWYgKG9wdGlvbnMuZXJyb3JGaXJzdCkge1xuXHRcdFx0XHRcdGlmIChyZXN1bHRbMF0pIHtcblx0XHRcdFx0XHRcdHJlamVjdChyZXN1bHQpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQuc2hpZnQoKTtcblx0XHRcdFx0XHRcdHJlc29sdmUocmVzdWx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzb2x2ZShyZXN1bHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9IGVsc2UgaWYgKG9wdGlvbnMuZXJyb3JGaXJzdCkge1xuXHRcdFx0YXJndW1lbnRzXy5wdXNoKChlcnJvciwgcmVzdWx0KSA9PiB7XG5cdFx0XHRcdGlmIChlcnJvcikge1xuXHRcdFx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzb2x2ZShyZXN1bHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0YXJndW1lbnRzXy5wdXNoKHJlc29sdmUpO1xuXHRcdH1cblxuXHRcdGNvbnN0IHNlbGYgPSB0aGlzID09PSBwcm94eSA/IHVud3JhcHBlZCA6IHRoaXM7XG5cdFx0UmVmbGVjdC5hcHBseShmdW5jdGlvbl8sIHNlbGYsIGFyZ3VtZW50c18pO1xuXHR9KTtcbn07XG5cbmNvbnN0IGZpbHRlckNhY2hlID0gbmV3IFdlYWtNYXAoKTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGlmeShpbnB1dCwgb3B0aW9ucykge1xuXHRvcHRpb25zID0ge1xuXHRcdGV4Y2x1ZGU6IFsvLisoPzpTeW5jfFN0cmVhbSkkL10sXG5cdFx0ZXJyb3JGaXJzdDogdHJ1ZSxcblx0XHRwcm9taXNlTW9kdWxlOiBQcm9taXNlLFxuXHRcdC4uLm9wdGlvbnMsXG5cdH07XG5cblx0Y29uc3Qgb2JqZWN0VHlwZSA9IHR5cGVvZiBpbnB1dDtcblx0aWYgKCEoaW5wdXQgIT09IG51bGwgJiYgKG9iamVjdFR5cGUgPT09ICdvYmplY3QnIHx8IG9iamVjdFR5cGUgPT09ICdmdW5jdGlvbicpKSkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIFxcYGlucHV0XFxgIHRvIGJlIGEgXFxgRnVuY3Rpb25cXGAgb3IgXFxgT2JqZWN0XFxgLCBnb3QgXFxgJHtpbnB1dCA9PT0gbnVsbCA/ICdudWxsJyA6IG9iamVjdFR5cGV9XFxgYCk7XG5cdH1cblxuXHRjb25zdCBmaWx0ZXIgPSAodGFyZ2V0LCBrZXkpID0+IHtcblx0XHRsZXQgY2FjaGVkID0gZmlsdGVyQ2FjaGUuZ2V0KHRhcmdldCk7XG5cblx0XHRpZiAoIWNhY2hlZCkge1xuXHRcdFx0Y2FjaGVkID0ge307XG5cdFx0XHRmaWx0ZXJDYWNoZS5zZXQodGFyZ2V0LCBjYWNoZWQpO1xuXHRcdH1cblxuXHRcdGlmIChrZXkgaW4gY2FjaGVkKSB7XG5cdFx0XHRyZXR1cm4gY2FjaGVkW2tleV07XG5cdFx0fVxuXG5cdFx0Y29uc3QgbWF0Y2ggPSBwYXR0ZXJuID0+ICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGtleSA9PT0gJ3N5bWJvbCcpID8ga2V5ID09PSBwYXR0ZXJuIDogcGF0dGVybi50ZXN0KGtleSk7XG5cdFx0Y29uc3QgZGVzY3JpcHRvciA9IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KTtcblx0XHRjb25zdCB3cml0YWJsZU9yQ29uZmlndXJhYmxlT3duID0gKGRlc2NyaXB0b3IgPT09IHVuZGVmaW5lZCB8fCBkZXNjcmlwdG9yLndyaXRhYmxlIHx8IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlKTtcblx0XHRjb25zdCBpbmNsdWRlZCA9IG9wdGlvbnMuaW5jbHVkZSA/IG9wdGlvbnMuaW5jbHVkZS5zb21lKGVsZW1lbnQgPT4gbWF0Y2goZWxlbWVudCkpIDogIW9wdGlvbnMuZXhjbHVkZS5zb21lKGVsZW1lbnQgPT4gbWF0Y2goZWxlbWVudCkpO1xuXHRcdGNvbnN0IHNob3VsZEZpbHRlciA9IGluY2x1ZGVkICYmIHdyaXRhYmxlT3JDb25maWd1cmFibGVPd247XG5cdFx0Y2FjaGVkW2tleV0gPSBzaG91bGRGaWx0ZXI7XG5cdFx0cmV0dXJuIHNob3VsZEZpbHRlcjtcblx0fTtcblxuXHRjb25zdCBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5cblx0Y29uc3QgcHJveHkgPSBuZXcgUHJveHkoaW5wdXQsIHtcblx0XHRhcHBseSh0YXJnZXQsIHRoaXNBcmcsIGFyZ3MpIHtcblx0XHRcdGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldCh0YXJnZXQpO1xuXG5cdFx0XHRpZiAoY2FjaGVkKSB7XG5cdFx0XHRcdHJldHVybiBSZWZsZWN0LmFwcGx5KGNhY2hlZCwgdGhpc0FyZywgYXJncyk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHBpZmllZCA9IG9wdGlvbnMuZXhjbHVkZU1haW4gPyB0YXJnZXQgOiBwcm9jZXNzRnVuY3Rpb24odGFyZ2V0LCBvcHRpb25zLCBwcm94eSwgdGFyZ2V0KTtcblx0XHRcdGNhY2hlLnNldCh0YXJnZXQsIHBpZmllZCk7XG5cdFx0XHRyZXR1cm4gUmVmbGVjdC5hcHBseShwaWZpZWQsIHRoaXNBcmcsIGFyZ3MpO1xuXHRcdH0sXG5cblx0XHRnZXQodGFyZ2V0LCBrZXkpIHtcblx0XHRcdGNvbnN0IHByb3BlcnR5ID0gdGFyZ2V0W2tleV07XG5cblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2UtZXh0ZW5kLW5hdGl2ZS9uby11c2UtZXh0ZW5kLW5hdGl2ZVxuXHRcdFx0aWYgKCFmaWx0ZXIodGFyZ2V0LCBrZXkpIHx8IHByb3BlcnR5ID09PSBGdW5jdGlvbi5wcm90b3R5cGVba2V5XSkge1xuXHRcdFx0XHRyZXR1cm4gcHJvcGVydHk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChwcm9wZXJ0eSk7XG5cblx0XHRcdGlmIChjYWNoZWQpIHtcblx0XHRcdFx0cmV0dXJuIGNhY2hlZDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRjb25zdCBwaWZpZWQgPSBwcm9jZXNzRnVuY3Rpb24ocHJvcGVydHksIG9wdGlvbnMsIHByb3h5LCB0YXJnZXQpO1xuXHRcdFx0XHRjYWNoZS5zZXQocHJvcGVydHksIHBpZmllZCk7XG5cdFx0XHRcdHJldHVybiBwaWZpZWQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwcm9wZXJ0eTtcblx0XHR9LFxuXHR9KTtcblxuXHRyZXR1cm4gcHJveHk7XG59XG4iLCJpbXBvcnQgeyBzdXBhYmFzZSB9IGZyb20gXCJ+bGliL3N1cGFiYXNlXCJcblxuY2hyb21lLnJ1bnRpbWUub25JbnN0YWxsZWQuYWRkTGlzdGVuZXIoYXN5bmMgKGRldGFpbHMpID0+IHtcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRTZXNzaW9uKClcbiAgY29uc29sZS5sb2coXCJBdXRoIHNlc3Npb246XCIsIGRhdGEpXG4gIGlmICghZGF0YS5zZXNzaW9uKSBjaHJvbWUucnVudGltZS5vcGVuT3B0aW9uc1BhZ2UoKVxuICBpZiAoZXJyb3IpIGNvbnNvbGUuZXJyb3IoZXJyb3IpXG59KVxuIl0sIm5hbWVzIjpbXSwidmVyc2lvbiI6MywiZmlsZSI6ImluZGV4LmpzLm1hcCJ9
 globalThis.define=__define;  })(globalThis.define);